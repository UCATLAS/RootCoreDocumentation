<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>RootCore Packages: SH Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="../../index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="../../search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="../../namespaces.html"><span>Namespace&nbsp;List</span></a></li>
      <li><a href="../../namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>SH Namespace Reference</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d5b/classSH_1_1DiskList.html">DiskList</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">an interface for listing directory contents, locally or on a file server  <a href="../../d1/d5b/classSH_1_1DiskList.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d47/classSH_1_1DiskListEOS.html">DiskListEOS</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">a <a class="el" href="../../d1/d5b/classSH_1_1DiskList.html" title="an interface for listing directory contents, locally or on a file server">DiskList</a> implementation for EOS  <a href="../../da/d47/classSH_1_1DiskListEOS.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9f/classSH_1_1DiskListLocal.html">DiskListLocal</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">a <a class="el" href="../../d1/d5b/classSH_1_1DiskList.html" title="an interface for listing directory contents, locally or on a file server">DiskList</a> implementation for local directories  <a href="../../d5/d9f/classSH_1_1DiskListLocal.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d9b/classSH_1_1DiskListSRM.html">DiskListSRM</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">a <a class="el" href="../../d1/d5b/classSH_1_1DiskList.html" title="an interface for listing directory contents, locally or on a file server">DiskList</a> implementation for the SRM protocol  <a href="../../d0/d9b/classSH_1_1DiskListSRM.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d5e/classSH_1_1DiskListXRD.html">DiskListXRD</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">a <a class="el" href="../../d1/d5b/classSH_1_1DiskList.html" title="an interface for listing directory contents, locally or on a file server">DiskList</a> implementation for the XRD protocol  <a href="../../d8/d5e/classSH_1_1DiskListXRD.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d99/classSH_1_1DiskOutput.html">DiskOutput</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">a class representing an output location for files  <a href="../../d6/d99/classSH_1_1DiskOutput.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d89/classSH_1_1DiskOutputLocal.html">DiskOutputLocal</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">an implementation of <a class="el" href="../../d6/d99/classSH_1_1DiskOutput.html" title="a class representing an output location for files">DiskOutput</a> for local disks  <a href="../../d5/d89/classSH_1_1DiskOutputLocal.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d4d/classSH_1_1DiskOutputXRD.html">DiskOutputXRD</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">an implementation of <a class="el" href="../../d6/d99/classSH_1_1DiskOutput.html" title="a class representing an output location for files">DiskOutput</a> using the XRD protocol  <a href="../../d6/d4d/classSH_1_1DiskOutputXRD.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd1/classSH_1_1DiskWriter.html">DiskWriter</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">an interface that manages writing a single output file  <a href="../../db/dd1/classSH_1_1DiskWriter.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d69/classSH_1_1DiskWriterLocal.html">DiskWriterLocal</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">an implementation of <a class="el" href="../../db/dd1/classSH_1_1DiskWriter.html" title="an interface that manages writing a single output file">DiskWriter</a> for local files  <a href="../../d2/d69/classSH_1_1DiskWriterLocal.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d85/classSH_1_1DiskWriterXRD.html">DiskWriterXRD</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">an implementation of <a class="el" href="../../db/dd1/classSH_1_1DiskWriter.html" title="an interface that manages writing a single output file">DiskWriter</a> for the XRD protocol  <a href="../../dc/d85/classSH_1_1DiskWriterXRD.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/def/structSH_1_1RucioListDidsEntry.html">RucioListDidsEntry</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">one entry from the rucio-list-dids command  <a href="../../d3/def/structSH_1_1RucioListDidsEntry.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d39/structSH_1_1RucioListFileReplicasEntry.html">RucioListFileReplicasEntry</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">one entry from the rucio-list-file-replicas command  <a href="../../d4/d39/structSH_1_1RucioListFileReplicasEntry.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d98/structSH_1_1RucioDownloadResult.html">RucioDownloadResult</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the result from rucio_download  <a href="../../d0/d98/structSH_1_1RucioDownloadResult.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d6a/classSH_1_1Meta.html">Meta</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="../../d4/dc4/structA.html">A</a> base class for classes that implement arbitrary meta-data.  <a href="../../d6/d6a/classSH_1_1Meta.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d63/classSH_1_1MetaData.html">MetaData</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="../../d4/dc4/structA.html">A</a> class implementing a templatized version of the meta-data.  <a href="../../da/d63/classSH_1_1MetaData.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d70/structSH_1_1MetaDataQuery.html">MetaDataQuery</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">an object containing the result of an AMI meta-data query  <a href="../../de/d70/structSH_1_1MetaDataQuery.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d33/structSH_1_1MetaDataSample.html">MetaDataSample</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">all the meta-data fields that we may try to read from AMI.  <a href="../../d2/d33/structSH_1_1MetaDataSample.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d06/structSH_1_1MetaFields.html">MetaFields</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class contains the known meta-data names.  <a href="../../d7/d06/structSH_1_1MetaFields.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d8c/structSH_1_1MetaNames.html">MetaNames</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the names of common meta-data  <a href="../../d2/d8c/structSH_1_1MetaNames.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/classSH_1_1MetaObject.html">MetaObject</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="../../d4/dc4/structA.html">A</a> class that manages meta-data to be associated with an object.  <a href="../../db/d3a/classSH_1_1MetaObject.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d63/classSH_1_1MetaVector.html">MetaVector</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class defines a templatized version of the meta-data in vector form.  <a href="../../de/d63/classSH_1_1MetaVector.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d5f/classSH_1_1Sample.html">Sample</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">a base class that manages a set of files belonging to a particular data set and the associated meta-data.  <a href="../../dd/d5f/classSH_1_1Sample.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d64/classSH_1_1SampleComposite.html">SampleComposite</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This module defines an implementation of <a class="el" href="../../dd/d5f/classSH_1_1Sample.html" title="a base class that manages a set of files belonging to a particular data set and the...">Sample</a> that contains composite samples.  <a href="../../d8/d64/classSH_1_1SampleComposite.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d36/classSH_1_1SampleGrid.html">SampleGrid</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class implements a <a class="el" href="../../dd/d5f/classSH_1_1Sample.html" title="a base class that manages a set of files belonging to a particular data set and the...">Sample</a> located on the grid.  <a href="../../d1/d36/classSH_1_1SampleGrid.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d56/classSH_1_1SampleHandler.html">SampleHandler</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="../../d4/dc4/structA.html">A</a> class that manages a list of <a class="el" href="../../dd/d5f/classSH_1_1Sample.html" title="a base class that manages a set of files belonging to a particular data set and the...">Sample</a> objects.  <a href="../../d1/d56/classSH_1_1SampleHandler.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d76/classSH_1_1SampleHist.html">SampleHist</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="../../d4/dc4/structA.html">A</a> sample that represents a single histogram file.  <a href="../../d4/d76/classSH_1_1SampleHist.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d31/classSH_1_1SampleLocal.html">SampleLocal</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="../../d4/dc4/structA.html">A</a> <a class="el" href="../../dd/d5f/classSH_1_1Sample.html" title="a base class that manages a set of files belonging to a particular data set and the...">Sample</a> based on a simple file list.  <a href="../../d8/d31/classSH_1_1SampleLocal.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d78/classSH_1_1SampleMeta.html">SampleMeta</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="../../d4/dc4/structA.html">A</a> <a class="el" href="../../dd/d5f/classSH_1_1Sample.html" title="a base class that manages a set of files belonging to a particular data set and the...">Sample</a> that consists only of Meta-Information.  <a href="../../dc/d78/classSH_1_1SampleMeta.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d8a/classSH_1_1SamplePtr.html">SamplePtr</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="../../d4/dc4/structA.html">A</a> smart pointer class that holds a single <a class="el" href="../../dd/d5f/classSH_1_1Sample.html" title="a base class that manages a set of files belonging to a particular data set and the...">Sample</a> object.  <a href="../../d8/d8a/classSH_1_1SamplePtr.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dc5/structSH_1_1ScanDir.html">ScanDir</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the class used for scanning local directories and file servers for samples  <a href="../../d2/dc5/structSH_1_1ScanDir.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d41/classSH_1_1TagList.html">TagList</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="../../d4/dc4/structA.html">A</a> class that manages a list of tags for identifying samples.  <a href="../../dd/d41/classSH_1_1TagList.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d9e/namespaceSH.html#aa0b7ce44ba17de01d4fa7626d145d4a2">fetchMetaData</a> (<a class="el" href="../../de/d70/structSH_1_1MetaDataQuery.html">MetaDataQuery</a> &amp;query)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d9e/namespaceSH.html#ae106084fda781abadf6f25014af03c9a">fetchMetaData</a> (<a class="el" href="../../d1/d56/classSH_1_1SampleHandler.html">SH::SampleHandler</a> &amp;sh, bool override)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d9e/namespaceSH.html#ace5d9d071743e96f94e6f186ee455bd7">checkVomsProxy</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return whether we have a valid VOMS proxy available  <a href="#ace5d9d071743e96f94e6f186ee455bd7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d9e/namespaceSH.html#a38ab5027d7b5de75a857682b0ea7f766">ensureVomsProxy</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ensure that we have a valid VOMS proxy available  <a href="#a38ab5027d7b5de75a857682b0ea7f766"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d9e/namespaceSH.html#a3541573890dcbf9738d9e0cc28e9c8bb">faxListFilesGlob</a> (const std::string &amp;name, const std::string &amp;filter)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">list the FAX URLs for all the files in the dataset or dataset container matching the given filter (as glob expression)  <a href="#a3541573890dcbf9738d9e0cc28e9c8bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d9e/namespaceSH.html#ad561ddee8a20d1fb0cf2ce96ccf3232f">faxListFilesRegex</a> (const std::string &amp;name, const std::string &amp;filter)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">list the FAX URLs for all the files in the dataset or dataset container matching the given filter (as regular expression)  <a href="#ad561ddee8a20d1fb0cf2ce96ccf3232f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="../../d3/def/structSH_1_1RucioListDidsEntry.html">RucioListDidsEntry</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d9e/namespaceSH.html#a371bc3580e0a7420385db611cb60d8fa">rucioListDids</a> (const std::string &amp;dataset)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">run rucio-list-dids for the given dataset  <a href="#a371bc3580e0a7420385db611cb60d8fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector<br class="typebreak"/>
&lt; <a class="el" href="../../d4/d39/structSH_1_1RucioListFileReplicasEntry.html">RucioListFileReplicasEntry</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d9e/namespaceSH.html#a3655fe15ee26f7dd352cd76300f6651b">rucioListFileReplicas</a> (const std::string &amp;dataset)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">run rucio-list-file-replicas for the given dataset  <a href="#a3655fe15ee26f7dd352cd76300f6651b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <br class="typebreak"/>
std::unique_ptr&lt; <a class="el" href="../../db/d3a/classSH_1_1MetaObject.html">MetaObject</a> &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d9e/namespaceSH.html#a3d55767dfa402d097eb36cad6af3e244">rucioGetMetadata</a> (const std::set&lt; std::string &gt; &amp;datasets)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">run rucio-get-metadata for the given list of datasets  <a href="#a3d55767dfa402d097eb36cad6af3e244"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d98/structSH_1_1RucioDownloadResult.html">RucioDownloadResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d9e/namespaceSH.html#a09f12a6815d65245d5c01bff15fec7cc">rucioDownload</a> (const std::string &amp;location, const std::string &amp;dataset)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">run rucio-download  <a href="#a09f12a6815d65245d5c01bff15fec7cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="../../d0/d98/structSH_1_1RucioDownloadResult.html">RucioDownloadResult</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d9e/namespaceSH.html#a08a97d09eb6664882be300a3d86acf9f">rucioDownloadList</a> (const std::string &amp;location, const std::vector&lt; std::string &gt; &amp;datasets)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">run rucio-download with multiple datasets  <a href="#a08a97d09eb6664882be300a3d86acf9f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3176ebf60dddfd41722e70a93c9967a"></a><!-- doxytag: member="SH::dbg" ref="af3176ebf60dddfd41722e70a93c9967a" args="(const Meta &amp;, unsigned)" -->
std::string&nbsp;</td><td class="memItemRight" valign="bottom"><b>dbg</b> (const <a class="el" href="../../d6/d6a/classSH_1_1Meta.html">Meta</a> &amp;, unsigned)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2f538a77e1915ec1ce58d77f5b81fed"></a><!-- doxytag: member="SH::dbg" ref="af2f538a77e1915ec1ce58d77f5b81fed" args="(const TagList &amp;obj, unsigned)" -->
std::string&nbsp;</td><td class="memItemRight" valign="bottom"><b>dbg</b> (const <a class="el" href="../../dd/d41/classSH_1_1TagList.html">TagList</a> &amp;obj, unsigned)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d9e/namespaceSH.html#a218a2853cca0943f8a4f76c31bfa8730">scanDir</a> (<a class="el" href="../../d1/d56/classSH_1_1SampleHandler.html">SampleHandler</a> &amp;sh, <a class="el" href="../../d1/d5b/classSH_1_1DiskList.html">DiskList</a> &amp;list, const std::string &amp;pattern, const std::string &amp;samplePattern, const std::string &amp;samplePostfix)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2d89cb584a6655ba42abc5c6e6db489"></a><!-- doxytag: member="SH::scanDir" ref="aa2d89cb584a6655ba42abc5c6e6db489" args="(SampleHandler &amp;sh, const std::string &amp;dir)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>scanDir</b> (<a class="el" href="../../d1/d56/classSH_1_1SampleHandler.html">SampleHandler</a> &amp;sh, const std::string &amp;dir)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa32cbf2836f729b6ac5f91c6dadfcf70"></a><!-- doxytag: member="SH::scanDir" ref="aa32cbf2836f729b6ac5f91c6dadfcf70" args="(SampleHandler &amp;sh, const std::string &amp;dir, const std::string &amp;prefix)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>scanDir</b> (<a class="el" href="../../d1/d56/classSH_1_1SampleHandler.html">SampleHandler</a> &amp;sh, const std::string &amp;dir, const std::string &amp;prefix)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d9e/namespaceSH.html#abbf46cdb18ddb60894c3dbf6f748aa02">scanFiles</a> (<a class="el" href="../../d1/d56/classSH_1_1SampleHandler.html">SampleHandler</a> &amp;sh, <a class="el" href="../../d1/d5b/classSH_1_1DiskList.html">DiskList</a> &amp;list, const std::string &amp;pattern)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dd/d5f/classSH_1_1Sample.html">Sample</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d9e/namespaceSH.html#a31190573b3ca12428ca591e080edfe73">makeFromTChain</a> (const std::string &amp;name, const TChain &amp;chain)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d9e/namespaceSH.html#abf33b8bdbc36bfc1b9da9a05a8144fa1">scanSingleDir</a> (<a class="el" href="../../d1/d56/classSH_1_1SampleHandler.html">SampleHandler</a> &amp;sh, const std::string &amp;name, <a class="el" href="../../d1/d5b/classSH_1_1DiskList.html">DiskList</a> &amp;list, const std::string &amp;pattern)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d9e/namespaceSH.html#a0f9184bf8c7ea029e2470460df5c0018">scanDQ2</a> (<a class="el" href="../../d1/d56/classSH_1_1SampleHandler.html">SampleHandler</a> &amp;sh, const std::string &amp;pattern)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d9e/namespaceSH.html#ab952a2257070fb18d9463201b1c3b2ef">scanRucio</a> (<a class="el" href="../../d1/d56/classSH_1_1SampleHandler.html">SampleHandler</a> &amp;sh, const std::string &amp;pattern, bool alwaysQuery=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">make a list of grid datasets using the given pattern  <a href="#ab952a2257070fb18d9463201b1c3b2ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d9e/namespaceSH.html#a03e83d8148faf96766c6fb3f6b05e000">addGrid</a> (<a class="el" href="../../d1/d56/classSH_1_1SampleHandler.html">SampleHandler</a> &amp;sh, const std::string &amp;ds)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d9e/namespaceSH.html#a3e94deb54c1ea1133d0128ee84a37f35">makeGridDirect</a> (<a class="el" href="../../d1/d56/classSH_1_1SampleHandler.html">SampleHandler</a> &amp;sh, const std::string &amp;disk, const std::string &amp;from, const std::string &amp;to, bool allow_partial)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d9e/namespaceSH.html#a86284338332ed63a54ef4bbfb17bb01f">scanForTrees</a> (<a class="el" href="../../d1/d56/classSH_1_1SampleHandler.html">SampleHandler</a> &amp;sh, const <a class="el" href="../../dd/d5f/classSH_1_1Sample.html">Sample</a> &amp;sample, const std::string &amp;pattern)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a62d6288798d7f10e1d7aef57b80ec199"></a><!-- doxytag: member="SH::scanForTrees" ref="a62d6288798d7f10e1d7aef57b80ec199" args="(SampleHandler &amp;sh, const std::string &amp;pattern)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>scanForTrees</b> (<a class="el" href="../../d1/d56/classSH_1_1SampleHandler.html">SampleHandler</a> &amp;sh, const std::string &amp;pattern)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d9e/namespaceSH.html#a194afcafddde244896bde31125db5c41">readFileList</a> (<a class="el" href="../../d1/d56/classSH_1_1SampleHandler.html">SampleHandler</a> &amp;sh, const std::string &amp;name, const std::string &amp;file)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d9e/namespaceSH.html#a7760d745da599e79133a3377470d52a7">printDuplicateEvents</a> (const <a class="el" href="../../dd/d5f/classSH_1_1Sample.html">Sample</a> &amp;sample)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d9e/namespaceSH.html#a5c26febcf499c79d8b5f300d7761da8f">printDuplicateEventsSplit</a> (const <a class="el" href="../../d1/d56/classSH_1_1SampleHandler.html">SampleHandler</a> &amp;sh)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d9e/namespaceSH.html#adde4965ab348cce4eee6e084c627d46e">printDuplicateEventsJoint</a> (const <a class="el" href="../../d1/d56/classSH_1_1SampleHandler.html">SampleHandler</a> &amp;sh)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d9e/namespaceSH.html#a395d783ebdcb48eb26537f48a7a7dd23">mergeSamples</a> (<a class="el" href="../../d1/d56/classSH_1_1SampleHandler.html">SampleHandler</a> &amp;sh, const std::string &amp;sampleName, const std::string &amp;pattern)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d9e/namespaceSH.html#a3ad11148548172678f19f8aadcae60ef">readSusyMeta</a> (const <a class="el" href="../../d1/d56/classSH_1_1SampleHandler.html">SampleHandler</a> &amp;sh, const std::string &amp;inputFile)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d9e/namespaceSH.html#a3b8fb791234933ae9182533c71d6d0ab">readSusyMetaDir</a> (const <a class="el" href="../../d1/d56/classSH_1_1SampleHandler.html">SampleHandler</a> &amp;sh, const std::string &amp;inputDir)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; TFile &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d9e/namespaceSH.html#a597d456d5d0884fa8e37f6ced82f55b4">openFile</a> (const std::string &amp;name, const <a class="el" href="../../db/d3a/classSH_1_1MetaObject.html">MetaObject</a> &amp;options)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">open a file with the given options  <a href="#a597d456d5d0884fa8e37f6ced82f55b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="../../d8/d31/classSH_1_1SampleLocal.html">SampleLocal</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d9e/namespaceSH.html#a22f1f197aecfb90ccdfc06f2af63f8c9">mergeFiles</a> (const <a class="el" href="../../dd/d5f/classSH_1_1Sample.html">Sample</a> &amp;sample, const std::string &amp;location, bool overwrite)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">merge all the files in the sample into a single file in the given location  <a href="#a22f1f197aecfb90ccdfc06f2af63f8c9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/d56/classSH_1_1SampleHandler.html">SampleHandler</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d9e/namespaceSH.html#af5d78958b196fdb211a17528b49946b4">mergeFiles</a> (const <a class="el" href="../../d1/d56/classSH_1_1SampleHandler.html">SampleHandler</a> &amp;sh, const std::string &amp;location, bool overwrite)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">merge all the files in the sample handles into a single file per sample in the given location  <a href="#af5d78958b196fdb211a17528b49946b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d9e/namespaceSH.html#a2e2d63946f5ce402c6456c8973adc241">scanNEvents</a> (<a class="el" href="../../d1/d56/classSH_1_1SampleHandler.html">SampleHandler</a> &amp;sh)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d9e/namespaceSH.html#a58d3a57d32ec34440dc4e21ebd92f1b6">scanNEvents</a> (<a class="el" href="../../dd/d5f/classSH_1_1Sample.html">Sample</a> &amp;sample)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/d56/classSH_1_1SampleHandler.html">SampleHandler</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d9e/namespaceSH.html#afc2481fc630dc76adafeb035e97c92fe">splitSample</a> (<a class="el" href="../../dd/d5f/classSH_1_1Sample.html">Sample</a> &amp;sample, const Long64_t nevt)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This module provides a lot of global definitions, forward declarations and includes that are used by all modules. As such it doesn't fall into the user vs. expert classification. This module is considered to be in the pre-alpha stage.</p>
<p>This module defines utility functions used for joining samples. The interface provided in this module is intended for the general user. The module is considered to be in the pre-alpha stage.</p>
<p>This module defines utility functions used for splitting samples. The interface provided in this module is intended for the general user. The module is considered to be in the pre-alpha stage. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a03e83d8148faf96766c6fb3f6b05e000"></a><!-- doxytag: member="SH::addGrid" ref="a03e83d8148faf96766c6fb3f6b05e000" args="(SampleHandler &amp;sh, const std::string &amp;ds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SH::addGrid </td>
          <td>(</td>
          <td class="paramtype">SampleHandler &amp;&nbsp;</td>
          <td class="paramname"> <em>sh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>ds</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>effects: add a grid dataset for dataset ds guarantee: strong failures: out of memory II requires: ds.find ("*") == std::string::npos </p>

</div>
</div>
<a class="anchor" id="ace5d9d071743e96f94e6f186ee455bd7"></a><!-- doxytag: member="SH::checkVomsProxy" ref="ace5d9d071743e96f94e6f186ee455bd7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SH::checkVomsProxy </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>return whether we have a valid VOMS proxy available </p>
<dl class="user"><dt><b>Guarantee</b></dt><dd>basic </dd></dl>
<dl class="user"><dt><b>Failures</b></dt><dd>grid utility failures </dd></dl>

</div>
</div>
<a class="anchor" id="a38ab5027d7b5de75a857682b0ea7f766"></a><!-- doxytag: member="SH::ensureVomsProxy" ref="a38ab5027d7b5de75a857682b0ea7f766" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SH::ensureVomsProxy </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>ensure that we have a valid VOMS proxy available </p>
<p>First this checks whether we have a valid PROXY, and if not it sets up a new certificate.</p>
<dl class="user"><dt><b>Guarantee</b></dt><dd>basic </dd></dl>
<dl class="user"><dt><b>Failures</b></dt><dd>grid utility failures<br/>
 failure to set up new VOMS proxy </dd></dl>

</div>
</div>
<a class="anchor" id="a3541573890dcbf9738d9e0cc28e9c8bb"></a><!-- doxytag: member="SH::faxListFilesGlob" ref="a3541573890dcbf9738d9e0cc28e9c8bb" args="(const std::string &amp;name, const std::string &amp;filter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; SH::faxListFilesGlob </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>filter</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>list the FAX URLs for all the files in the dataset or dataset container matching the given filter (as glob expression) </p>
<dl class="user"><dt><b>Guarantee</b></dt><dd>strong </dd></dl>
<dl class="user"><dt><b>Failures</b></dt><dd>grid utility failures </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>!name.empty() </dd>
<dd>
name.find('*') == std::string::npos </dd>
<dd>
!filter.empty() </dd></dl>

</div>
</div>
<a class="anchor" id="ad561ddee8a20d1fb0cf2ce96ccf3232f"></a><!-- doxytag: member="SH::faxListFilesRegex" ref="ad561ddee8a20d1fb0cf2ce96ccf3232f" args="(const std::string &amp;name, const std::string &amp;filter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; SH::faxListFilesRegex </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>filter</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>list the FAX URLs for all the files in the dataset or dataset container matching the given filter (as regular expression) </p>
<dl class="user"><dt><b>Guarantee</b></dt><dd>strong </dd></dl>
<dl class="user"><dt><b>Failures</b></dt><dd>grid utility failures </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>!name.empty() </dd>
<dd>
name.find('*') == std::string::npos </dd>
<dd>
!filter.empty() </dd></dl>

</div>
</div>
<a class="anchor" id="ae106084fda781abadf6f25014af03c9a"></a><!-- doxytag: member="SH::fetchMetaData" ref="ae106084fda781abadf6f25014af03c9a" args="(SH::SampleHandler &amp;sh, bool override)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SH::fetchMetaData </td>
          <td>(</td>
          <td class="paramtype">SampleHandler &amp;&nbsp;</td>
          <td class="paramname"> <em>sh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>override</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>effects: fetch information on all the samples in the sample handler. if override is specified it will override the existing meta-data fields, otherwise they will only be used if the given fields do not yet exist guarantee: basic </p>

</div>
</div>
<a class="anchor" id="aa0b7ce44ba17de01d4fa7626d145d4a2"></a><!-- doxytag: member="SH::fetchMetaData" ref="aa0b7ce44ba17de01d4fa7626d145d4a2" args="(MetaDataQuery &amp;query)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SH::fetchMetaData </td>
          <td>(</td>
          <td class="paramtype">MetaDataQuery &amp;&nbsp;</td>
          <td class="paramname"> <em>query</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>effects: fetch information on all the samples/datasets specified guarantee: basic </p>

</div>
</div>
<a class="anchor" id="a31190573b3ca12428ca591e080edfe73"></a><!-- doxytag: member="SH::makeFromTChain" ref="a31190573b3ca12428ca591e080edfe73" args="(const std::string &amp;name, const TChain &amp;chain)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dd/d5f/classSH_1_1Sample.html">Sample</a> * SH::makeFromTChain </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TChain &amp;&nbsp;</td>
          <td class="paramname"> <em>chain</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>effects: create a sample with the given name from the given TChain object guarantee: strong failures: out of memory II </p>

</div>
</div>
<a class="anchor" id="a3e94deb54c1ea1133d0128ee84a37f35"></a><!-- doxytag: member="SH::makeGridDirect" ref="a3e94deb54c1ea1133d0128ee84a37f35" args="(SampleHandler &amp;sh, const std::string &amp;disk, const std::string &amp;from, const std::string &amp;to, bool allow_partial)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SH::makeGridDirect </td>
          <td>(</td>
          <td class="paramtype">SampleHandler &amp;&nbsp;</td>
          <td class="paramname"> <em>sh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>disk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>allow_partial</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>effects: update all grid samples in the sample handler that are located on the given disk to be opened directly. for that it replaces the from part of the file with the to part. if allow_partial is set, it allows for partial datasets (meaning you may lose some files that are not there). guarantee: basic, may convert only some samples failures: out of memory III failures: dq2-ls errors failures: from not part of file name </p>

</div>
</div>
<a class="anchor" id="af5d78958b196fdb211a17528b49946b4"></a><!-- doxytag: member="SH::mergeFiles" ref="af5d78958b196fdb211a17528b49946b4" args="(const SampleHandler &amp;sh, const std::string &amp;location, bool overwrite)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/d56/classSH_1_1SampleHandler.html">SampleHandler</a> SH::mergeFiles </td>
          <td>(</td>
          <td class="paramtype">const SampleHandler &amp;&nbsp;</td>
          <td class="paramname"> <em>sh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>overwrite</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>merge all the files in the sample handles into a single file per sample in the given location </p>
<p>This is mostly meant to allow merging histogram files (particularly in EventLoop), but in some cases it can also be used to merge n-tuple files together.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a sample handler containing the merged files </dd></dl>
<dl class="user"><dt><b>Guarantee</b></dt><dd>basic </dd></dl>
<dl class="user"><dt><b>Failures</b></dt><dd>i/o errors<br/>
 out of memory III </dd></dl>

</div>
</div>
<a class="anchor" id="a22f1f197aecfb90ccdfc06f2af63f8c9"></a><!-- doxytag: member="SH::mergeFiles" ref="a22f1f197aecfb90ccdfc06f2af63f8c9" args="(const Sample &amp;sample, const std::string &amp;location, bool overwrite)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="../../d8/d31/classSH_1_1SampleLocal.html">SampleLocal</a> &gt; SH::mergeFiles </td>
          <td>(</td>
          <td class="paramtype">const Sample &amp;&nbsp;</td>
          <td class="paramname"> <em>sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>overwrite</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>merge all the files in the sample into a single file in the given location </p>
<p>This is mostly meant to allow merging histogram files (particularly in EventLoop), but in some cases it can also be used to merge n-tuple fiels together.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a sample containing the merged file </dd></dl>
<dl class="user"><dt><b>Guarantee</b></dt><dd>basic </dd></dl>
<dl class="user"><dt><b>Failures</b></dt><dd>i/o errors<br/>
 out of memory III </dd></dl>

</div>
</div>
<a class="anchor" id="a395d783ebdcb48eb26537f48a7a7dd23"></a><!-- doxytag: member="SH::mergeSamples" ref="a395d783ebdcb48eb26537f48a7a7dd23" args="(SampleHandler &amp;sh, const std::string &amp;sampleName, const std::string &amp;pattern)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SH::mergeSamples </td>
          <td>(</td>
          <td class="paramtype">SampleHandler &amp;&nbsp;</td>
          <td class="paramname"> <em>sh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>sampleName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>pattern</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>effects: remove all samples matching the name pattern, and join them into a single sample named sampleName guarantee: strong failures: out of memory II failures: i/o errors </p>

</div>
</div>
<a class="anchor" id="a597d456d5d0884fa8e37f6ced82f55b4"></a><!-- doxytag: member="SH::openFile" ref="a597d456d5d0884fa8e37f6ced82f55b4" args="(const std::string &amp;name, const MetaObject &amp;options)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; TFile &gt; SH::openFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MetaObject &amp;&nbsp;</td>
          <td class="paramname"> <em>options</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>open a file with the given options </p>
<p>for now this is to allow opening files with retries, but in the future there may be other options as well. </p>
<dl class="user"><dt><b>Guarantee</b></dt><dd>strong </dd></dl>
<dl class="user"><dt><b>Failures</b></dt><dd>i/o errors<br/>
 file not found </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>result != nullptr </dd></dl>

</div>
</div>
<a class="anchor" id="a7760d745da599e79133a3377470d52a7"></a><!-- doxytag: member="SH::printDuplicateEvents" ref="a7760d745da599e79133a3377470d52a7" args="(const Sample &amp;sample)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SH::printDuplicateEvents </td>
          <td>(</td>
          <td class="paramtype">const Sample &amp;&nbsp;</td>
          <td class="paramname"> <em>sample</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>effects: check the given sample for duplicate events and then print them out guarantee: basic, may print partially failures: out of memory III failures: i/o errors </p>

</div>
</div>
<a class="anchor" id="adde4965ab348cce4eee6e084c627d46e"></a><!-- doxytag: member="SH::printDuplicateEventsJoint" ref="adde4965ab348cce4eee6e084c627d46e" args="(const SampleHandler &amp;sh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SH::printDuplicateEventsJoint </td>
          <td>(</td>
          <td class="paramtype">const SampleHandler &amp;&nbsp;</td>
          <td class="paramname"> <em>sh</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>effects: check for duplicate events between all the samples and then print them out guarantee: basic, may print partially failures: out of memory III failures: i/o errors </p>

</div>
</div>
<a class="anchor" id="a5c26febcf499c79d8b5f300d7761da8f"></a><!-- doxytag: member="SH::printDuplicateEventsSplit" ref="a5c26febcf499c79d8b5f300d7761da8f" args="(const SampleHandler &amp;sh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SH::printDuplicateEventsSplit </td>
          <td>(</td>
          <td class="paramtype">const SampleHandler &amp;&nbsp;</td>
          <td class="paramname"> <em>sh</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>effects: check each sample for duplicate events and then print them out guarantee: basic, may print partially failures: out of memory III failures: i/o errors </p>

</div>
</div>
<a class="anchor" id="a194afcafddde244896bde31125db5c41"></a><!-- doxytag: member="SH::readFileList" ref="a194afcafddde244896bde31125db5c41" args="(SampleHandler &amp;sh, const std::string &amp;name, const std::string &amp;file)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SH::readFileList </td>
          <td>(</td>
          <td class="paramtype">SampleHandler &amp;&nbsp;</td>
          <td class="paramname"> <em>sh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>file</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>effects: read a file list from a text file guarantee: strong failures: out of memory III failures: i/o errors </p>

</div>
</div>
<a class="anchor" id="a3ad11148548172678f19f8aadcae60ef"></a><!-- doxytag: member="SH::readSusyMeta" ref="a3ad11148548172678f19f8aadcae60ef" args="(const SampleHandler &amp;sh, const std::string &amp;inputFile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SH::readSusyMeta </td>
          <td>(</td>
          <td class="paramtype">const SampleHandler &amp;&nbsp;</td>
          <td class="paramname"> <em>sh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>inputFile</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>effects: read the susy-meta-data file and add its information to the samples from the given sample handler guarantee: basic failures: i/o errors warning: there are no checks for duplicate and inconsistent sample definitions </p>

</div>
</div>
<a class="anchor" id="a3b8fb791234933ae9182533c71d6d0ab"></a><!-- doxytag: member="SH::readSusyMetaDir" ref="a3b8fb791234933ae9182533c71d6d0ab" args="(const SampleHandler &amp;sh, const std::string &amp;inputDir)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SH::readSusyMetaDir </td>
          <td>(</td>
          <td class="paramtype">const SampleHandler &amp;&nbsp;</td>
          <td class="paramname"> <em>sh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>inputDir</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>effects: read an entire directory of susy-meta-data files and add their information to the samples from the given sample handle. for that it assumes that all files ending in ".txt" are susy-meta-data files. guarantee: basic failures: i/o errors warning: there are no checks for duplicate and inconsistent sample definitions </p>

</div>
</div>
<a class="anchor" id="a09f12a6815d65245d5c01bff15fec7cc"></a><!-- doxytag: member="SH::rucioDownload" ref="a09f12a6815d65245d5c01bff15fec7cc" args="(const std::string &amp;location, const std::string &amp;dataset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d98/structSH_1_1RucioDownloadResult.html">RucioDownloadResult</a> SH::rucioDownload </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>dataset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>run rucio-download </p>
<dl class="user"><dt><b>Guarantee</b></dt><dd>basic </dd></dl>
<dl class="user"><dt><b>Failures</b></dt><dd>grid utility failures </dd></dl>

</div>
</div>
<a class="anchor" id="a08a97d09eb6664882be300a3d86acf9f"></a><!-- doxytag: member="SH::rucioDownloadList" ref="a08a97d09eb6664882be300a3d86acf9f" args="(const std::string &amp;location, const std::vector&lt; std::string &gt; &amp;datasets)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="../../d0/d98/structSH_1_1RucioDownloadResult.html">RucioDownloadResult</a> &gt; SH::rucioDownloadList </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>datasets</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>run rucio-download with multiple datasets </p>
<dl class="user"><dt><b>Guarantee</b></dt><dd>basic </dd></dl>
<dl class="user"><dt><b>Failures</b></dt><dd>grid utility failures </dd></dl>

</div>
</div>
<a class="anchor" id="a3d55767dfa402d097eb36cad6af3e244"></a><!-- doxytag: member="SH::rucioGetMetadata" ref="a3d55767dfa402d097eb36cad6af3e244" args="(const std::set&lt; std::string &gt; &amp;datasets)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, std::unique_ptr&lt; <a class="el" href="../../db/d3a/classSH_1_1MetaObject.html">MetaObject</a> &gt; &gt; SH::rucioGetMetadata </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; std::string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>datasets</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>run rucio-get-metadata for the given list of datasets </p>
<dl class="user"><dt><b>Guarantee</b></dt><dd>strong </dd></dl>
<dl class="user"><dt><b>Failures</b></dt><dd>grid utility failures </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>!datasets.empty() </dd>
<dd>
!dataset.empty() (for each dataset) </dd></dl>

</div>
</div>
<a class="anchor" id="a371bc3580e0a7420385db611cb60d8fa"></a><!-- doxytag: member="SH::rucioListDids" ref="a371bc3580e0a7420385db611cb60d8fa" args="(const std::string &amp;dataset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="../../d3/def/structSH_1_1RucioListDidsEntry.html">RucioListDidsEntry</a> &gt; SH::rucioListDids </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>dataset</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>run rucio-list-dids for the given dataset </p>
<dl class="user"><dt><b>Guarantee</b></dt><dd>strong </dd></dl>
<dl class="user"><dt><b>Failures</b></dt><dd>grid utility failures </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>!dataset.empty() </dd></dl>

</div>
</div>
<a class="anchor" id="a3655fe15ee26f7dd352cd76300f6651b"></a><!-- doxytag: member="SH::rucioListFileReplicas" ref="a3655fe15ee26f7dd352cd76300f6651b" args="(const std::string &amp;dataset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="../../d4/d39/structSH_1_1RucioListFileReplicasEntry.html">RucioListFileReplicasEntry</a> &gt; SH::rucioListFileReplicas </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>dataset</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>run rucio-list-file-replicas for the given dataset </p>
<dl class="user"><dt><b>Guarantee</b></dt><dd>strong </dd></dl>
<dl class="user"><dt><b>Failures</b></dt><dd>grid utility failures </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>!dataset.empty() </dd></dl>

</div>
</div>
<a class="anchor" id="a218a2853cca0943f8a4f76c31bfa8730"></a><!-- doxytag: member="SH::scanDir" ref="a218a2853cca0943f8a4f76c31bfa8730" args="(SampleHandler &amp;sh, DiskList &amp;list, const std::string &amp;pattern, const std::string &amp;samplePattern, const std::string &amp;samplePostfix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SH::scanDir </td>
          <td>(</td>
          <td class="paramtype">SampleHandler &amp;&nbsp;</td>
          <td class="paramname"> <em>sh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiskList &amp;&nbsp;</td>
          <td class="paramname"> <em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>pattern</em> = <code>&quot;*.root*&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>samplePattern</em> = <code>&quot;*&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>samplePostfix</em> = <code>&quot;&quot;</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>effects: scan the given directory and add all subdirectories as samples that contain root files. if prefix is provided, use that instead of dir when constructing the file names. guarantee: basic, only some samples might be added failures: low level errors IV failures: directory not found failures: duplicate samples rationale: the prefix option is for the Tier 3 prototype, where you scan the local directory, but then access the files through xrootd </p>

</div>
</div>
<a class="anchor" id="a0f9184bf8c7ea029e2470460df5c0018"></a><!-- doxytag: member="SH::scanDQ2" ref="a0f9184bf8c7ea029e2470460df5c0018" args="(SampleHandler &amp;sh, const std::string &amp;pattern)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SH::scanDQ2 </td>
          <td>(</td>
          <td class="paramtype">SampleHandler &amp;&nbsp;</td>
          <td class="paramname"> <em>sh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>pattern</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>effects: make a list from DQ2 using the given pattern guarantee: basic, may add partially failures: out of memory III failures: dq2-ls errors </p>

</div>
</div>
<a class="anchor" id="abbf46cdb18ddb60894c3dbf6f748aa02"></a><!-- doxytag: member="SH::scanFiles" ref="abbf46cdb18ddb60894c3dbf6f748aa02" args="(SampleHandler &amp;sh, DiskList &amp;list, const std::string &amp;pattern)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SH::scanFiles </td>
          <td>(</td>
          <td class="paramtype">SampleHandler &amp;&nbsp;</td>
          <td class="paramname"> <em>sh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiskList &amp;&nbsp;</td>
          <td class="paramname"> <em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>pattern</em> = <code>&quot;*.root*&quot;</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>effects: scan the given directory tree and make a separate sample for each file (using the file name before any "." as the sample name). guarantee: basic, only some samples might be added failures: out of memory III failures: i/o errors failures: duplicate samples </p>

</div>
</div>
<a class="anchor" id="a86284338332ed63a54ef4bbfb17bb01f"></a><!-- doxytag: member="SH::scanForTrees" ref="a86284338332ed63a54ef4bbfb17bb01f" args="(SampleHandler &amp;sh, const Sample &amp;sample, const std::string &amp;pattern)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SH::scanForTrees </td>
          <td>(</td>
          <td class="paramtype">SampleHandler &amp;&nbsp;</td>
          <td class="paramname"> <em>sh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Sample &amp;&nbsp;</td>
          <td class="paramname"> <em>sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>pattern</em> = <code>&quot;.*&quot;</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>effects: scan for trees in the given sample (or sample handler), and create a separate sample for each tree. if pattern is specified it is applied to the allowed tree names. guarantee: strong failures: out of memory III failures: i/o errors </p>

</div>
</div>
<a class="anchor" id="a58d3a57d32ec34440dc4e21ebd92f1b6"></a><!-- doxytag: member="SH::scanNEvents" ref="a58d3a57d32ec34440dc4e21ebd92f1b6" args="(Sample &amp;sample)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SH::scanNEvents </td>
          <td>(</td>
          <td class="paramtype">Sample &amp;&nbsp;</td>
          <td class="paramname"> <em>sample</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>effects: scan the given sample and store the number of entries per file in the meta-data guarantee: strong failures: out of memory failures: read errors failures: invalid sample type </p>

</div>
</div>
<a class="anchor" id="a2e2d63946f5ce402c6456c8973adc241"></a><!-- doxytag: member="SH::scanNEvents" ref="a2e2d63946f5ce402c6456c8973adc241" args="(SampleHandler &amp;sh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SH::scanNEvents </td>
          <td>(</td>
          <td class="paramtype">SampleHandler &amp;&nbsp;</td>
          <td class="paramname"> <em>sh</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>effects: scan each sample in the sample handler and store the number of entries per file in the meta-data guarantee: basic, may only scan some failures: out of memory failures: read errors failures: invalid sample type </p>

</div>
</div>
<a class="anchor" id="ab952a2257070fb18d9463201b1c3b2ef"></a><!-- doxytag: member="SH::scanRucio" ref="ab952a2257070fb18d9463201b1c3b2ef" args="(SampleHandler &amp;sh, const std::string &amp;pattern, bool alwaysQuery=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SH::scanRucio </td>
          <td>(</td>
          <td class="paramtype">SampleHandler &amp;&nbsp;</td>
          <td class="paramname"> <em>sh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>alwaysQuery</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>make a list of grid datasets using the given pattern </p>
<p>This will first look for dataset containers, and if none are found, it will instead look for datasets. If those are also not found it will produce an error.</p>
<p>For patterns that don't contain a wild-card (i.e. that can only match one dataset/container) it instead adds the dataset directly without querying rucio. This is a performance optimization based on the assumption that you probably checked the dataset names beforehand, and that if you made a mistake it will pop up at a later stage anyways. If you want to query rucio even in those cases set alwaysQuery to true.</p>
<dl class="user"><dt><b>Guarantee</b></dt><dd>basic, may add some datasets </dd></dl>
<dl class="user"><dt><b>Failures</b></dt><dd>no pattern match<br/>
 rucio failures<br/>
 out of memory III </dd></dl>

</div>
</div>
<a class="anchor" id="abf33b8bdbc36bfc1b9da9a05a8144fa1"></a><!-- doxytag: member="SH::scanSingleDir" ref="abf33b8bdbc36bfc1b9da9a05a8144fa1" args="(SampleHandler &amp;sh, const std::string &amp;name, DiskList &amp;list, const std::string &amp;pattern)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SH::scanSingleDir </td>
          <td>(</td>
          <td class="paramtype">SampleHandler &amp;&nbsp;</td>
          <td class="paramname"> <em>sh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiskList &amp;&nbsp;</td>
          <td class="paramname"> <em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>pattern</em> = <code>&quot;*.root*&quot;</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>effects: scan the given directory tree and turn it into a single sample of the given name guarantee: strong failures: out of memory III </p>

</div>
</div>
<a class="anchor" id="afc2481fc630dc76adafeb035e97c92fe"></a><!-- doxytag: member="SH::splitSample" ref="afc2481fc630dc76adafeb035e97c92fe" args="(Sample &amp;sample, const Long64_t nevt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/d56/classSH_1_1SampleHandler.html">SampleHandler</a> SH::splitSample </td>
          <td>(</td>
          <td class="paramtype">Sample &amp;&nbsp;</td>
          <td class="paramname"> <em>sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Long64_t&nbsp;</td>
          <td class="paramname"> <em>nevt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>effects: split the given sample into a set of samples, with each sample containing either exactly one file or at most nevt events side effects: if scanNEvents hasn't been run on this sample, run it. guarantee: strong failures: out of memory failures: scanning errors </p>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 14 Apr 2017 for RootCore Packages by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
