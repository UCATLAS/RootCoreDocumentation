<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>RootCore Packages: SG::AuxElement Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="../../index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="../../search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="../../annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="../../classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="../../hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="../../functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="../../dd/d59/namespaceSG.html">SG</a>::<a class="el" href="../../dc/db0/classSG_1_1AuxElement.html">AuxElement</a>
  </div>
</div>
<div class="contents">
<h1>SG::AuxElement Class Reference</h1><!-- doxytag: class="SG::AuxElement" --><!-- doxytag: inherits="SG::IAuxElement" -->
<p>Base class for elements of a container that can have aux data.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d1/d6f/AuxElement_8h_source.html">AuxElement.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SG::AuxElement:</div>
<div class="dynsection">
 <div class="center">
  <img src="../../dc/db0/classSG_1_1AuxElement.gif" usemap="#SG::AuxElement_map" alt=""/>
  <map id="SG::AuxElement_map" name="SG::AuxElement_map">
<area href="../../df/dca/classSG_1_1IAuxElement.html" alt="SG::IAuxElement" shape="rect" coords="0,0,253,24"/>
<area href="../../d1/d51/structAAux.html" alt="AAux" shape="rect" coords="263,112,516,136"/>
<area href="../../d9/db3/structB.html" alt="B" shape="rect" coords="263,168,516,192"/>
<area href="../../db/db2/structC.html" alt="C" shape="rect" coords="263,224,516,248"/>
<area href="../../df/df0/structCAux.html" alt="CAux" shape="rect" coords="263,280,516,304"/>
<area href="../../de/d20/classElt.html" alt="Elt" shape="rect" coords="263,336,516,360"/>
<area href="../../de/d20/classElt.html" alt="Elt" shape="rect" coords="263,392,516,416"/>
<area href="../../d0/d71/classxAOD_1_1AFPData__v1.html" alt="xAOD::AFPData_v1" shape="rect" coords="263,448,516,472"/>
<area href="../../d4/dae/classxAOD_1_1AFPSiHit__v1.html" alt="xAOD::AFPSiHit_v1" shape="rect" coords="263,504,516,528"/>
<area href="../../d0/d58/classxAOD_1_1AFPTrack__v1.html" alt="xAOD::AFPTrack_v1" shape="rect" coords="263,560,516,584"/>
<area href="../../d5/df4/classxAOD_1_1ALFAData__v1.html" alt="xAOD::ALFAData_v1" shape="rect" coords="263,616,516,640"/>
<area href="../../d3/d9c/classxAOD_1_1BCMRawData__v1.html" alt="xAOD::BCMRawData_v1" shape="rect" coords="263,672,516,696"/>
<area href="../../de/d87/classxAOD_1_1BTagging__v1.html" alt="xAOD::BTagging_v1" shape="rect" coords="263,728,516,752"/>
<area href="../../df/d95/classxAOD_1_1BTagVertex__v1.html" alt="xAOD::BTagVertex_v1" shape="rect" coords="263,784,516,808"/>
<area href="../../d5/d22/classxAOD_1_1BunchConf__v1.html" alt="xAOD::BunchConf_v1" shape="rect" coords="263,840,516,864"/>
<area href="../../d9/d99/classxAOD_1_1CMMCPHits__v1.html" alt="xAOD::CMMCPHits_v1" shape="rect" coords="263,896,516,920"/>
<area href="../../dc/d52/classxAOD_1_1CMMEtSums__v1.html" alt="xAOD::CMMEtSums_v1" shape="rect" coords="263,952,516,976"/>
<area href="../../dd/de0/classxAOD_1_1CMMJetHits__v1.html" alt="xAOD::CMMJetHits_v1" shape="rect" coords="263,1008,516,1032"/>
<area href="../../db/d09/classxAOD_1_1CMMRoI__v1.html" alt="xAOD::CMMRoI_v1" shape="rect" coords="263,1064,516,1088"/>
<area href="../../d8/dd5/classxAOD_1_1CMXCPHits__v1.html" alt="xAOD::CMXCPHits_v1" shape="rect" coords="263,1120,516,1144"/>
<area href="../../d6/dcc/classxAOD_1_1CMXCPTob__v1.html" alt="xAOD::CMXCPTob_v1" shape="rect" coords="263,1176,516,1200"/>
<area href="../../da/d64/classxAOD_1_1CMXEtSums__v1.html" alt="xAOD::CMXEtSums_v1" shape="rect" coords="263,1232,516,1256"/>
<area href="../../da/d39/classxAOD_1_1CMXJetHits__v1.html" alt="xAOD::CMXJetHits_v1" shape="rect" coords="263,1288,516,1312"/>
<area href="../../d4/d7e/classxAOD_1_1CMXJetTob__v1.html" alt="xAOD::CMXJetTob_v1" shape="rect" coords="263,1344,516,1368"/>
<area href="../../d5/d01/classxAOD_1_1CMXRoI__v1.html" alt="xAOD::CMXRoI_v1" shape="rect" coords="263,1400,516,1424"/>
<area href="../../da/d15/classxAOD_1_1CPMHits__v1.html" alt="xAOD::CPMHits_v1" shape="rect" coords="263,1456,516,1480"/>
<area href="../../dc/d40/classxAOD_1_1CPMRoI__v1.html" alt="xAOD::CPMRoI_v1" shape="rect" coords="263,1512,516,1536"/>
<area href="../../d4/df9/classxAOD_1_1CPMTobRoI__v1.html" alt="xAOD::CPMTobRoI_v1" shape="rect" coords="263,1568,516,1592"/>
<area href="../../db/d35/classxAOD_1_1CPMTower__v1.html" alt="xAOD::CPMTower_v1" shape="rect" coords="263,1624,516,1648"/>
<area href="../../d7/d8c/classxAOD_1_1CPMTower__v2.html" alt="xAOD::CPMTower_v2" shape="rect" coords="263,1680,516,1704"/>
<area href="../../d5/db4/classxAOD_1_1CutBookkeeper__v1.html" alt="xAOD::CutBookkeeper_v1" shape="rect" coords="263,1736,516,1760"/>
<area href="../../d4/d49/classxAOD_1_1EmTauRoI__v1.html" alt="xAOD::EmTauRoI_v1" shape="rect" coords="263,1792,516,1816"/>
<area href="../../da/d1c/classxAOD_1_1EmTauRoI__v2.html" alt="xAOD::EmTauRoI_v2" shape="rect" coords="263,1848,516,1872"/>
<area href="../../db/d79/classxAOD_1_1EnergySumRoI__v1.html" alt="xAOD::EnergySumRoI_v1" shape="rect" coords="263,1904,516,1928"/>
<area href="../../df/df8/classxAOD_1_1EventInfo__v1.html" alt="xAOD::EventInfo_v1" shape="rect" coords="263,1960,516,1984"/>
<area href="../../d7/d93/classxAOD_1_1EventShape__v1.html" alt="xAOD::EventShape_v1" shape="rect" coords="263,2016,516,2040"/>
<area href="../../d1/dca/classxAOD_1_1FileMetaData__v1.html" alt="xAOD::FileMetaData_v1" shape="rect" coords="263,2072,516,2096"/>
<area href="../../da/d51/classxAOD_1_1ForwardEventInfo__v1.html" alt="xAOD::ForwardEventInfo_v1" shape="rect" coords="263,2128,516,2152"/>
<area href="../../d0/d63/classxAOD_1_1HIEventShape__v1.html" alt="xAOD::HIEventShape_v1" shape="rect" coords="263,2184,516,2208"/>
<area href="../../df/d4d/classxAOD_1_1HIEventShape__v2.html" alt="xAOD::HIEventShape_v2" shape="rect" coords="263,2240,516,2264"/>
<area href="../../d5/d4c/classxAOD_1_1IParticle.html" alt="xAOD::IParticle" shape="rect" coords="263,2296,516,2320"/>
<area href="../../d0/da2/classxAOD_1_1JEMEtSums__v1.html" alt="xAOD::JEMEtSums_v1" shape="rect" coords="263,2352,516,2376"/>
<area href="../../dd/d63/classxAOD_1_1JEMEtSums__v2.html" alt="xAOD::JEMEtSums_v2" shape="rect" coords="263,2408,516,2432"/>
<area href="../../dc/d46/classxAOD_1_1JEMHits__v1.html" alt="xAOD::JEMHits_v1" shape="rect" coords="263,2464,516,2488"/>
<area href="../../d0/d24/classxAOD_1_1JEMRoI__v1.html" alt="xAOD::JEMRoI_v1" shape="rect" coords="263,2520,516,2544"/>
<area href="../../dd/d13/classxAOD_1_1JEMTobRoI__v1.html" alt="xAOD::JEMTobRoI_v1" shape="rect" coords="263,2576,516,2600"/>
<area href="../../d5/d41/classxAOD_1_1JetElement__v1.html" alt="xAOD::JetElement_v1" shape="rect" coords="263,2632,516,2656"/>
<area href="../../d1/dc0/classxAOD_1_1JetElement__v2.html" alt="xAOD::JetElement_v2" shape="rect" coords="263,2688,516,2712"/>
<area href="../../da/d26/classxAOD_1_1JetEtRoI__v1.html" alt="xAOD::JetEtRoI_v1" shape="rect" coords="263,2744,516,2768"/>
<area href="../../d3/daa/classxAOD_1_1JetRoI__v1.html" alt="xAOD::JetRoI_v1" shape="rect" coords="263,2800,516,2824"/>
<area href="../../da/dbb/classxAOD_1_1JetRoI__v2.html" alt="xAOD::JetRoI_v2" shape="rect" coords="263,2856,516,2880"/>
<area href="../../d8/d83/classxAOD_1_1L1TopoRawData__v1.html" alt="xAOD::L1TopoRawData_v1" shape="rect" coords="263,2912,516,2936"/>
<area href="../../d0/d7e/classxAOD_1_1LumiBlockRange__v1.html" alt="xAOD::LumiBlockRange_v1" shape="rect" coords="263,2968,516,2992"/>
<area href="../../da/dc5/classxAOD_1_1MBTSModule__v1.html" alt="xAOD::MBTSModule_v1" shape="rect" coords="263,3024,516,3048"/>
<area href="../../dd/d06/classxAOD_1_1MissingET__v1.html" alt="xAOD::MissingET_v1" shape="rect" coords="263,3080,516,3104"/>
<area href="../../d5/d15/classxAOD_1_1MissingETAssociation__v1.html" alt="xAOD::MissingETAssociation_v1" shape="rect" coords="263,3136,516,3160"/>
<area href="../../d8/d38/classxAOD_1_1MissingETComponent__v1.html" alt="xAOD::MissingETComponent_v1" shape="rect" coords="263,3192,516,3216"/>
<area href="../../d9/d4f/classxAOD_1_1MuonRoI__v1.html" alt="xAOD::MuonRoI_v1" shape="rect" coords="263,3248,516,3272"/>
<area href="../../d8/d3e/classxAOD_1_1MuonSegment__v1.html" alt="xAOD::MuonSegment_v1" shape="rect" coords="263,3304,516,3328"/>
<area href="../../d9/d91/classxAOD_1_1RODHeader__v1.html" alt="xAOD::RODHeader_v1" shape="rect" coords="263,3360,516,3384"/>
<area href="../../d8/de4/classxAOD_1_1RODHeader__v2.html" alt="xAOD::RODHeader_v2" shape="rect" coords="263,3416,516,3440"/>
<area href="../../d6/d9c/classxAOD_1_1RoiDescriptorStore__v1.html" alt="xAOD::RoiDescriptorStore_v1" shape="rect" coords="263,3472,516,3496"/>
<area href="../../d2/d32/classxAOD_1_1SCTRawHitValidation__v1.html" alt="xAOD::SCTRawHitValidation_v1" shape="rect" coords="263,3528,516,3552"/>
<area href="../../d7/d60/classxAOD_1_1SlowMuon__v1.html" alt="xAOD::SlowMuon_v1" shape="rect" coords="263,3584,516,3608"/>
<area href="../../df/d48/classxAOD_1_1TrackMeasurementValidation__v1.html" alt="xAOD::TrackMeasurementValidation_v1" shape="rect" coords="263,3640,516,3664"/>
<area href="../../d0/d48/classxAOD_1_1TrackParticleClusterAssociation__v1.html" alt="xAOD::TrackParticleClusterAssociation_v1" shape="rect" coords="263,3696,516,3720"/>
<area href="../../d9/deb/classxAOD_1_1TrackStateValidation__v1.html" alt="xAOD::TrackStateValidation_v1" shape="rect" coords="263,3752,516,3776"/>
<area href="../../d2/dd6/classxAOD_1_1TrigBphys__v1.html" alt="xAOD::TrigBphys_v1" shape="rect" coords="263,3808,516,3832"/>
<area href="../../d7/dad/classxAOD_1_1TrigCaloCluster__v1.html" alt="xAOD::TrigCaloCluster_v1" shape="rect" coords="263,3864,516,3888"/>
<area href="../../de/dd4/classxAOD_1_1TrigComposite__v1.html" alt="xAOD::TrigComposite_v1" shape="rect" coords="263,3920,516,3944"/>
<area href="../../da/d7b/classxAOD_1_1TrigDecision__v1.html" alt="xAOD::TrigDecision_v1" shape="rect" coords="263,3976,516,4000"/>
<area href="../../d0/d12/classxAOD_1_1TriggerMenu__v1.html" alt="xAOD::TriggerMenu_v1" shape="rect" coords="263,4032,516,4056"/>
<area href="../../d9/d6d/classxAOD_1_1TriggerTower__v1.html" alt="xAOD::TriggerTower_v1" shape="rect" coords="263,4088,516,4112"/>
<area href="../../dc/d8a/classxAOD_1_1TrigHisto2D__v1.html" alt="xAOD::TrigHisto2D_v1" shape="rect" coords="263,4144,516,4168"/>
<area href="../../d5/d0a/classxAOD_1_1TrigMissingET__v1.html" alt="xAOD::TrigMissingET_v1" shape="rect" coords="263,4200,516,4224"/>
<area href="../../d9/db6/classxAOD_1_1TrigNavigation__v1.html" alt="xAOD::TrigNavigation_v1" shape="rect" coords="263,4256,516,4280"/>
<area href="../../d9/dc1/classxAOD_1_1TrigPassBits__v1.html" alt="xAOD::TrigPassBits_v1" shape="rect" coords="263,4312,516,4336"/>
<area href="../../d0/d9f/classxAOD_1_1TrigRingerRings__v1.html" alt="xAOD::TrigRingerRings_v1" shape="rect" coords="263,4368,516,4392"/>
<area href="../../d7/d25/classxAOD_1_1TrigRingerRings__v2.html" alt="xAOD::TrigRingerRings_v2" shape="rect" coords="263,4424,516,4448"/>
<area href="../../dc/db7/classxAOD_1_1TrigRNNOutput__v1.html" alt="xAOD::TrigRNNOutput_v1" shape="rect" coords="263,4480,516,4504"/>
<area href="../../df/dfb/classxAOD_1_1TrigRNNOutput__v2.html" alt="xAOD::TrigRNNOutput_v2" shape="rect" coords="263,4536,516,4560"/>
<area href="../../d3/dc1/classxAOD_1_1TrigSpacePointCounts__v1.html" alt="xAOD::TrigSpacePointCounts_v1" shape="rect" coords="263,4592,516,4616"/>
<area href="../../db/d50/classxAOD_1_1TrigT2MbtsBits__v1.html" alt="xAOD::TrigT2MbtsBits_v1" shape="rect" coords="263,4648,516,4672"/>
<area href="../../dd/de9/classxAOD_1_1TrigT2ZdcSignals__v1.html" alt="xAOD::TrigT2ZdcSignals_v1" shape="rect" coords="263,4704,516,4728"/>
<area href="../../d3/d07/classxAOD_1_1TrigTrackCounts__v1.html" alt="xAOD::TrigTrackCounts_v1" shape="rect" coords="263,4760,516,4784"/>
<area href="../../d3/d8a/classxAOD_1_1TrigVertexCounts__v1.html" alt="xAOD::TrigVertexCounts_v1" shape="rect" coords="263,4816,516,4840"/>
<area href="../../df/dad/classxAOD_1_1TruthEventBase__v1.html" alt="xAOD::TruthEventBase_v1" shape="rect" coords="263,4872,516,4896"/>
<area href="../../d2/de3/classxAOD_1_1TruthMetaData__v1.html" alt="xAOD::TruthMetaData_v1" shape="rect" coords="263,4928,516,4952"/>
<area href="../../d8/dfa/classxAOD_1_1TruthVertex__v1.html" alt="xAOD::TruthVertex_v1" shape="rect" coords="263,4984,516,5008"/>
<area href="../../db/dd1/classxAOD_1_1Vertex__v1.html" alt="xAOD::Vertex_v1" shape="rect" coords="263,5040,516,5064"/>
<area href="../../d4/d68/classxAOD_1_1ZdcModule__v1.html" alt="xAOD::ZdcModule_v1" shape="rect" coords="263,5096,516,5120"/>
</map>
 </div>
</div>

<p><a href="../../da/d11/classSG_1_1AuxElement-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d31/classSG_1_1AuxElement_1_1Accessor.html">Accessor</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper class to provide type-safe access to aux data.  <a href="../../d8/d31/classSG_1_1AuxElement_1_1Accessor.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d86/classSG_1_1AuxElement_1_1ConstAccessor.html">ConstAccessor</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper class to provide constant type-safe access to aux data.  <a href="../../dd/d86/classSG_1_1AuxElement_1_1ConstAccessor.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d59/classSG_1_1AuxElement_1_1Decorator.html">Decorator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper class to provide type-safe access to aux data.  <a href="../../d3/d59/classSG_1_1AuxElement_1_1Decorator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dd4/classSG_1_1AuxElement_1_1TypelessConstAccessor.html">TypelessConstAccessor</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper class to provide const generic access to aux data.  <a href="../../d2/dd4/classSG_1_1AuxElement_1_1TypelessConstAccessor.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef247a3ae0d53cd8c4f90702c7501d2f"></a><!-- doxytag: member="SG::AuxElement::AuxElement" ref="aef247a3ae0d53cd8c4f90702c7501d2f" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/db0/classSG_1_1AuxElement.html#aef247a3ae0d53cd8c4f90702c7501d2f">AuxElement</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/db0/classSG_1_1AuxElement.html#ac8345167ba85a0788d804a39b8325a36">AuxElement</a> (const <a class="el" href="../../dc/db0/classSG_1_1AuxElement.html">AuxElement</a> &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy Constructor.  <a href="#ac8345167ba85a0788d804a39b8325a36"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/db0/classSG_1_1AuxElement.html">AuxElement</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/db0/classSG_1_1AuxElement.html#a1ecd49ad16cba61c3131046d8e068650">operator=</a> (const <a class="el" href="../../dc/db0/classSG_1_1AuxElement.html">AuxElement</a> &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment.  <a href="#a1ecd49ad16cba61c3131046d8e068650"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/db0/classSG_1_1AuxElement.html#a0b6a5f12eb826137b6d218f5738bb0b1">~AuxElement</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#a0b6a5f12eb826137b6d218f5738bb0b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9004b51bd3619cab56c3d52e290c09b9"></a><!-- doxytag: member="SG::AuxElement::container" ref="a9004b51bd3619cab56c3d52e290c09b9" args="()" -->
<a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html">SG::AuxVectorData</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/db0/classSG_1_1AuxElement.html#a9004b51bd3619cab56c3d52e290c09b9">container</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the container holding this element. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45f6f3563f9c8f088e4b840f81103588"></a><!-- doxytag: member="SG::AuxElement::container" ref="a45f6f3563f9c8f088e4b840f81103588" args="() const " -->
const <a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html">SG::AuxVectorData</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/db0/classSG_1_1AuxElement.html#a45f6f3563f9c8f088e4b840f81103588">container</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the container holding this element. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba555afb4547fbe96fbdc4b266f75f16"></a><!-- doxytag: member="SG::AuxElement::index" ref="aba555afb4547fbe96fbdc4b266f75f16" args="() const " -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/db0/classSG_1_1AuxElement.html#aba555afb4547fbe96fbdc4b266f75f16">index</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the index of this element within its container. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d0/d6e/classSG_1_1AuxDataTraits.html">AuxDataTraits</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a> &gt;::reference_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/db0/classSG_1_1AuxElement.html#ace84dc4cbb05aa996bc0bb12ea0580b0">auxdata</a> (const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch an aux data variable, as a non-const reference.  <a href="#ace84dc4cbb05aa996bc0bb12ea0580b0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d0/d6e/classSG_1_1AuxDataTraits.html">AuxDataTraits</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a> &gt;::reference_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/db0/classSG_1_1AuxElement.html#a7aaa8e9eb54091ab7ee43bb7c73918e4">auxdata</a> (const std::string &amp;name, const std::string &amp;clsname)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch an aux data variable, as a non-const reference.  <a href="#a7aaa8e9eb54091ab7ee43bb7c73918e4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d0/d6e/classSG_1_1AuxDataTraits.html">AuxDataTraits</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a> &gt;<br class="typebreak"/>
::const_reference_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/db0/classSG_1_1AuxElement.html#acd13909ea46d99e1b502834f133a159c">auxdata</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch an aux data variable, as a const reference.  <a href="#acd13909ea46d99e1b502834f133a159c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d0/d6e/classSG_1_1AuxDataTraits.html">AuxDataTraits</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a> &gt;<br class="typebreak"/>
::const_reference_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/db0/classSG_1_1AuxElement.html#a5279e0349d690c26121f60b5a8778322">auxdata</a> (const std::string &amp;name, const std::string &amp;clsname) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch an aux data variable, as a const reference.  <a href="#a5279e0349d690c26121f60b5a8778322"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d0/d6e/classSG_1_1AuxDataTraits.html">AuxDataTraits</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a> &gt;<br class="typebreak"/>
::const_reference_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/db0/classSG_1_1AuxElement.html#a1fc119dd13bd2c74f2ce4f2ba19c8898">auxdataConst</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch an aux data variable, as a const reference.  <a href="#a1fc119dd13bd2c74f2ce4f2ba19c8898"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d0/d6e/classSG_1_1AuxDataTraits.html">AuxDataTraits</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a> &gt;<br class="typebreak"/>
::const_reference_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/db0/classSG_1_1AuxElement.html#afa20cbd90cdb931e16c2751709e35271">auxdataConst</a> (const std::string &amp;name, const std::string &amp;clsname) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch an aux data variable, as a const reference.  <a href="#afa20cbd90cdb931e16c2751709e35271"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/db0/classSG_1_1AuxElement.html#af727b22ab51f1d848fc3cf59065b99ea">isAvailable</a> (const std::string &amp;name, const std::string &amp;clsname=&quot;&quot;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if an aux variable is available for reading.  <a href="#af727b22ab51f1d848fc3cf59065b99ea"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/db0/classSG_1_1AuxElement.html#a864fc1dab026cbcf20b2c7e3904b89a4">isAvailableWritable</a> (const std::string &amp;name, const std::string &amp;clsname=&quot;&quot;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if an aux variable is available for writing.  <a href="#a864fc1dab026cbcf20b2c7e3904b89a4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/db0/classSG_1_1AuxElement.html#a5c56e0b548ba0f0fa6eba200defaa44d">isAvailableWritableAsDecoration</a> (const std::string &amp;name, const std::string &amp;clsname=&quot;&quot;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if an aux variable is available for writing as a decoration.  <a href="#a5c56e0b548ba0f0fa6eba200defaa44d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d0/d6e/classSG_1_1AuxDataTraits.html">AuxDataTraits</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a> &gt;::reference_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/db0/classSG_1_1AuxElement.html#af85b897bffef87879e0ed6a58428a60b">auxdecor</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch an aux decoration, as a non-const reference.  <a href="#af85b897bffef87879e0ed6a58428a60b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d0/d6e/classSG_1_1AuxDataTraits.html">AuxDataTraits</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a> &gt;::reference_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/db0/classSG_1_1AuxElement.html#a6c8fc3d315a5ec0633e7ae6a2b26a432">auxdecor</a> (const std::string &amp;name, const std::string &amp;clsname) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch an aux decoration, as a non-const reference.  <a href="#a6c8fc3d315a5ec0633e7ae6a2b26a432"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/db0/classSG_1_1AuxElement.html#a197bf9fc579d49e25a850a4b3a5c14e8">makePrivateStore</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new (empty) private store for this object.  <a href="#a197bf9fc579d49e25a850a4b3a5c14e8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class U1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/db0/classSG_1_1AuxElement.html#ad2eaf2e38536e93c05aebaf1218516a2">makePrivateStore</a> (const U1 &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new private store for this object and copy aux data.  <a href="#ad2eaf2e38536e93c05aebaf1218516a2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class U1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/db0/classSG_1_1AuxElement.html#a164f94b3ddbbc773ba8beefdb7cb8677">makePrivateStore</a> (const U1 *other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new private store for this object and copy aux data.  <a href="#a164f94b3ddbbc773ba8beefdb7cb8677"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/db0/classSG_1_1AuxElement.html#aab2f280f3c832e285fe020365bb3ac1e">releasePrivateStore</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release and free any private store associated with this object.  <a href="#aab2f280f3c832e285fe020365bb3ac1e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/db0/classSG_1_1AuxElement.html#a57b602d3ec1c0129811375f46c18c049">setStore</a> (const <a class="el" href="../../d3/dd5/classSG_1_1IConstAuxStore.html">SG::IConstAuxStore</a> *store)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the store associated with this object.  <a href="#a57b602d3ec1c0129811375f46c18c049"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/db0/classSG_1_1AuxElement.html#a9cc58e245a417833f297e836d9559a32">setStore</a> (<a class="el" href="../../dc/d05/classSG_1_1IAuxStore.html">SG::IAuxStore</a> *store)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the store associated with this object.  <a href="#a9cc58e245a417833f297e836d9559a32"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/db0/classSG_1_1AuxElement.html#a4bdca4ef5f1df892b5dc9742644444b8">setStore</a> (const <a class="el" href="../../da/da2/classDataLink.html">DataLink</a>&lt; <a class="el" href="../../d3/dd5/classSG_1_1IConstAuxStore.html">SG::IConstAuxStore</a> &gt; &amp;store)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the store associated with this object.  <a href="#a4bdca4ef5f1df892b5dc9742644444b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/db0/classSG_1_1AuxElement.html#a3079709e44e8ac7452c05454f4994ce9">setConstStore</a> (const <a class="el" href="../../d3/dd5/classSG_1_1IConstAuxStore.html">SG::IConstAuxStore</a> *store)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Synonym for <code>setStore</code> with <code><a class="el" href="../../d3/dd5/classSG_1_1IConstAuxStore.html" title="Interface for const operations on an auxiliary store.">IConstAuxStore</a></code>.  <a href="#a3079709e44e8ac7452c05454f4994ce9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/db0/classSG_1_1AuxElement.html#a68b13428943609fd2b56c35c9dec85b3">setNonConstStore</a> (<a class="el" href="../../dc/d05/classSG_1_1IAuxStore.html">SG::IAuxStore</a> *store)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Synonym for <code>setStore</code> with <code><a class="el" href="../../dc/d05/classSG_1_1IAuxStore.html" title="Interface for non-const operations on an auxiliary store.">IAuxStore</a></code>.  <a href="#a68b13428943609fd2b56c35c9dec85b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7f08e277b177f9dd74924e7d635034e"></a><!-- doxytag: member="SG::AuxElement::usingPrivateStore" ref="ad7f08e277b177f9dd74924e7d635034e" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/db0/classSG_1_1AuxElement.html#ad7f08e277b177f9dd74924e7d635034e">usingPrivateStore</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test to see if this object is currently using a private store. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/db0/classSG_1_1AuxElement.html#af97c2ef167b0d66ada327a0ada1015e7">usingStandaloneStore</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test to see if this object is currently using a standalone store.  <a href="#af97c2ef167b0d66ada327a0ada1015e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d3/dd5/classSG_1_1IConstAuxStore.html">SG::IConstAuxStore</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/db0/classSG_1_1AuxElement.html#a324d8fccbfe274b6ff91d6a19de35caf">getConstStore</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the current store, as a const interface.  <a href="#a324d8fccbfe274b6ff91d6a19de35caf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/d05/classSG_1_1IAuxStore.html">SG::IAuxStore</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/db0/classSG_1_1AuxElement.html#afc4602cf2edeb01c3350367f5985f49b">getStore</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the current store, as a non-const interface.  <a href="#afc4602cf2edeb01c3350367f5985f49b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/db0/classSG_1_1AuxElement.html#a127c2c4839333f537cb83ecdc82ad99d">clearCache</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear the cached aux data pointers.  <a href="#a127c2c4839333f537cb83ecdc82ad99d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../dd/dac/classSG_1_1unordered__set.html">SG::auxid_set_t</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/db0/classSG_1_1AuxElement.html#a607ee93fe8081d2bd3aa1745f0cbbb50">getAuxIDs</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a set of identifiers for existing data items for this object.  <a href="#a607ee93fe8081d2bd3aa1745f0cbbb50"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/db0/classSG_1_1AuxElement.html#a2d354faac53b7a003d29c0f7b95f3672">hasStore</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if this object has an associated store.  <a href="#a2d354faac53b7a003d29c0f7b95f3672"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/db0/classSG_1_1AuxElement.html#ac4bc75a2f7b1ed984ffae1bba6de58ba">hasNonConstStore</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if this object has an associated non-const store.  <a href="#ac4bc75a2f7b1ed984ffae1bba6de58ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/db0/classSG_1_1AuxElement.html#a71044a012a37af1bb0b6fab3d3ea1230">clearDecorations</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear all decorations.  <a href="#a71044a012a37af1bb0b6fab3d3ea1230"></a><br/></td></tr>
<tr><td colspan="2"><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a154ec406bc6531a348a80e679da31f"></a><!-- doxytag: member="SG::AuxElement::SG::AuxVectorBase" ref="a6a154ec406bc6531a348a80e679da31f" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/db0/classSG_1_1AuxElement.html#a6a154ec406bc6531a348a80e679da31f">SG::AuxVectorBase</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4573c8a5a16556f7a1826c502a8a1577"></a><!-- doxytag: member="SG::AuxElement::SG::AuxVectorBase_test" ref="a4573c8a5a16556f7a1826c502a8a1577" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/db0/classSG_1_1AuxElement.html#a4573c8a5a16556f7a1826c502a8a1577">SG::AuxVectorBase_test</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Base class for elements of a container that can have aux data. </p>
<p>Classes that want to have associated auxiliary data should derive from this class. (It is also possible to use this class directly, if you want a container that _only_ stores auxiliary data.)</p>
<p>The first thing that happens when you derive from <code><a class="el" href="../../dc/db0/classSG_1_1AuxElement.html" title="Base class for elements of a container that can have aux data.">AuxElement</a></code> is that when an object is inserted into a <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code>, the vector will maintain information in the object telling were it is within the vector. For example:</p>
<div class="fragment"><pre class="fragment">  <a class="code" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&amp;lt;T&amp;gt;.">DataVector&lt;SG::AuxElement&gt;</a> v (2);
  v[1] = <span class="keyword">new</span> <a class="code" href="../../dc/db0/classSG_1_1AuxElement.html" title="Base class for elements of a container that can have aux data.">SG::AuxElement</a>;
  assert (v[1]-&gt;<a class="code" href="../../dc/db0/classSG_1_1AuxElement.html#aba555afb4547fbe96fbdc4b266f75f16" title="Return the index of this element within its container.">index</a>() == 1);
  assert (v[1]=&gt;<a class="code" href="../../dc/db0/classSG_1_1AuxElement.html#a9004b51bd3619cab56c3d52e290c09b9" title="Return the container holding this element.">container</a>() == &amp;v);
</pre></div><p>As long as you don't use <code><a class="el" href="../../d0/d4d/classDataVector.html#a0e2e64a35d842a206c96ccfec265df21" title="Return the underlying std::vector of the container.">DataVector::stdcont</a></code> or use unsafe casts, <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> will correctly maintain this information.</p>
<p>When an object deriving from <code><a class="el" href="../../dc/db0/classSG_1_1AuxElement.html" title="Base class for elements of a container that can have aux data.">AuxElement</a></code> is in a <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> it may have auxiliary data associated with it; that is, named data objects of arbitrary type. The recommended way of accessing auxiliary data is through the <code><a class="el" href="../../d8/d31/classSG_1_1AuxElement_1_1Accessor.html" title="Helper class to provide type-safe access to aux data.">Accessor</a></code> and <code><a class="el" href="../../dd/d86/classSG_1_1AuxElement_1_1ConstAccessor.html" title="Helper class to provide constant type-safe access to aux data.">ConstAccessor</a></code> classes, which cache the lookup between the aux data item name and its internal representation. The difference between these two is that <code><a class="el" href="../../dd/d86/classSG_1_1AuxElement_1_1ConstAccessor.html" title="Helper class to provide constant type-safe access to aux data.">ConstAccessor</a></code> allows only const access to the element, while <code><a class="el" href="../../d8/d31/classSG_1_1AuxElement_1_1Accessor.html" title="Helper class to provide type-safe access to aux data.">Accessor</a></code>, which derives from it, allows non-const access as well. <a class="el" href="../../d4/dc4/structA.html">A</a> given name must always have the same type, no matter where it is used (even across different classes); otherwise, an exception will be thrown. To help prevent conflicts between different classes, aux data item names may be optionally qualified with a class name. Here's an example of using <code><a class="el" href="../../dd/d86/classSG_1_1AuxElement_1_1ConstAccessor.html" title="Helper class to provide constant type-safe access to aux data.">ConstAccessor</a>:</code> </p>
<div class="fragment"><pre class="fragment">   <span class="comment">// Only need to do this once.</span>
   Myclass::ConstAccessor&lt;int&gt; vint1 (<span class="stringliteral">&quot;myInt&quot;</span>);
   ...
   <span class="keyword">const</span> Myclass* m = ...;
   <span class="keywordtype">int</span> x = vint1 (*m);
</pre></div><p>The <code>auxdata</code> methods can be used as a shortcut for this, but that's not recommended for anything for which performance is an issue.</p>
<p>You can also define getters/setters in your class:</p>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>Myclass {
    ...
    <span class="keywordtype">int</span> get_x()<span class="keyword"> const</span>
<span class="keyword">    </span>{ <span class="keyword">static</span> ConstAccessor&lt;int&gt; acc (<span class="stringliteral">&quot;x&quot;</span>, <span class="stringliteral">&quot;Myclass&quot;</span>);
      <span class="keywordflow">return</span> acc (*<span class="keyword">this</span>); }
    <span class="keywordtype">int</span>&amp; get_x()
    { <span class="keyword">static</span> Accessor&lt;int&gt; acc (<span class="stringliteral">&quot;x&quot;</span>, <span class="stringliteral">&quot;Myclass&quot;</span>);
      <span class="keywordflow">return</span> acc (*<span class="keyword">this</span>); }
</pre></div><p>In addition, one sometimes wants to add additional auxiliary data to an existing const container; for example, after a container has been retrieved from StoreGate. This is called `decoration', and is handled by the <code><a class="el" href="../../d3/d59/classSG_1_1AuxElement_1_1Decorator.html" title="Helper class to provide type-safe access to aux data.">Decorator</a></code> object, which is much like <code><a class="el" href="../../d8/d31/classSG_1_1AuxElement_1_1Accessor.html" title="Helper class to provide type-safe access to aux data.">Accessor</a></code> and <code><a class="el" href="../../dd/d86/classSG_1_1AuxElement_1_1ConstAccessor.html" title="Helper class to provide constant type-safe access to aux data.">ConstAccessor</a></code>. The difference is that <code><a class="el" href="../../d3/d59/classSG_1_1AuxElement_1_1Decorator.html" title="Helper class to provide type-safe access to aux data.">Decorator</a></code> can take a const container and return a non-const, modifiable reference. If the container has been locked by calling <code>StoreGateSvc::setConst</code>, then this is allowed only if this is a new auxiliary item, in which case it is marked as a decoration, or if it is already marked as a decoration. This prevents changing existing variables in a locked container. An <code>auxdecor</code> method is also available, analogous to <code>auxdata</code>.</p>
<p>In addition to the above, the class <code><a class="el" href="../../d2/dd4/classSG_1_1AuxElement_1_1TypelessConstAccessor.html" title="Helper class to provide const generic access to aux data.">TypelessConstAccessor</a></code> is a non-templated class that allows access to auxiliary data items directly as a `void *`. This is useful for code which operates on auxiliary data generically; it shouldn't really be used in other contexts.</p>
<p>Normally, an object can have auxiliary data only when it is part of a container. But sometimes it is useful to be able to associate aux data with an object before it has been added to a container. You can enable this by creating a `private store' for the object with <code>makePrivateStore</code>. This can optionally take an argument from which aux data should be copied. (Using a private store adds overhead, which is why it is not enabled by default.) Example:</p>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>Myclass : <span class="keyword">public</span> SG::<a class="code" href="../../dc/db0/classSG_1_1AuxElement.html#aef247a3ae0d53cd8c4f90702c7501d2f" title="Default constructor.">AuxElement</a> { ... };
  ...
  Myclass::Accessor&lt;int&gt; myint (<span class="stringliteral">&quot;myint&quot;</span>);
  <span class="keyword">const</span> Myclass* m = <span class="keyword">new</span> Myclass;
  m-&gt;makePrivateStore();
  myint(*m) = 10;
  <a class="code" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&amp;lt;T&amp;gt;.">DataVector&lt;Myclass&gt;</a> v;
  v.<a class="code" href="../../d0/d4d/classDataVector.html#a486aeb4868e7c29331717adb06ea0df2" title="Add an element to the end of the collection.">push_back</a>(m);
  assert (myint(v[0]) == 10);
</pre></div><p>When an object with a private store is added to a container, the aux data is copied to the container and the private store is released. However, the fact that we had a private store is remembered; if the object is later removed from the container, the private store will be remade, and the aux data will be copied back from the container to the private store. To explicitly release the private store (so that it won't come back automatically), call <code>releasePrivateStore</code>.</p>
<p>If you add <code>makePrivateStore</code> calls to the constructors of your class, then you should be able to treat aux data as if it were part of the object itself; the required copying will be handled automatically.</p>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>Myclass : <span class="keyword">public</span> SG::<a class="code" href="../../dc/db0/classSG_1_1AuxElement.html#aef247a3ae0d53cd8c4f90702c7501d2f" title="Default constructor.">AuxElement</a>
  {
  <span class="keyword">public</span>:
    Myclass() { <a class="code" href="../../dc/db0/classSG_1_1AuxElement.html#a197bf9fc579d49e25a850a4b3a5c14e8" title="Create a new (empty) private store for this object.">makePrivateStore</a>(); }
    Myclass(<span class="keyword">const</span> Myclass* other) { <a class="code" href="../../dc/db0/classSG_1_1AuxElement.html#a197bf9fc579d49e25a850a4b3a5c14e8" title="Create a new (empty) private store for this object.">makePrivateStore</a>(other); }
</pre></div><p>The <code><a class="el" href="../../df/dbd/classSG_1_1AuxElementComplete.html" title="Wrapper to automatically create a private store for an element.">SG::AuxElementComplete</a></code> template class may be helpful in setting this up.</p>
<p>It is also possible to associate one of these objects with an external aux data store. This is the `standalone' mode. To do this, use the <code>setStore</code> methods, exactly as you would for a container that has aux data. <code>setStore</code> will throw an exception if the object is a member of a container or has a private store.</p>
<p>This class should not have any virtual methods (to avoid forcing derived classes to have a vtable). </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac8345167ba85a0788d804a39b8325a36"></a><!-- doxytag: member="SG::AuxElement::AuxElement" ref="ac8345167ba85a0788d804a39b8325a36" args="(const AuxElement &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SG::AuxElement::AuxElement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/db0/classSG_1_1AuxElement.html">AuxElement</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy Constructor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>other</em>&nbsp;</td><td>Object being copied.</td></tr>
  </table>
  </dd>
</dl>
<p>We do not copy the container/index --- the new object is not yet in a container!</p>
<p>In the case of constructing an object with a private store, <code>makePrivateStore</code> will take care of copying the aux data. </p>

</div>
</div>
<a class="anchor" id="a0b6a5f12eb826137b6d218f5738bb0b1"></a><!-- doxytag: member="SG::AuxElement::~AuxElement" ref="a0b6a5f12eb826137b6d218f5738bb0b1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SG::AuxElement::~AuxElement </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. </p>
<p>Any private store is deleted. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a5279e0349d690c26121f60b5a8778322"></a><!-- doxytag: member="SG::AuxElement::auxdata" ref="a5279e0349d690c26121f60b5a8778322" args="(const std::string &amp;name, const std::string &amp;clsname) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d6e/classSG_1_1AuxDataTraits.html">AuxDataTraits</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a> &gt;::const_reference_type SG::AuxElement::auxdata </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>clsname</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch an aux data variable, as a const reference. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of the aux variable. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clsname</em>&nbsp;</td><td>The name of the associated class. May be blank.</td></tr>
  </table>
  </dd>
</dl>
<p>This method has to translate from the aux data name to the internal representation each time it is called. Using this method inside of loops is discouraged; instead use the <code><a class="el" href="../../d8/d31/classSG_1_1AuxElement_1_1Accessor.html" title="Helper class to provide type-safe access to aux data.">Accessor</a></code> or <code><a class="el" href="../../dd/d86/classSG_1_1AuxElement_1_1ConstAccessor.html" title="Helper class to provide constant type-safe access to aux data.">ConstAccessor</a></code> classes above. </p>

<p>Reimplemented in <a class="el" href="../../d5/d4c/classxAOD_1_1IParticle.html#a523f65a37d801b93f9334dc555257ef6">xAOD::IParticle</a>.</p>

</div>
</div>
<a class="anchor" id="acd13909ea46d99e1b502834f133a159c"></a><!-- doxytag: member="SG::AuxElement::auxdata" ref="acd13909ea46d99e1b502834f133a159c" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d6e/classSG_1_1AuxDataTraits.html">AuxDataTraits</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a> &gt;::const_reference_type SG::AuxElement::auxdata </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch an aux data variable, as a const reference. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of the aux variable.</td></tr>
  </table>
  </dd>
</dl>
<p>This method has to translate from the aux data name to the internal representation each time it is called. Using this method inside of loops is discouraged; instead use the <code><a class="el" href="../../d8/d31/classSG_1_1AuxElement_1_1Accessor.html" title="Helper class to provide type-safe access to aux data.">Accessor</a></code> or <code><a class="el" href="../../dd/d86/classSG_1_1AuxElement_1_1ConstAccessor.html" title="Helper class to provide constant type-safe access to aux data.">ConstAccessor</a></code> classes above. </p>

</div>
</div>
<a class="anchor" id="a7aaa8e9eb54091ab7ee43bb7c73918e4"></a><!-- doxytag: member="SG::AuxElement::auxdata" ref="a7aaa8e9eb54091ab7ee43bb7c73918e4" args="(const std::string &amp;name, const std::string &amp;clsname)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d6e/classSG_1_1AuxDataTraits.html">AuxDataTraits</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a> &gt;::reference_type SG::AuxElement::auxdata </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>clsname</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch an aux data variable, as a non-const reference. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of the aux variable. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clsname</em>&nbsp;</td><td>The name of the associated class. May be blank.</td></tr>
  </table>
  </dd>
</dl>
<p>This method has to translate from the aux data name to the internal representation each time it is called. Using this method inside of loops is discouraged; instead use the <code><a class="el" href="../../d8/d31/classSG_1_1AuxElement_1_1Accessor.html" title="Helper class to provide type-safe access to aux data.">Accessor</a></code> class above. </p>

<p>Reimplemented in <a class="el" href="../../d5/d4c/classxAOD_1_1IParticle.html#a27c59a50a203be500dae35e8ab217c75">xAOD::IParticle</a>.</p>

</div>
</div>
<a class="anchor" id="ace84dc4cbb05aa996bc0bb12ea0580b0"></a><!-- doxytag: member="SG::AuxElement::auxdata" ref="ace84dc4cbb05aa996bc0bb12ea0580b0" args="(const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d6e/classSG_1_1AuxDataTraits.html">AuxDataTraits</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a> &gt;::reference_type SG::AuxElement::auxdata </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch an aux data variable, as a non-const reference. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of the aux variable.</td></tr>
  </table>
  </dd>
</dl>
<p>This method has to translate from the aux data name to the internal representation each time it is called. Using this method inside of loops is discouraged; instead use the <code><a class="el" href="../../d8/d31/classSG_1_1AuxElement_1_1Accessor.html" title="Helper class to provide type-safe access to aux data.">Accessor</a></code> class above.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of the aux variable. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clsname</em>&nbsp;</td><td>The name of the associated class. May be blank.</td></tr>
  </table>
  </dd>
</dl>
<p>This method has to translate from the aux data name to the internal representation each time it is called. Using this method inside of loops is discouraged; instead use the <code><a class="el" href="../../d8/d31/classSG_1_1AuxElement_1_1Accessor.html" title="Helper class to provide type-safe access to aux data.">Accessor</a></code> class above. </p>

</div>
</div>
<a class="anchor" id="afa20cbd90cdb931e16c2751709e35271"></a><!-- doxytag: member="SG::AuxElement::auxdataConst" ref="afa20cbd90cdb931e16c2751709e35271" args="(const std::string &amp;name, const std::string &amp;clsname) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d6e/classSG_1_1AuxDataTraits.html">AuxDataTraits</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a> &gt;::const_reference_type SG::AuxElement::auxdataConst </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>clsname</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch an aux data variable, as a const reference. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of the aux variable. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clsname</em>&nbsp;</td><td>The name of the associated class. May be blank.</td></tr>
  </table>
  </dd>
</dl>
<p>This method has to translate from the aux data name to the internal representation each time it is called. Using this method inside of loops is discouraged; instead use the <code><a class="el" href="../../dd/d86/classSG_1_1AuxElement_1_1ConstAccessor.html" title="Helper class to provide constant type-safe access to aux data.">ConstAccessor</a></code> class above. </p>

</div>
</div>
<a class="anchor" id="a1fc119dd13bd2c74f2ce4f2ba19c8898"></a><!-- doxytag: member="SG::AuxElement::auxdataConst" ref="a1fc119dd13bd2c74f2ce4f2ba19c8898" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d6e/classSG_1_1AuxDataTraits.html">AuxDataTraits</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a> &gt;::const_reference_type SG::AuxElement::auxdataConst </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch an aux data variable, as a const reference. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of the aux variable.</td></tr>
  </table>
  </dd>
</dl>
<p>This method has to translate from the aux data name to the internal representation each time it is called. Using this method inside of loops is discouraged; instead use the <code><a class="el" href="../../dd/d86/classSG_1_1AuxElement_1_1ConstAccessor.html" title="Helper class to provide constant type-safe access to aux data.">ConstAccessor</a></code> class above. </p>

</div>
</div>
<a class="anchor" id="a6c8fc3d315a5ec0633e7ae6a2b26a432"></a><!-- doxytag: member="SG::AuxElement::auxdecor" ref="a6c8fc3d315a5ec0633e7ae6a2b26a432" args="(const std::string &amp;name, const std::string &amp;clsname) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d6e/classSG_1_1AuxDataTraits.html">AuxDataTraits</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a> &gt;::reference_type SG::AuxElement::auxdecor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>clsname</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch an aux decoration, as a non-const reference. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of the aux variable. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clsname</em>&nbsp;</td><td>The name of the associated class. May be blank.</td></tr>
  </table>
  </dd>
</dl>
<p>This method has to translate from the aux data name to the internal representation each time it is called. Using this method inside of loops is discouraged; instead use the <code><a class="el" href="../../d8/d31/classSG_1_1AuxElement_1_1Accessor.html" title="Helper class to provide type-safe access to aux data.">Accessor</a></code> class above.</p>
<p>If the container is locked, this will allow fetching only variables that do not yet exist (in which case they will be marked as decorations) or variables already marked as decorations. </p>

</div>
</div>
<a class="anchor" id="af85b897bffef87879e0ed6a58428a60b"></a><!-- doxytag: member="SG::AuxElement::auxdecor" ref="af85b897bffef87879e0ed6a58428a60b" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d6e/classSG_1_1AuxDataTraits.html">AuxDataTraits</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a> &gt;::reference_type SG::AuxElement::auxdecor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch an aux decoration, as a non-const reference. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of the aux variable.</td></tr>
  </table>
  </dd>
</dl>
<p>This method has to translate from the aux data name to the internal representation each time it is called. Using this method inside of loops is discouraged; instead use the <code><a class="el" href="../../d8/d31/classSG_1_1AuxElement_1_1Accessor.html" title="Helper class to provide type-safe access to aux data.">Accessor</a></code> class above.</p>
<p>If the container is locked, this will allow fetching only variables that do not yet exist (in which case they will be marked as decorations) or variables already marked as decorations.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of the aux variable. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clsname</em>&nbsp;</td><td>The name of the associated class. May be blank.</td></tr>
  </table>
  </dd>
</dl>
<p>This method has to translate from the aux data name to the internal representation each time it is called. Using this method inside of loops is discouraged; instead use the <code><a class="el" href="../../d8/d31/classSG_1_1AuxElement_1_1Accessor.html" title="Helper class to provide type-safe access to aux data.">Accessor</a></code> class above.</p>
<p>If the container is locked, this will allow fetching only variables that do not yet exist (in which case they will be marked as decorations) or variables already marked as decorations. </p>

</div>
</div>
<a class="anchor" id="a127c2c4839333f537cb83ecdc82ad99d"></a><!-- doxytag: member="SG::AuxElement::clearCache" ref="a127c2c4839333f537cb83ecdc82ad99d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SG::AuxElement::clearCache </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clear the cached aux data pointers. </p>
<p>You should call this any time something changes in the aux store that could invalidate the vector pointers. </p>

</div>
</div>
<a class="anchor" id="a71044a012a37af1bb0b6fab3d3ea1230"></a><!-- doxytag: member="SG::AuxElement::clearDecorations" ref="a71044a012a37af1bb0b6fab3d3ea1230" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SG::AuxElement::clearDecorations </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clear all decorations. </p>
<p>Erase all decorations from an associated store, restoring the state to when <code>lock</code> was called. </p>

</div>
</div>
<a class="anchor" id="a607ee93fe8081d2bd3aa1745f0cbbb50"></a><!-- doxytag: member="SG::AuxElement::getAuxIDs" ref="a607ee93fe8081d2bd3aa1745f0cbbb50" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dd/dac/classSG_1_1unordered__set.html">SG::auxid_set_t</a> &amp; SG::AuxElement::getAuxIDs </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a set of identifiers for existing data items for this object. </p>
<p>If this object has a private or standalone store, then information from that will be returned. Otherwise, if this element is part of a container, then information for the container will be returned. Otherwise, return an empty set. </p>

</div>
</div>
<a class="anchor" id="a324d8fccbfe274b6ff91d6a19de35caf"></a><!-- doxytag: member="SG::AuxElement::getConstStore" ref="a324d8fccbfe274b6ff91d6a19de35caf" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d3/dd5/classSG_1_1IConstAuxStore.html">SG::IConstAuxStore</a> * SG::AuxElement::getConstStore </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the current store, as a const interface. </p>
<p>This will be non-zero if either a const or non-const store is associated with this object. This will fetch either a private or standalone store. </p>

</div>
</div>
<a class="anchor" id="afc4602cf2edeb01c3350367f5985f49b"></a><!-- doxytag: member="SG::AuxElement::getStore" ref="afc4602cf2edeb01c3350367f5985f49b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d05/classSG_1_1IAuxStore.html">SG::IAuxStore</a> * SG::AuxElement::getStore </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the current store, as a non-const interface. </p>
<p>This will be non-zero if a non-const store is associated with this object. This will fetch either a private or standalone store. </p>

</div>
</div>
<a class="anchor" id="ac4bc75a2f7b1ed984ffae1bba6de58ba"></a><!-- doxytag: member="SG::AuxElement::hasNonConstStore" ref="ac4bc75a2f7b1ed984ffae1bba6de58ba" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SG::AuxElement::hasNonConstStore </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if this object has an associated non-const store. </p>
<p>This will be true for either a private or standalone store. </p>

</div>
</div>
<a class="anchor" id="a2d354faac53b7a003d29c0f7b95f3672"></a><!-- doxytag: member="SG::AuxElement::hasStore" ref="a2d354faac53b7a003d29c0f7b95f3672" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SG::AuxElement::hasStore </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if this object has an associated store. </p>
<p>This will be true for either a private or standalone store. </p>

</div>
</div>
<a class="anchor" id="af727b22ab51f1d848fc3cf59065b99ea"></a><!-- doxytag: member="SG::AuxElement::isAvailable" ref="af727b22ab51f1d848fc3cf59065b99ea" args="(const std::string &amp;name, const std::string &amp;clsname=&quot;&quot;) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool SG::AuxElement::isAvailable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>clsname</em> = <code>&quot;&quot;</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if an aux variable is available for reading. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of the aux variable. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clsname</em>&nbsp;</td><td>The name of the associated class. May be blank.</td></tr>
  </table>
  </dd>
</dl>
<p>This method has to translate from the aux data name to the internal representation each time it is called. Using this method inside of loops is discouraged; instead use the <code><a class="el" href="../../d8/d31/classSG_1_1AuxElement_1_1Accessor.html" title="Helper class to provide type-safe access to aux data.">Accessor</a></code> class above. </p>

<p>Reimplemented in <a class="el" href="../../d5/d4c/classxAOD_1_1IParticle.html#a73d35d149fce4bcc1ce55da0faf8e0d5">xAOD::IParticle</a>.</p>

</div>
</div>
<a class="anchor" id="a864fc1dab026cbcf20b2c7e3904b89a4"></a><!-- doxytag: member="SG::AuxElement::isAvailableWritable" ref="a864fc1dab026cbcf20b2c7e3904b89a4" args="(const std::string &amp;name, const std::string &amp;clsname=&quot;&quot;) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool SG::AuxElement::isAvailableWritable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>clsname</em> = <code>&quot;&quot;</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if an aux variable is available for writing. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of the aux variable. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clsname</em>&nbsp;</td><td>The name of the associated class. May be blank.</td></tr>
  </table>
  </dd>
</dl>
<p>This method has to translate from the aux data name to the internal representation each time it is called. Using this method inside of loops is discouraged; instead use the <code><a class="el" href="../../d8/d31/classSG_1_1AuxElement_1_1Accessor.html" title="Helper class to provide type-safe access to aux data.">Accessor</a></code> class above. </p>

<p>Reimplemented in <a class="el" href="../../d5/d4c/classxAOD_1_1IParticle.html#a0b30769b501e807f246424b3a8fa20da">xAOD::IParticle</a>.</p>

</div>
</div>
<a class="anchor" id="a5c56e0b548ba0f0fa6eba200defaa44d"></a><!-- doxytag: member="SG::AuxElement::isAvailableWritableAsDecoration" ref="a5c56e0b548ba0f0fa6eba200defaa44d" args="(const std::string &amp;name, const std::string &amp;clsname=&quot;&quot;) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool SG::AuxElement::isAvailableWritableAsDecoration </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>clsname</em> = <code>&quot;&quot;</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if an aux variable is available for writing as a decoration. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of the aux variable. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clsname</em>&nbsp;</td><td>The name of the associated class. May be blank.</td></tr>
  </table>
  </dd>
</dl>
<p>This method has to translate from the aux data name to the internal representation each time it is called. Using this method inside of loops is discouraged; instead use the <code><a class="el" href="../../d8/d31/classSG_1_1AuxElement_1_1Accessor.html" title="Helper class to provide type-safe access to aux data.">Accessor</a></code> class above. </p>

</div>
</div>
<a class="anchor" id="a164f94b3ddbbc773ba8beefdb7cb8677"></a><!-- doxytag: member="SG::AuxElement::makePrivateStore" ref="a164f94b3ddbbc773ba8beefdb7cb8677" args="(const U1 *other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SG::AuxElement::makePrivateStore </td>
          <td>(</td>
          <td class="paramtype">const U1 *&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new private store for this object and copy aux data. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>other</em>&nbsp;</td><td>The object from which aux data should be copied.</td></tr>
  </table>
  </dd>
</dl>
<p><code><a class="el" href="../../d8/ded/classSG_1_1ExcBadPrivateStore.html" title="Exception --- Bad use of private store.">ExcBadPrivateStore</a></code> will be thrown if this object is already associated with a store.</p>
<p>If <code>other</code> is an object that has aux data, then those data will be copied; otherwise, nothing will be done. </p>

</div>
</div>
<a class="anchor" id="ad2eaf2e38536e93c05aebaf1218516a2"></a><!-- doxytag: member="SG::AuxElement::makePrivateStore" ref="ad2eaf2e38536e93c05aebaf1218516a2" args="(const U1 &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SG::AuxElement::makePrivateStore </td>
          <td>(</td>
          <td class="paramtype">const U1 &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new private store for this object and copy aux data. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>other</em>&nbsp;</td><td>The object from which aux data should be copied.</td></tr>
  </table>
  </dd>
</dl>
<p><code><a class="el" href="../../d8/ded/classSG_1_1ExcBadPrivateStore.html" title="Exception --- Bad use of private store.">ExcBadPrivateStore</a></code> will be thrown if this object is already associated with a store.</p>
<p>If <code>other</code> is an object that has aux data, then those data will be copied; otherwise, nothing will be done. </p>

</div>
</div>
<a class="anchor" id="a197bf9fc579d49e25a850a4b3a5c14e8"></a><!-- doxytag: member="SG::AuxElement::makePrivateStore" ref="a197bf9fc579d49e25a850a4b3a5c14e8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SG::AuxElement::makePrivateStore </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new (empty) private store for this object. </p>
<p><code><a class="el" href="../../d8/ded/classSG_1_1ExcBadPrivateStore.html" title="Exception --- Bad use of private store.">ExcBadPrivateStore</a></code> will be thrown if this object is already associated with a store. </p>

</div>
</div>
<a class="anchor" id="a1ecd49ad16cba61c3131046d8e068650"></a><!-- doxytag: member="SG::AuxElement::operator=" ref="a1ecd49ad16cba61c3131046d8e068650" args="(const AuxElement &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/db0/classSG_1_1AuxElement.html">AuxElement</a> &amp; SG::AuxElement::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/db0/classSG_1_1AuxElement.html">AuxElement</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assignment. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>other</em>&nbsp;</td><td>The object from which we're assigning.</td></tr>
  </table>
  </dd>
</dl>
<p>We don't copy container/index, as assignment doesn't change where this object is. However, if we have aux data, then we copy aux data if we're copying from an object that also has it; otherwise, if we're copying from an object with no aux data, then we clear ours. </p>

<p>Reimplemented in <a class="el" href="../../dd/d91/classxAOD_1_1CaloCluster__v1.html#aa30ef130e947c9e5226ffef1567e0d22">xAOD::CaloCluster_v1</a>, <a class="el" href="../../d5/d4c/classxAOD_1_1Egamma__v1.html#ab0ba0e6120b3eea36befb17bbf31906d">xAOD::Egamma_v1</a>, <a class="el" href="../../d3/da7/classxAOD_1_1Electron__v1.html#a23218cf2fbf6fc29d3ebdea5b443be98">xAOD::Electron_v1</a>, <a class="el" href="../../df/df1/classxAOD_1_1Photon__v1.html#a540c991d01ca45db43d46035f8ad6eeb">xAOD::Photon_v1</a>, <a class="el" href="../../db/d9c/classxAOD_1_1Jet__v1.html#aaf4ace5c5e7e8efb104d783e107f1ba8">xAOD::Jet_v1</a>, <a class="el" href="../../d0/d7e/classxAOD_1_1LumiBlockRange__v1.html#a29c81beea8b3d41a6c99a611b6d7e74d">xAOD::LumiBlockRange_v1</a>, <a class="el" href="../../dd/d06/classxAOD_1_1MissingET__v1.html#ad8d6930f3660dc6672995e056dfe09f2">xAOD::MissingET_v1</a>, <a class="el" href="../../d5/d15/classxAOD_1_1MissingETAssociation__v1.html#ab972f478b8964041f4244562670b2ac0">xAOD::MissingETAssociation_v1</a>, <a class="el" href="../../d8/d38/classxAOD_1_1MissingETComponent__v1.html#af65ce358a105ca7da8e06d115a308acc">xAOD::MissingETComponent_v1</a>, <a class="el" href="../../d5/d44/classxAOD_1_1NeutralParticle__v1.html#a7602e298fd114e26a3e530633e497050">xAOD::NeutralParticle_v1</a>, <a class="el" href="../../d9/d1d/classxAOD_1_1TrackParticle__v1.html#a4cb50ea5ecebf754371d62ad1bd13de2">xAOD::TrackParticle_v1</a>, <a class="el" href="../../db/dd1/classxAOD_1_1Vertex__v1.html#a410d6c5cc96a2bc64b39eaeec5c1aa43">xAOD::Vertex_v1</a>, and <a class="el" href="../../d7/d45/classxAOD_1_1TriggerTower__v2.html#a26b3990c7a352476bbe314ea981f701c">xAOD::TriggerTower_v2</a>.</p>

</div>
</div>
<a class="anchor" id="aab2f280f3c832e285fe020365bb3ac1e"></a><!-- doxytag: member="SG::AuxElement::releasePrivateStore" ref="aab2f280f3c832e285fe020365bb3ac1e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SG::AuxElement::releasePrivateStore </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Release and free any private store associated with this object. </p>
<p><code><a class="el" href="../../d8/ded/classSG_1_1ExcBadPrivateStore.html" title="Exception --- Bad use of private store.">ExcBadPrivateStore</a></code> will be thrown if this object does not have a private store. </p>

</div>
</div>
<a class="anchor" id="a3079709e44e8ac7452c05454f4994ce9"></a><!-- doxytag: member="SG::AuxElement::setConstStore" ref="a3079709e44e8ac7452c05454f4994ce9" args="(const SG::IConstAuxStore *store)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SG::AuxElement::setConstStore </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/dd5/classSG_1_1IConstAuxStore.html">SG::IConstAuxStore</a> *&nbsp;</td>
          <td class="paramname"> <em>store</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Synonym for <code>setStore</code> with <code><a class="el" href="../../d3/dd5/classSG_1_1IConstAuxStore.html" title="Interface for const operations on an auxiliary store.">IConstAuxStore</a></code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>store</em>&nbsp;</td><td>The new store. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a68b13428943609fd2b56c35c9dec85b3"></a><!-- doxytag: member="SG::AuxElement::setNonConstStore" ref="a68b13428943609fd2b56c35c9dec85b3" args="(SG::IAuxStore *store)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SG::AuxElement::setNonConstStore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d05/classSG_1_1IAuxStore.html">SG::IAuxStore</a> *&nbsp;</td>
          <td class="paramname"> <em>store</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Synonym for <code>setStore</code> with <code><a class="el" href="../../dc/d05/classSG_1_1IAuxStore.html" title="Interface for non-const operations on an auxiliary store.">IAuxStore</a></code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>store</em>&nbsp;</td><td>The new store. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4bdca4ef5f1df892b5dc9742644444b8"></a><!-- doxytag: member="SG::AuxElement::setStore" ref="a4bdca4ef5f1df892b5dc9742644444b8" args="(const DataLink&lt; SG::IConstAuxStore &gt; &amp;store)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SG::AuxElement::setStore </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/da2/classDataLink.html">DataLink</a>&lt; <a class="el" href="../../d3/dd5/classSG_1_1IConstAuxStore.html">SG::IConstAuxStore</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>store</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the store associated with this object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>store</em>&nbsp;</td><td>The new store.</td></tr>
  </table>
  </dd>
</dl>
<p>If store is nonzero, this adds a standalone store to the object. The object must not be in a container and must not have a private store. If store is zero, this removes a standalone store.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>store</em>&nbsp;</td><td>Link to the new store. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9cc58e245a417833f297e836d9559a32"></a><!-- doxytag: member="SG::AuxElement::setStore" ref="a9cc58e245a417833f297e836d9559a32" args="(SG::IAuxStore *store)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SG::AuxElement::setStore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d05/classSG_1_1IAuxStore.html">SG::IAuxStore</a> *&nbsp;</td>
          <td class="paramname"> <em>store</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the store associated with this object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>store</em>&nbsp;</td><td>The new store.</td></tr>
  </table>
  </dd>
</dl>
<p>If store is nonzero, this adds a standalone store to the object. The object must not be in a container and must not have a private store. If store is zero, this removes a standalone store. </p>

</div>
</div>
<a class="anchor" id="a57b602d3ec1c0129811375f46c18c049"></a><!-- doxytag: member="SG::AuxElement::setStore" ref="a57b602d3ec1c0129811375f46c18c049" args="(const SG::IConstAuxStore *store)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SG::AuxElement::setStore </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/dd5/classSG_1_1IConstAuxStore.html">SG::IConstAuxStore</a> *&nbsp;</td>
          <td class="paramname"> <em>store</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the store associated with this object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>store</em>&nbsp;</td><td>The new store.</td></tr>
  </table>
  </dd>
</dl>
<p>If store is nonzero, this adds a standalone store to the object. The object must not be in a container and must not have a private store. If store is zero, this removes a standalone store. </p>

</div>
</div>
<a class="anchor" id="af97c2ef167b0d66ada327a0ada1015e7"></a><!-- doxytag: member="SG::AuxElement::usingStandaloneStore" ref="af97c2ef167b0d66ada327a0ada1015e7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SG::AuxElement::usingStandaloneStore </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test to see if this object is currently using a standalone store. </p>
<p>Test to see if this object is currently using a private store. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/<a class="el" href="../../d1/d6f/AuxElement_8h_source.html">AuxElement.h</a></li>
<li>/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/<a class="el" href="../../d2/d37/AuxElement_8icc.html">AuxElement.icc</a></li>
<li>/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/Root/AuxElement.cxx</li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 15 Apr 2017 for RootCore Packages by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
