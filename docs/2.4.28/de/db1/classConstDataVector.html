<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>RootCore Packages: ConstDataVector&lt; DV &gt; Class Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="../../index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="../../search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="../../annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="../../classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="../../hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="../../functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>ConstDataVector&lt; DV &gt; Class Template Reference</h1><!-- doxytag: class="ConstDataVector" --><!-- doxytag: inherits="DV" -->
<p><code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> adapter that acts like it holds const pointers.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d2/d0d/ConstDataVector_8h_source.html">ConstDataVector.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ConstDataVector&lt; DV &gt;:</div>
<div class="dynsection">
 <div class="center">
  <img src="../../de/db1/classConstDataVector.gif" usemap="#ConstDataVector&lt; DV &gt;_map" alt=""/>
  <map id="ConstDataVector&lt; DV &gt;_map" name="ConstDataVector&lt; DV &gt;_map">
<area href="../../d3/d78/structDV.html" alt="DV&lt; T &gt;" shape="rect" coords="0,0,150,24"/>
</map>
 </div>
</div>

<p><a href="../../d8/d7b/classConstDataVector-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b7cdd6c8969c3dbdbbb23eabfb4d524"></a><!-- doxytag: member="ConstDataVector::size_type" ref="a0b7cdd6c8969c3dbdbbb23eabfb4d524" args="" -->
typedef DV::size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classConstDataVector.html#a0b7cdd6c8969c3dbdbbb23eabfb4d524">size_type</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Basic types, forwarded from the base. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae91ee747ca495db8cd44dbfa71ba00b8"></a><!-- doxytag: member="ConstDataVector::difference_type" ref="ae91ee747ca495db8cd44dbfa71ba00b8" args="" -->
typedef DV::difference_type&nbsp;</td><td class="memItemRight" valign="bottom"><b>difference_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9400833462c9bc512aa23be9990a5944"></a><!-- doxytag: member="ConstDataVector::allocator_type" ref="a9400833462c9bc512aa23be9990a5944" args="" -->
typedef DV::allocator_type&nbsp;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a14e111177f6f6ad503b29717e6206f94"></a><!-- doxytag: member="ConstDataVector::base_value_type" ref="a14e111177f6f6ad503b29717e6206f94" args="" -->
typedef <a class="el" href="../../d1/def/classT.html">DV::base_value_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>base_value_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94b6d29ec468ba71421e9024ffd94d7d"></a><!-- doxytag: member="ConstDataVector::BaseContainer" ref="a94b6d29ec468ba71421e9024ffd94d7d" args="" -->
typedef DV::BaseContainer&nbsp;</td><td class="memItemRight" valign="bottom"><b>BaseContainer</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37aa61669c8583d4282501f19aa31fa2"></a><!-- doxytag: member="ConstDataVector::DVL_BASE" ref="a37aa61669c8583d4282501f19aa31fa2" args="" -->
typedef DV::DVL_BASE&nbsp;</td><td class="memItemRight" valign="bottom"><b>DVL_BASE</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a935868c884bd601580c9cb16417ab824"></a><!-- doxytag: member="ConstDataVector::const_iterator" ref="a935868c884bd601580c9cb16417ab824" args="" -->
typedef DV::const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6bada5d12cdd28e052930b246e1c0e0"></a><!-- doxytag: member="ConstDataVector::const_reverse_iterator" ref="ad6bada5d12cdd28e052930b246e1c0e0" args="" -->
typedef DV::const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_reverse_iterator</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c01b8e57502c2965543246ca1706a4f"></a><!-- doxytag: member="ConstDataVector::base_data_vector" ref="a1c01b8e57502c2965543246ca1706a4f" args="" -->
typedef <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a><br class="typebreak"/>
&lt; <a class="el" href="../../d1/def/classT.html">base_value_type</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>base_data_vector</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef DV::const_value_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classConstDataVector.html#a5fd314970812a0e01af18df65729d2bd">value_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc3973f6f1997d9ffe8d59d69df44064"></a><!-- doxytag: member="ConstDataVector::const_value_type" ref="afc3973f6f1997d9ffe8d59d69df44064" args="" -->
typedef DV::const_value_type&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_value_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff756fd715ce881a7a183fbaa8cbf3dc"></a><!-- doxytag: member="ConstDataVector::reference" ref="aff756fd715ce881a7a183fbaa8cbf3dc" args="" -->
typedef DV::const_value_type &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>reference</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac4cc72b4aea1f96d7b08f164cee830bf"></a><!-- doxytag: member="ConstDataVector::const_reference" ref="ac4cc72b4aea1f96d7b08f164cee830bf" args="" -->
typedef DV::const_value_type <br class="typebreak"/>
const &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_reference</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f977a6be1da7b3e49bd6f78cda97acb"></a><!-- doxytag: member="ConstDataVector::pointer" ref="a0f977a6be1da7b3e49bd6f78cda97acb" args="" -->
typedef DV::const_value_type *&nbsp;</td><td class="memItemRight" valign="bottom"><b>pointer</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad16134b94c5445bb9812892bbcb6f0ef"></a><!-- doxytag: member="ConstDataVector::const_pointer" ref="ad16134b94c5445bb9812892bbcb6f0ef" args="" -->
typedef DV::const_value_type <br class="typebreak"/>
const *&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="../../d7/d05/classDataModel__detail_1_1ElementProxy.html">DataModel_detail::ElementProxy</a><br class="typebreak"/>
&lt; <a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classConstDataVector.html#a35cc742d7d47a25c240d3389c25b3caf">ElementProxy</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf241232ecaa158cfe092713d2699d5f"></a><!-- doxytag: member="ConstDataVector::iterator" ref="abf241232ecaa158cfe092713d2699d5f" args="" -->
typedef <br class="typebreak"/>
<a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">DataModel_detail::iterator</a><br class="typebreak"/>
&lt; <a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classConstDataVector.html#abf241232ecaa158cfe092713d2699d5f">iterator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The iterator for this type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::reverse_iterator<br class="typebreak"/>
&lt; <a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classConstDataVector.html#ad6f83847ddbbcc881f467bdfa06d93a9">reverse_iterator</a></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors, destructors, assignment.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpb39bb9cb1bc18cddc74e7f363d4e2167"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classConstDataVector.html#a1cdaac1590ea31083cc54ac56adb9caa">ConstDataVector</a> (<a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">SG::OwnershipPolicy</a> ownPolicy=SG::OWN_ELEMENTS)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor.  <a href="#a1cdaac1590ea31083cc54ac56adb9caa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classConstDataVector.html#a981d20627c4b6e8ac36e6e5972dc0ab9">ConstDataVector</a> (<a class="el" href="../../de/db1/classConstDataVector.html#a0b7cdd6c8969c3dbdbbb23eabfb4d524">size_type</a> n, <a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">SG::OwnershipPolicy</a> ownPolicy=SG::OWN_ELEMENTS)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sized constructor.  <a href="#a981d20627c4b6e8ac36e6e5972dc0ab9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/db1/classConstDataVector.html#aa6ea74c079d85b66156704a096d14a89">ConstDataVector</a> (InputIterator first, InputIterator last, <a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">SG::OwnershipPolicy</a> ownPolicy=SG::VIEW_ELEMENTS)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor from iterators.  <a href="#aa6ea74c079d85b66156704a096d14a89"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classConstDataVector.html#ab0e570bb8e3da3b9ce9c465327eed052">operator=</a> (const <a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor.  <a href="#ab0e570bb8e3da3b9ce9c465327eed052"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/db1/classConstDataVector.html#a52e7a6b1254389e5ad4ebe7e8e4505bb">assign</a> (InputIterator first, InputIterator last)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assign from iterators.  <a href="#a52e7a6b1254389e5ad4ebe7e8e4505bb"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Element access.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp03f08060dbcda9a05f3dd6a98ff9f981"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d7/d05/classDataModel__detail_1_1ElementProxy.html">ElementProxy</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classConstDataVector.html#aae62dc3e4f66c0fd8ef43c252a13b48d">operator[]</a> (<a class="el" href="../../de/db1/classConstDataVector.html#a0b7cdd6c8969c3dbdbbb23eabfb4d524">size_type</a> n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access an element, as an lvalue.  <a href="#aae62dc3e4f66c0fd8ef43c252a13b48d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d7/d05/classDataModel__detail_1_1ElementProxy.html">ElementProxy</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classConstDataVector.html#a7565e82eb51c3c4492ca8f5abd915138">at</a> (<a class="el" href="../../de/db1/classConstDataVector.html#a0b7cdd6c8969c3dbdbbb23eabfb4d524">size_type</a> n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access an element, as an lvalue.  <a href="#a7565e82eb51c3c4492ca8f5abd915138"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d7/d05/classDataModel__detail_1_1ElementProxy.html">ElementProxy</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classConstDataVector.html#a4993339b08404582cd9d83127c344802">front</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access the first element in the collection as an lvalue.  <a href="#a4993339b08404582cd9d83127c344802"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d7/d05/classDataModel__detail_1_1ElementProxy.html">ElementProxy</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classConstDataVector.html#ab16ba63da380c5fef188eded070fca0d">back</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access the last element in the collection as an lvalue.  <a href="#ab16ba63da380c5fef188eded070fca0d"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Iterator creation.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp04fea93d7622927e954392dcd5690674"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classConstDataVector.html#a1eebe42ee99ce34ab685d69a53b65dc0">begin</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return an <code>iterator</code> pointing at the beginning of the collection.  <a href="#a1eebe42ee99ce34ab685d69a53b65dc0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classConstDataVector.html#a7e790c3b42f79d58586ebb3cf027781a">end</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return an <code>iterator</code> pointing past the end of the collection.  <a href="#a7e790c3b42f79d58586ebb3cf027781a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/db1/classConstDataVector.html#ad6f83847ddbbcc881f467bdfa06d93a9">reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classConstDataVector.html#ae71dc63f2039fcb8a99040701ec37e7a">rbegin</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a <code>reverse_iterator</code> pointing past the end of the collection.  <a href="#ae71dc63f2039fcb8a99040701ec37e7a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/db1/classConstDataVector.html#ad6f83847ddbbcc881f467bdfa06d93a9">reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classConstDataVector.html#abdeb7d8faaaf6e0fd5d4c5dbc29fc94a">rend</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a <code>reverse_iterator</code> pointing at the beginning of the collection.  <a href="#abdeb7d8faaaf6e0fd5d4c5dbc29fc94a"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Insertion operations.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpc4ff45e64b9f41cc82677be76808116c"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classConstDataVector.html#a83ff6832bd6d52468225dca32c516121">push_back</a> (<a class="el" href="../../de/db1/classConstDataVector.html#a5fd314970812a0e01af18df65729d2bd">value_type</a> pElem)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add an element to the end of the collection.  <a href="#a83ff6832bd6d52468225dca32c516121"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classConstDataVector.html#aaad6e69e9afc63551cf6aa9898807a90">emplace_back</a> (<a class="el" href="../../de/db1/classConstDataVector.html#a5fd314970812a0e01af18df65729d2bd">value_type</a> pElem)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add an element to the end of the collection.  <a href="#aaad6e69e9afc63551cf6aa9898807a90"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classConstDataVector.html#ad6acd17f41c3809ce00ed14aa78e7d80">insert</a> (<a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a> position, <a class="el" href="../../de/db1/classConstDataVector.html#a5fd314970812a0e01af18df65729d2bd">value_type</a> pElem)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a new element to the collection.  <a href="#ad6acd17f41c3809ce00ed14aa78e7d80"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classConstDataVector.html#a7d0675548e4ee8d8e5cc50960a5b0fc5">emplace</a> (<a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a> position, <a class="el" href="../../de/db1/classConstDataVector.html#a5fd314970812a0e01af18df65729d2bd">value_type</a> pElem)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a new element to the collection.  <a href="#a7d0675548e4ee8d8e5cc50960a5b0fc5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/db1/classConstDataVector.html#a6a95569685418afead723f1798ac143f">insert</a> (<a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a> position, InputIterator first, InputIterator last)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a group of new elements to the collection.  <a href="#a6a95569685418afead723f1798ac143f"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Erasure operations.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp5dd35913d37b538bffc58eac1d7946e3"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classConstDataVector.html#a191b17e706f9efc349510e54b00f8a19">erase</a> (<a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a> position)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove element at a given position.  <a href="#a191b17e706f9efc349510e54b00f8a19"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classConstDataVector.html#ad4e0cbb65c66bb7b712bde4e92de182e">erase</a> (<a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a> first, <a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a> last)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove a range of elements.  <a href="#ad4e0cbb65c66bb7b712bde4e92de182e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classConstDataVector.html#ae8944232be996809a74b641ac20e7aa2">clear</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase all the elements in the collection.  <a href="#ae8944232be996809a74b641ac20e7aa2"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Non-standard operations.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp67b3645f65a6afd377578740fa3b4ed2"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classConstDataVector.html#a63dd71d02bdefb4cf4501b8d788998bf">swapElement</a> (<a class="el" href="../../de/db1/classConstDataVector.html#a0b7cdd6c8969c3dbdbbb23eabfb4d524">size_type</a> index, <a class="el" href="../../de/db1/classConstDataVector.html#a5fd314970812a0e01af18df65729d2bd">value_type</a> newElem, reference oldElem)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swap one element out of the container.  <a href="#a63dd71d02bdefb4cf4501b8d788998bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classConstDataVector.html#a86413c1535c7b64e7d9fff0b55295a08">swapElement</a> (<a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a> pos, <a class="el" href="../../de/db1/classConstDataVector.html#a5fd314970812a0e01af18df65729d2bd">value_type</a> newElem, reference oldElem)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swap one element out of the container.  <a href="#a86413c1535c7b64e7d9fff0b55295a08"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc25e0985e21c58a97654203aa8c2635"></a><!-- doxytag: member="ConstDataVector::asDataVector" ref="afc25e0985e21c58a97654203aa8c2635" args="() const " -->
const <a class="el" href="../../d3/d78/structDV.html">DV</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classConstDataVector.html#afc25e0985e21c58a97654203aa8c2635">asDataVector</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a pointer to this object, as a const <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classConstDataVector.html#a12fe9d9af90d3aa4afbe056fe433a5cc">resortAux</a> (<a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>, <a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset indices / reorder aux data after elements have been permuted.  <a href="#a12fe9d9af90d3aa4afbe056fe433a5cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classConstDataVector.html#a60cd1ffb1829e484e82e6739ab7c872e">clear</a> (<a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">SG::OwnershipPolicy</a> ownPolicy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase all the elements in the collection, and reset the ownership mode.  <a href="#a60cd1ffb1829e484e82e6739ab7c872e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html">SG::AuxVectorBase</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classConstDataVector.html#a5d42315073854c68017710bf0134289b">auxbase</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert to <code>AuxVectorBase</code>.  <a href="#a5d42315073854c68017710bf0134289b"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Relational operators.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp2dfb2a28709c2d057d20a41ab65c066f"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classConstDataVector.html#ac5c9d1ec571f2c3ab6026ab0b72fe923">operator&lt;</a> (const <a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a> &amp;b) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Vector ordering relation.  <a href="#ac5c9d1ec571f2c3ab6026ab0b72fe923"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66ba01eeef2c5261ea250243dea97cc1"></a><!-- doxytag: member="ConstDataVector::operator&gt;" ref="a66ba01eeef2c5261ea250243dea97cc1" args="(const ConstDataVector &amp;b) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classConstDataVector.html#a66ba01eeef2c5261ea250243dea97cc1">operator&gt;</a> (const <a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a> &amp;b) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Based on operator&lt;. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac9ce62241a1eda0eedb063e3ab3c4ae4"></a><!-- doxytag: member="ConstDataVector::operator&lt;=" ref="ac9ce62241a1eda0eedb063e3ab3c4ae4" args="(const ConstDataVector &amp;b) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classConstDataVector.html#ac9ce62241a1eda0eedb063e3ab3c4ae4">operator&lt;=</a> (const <a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a> &amp;b) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Based on operator&lt;. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a92ccbf552b74b78803c2e1cab7e29b34"></a><!-- doxytag: member="ConstDataVector::operator&gt;=" ref="a92ccbf552b74b78803c2e1cab7e29b34" args="(const ConstDataVector &amp;b) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classConstDataVector.html#a92ccbf552b74b78803c2e1cab7e29b34">operator&gt;=</a> (const <a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a> &amp;b) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Based on operator&lt;. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classConstDataVector.html#ac7823edb4c1dce015b3bd63ca32da738">operator==</a> (const <a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a> &amp;b) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Vector equality comparison.  <a href="#ac7823edb4c1dce015b3bd63ca32da738"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7170fcea63b52dd151c3c3f1d20a830e"></a><!-- doxytag: member="ConstDataVector::operator!=" ref="a7170fcea63b52dd151c3c3f1d20a830e" args="(const ConstDataVector &amp;b) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classConstDataVector.html#a7170fcea63b52dd151c3c3f1d20a830e">operator!=</a> (const <a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a> &amp;b) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Based on operator==. <br/></td></tr>
<tr><td colspan="2"><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a445c221fe5fd876a4223a66274f4038b"></a><!-- doxytag: member="ConstDataVector::has_virtual" ref="a445c221fe5fd876a4223a66274f4038b" args="" -->
static const bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classConstDataVector.html#a445c221fe5fd876a4223a66274f4038b">has_virtual</a> = DV::has_virtual</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This needs to be forwarded from the base as well. <br/></td></tr>
<tr><td colspan="2"><h2>Private helpers.</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrpe5a69a01ae6824427c974a9ce34af1a7"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b0a1ab3eaccbc67e7a492a884e6238c"></a><!-- doxytag: member="ConstDataVector::DataModel_detail::ElementProxy&lt; ConstDataVector &gt;" ref="a2b0a1ab3eaccbc67e7a492a884e6238c" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classConstDataVector.html#a2b0a1ab3eaccbc67e7a492a884e6238c">DataModel_detail::ElementProxy&lt; ConstDataVector &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1119a539ef95e66a83ed73e65ce4acb9"></a><!-- doxytag: member="ConstDataVector::test2_assignelement1" ref="a1119a539ef95e66a83ed73e65ce4acb9" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>test2_assignelement1</b> ()</td></tr>
<tr><td colspan="2"><h2>Swap and sort.</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp48740572230bf871bbbe3f4450b8e26c"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classConstDataVector.html#ae42c031d0522fde4a983f3a8c10328d3">swap</a> (<a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swap this collection with another.  <a href="#ae42c031d0522fde4a983f3a8c10328d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classConstDataVector.html#af4024a744ff89b92eb8e8a8e60e80d0e">iter_swap</a> (<a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a> a, <a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a> b)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swap the referents of two <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> iterators.  <a href="#af4024a744ff89b92eb8e8a8e60e80d0e"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class DV&gt;<br/>
 class ConstDataVector&lt; DV &gt;</h3>

<p><code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> adapter that acts like it holds const pointers. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a35cc742d7d47a25c240d3389c25b3caf"></a><!-- doxytag: member="ConstDataVector::ElementProxy" ref="a35cc742d7d47a25c240d3389c25b3caf" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="../../d7/d05/classDataModel__detail_1_1ElementProxy.html">DataModel_detail::ElementProxy</a>&lt;<a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a>&gt; <a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a>&lt; <a class="el" href="../../d3/d78/structDV.html">DV</a> &gt;::<a class="el" href="../../d7/d05/classDataModel__detail_1_1ElementProxy.html">ElementProxy</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This type is used to proxy lvalue accesses to <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> elements, in order to handle ownership. </p>

</div>
</div>
<a class="anchor" id="ad6f83847ddbbcc881f467bdfa06d93a9"></a><!-- doxytag: member="ConstDataVector::reverse_iterator" ref="ad6f83847ddbbcc881f467bdfa06d93a9" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::reverse_iterator&lt;<a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&gt; <a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a>&lt; <a class="el" href="../../d3/d78/structDV.html">DV</a> &gt;::<a class="el" href="../../de/db1/classConstDataVector.html#ad6f83847ddbbcc881f467bdfa06d93a9">reverse_iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Standard <code>reverse_iterator</code>. Note that lvalue references here will yield an <code>ElementProxy</code>, not a <code>reference</code>. </p>

</div>
</div>
<a class="anchor" id="a5fd314970812a0e01af18df65729d2bd"></a><!-- doxytag: member="ConstDataVector::value_type" ref="a5fd314970812a0e01af18df65729d2bd" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef DV::const_value_type <a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a>&lt; <a class="el" href="../../d3/d78/structDV.html">DV</a> &gt;::<a class="el" href="../../de/db1/classConstDataVector.html#a5fd314970812a0e01af18df65729d2bd">value_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>These types get modified so that the base's <code>const_value_type</code> becomes our <code>value_type</code>. </p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a1cdaac1590ea31083cc54ac56adb9caa"></a><!-- doxytag: member="ConstDataVector::ConstDataVector" ref="a1cdaac1590ea31083cc54ac56adb9caa" args="(SG::OwnershipPolicy ownPolicy=SG::OWN_ELEMENTS)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a>&lt; <a class="el" href="../../d3/d78/structDV.html">DV</a> &gt;::<a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">SG::OwnershipPolicy</a>&nbsp;</td>
          <td class="paramname"> <em>ownPolicy</em> = <code>SG::OWN_ELEMENTS</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default constructor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ownPolicy</em>&nbsp;</td><td>The ownership mode for the container.</td></tr>
  </table>
  </dd>
</dl>
<p>By default, a <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> will own its elements. To avoid this, pass <code><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8ad7d4cf2303700f0966e4140f236c4bf1" title="this data object is a view, it does not own its elmts">SG::VIEW_ELEMENTS</a></code> for <em>ownPolicy</em>. </p>

</div>
</div>
<a class="anchor" id="a981d20627c4b6e8ac36e6e5972dc0ab9"></a><!-- doxytag: member="ConstDataVector::ConstDataVector" ref="a981d20627c4b6e8ac36e6e5972dc0ab9" args="(size_type n, SG::OwnershipPolicy ownPolicy=SG::OWN_ELEMENTS)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a>&lt; <a class="el" href="../../d3/d78/structDV.html">DV</a> &gt;::<a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/db1/classConstDataVector.html#a0b7cdd6c8969c3dbdbbb23eabfb4d524">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">SG::OwnershipPolicy</a>&nbsp;</td>
          <td class="paramname"> <em>ownPolicy</em> = <code>SG::OWN_ELEMENTS</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sized constructor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>The size of the container. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ownPolicy</em>&nbsp;</td><td>The ownership mode for the container.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that unlike the standard vector constructor, you can't specify an initial value here. The container will be initialized with 0's.</p>
<p>By default, a <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> will own its elements. To avoid this, pass <code><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8ad7d4cf2303700f0966e4140f236c4bf1" title="this data object is a view, it does not own its elmts">SG::VIEW_ELEMENTS</a></code> for <em>ownPolicy</em>. </p>

</div>
</div>
<a class="anchor" id="aa6ea74c079d85b66156704a096d14a89"></a><!-- doxytag: member="ConstDataVector::ConstDataVector" ref="aa6ea74c079d85b66156704a096d14a89" args="(InputIterator first, InputIterator last, SG::OwnershipPolicy ownPolicy=SG::VIEW_ELEMENTS)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DV &gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a>&lt; <a class="el" href="../../d3/d78/structDV.html">DV</a> &gt;::<a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a> </td>
          <td>(</td>
          <td class="paramtype">InputIterator&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">SG::OwnershipPolicy</a>&nbsp;</td>
          <td class="paramname"> <em>ownPolicy</em> = <code>SG::VIEW_ELEMENTS</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor from iterators. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>The start of the range to put in the new container. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>last</em>&nbsp;</td><td>The end of the range to put in the new container. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ownPolicy</em>&nbsp;</td><td>The ownership mode for the container.</td></tr>
  </table>
  </dd>
</dl>
<p>By default, a <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> will own its elements (and take ownership of the pointers passed to this constructor). To avoid this, pass <code><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8ad7d4cf2303700f0966e4140f236c4bf1" title="this data object is a view, it does not own its elmts">SG::VIEW_ELEMENTS</a></code> for <em>ownPolicy</em>. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a52e7a6b1254389e5ad4ebe7e8e4505bb"></a><!-- doxytag: member="ConstDataVector::assign" ref="a52e7a6b1254389e5ad4ebe7e8e4505bb" args="(InputIterator first, InputIterator last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DV &gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a>&lt; <a class="el" href="../../d3/d78/structDV.html">DV</a> &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">InputIterator&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assign from iterators. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>The start of the range to put in the container. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>last</em>&nbsp;</td><td>The end of the range to put in the container.</td></tr>
  </table>
  </dd>
</dl>
<p>Any existing owned elements will be released. The <code>DataVector's</code> ownership policy determines whether it will take ownership of the new elements. </p>

</div>
</div>
<a class="anchor" id="a7565e82eb51c3c4492ca8f5abd915138"></a><!-- doxytag: member="ConstDataVector::at" ref="a7565e82eb51c3c4492ca8f5abd915138" args="(size_type n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a>&lt; <a class="el" href="../../d3/d78/structDV.html">DV</a> &gt;::<a class="el" href="../../d7/d05/classDataModel__detail_1_1ElementProxy.html">ElementProxy</a> <a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a>&lt; <a class="el" href="../../d3/d78/structDV.html">DV</a> &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/db1/classConstDataVector.html#a0b7cdd6c8969c3dbdbbb23eabfb4d524">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access an element, as an lvalue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>Array index to access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Proxy to the element at <em>n</em>.</dd></dl>
<p>Will raise <code>std::out_of_range</code> if the index is out-of-bounds. Note that we return a proxy object rather than a reference; the proxy will handle deleting an owned element if it's assigned to. </p>

</div>
</div>
<a class="anchor" id="a5d42315073854c68017710bf0134289b"></a><!-- doxytag: member="ConstDataVector::auxbase" ref="a5d42315073854c68017710bf0134289b" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html">SG::AuxVectorBase</a> &amp; <a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a>&lt; <a class="el" href="../../d3/d78/structDV.html">DV</a> &gt;::auxbase </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert to <code>AuxVectorBase</code>. </p>
<p>Needed to get  AuxVectorBase from a <code><a class="el" href="../../de/db1/classConstDataVector.html" title="DataVector adapter that acts like it holds const pointers.">ConstDataVector</a></code>. Present in <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> as well for consistency. </p>

</div>
</div>
<a class="anchor" id="ab16ba63da380c5fef188eded070fca0d"></a><!-- doxytag: member="ConstDataVector::back" ref="ab16ba63da380c5fef188eded070fca0d" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a>&lt; <a class="el" href="../../d3/d78/structDV.html">DV</a> &gt;::<a class="el" href="../../d7/d05/classDataModel__detail_1_1ElementProxy.html">ElementProxy</a> <a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a>&lt; <a class="el" href="../../d3/d78/structDV.html">DV</a> &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access the last element in the collection as an lvalue. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Proxy to the last element in the collection.</dd></dl>
<p>No checking is done to ensure that the container is not empty. Note that we return a proxy object rather than a reference; the proxy will handle deleting an owned element if it's assigned to. </p>

</div>
</div>
<a class="anchor" id="a1eebe42ee99ce34ab685d69a53b65dc0"></a><!-- doxytag: member="ConstDataVector::begin" ref="a1eebe42ee99ce34ab685d69a53b65dc0" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a>&lt; <a class="el" href="../../d3/d78/structDV.html">DV</a> &gt;::<a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a> <a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a>&lt; <a class="el" href="../../d3/d78/structDV.html">DV</a> &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return an <code>iterator</code> pointing at the beginning of the collection. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>An <code>iterator</code>.</dd></dl>
<p>Note that dereferencing the iterator will yield a proxy rather than a reference; the proxy will handle deleting an owned element if it's assigned to. </p>

</div>
</div>
<a class="anchor" id="a60cd1ffb1829e484e82e6739ab7c872e"></a><!-- doxytag: member="ConstDataVector::clear" ref="a60cd1ffb1829e484e82e6739ab7c872e" args="(SG::OwnershipPolicy ownPolicy)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a>&lt; <a class="el" href="../../d3/d78/structDV.html">DV</a> &gt;::clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">SG::OwnershipPolicy</a>&nbsp;</td>
          <td class="paramname"> <em>ownPolicy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Erase all the elements in the collection, and reset the ownership mode. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ownPolicy</em>&nbsp;</td><td>The new ownership policy of the container.</td></tr>
  </table>
  </dd>
</dl>
<p>If the container owns its elements, then the removed elements will be deleted. Any duplicates will be removed in this process, but don't rely on this. </p>

</div>
</div>
<a class="anchor" id="ae8944232be996809a74b641ac20e7aa2"></a><!-- doxytag: member="ConstDataVector::clear" ref="ae8944232be996809a74b641ac20e7aa2" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a>&lt; <a class="el" href="../../d3/d78/structDV.html">DV</a> &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Erase all the elements in the collection. </p>
<p><a class="el" href="../../de/db1/classConstDataVector.html#ae8944232be996809a74b641ac20e7aa2" title="Erase all the elements in the collection.">clear()</a></p>
<p>If the container owns its elements, then the removed elements will be deleted. Any duplicates will be removed in this process, but don't rely on this.</p>
<p>Erase all the elements in the collection. If the container owns its elements, then the removed elements will be deleted. Any duplicates will be removed in this process, but don't rely on this. </p>

</div>
</div>
<a class="anchor" id="a7d0675548e4ee8d8e5cc50960a5b0fc5"></a><!-- doxytag: member="ConstDataVector::emplace" ref="a7d0675548e4ee8d8e5cc50960a5b0fc5" args="(iterator position, value_type pElem)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a>&lt; <a class="el" href="../../d3/d78/structDV.html">DV</a> &gt;::<a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a> <a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a>&lt; <a class="el" href="../../d3/d78/structDV.html">DV</a> &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../de/db1/classConstDataVector.html#a5fd314970812a0e01af18df65729d2bd">value_type</a>&nbsp;</td>
          <td class="paramname"> <em>pElem</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a new element to the collection. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>position</em>&nbsp;</td><td>Iterator before which the element will be added. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pElem</em>&nbsp;</td><td>The element to add to the collection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An iterator that points to the inserted data.</dd></dl>
<p>The container's ownership policy will determine if it takes ownership of the new element.</p>
<p>Note: this method may only be called using the most derived <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> in the hierarchy.</p>
<p>For <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code>, this is just the same as <code>insert</code>. It's included just for interface compatibility with `stdvector`. </p>

</div>
</div>
<a class="anchor" id="aaad6e69e9afc63551cf6aa9898807a90"></a><!-- doxytag: member="ConstDataVector::emplace_back" ref="aaad6e69e9afc63551cf6aa9898807a90" args="(value_type pElem)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a>&lt; <a class="el" href="../../d3/d78/structDV.html">DV</a> &gt;::emplace_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/db1/classConstDataVector.html#a5fd314970812a0e01af18df65729d2bd">value_type</a>&nbsp;</td>
          <td class="paramname"> <em>pElem</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add an element to the end of the collection. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pElem</em>&nbsp;</td><td>The element to add to the collection.</td></tr>
  </table>
  </dd>
</dl>
<p>The container's ownership policy will determine if it takes ownership of the new element.</p>
<p>Note: this method may only be called using the most derived <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> in the hierarchy.</p>
<p>For <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code>, this is just the same as <code>push_back</code>. It's included just for interface compatibility with `stdvector`. </p>

</div>
</div>
<a class="anchor" id="a7e790c3b42f79d58586ebb3cf027781a"></a><!-- doxytag: member="ConstDataVector::end" ref="a7e790c3b42f79d58586ebb3cf027781a" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a>&lt; <a class="el" href="../../d3/d78/structDV.html">DV</a> &gt;::<a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a> <a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a>&lt; <a class="el" href="../../d3/d78/structDV.html">DV</a> &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return an <code>iterator</code> pointing past the end of the collection. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>An <code>iterator</code>.</dd></dl>
<p>Note that dereferencing the iterator will yield a proxy rather than a reference; the proxy will handle deleting an owned element if it's assigned to. </p>

</div>
</div>
<a class="anchor" id="ad4e0cbb65c66bb7b712bde4e92de182e"></a><!-- doxytag: member="ConstDataVector::erase" ref="ad4e0cbb65c66bb7b712bde4e92de182e" args="(iterator first, iterator last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a>&lt; <a class="el" href="../../d3/d78/structDV.html">DV</a> &gt;::<a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a> <a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a>&lt; <a class="el" href="../../d3/d78/structDV.html">DV</a> &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove a range of elements. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>Iterator pointing to the first element to be removed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>last</em>&nbsp;</td><td>Iterator pointing one past the last element to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An iterator pointing to the element pointed to by <em>last</em> prior to erasing (or <code><a class="el" href="../../de/db1/classConstDataVector.html#a7e790c3b42f79d58586ebb3cf027781a" title="Return an iterator pointing past the end of the collection.">end()</a></code>).</dd></dl>
<p>If the container owns its elements, then the removed elements will be deleted. Any duplicates will be removed in this process, but don't rely on this. </p>

</div>
</div>
<a class="anchor" id="a191b17e706f9efc349510e54b00f8a19"></a><!-- doxytag: member="ConstDataVector::erase" ref="a191b17e706f9efc349510e54b00f8a19" args="(iterator position)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a>&lt; <a class="el" href="../../d3/d78/structDV.html">DV</a> &gt;::<a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a> <a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a>&lt; <a class="el" href="../../d3/d78/structDV.html">DV</a> &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove element at a given position. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>position</em>&nbsp;</td><td>Iterator pointing to the element to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An iterator pointing to the next element (or <code><a class="el" href="../../de/db1/classConstDataVector.html#a7e790c3b42f79d58586ebb3cf027781a" title="Return an iterator pointing past the end of the collection.">end()</a></code>).</dd></dl>
<p>If the container owns its elements, then the pointed-to element will be deleted. </p>

</div>
</div>
<a class="anchor" id="a4993339b08404582cd9d83127c344802"></a><!-- doxytag: member="ConstDataVector::front" ref="a4993339b08404582cd9d83127c344802" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a>&lt; <a class="el" href="../../d3/d78/structDV.html">DV</a> &gt;::<a class="el" href="../../d7/d05/classDataModel__detail_1_1ElementProxy.html">ElementProxy</a> <a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a>&lt; <a class="el" href="../../d3/d78/structDV.html">DV</a> &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access the first element in the collection as an lvalue. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Proxy to the first element in the collection.</dd></dl>
<p>No checking is done to ensure that the container is not empty. Note that we return a proxy object rather than a reference; the proxy will handle deleting an owned element if it's assigned to. </p>

</div>
</div>
<a class="anchor" id="a6a95569685418afead723f1798ac143f"></a><!-- doxytag: member="ConstDataVector::insert" ref="a6a95569685418afead723f1798ac143f" args="(iterator position, InputIterator first, InputIterator last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DV &gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a>&lt; <a class="el" href="../../d3/d78/structDV.html">DV</a> &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a group of new elements to the collection. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>position</em>&nbsp;</td><td>Iterator before which the element will be added. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>The start of the range to put in the container. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>last</em>&nbsp;</td><td>The end of the range to put in the container.</td></tr>
  </table>
  </dd>
</dl>
<p>The container's ownership policy will determine if it takes ownership of the new element.</p>
<p>Note: this method may only be called using the most derived <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> in the hierarchy. </p>

</div>
</div>
<a class="anchor" id="ad6acd17f41c3809ce00ed14aa78e7d80"></a><!-- doxytag: member="ConstDataVector::insert" ref="ad6acd17f41c3809ce00ed14aa78e7d80" args="(iterator position, value_type pElem)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a>&lt; <a class="el" href="../../d3/d78/structDV.html">DV</a> &gt;::<a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a> <a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a>&lt; <a class="el" href="../../d3/d78/structDV.html">DV</a> &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../de/db1/classConstDataVector.html#a5fd314970812a0e01af18df65729d2bd">value_type</a>&nbsp;</td>
          <td class="paramname"> <em>pElem</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a new element to the collection. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>position</em>&nbsp;</td><td>Iterator before which the element will be added. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pElem</em>&nbsp;</td><td>The element to add to the collection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An iterator that points to the inserted data.</dd></dl>
<p>The container's ownership policy will determine if it takes ownership of the new element.</p>
<p>Note: this method may only be called using the most derived <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> in the hierarchy. </p>

</div>
</div>
<a class="anchor" id="af4024a744ff89b92eb8e8a8e60e80d0e"></a><!-- doxytag: member="ConstDataVector::iter_swap" ref="af4024a744ff89b92eb8e8a8e60e80d0e" args="(iterator a, iterator b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a>&lt; <a class="el" href="../../d3/d78/structDV.html">DV</a> &gt;::iter_swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swap the referents of two <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> iterators. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>The first iterator for the swap. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>The second iterator for the swap/ </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac5c9d1ec571f2c3ab6026ab0b72fe923"></a><!-- doxytag: member="ConstDataVector::operator&lt;" ref="ac5c9d1ec571f2c3ab6026ab0b72fe923" args="(const ConstDataVector &amp;b) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a>&lt; <a class="el" href="../../d3/d78/structDV.html">DV</a> &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a>&lt; <a class="el" href="../../d3/d78/structDV.html">DV</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Vector ordering relation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td><a class="el" href="../../d4/dc4/structA.html">A</a> <code><a class="el" href="../../de/db1/classConstDataVector.html" title="DataVector adapter that acts like it holds const pointers.">ConstDataVector</a></code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td><a class="el" href="../../d4/dc4/structA.html">A</a> <code><a class="el" href="../../de/db1/classConstDataVector.html" title="DataVector adapter that acts like it holds const pointers.">ConstDataVector</a></code> of the same type as <em>x</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True iff <em>x</em> is lexicographically less than <em>y</em>.</dd></dl>
<p>This is a total ordering relation. It is linear in the size of the vectors. Comparisons are done on the pointer values of the elements.</p>
<p>See <code>std::lexicographical_compare()</code> for how the determination is made. </p>

</div>
</div>
<a class="anchor" id="ab0e570bb8e3da3b9ce9c465327eed052"></a><!-- doxytag: member="ConstDataVector::operator=" ref="ab0e570bb8e3da3b9ce9c465327eed052" args="(const ConstDataVector &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a>&lt; <a class="el" href="../../d3/d78/structDV.html">DV</a> &gt; &amp; <a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a>&lt; <a class="el" href="../../d3/d78/structDV.html">DV</a> &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a>&lt; <a class="el" href="../../d3/d78/structDV.html">DV</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor. </p>
<p>Assignment operator.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>The container from which to copy.</td></tr>
  </table>
  </dd>
</dl>
<p>This is a `shallow' copy; the new container will not own its elements. Assignment operator. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>The <a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a> from which to assign. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>This object.</dd></dl>
<p>This is a `shallow' copy; after the completion of this, the <a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a> will not own its elements. Any elements it owned prior to this call will be released.</p>
<p>Note: this method may only be called using the most derived <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> in the hierarchy.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>The <a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a> from which to assign. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>This object.</dd></dl>
<p>This is a `shallow' copy; after the completion of this, the <a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a> will not own its elements. Any elements it owned prior to this call will be released.</p>
<p>Note: this method may only be called using the most derived <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> in the hierarchy. </p>

</div>
</div>
<a class="anchor" id="ac7823edb4c1dce015b3bd63ca32da738"></a><!-- doxytag: member="ConstDataVector::operator==" ref="ac7823edb4c1dce015b3bd63ca32da738" args="(const ConstDataVector &amp;b) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a>&lt; <a class="el" href="../../d3/d78/structDV.html">DV</a> &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a>&lt; <a class="el" href="../../d3/d78/structDV.html">DV</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Vector equality comparison. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td><a class="el" href="../../d4/dc4/structA.html">A</a> <code><a class="el" href="../../de/db1/classConstDataVector.html" title="DataVector adapter that acts like it holds const pointers.">ConstDataVector</a></code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td><a class="el" href="../../d4/dc4/structA.html">A</a> <code><a class="el" href="../../de/db1/classConstDataVector.html" title="DataVector adapter that acts like it holds const pointers.">ConstDataVector</a></code> of the same type as <em>x</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True iff the size and elements of the vectors are equal.</dd></dl>
<p>This is an equivalence relation. It is linear in the size of the vectors. Vectors are considered equivalent if their sizes are equal, and if corresponding elements compare equal. </p>

</div>
</div>
<a class="anchor" id="aae62dc3e4f66c0fd8ef43c252a13b48d"></a><!-- doxytag: member="ConstDataVector::operator[]" ref="aae62dc3e4f66c0fd8ef43c252a13b48d" args="(size_type n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a>&lt; <a class="el" href="../../d3/d78/structDV.html">DV</a> &gt;::<a class="el" href="../../d7/d05/classDataModel__detail_1_1ElementProxy.html">ElementProxy</a> <a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a>&lt; <a class="el" href="../../d3/d78/structDV.html">DV</a> &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/db1/classConstDataVector.html#a0b7cdd6c8969c3dbdbbb23eabfb4d524">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access an element, as an lvalue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>Array index to access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Proxy to the element at <em>n</em>.</dd></dl>
<p>No bounds checking is done. Note that we return a proxy object rather than a reference; the proxy will handle deleting an owned element if it's assigned to. </p>

</div>
</div>
<a class="anchor" id="a83ff6832bd6d52468225dca32c516121"></a><!-- doxytag: member="ConstDataVector::push_back" ref="a83ff6832bd6d52468225dca32c516121" args="(value_type pElem)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a>&lt; <a class="el" href="../../d3/d78/structDV.html">DV</a> &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/db1/classConstDataVector.html#a5fd314970812a0e01af18df65729d2bd">value_type</a>&nbsp;</td>
          <td class="paramname"> <em>pElem</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add an element to the end of the collection. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pElem</em>&nbsp;</td><td>The element to add to the collection.</td></tr>
  </table>
  </dd>
</dl>
<p>The container's ownership policy will determine if it takes ownership of the new element.</p>
<p>Note: this method may only be called using the most derived <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> in the hierarchy. </p>

</div>
</div>
<a class="anchor" id="ae71dc63f2039fcb8a99040701ec37e7a"></a><!-- doxytag: member="ConstDataVector::rbegin" ref="ae71dc63f2039fcb8a99040701ec37e7a" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a>&lt; <a class="el" href="../../d3/d78/structDV.html">DV</a> &gt;::<a class="el" href="../../de/db1/classConstDataVector.html#ad6f83847ddbbcc881f467bdfa06d93a9">reverse_iterator</a> <a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a>&lt; <a class="el" href="../../d3/d78/structDV.html">DV</a> &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a <code>reverse_iterator</code> pointing past the end of the collection. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="../../d4/dc4/structA.html">A</a> <code>reverse_iterator</code>.</dd></dl>
<p>Note that dereferencing the iterator will yield a proxy rather than a reference; the proxy will handle deleting an owned element if it's assigned to. </p>

</div>
</div>
<a class="anchor" id="abdeb7d8faaaf6e0fd5d4c5dbc29fc94a"></a><!-- doxytag: member="ConstDataVector::rend" ref="abdeb7d8faaaf6e0fd5d4c5dbc29fc94a" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a>&lt; <a class="el" href="../../d3/d78/structDV.html">DV</a> &gt;::<a class="el" href="../../de/db1/classConstDataVector.html#ad6f83847ddbbcc881f467bdfa06d93a9">reverse_iterator</a> <a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a>&lt; <a class="el" href="../../d3/d78/structDV.html">DV</a> &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a <code>reverse_iterator</code> pointing at the beginning of the collection. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="../../d4/dc4/structA.html">A</a> <code>reverse_iterator</code>.</dd></dl>
<p>Note that dereferencing the iterator will yield a proxy rather than a reference; the proxy will handle deleting an owned element if it's assigned to. </p>

</div>
</div>
<a class="anchor" id="a12fe9d9af90d3aa4afbe056fe433a5cc"></a><!-- doxytag: member="ConstDataVector::resortAux" ref="a12fe9d9af90d3aa4afbe056fe433a5cc" args="(iterator, iterator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a>&lt; <a class="el" href="../../d3/d78/structDV.html">DV</a> &gt;::resortAux </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reset indices / reorder aux data after elements have been permuted. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>beg</em>&nbsp;</td><td>Start of the range of elements to process. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>End of the range of elements to process.</td></tr>
  </table>
  </dd>
</dl>
<p>This is a no-op for <code><a class="el" href="../../de/db1/classConstDataVector.html" title="DataVector adapter that acts like it holds const pointers.">ConstDataVector</a></code>. </p>

</div>
</div>
<a class="anchor" id="ae42c031d0522fde4a983f3a8c10328d3"></a><!-- doxytag: member="ConstDataVector::swap" ref="ae42c031d0522fde4a983f3a8c10328d3" args="(ConstDataVector &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a>&lt; <a class="el" href="../../d3/d78/structDV.html">DV</a> &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a>&lt; <a class="el" href="../../d3/d78/structDV.html">DV</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swap this collection with another. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>The collection with which to swap.</td></tr>
  </table>
  </dd>
</dl>
<p>Ownership is swapped along with the collection content.</p>
<p>Note: this method may only be called using the most-derived <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> in the hierarchy. The <em>rhs</em> must also be referenced using the most-derived <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code>. </p>

</div>
</div>
<a class="anchor" id="a86413c1535c7b64e7d9fff0b55295a08"></a><!-- doxytag: member="ConstDataVector::swapElement" ref="a86413c1535c7b64e7d9fff0b55295a08" args="(iterator pos, value_type newElem, reference oldElem)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a>&lt; <a class="el" href="../../d3/d78/structDV.html">DV</a> &gt;::swapElement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../de/db1/classConstDataVector.html#a5fd314970812a0e01af18df65729d2bd">value_type</a>&nbsp;</td>
          <td class="paramname"> <em>newElem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reference&nbsp;</td>
          <td class="paramname"> <em>oldElem</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swap one element out of the container. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>The element in the container to swap. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newElem</em>&nbsp;</td><td>New element to put in the container. May be 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>oldElem</em>&nbsp;</td><td>Reference to receive the element removed from the container.</td></tr>
  </table>
  </dd>
</dl>
<p>Reference <em>oldElem</em> is initialized with element <em>pos</em> of the collection (no bounds checking). Then element <em>index</em> is set to <code>newElem</code>. If the collection owns its elements, then it will take ownership of <em>newElem</em> and release (without deleting) the element returned through <em>oldElem</em>.</p>
<p>Note: this method may only be called using the most derived <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a></code> in the hierarchy. </p>

</div>
</div>
<a class="anchor" id="a63dd71d02bdefb4cf4501b8d788998bf"></a><!-- doxytag: member="ConstDataVector::swapElement" ref="a63dd71d02bdefb4cf4501b8d788998bf" args="(size_type index, value_type newElem, reference oldElem)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/db1/classConstDataVector.html">ConstDataVector</a>&lt; <a class="el" href="../../d3/d78/structDV.html">DV</a> &gt;::swapElement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/db1/classConstDataVector.html#a0b7cdd6c8969c3dbdbbb23eabfb4d524">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../de/db1/classConstDataVector.html#a5fd314970812a0e01af18df65729d2bd">value_type</a>&nbsp;</td>
          <td class="paramname"> <em>newElem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reference&nbsp;</td>
          <td class="paramname"> <em>oldElem</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swap one element out of the container. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>Index of the element in the container to swap. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newElem</em>&nbsp;</td><td>New element to put in the container. May be 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>oldElem</em>&nbsp;</td><td>Reference to receive the element removed from the container.</td></tr>
  </table>
  </dd>
</dl>
<p>Reference <em>oldElem</em> is initialized with element <em>index</em> of the collection (no bounds checking). Then element <em>index</em> is set to <code>newElem</code>. If the collection owns its elements, then it will take ownership of <em>newElem</em> and release (without deleting) the element returned through <em>oldElem</em>.</p>
<p>Note: this method may only be called using the most derived <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> in the hierarchy. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/<a class="el" href="../../d2/d0d/ConstDataVector_8h_source.html">ConstDataVector.h</a></li>
<li>/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/<a class="el" href="../../d2/d61/ConstDataVector_8icc.html">ConstDataVector.icc</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 15 Apr 2017 for RootCore Packages by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
