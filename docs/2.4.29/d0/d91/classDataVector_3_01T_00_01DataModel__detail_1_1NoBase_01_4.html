<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>RootCore Packages: DataVector&lt; T, DataModel_detail::NoBase &gt; Class Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="../../index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="../../search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="../../annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="../../classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="../../hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="../../functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>DataVector&lt; T, DataModel_detail::NoBase &gt; Class Template Reference</h1><!-- doxytag: class="DataVector&lt; T, DataModel_detail::NoBase &gt;" --><!-- doxytag: inherits="SG::AuxVectorBase" -->
<p>Base specialization for <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a>&lt;<a class="el" href="../../d1/def/classT.html">T</a>&gt;</code>.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d7/dd6/DataVector_8h_source.html">DataVector.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for DataVector&lt; T, DataModel_detail::NoBase &gt;:</div>
<div class="dynsection">
 <div class="center">
  <img src="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.gif" usemap="#DataVector&lt; T, DataModel_detail::NoBase &gt;_map" alt=""/>
  <map id="DataVector&lt; T, DataModel_detail::NoBase &gt;_map" name="DataVector&lt; T, DataModel_detail::NoBase &gt;_map">
<area href="../../dd/da5/classSG_1_1AuxVectorBase.html" alt="SG::AuxVectorBase" shape="rect" coords="137,56,401,80"/>
<area href="../../db/dd6/classSG_1_1AuxVectorData.html" alt="SG::AuxVectorData" shape="rect" coords="0,0,264,24"/>
<area href="../../db/dd6/classSG_1_1AuxVectorData.html" alt="SG::AuxVectorData" shape="rect" coords="274,0,538,24"/>
</map>
 </div>
</div>

<p><a href="../../d1/db6/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac35f5551429d21ca6cbcca041a2d9abf"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::DataVector_BASE" ref="ac35f5551429d21ca6cbcca041a2d9abf" args="" -->
typedef <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>DataVector_BASE</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af58267834003be5047f5c22527b414c8"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::DVL_BASE" ref="af58267834003be5047f5c22527b414c8" args="" -->
typedef <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>DVL_BASE</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d22da7eb5426078d4caa20180a8b42f"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::isSequence" ref="a8d22da7eb5426078d4caa20180a8b42f" args="" -->
typedef boost::true_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a8d22da7eb5426078d4caa20180a8b42f">isSequence</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mark as a sequence, for <a class="el" href="../../da/da2/classDataLink.html" title="DataLink implementation for ROOT usage.">DataLink</a> / <a class="el" href="../../d6/d6e/classElementLink.html" title="ElementLink implementation for ROOT usage.">ElementLink</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="../../d1/def/classT.html">T</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a9037cb597ab293dcf843bd9f5d88699f">PtrVector</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae7b59e0e4711d397158b222c7cb0968b"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::BaseContainer" ref="ae7b59e0e4711d397158b222c7cb0968b" args="" -->
typedef std::vector&lt; <a class="el" href="../../d1/def/classT.html">T</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>BaseContainer</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a36a15ced3a471eba601bc466cceb1407"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::reference" ref="a36a15ced3a471eba601bc466cceb1407" args="" -->
typedef <a class="el" href="../../d1/def/classT.html">T</a> *&amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>reference</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4fe89196f2c3310e1682d52eaa6bf1a"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::const_reference" ref="af4fe89196f2c3310e1682d52eaa6bf1a" args="" -->
typedef <a class="el" href="../../d1/def/classT.html">T</a> *const &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_reference</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a426cf9faa6a9550c9400c68a49d278"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::size_type" ref="a0a426cf9faa6a9550c9400c68a49d278" args="" -->
typedef PtrVector::size_type&nbsp;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7424c314b1b4a04aeaf6a9a88fbcd27"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::difference_type" ref="aa7424c314b1b4a04aeaf6a9a88fbcd27" args="" -->
typedef PtrVector::difference_type&nbsp;</td><td class="memItemRight" valign="bottom"><b>difference_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e0714111ae690350811e21ba22110a9"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::value_type" ref="a0e0714111ae690350811e21ba22110a9" args="" -->
typedef <a class="el" href="../../d1/def/classT.html">T</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b690898dbe6d9cff5454000275d141a"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::allocator_type" ref="a2b690898dbe6d9cff5454000275d141a" args="" -->
typedef PtrVector::allocator_type&nbsp;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeecc2f1041e730ee4161320f785ade2c"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::pointer" ref="aeecc2f1041e730ee4161320f785ade2c" args="" -->
typedef <a class="el" href="../../d1/def/classT.html">T</a> **&nbsp;</td><td class="memItemRight" valign="bottom"><b>pointer</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abcf14ad6aec74539a12dd463ee2569bc"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::const_pointer" ref="abcf14ad6aec74539a12dd463ee2569bc" args="" -->
typedef <a class="el" href="../../d1/def/classT.html">T</a> *const *&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75acba4abcd3d7b9728b643379e080e3"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::const_value_type" ref="a75acba4abcd3d7b9728b643379e080e3" args="" -->
typedef const <a class="el" href="../../d1/def/classT.html">T</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_value_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="../../d1/def/classT.html">T</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#adc2ad3e5de641d68b5490651f15d9448">base_value_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="../../d7/d05/classDataModel__detail_1_1ElementProxy.html">DataModel_detail::ElementProxy</a><br class="typebreak"/>
&lt; <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a99ab9c1706c2cd3273ec27a4b218ccfa">ElementProxy</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad14d8fa936e56241eea1626b464c3b8c"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::const_iterator" ref="ad14d8fa936e56241eea1626b464c3b8c" args="" -->
typedef PtrVector::const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#ad14d8fa936e56241eea1626b464c3b8c">const_iterator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Standard <code>const_iterator</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">DataModel_detail::iterator</a><br class="typebreak"/>
&lt; <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a0a24970f8d3743d873f69407fbf76872">iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a61d77f0c504d473f85376ddce8bd2163"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::const_reverse_iterator" ref="a61d77f0c504d473f85376ddce8bd2163" args="" -->
typedef std::reverse_iterator<br class="typebreak"/>
&lt; <a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#ad14d8fa936e56241eea1626b464c3b8c">const_iterator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a61d77f0c504d473f85376ddce8bd2163">const_reverse_iterator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Standard <code>const_reverse_iterator</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::reverse_iterator<br class="typebreak"/>
&lt; <a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a3551d2e1bdbe02ade11f731cfb976f4f">reverse_iterator</a></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors, destructors, assignment.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpb39bb9cb1bc18cddc74e7f363d4e2167"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a51d310761242622f1b5329a6fe398e51">DataVector</a> (<a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">SG::OwnershipPolicy</a> ownPolicy=SG::OWN_ELEMENTS, <a class="el" href="../../dd/d59/namespaceSG.html#a9f3d699f65390b7f8baf54d9cd634573">SG::IndexTrackingPolicy</a> trackIndices=SG::DEFAULT_TRACK_INDICES)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor.  <a href="#a51d310761242622f1b5329a6fe398e51"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#acd6dcc16e6805765bd3b11f9124d4e76">DataVector</a> (size_type n, <a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">SG::OwnershipPolicy</a> ownPolicy=SG::OWN_ELEMENTS, <a class="el" href="../../dd/d59/namespaceSG.html#a9f3d699f65390b7f8baf54d9cd634573">SG::IndexTrackingPolicy</a> trackIndices=SG::DEFAULT_TRACK_INDICES)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sized constructor.  <a href="#acd6dcc16e6805765bd3b11f9124d4e76"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a507c03514b600a8808c0d50e5f2292ec">DataVector</a> (const <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor.  <a href="#a507c03514b600a8808c0d50e5f2292ec"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#af9d46e1bf3b98f7910fcde5ad4dc7b7a">DataVector</a> (InputIterator first, InputIterator last, <a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">SG::OwnershipPolicy</a> ownPolicy=SG::VIEW_ELEMENTS, <a class="el" href="../../dd/d59/namespaceSG.html#a9f3d699f65390b7f8baf54d9cd634573">SG::IndexTrackingPolicy</a> trackIndices=SG::DEFAULT_TRACK_INDICES, <a class="el" href="../../dc/d05/classSG_1_1IAuxStore.html">SG::IAuxStore</a> *store=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor from iterators.  <a href="#af9d46e1bf3b98f7910fcde5ad4dc7b7a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#ad7e3dcf0a187de3ad9091d75e4e27d15">operator=</a> (const <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment operator.  <a href="#ad7e3dcf0a187de3ad9091d75e4e27d15"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#abbf0f556cf535ba01907867cfe6ddca8">assign</a> (InputIterator first, InputIterator last)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assign from iterators.  <a href="#abbf0f556cf535ba01907867cfe6ddca8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#ab824ffa2d0adf0efec55d86c236e069c">~DataVector</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#ab824ffa2d0adf0efec55d86c236e069c"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Size and capacity.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp91690d5f8f79d42f64e62a4bfc370024"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa373b4153b48277e38b13e3d1b12ca57"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::size" ref="aa373b4153b48277e38b13e3d1b12ca57" args="() const " -->
size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#aa373b4153b48277e38b13e3d1b12ca57">size</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of elements in the collection. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a258f5c8833dc8e1d659960784c468f25">size_v</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of elements in the collection.  <a href="#a258f5c8833dc8e1d659960784c468f25"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af073ac3549c572ef07b6dea868683034"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::max_size" ref="af073ac3549c572ef07b6dea868683034" args="() const " -->
size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#af073ac3549c572ef07b6dea868683034">max_size</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the <code><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#aa373b4153b48277e38b13e3d1b12ca57" title="Returns the number of elements in the collection.">size()</a></code> of the largest possible collection. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a43652bda389a83f437300f0f1de68e05">resize</a> (size_type sz)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resizes the collection to the specified number of elements.  <a href="#a43652bda389a83f437300f0f1de68e05"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a89410e14163ca5e0914e7fa596d41685"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::capacity" ref="a89410e14163ca5e0914e7fa596d41685" args="() const " -->
size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a89410e14163ca5e0914e7fa596d41685">capacity</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the total number of elements that the collection can hold before needing to allocate more memory. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a236a9f58b14de59ef54c5107dfcff5dc">capacity_v</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the total number of elements that the collection can hold before needing to allocate more memory.  <a href="#a236a9f58b14de59ef54c5107dfcff5dc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9cba59c9dc31127ba7a3fd98e0b23282"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::empty" ref="a9cba59c9dc31127ba7a3fd98e0b23282" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a9cba59c9dc31127ba7a3fd98e0b23282">empty</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if the collection is empty. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#ad057592307e2749e25a3970ed6426b17">reserve</a> (size_type n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to preallocate enough memory for a specified number of elements.  <a href="#ad057592307e2749e25a3970ed6426b17"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Element access.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp03f08060dbcda9a05f3dd6a98ff9f981"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d1/def/classT.html">T</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#ad3eba15a4069718475af38248a3d0d2e">operator[]</a> (size_type n) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access an element, as an rvalue.  <a href="#ad3eba15a4069718475af38248a3d0d2e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d1/def/classT.html">T</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a4c53dc5625a660a87187d033194dad02">get</a> (size_type n) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access an element, as an rvalue.  <a href="#a4c53dc5625a660a87187d033194dad02"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d7/d05/classDataModel__detail_1_1ElementProxy.html">ElementProxy</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a9dfa8e78005f6ba076fa4fd8f89905cc">operator[]</a> (size_type n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access an element, as an lvalue.  <a href="#a9dfa8e78005f6ba076fa4fd8f89905cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d1/def/classT.html">T</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#aa8ea77da44d88c17ebb3ab9c3f6d78e1">at</a> (size_type n) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access an element, as an rvalue.  <a href="#aa8ea77da44d88c17ebb3ab9c3f6d78e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d7/d05/classDataModel__detail_1_1ElementProxy.html">ElementProxy</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a3744541d5aee9f68ea81cbe58e474fec">at</a> (size_type n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access an element, as an lvalue.  <a href="#a3744541d5aee9f68ea81cbe58e474fec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d1/def/classT.html">T</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a8b4e4253e25498a4aed16cf5fd19176b">front</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access the first element in the collection as an rvalue.  <a href="#a8b4e4253e25498a4aed16cf5fd19176b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d1/def/classT.html">T</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a94471e13ddf6ee1c7808d032b60d40a5">back</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access the last element in the collection as an rvalue.  <a href="#a94471e13ddf6ee1c7808d032b60d40a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d7/d05/classDataModel__detail_1_1ElementProxy.html">ElementProxy</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a12489c7ded0c123b55d5b4d8ff5386ae">front</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access the first element in the collection as an lvalue.  <a href="#a12489c7ded0c123b55d5b4d8ff5386ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d7/d05/classDataModel__detail_1_1ElementProxy.html">ElementProxy</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a0ded16015ae169fe929ab34eda1c079a">back</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access the last element in the collection as an lvalue.  <a href="#a0ded16015ae169fe929ab34eda1c079a"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Iterator creation.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp04fea93d7622927e954392dcd5690674"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#ad14d8fa936e56241eea1626b464c3b8c">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a31fc0611d6e14e7dc95a7444b5389786">begin</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a <code>const_iterator</code> pointing at the beginning of the collection.  <a href="#a31fc0611d6e14e7dc95a7444b5389786"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#ad14d8fa936e56241eea1626b464c3b8c">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a4c31b486a1b577d581bcded32f8c0d4a">end</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a <code>const_iterator</code> pointing past the end of the collection.  <a href="#a4c31b486a1b577d581bcded32f8c0d4a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a016e07a7a7a825f01214a03d136381cb">begin</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return an <code>iterator</code> pointing at the beginning of the collection.  <a href="#a016e07a7a7a825f01214a03d136381cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a084ec53b556ed4283f598bdd33398943">end</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return an <code>iterator</code> pointing past the end of the collection.  <a href="#a084ec53b556ed4283f598bdd33398943"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a61d77f0c504d473f85376ddce8bd2163">const_reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a6225bfe9a292ddead10cec769022a2ce">rbegin</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a <code>const_reverse_iterator</code> pointing past the end of the collection.  <a href="#a6225bfe9a292ddead10cec769022a2ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a61d77f0c504d473f85376ddce8bd2163">const_reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#acfa741d2f764cf729035ce630c542d43">rend</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a <code>const_reverse_iterator</code> pointing at the beginning of the collection.  <a href="#acfa741d2f764cf729035ce630c542d43"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a3551d2e1bdbe02ade11f731cfb976f4f">reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a2b47037798be81db90016ad9584899e9">rbegin</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a <code>reverse_iterator</code> pointing past the end of the collection.  <a href="#a2b47037798be81db90016ad9584899e9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a3551d2e1bdbe02ade11f731cfb976f4f">reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a3346ad4e2fe7f416b8c1b7f62a838076">rend</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a <code>reverse_iterator</code> pointing at the beginning of the collection.  <a href="#a3346ad4e2fe7f416b8c1b7f62a838076"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#ad14d8fa936e56241eea1626b464c3b8c">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a865ba4448ebb8fcb61ed2ebe69a900fc">cbegin</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a <code>const_iterator</code> pointing at the beginning of the collection.  <a href="#a865ba4448ebb8fcb61ed2ebe69a900fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#ad14d8fa936e56241eea1626b464c3b8c">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a87f60ec41043c1ef5dfb5b50dd4b08d8">cend</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a <code>const_iterator</code> pointing past the end of the collection.  <a href="#a87f60ec41043c1ef5dfb5b50dd4b08d8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a61d77f0c504d473f85376ddce8bd2163">const_reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a1d1064401af7c90703d0a2f79136e0ec">crbegin</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a <code>const_reverse_iterator</code> pointing past the end of the collection.  <a href="#a1d1064401af7c90703d0a2f79136e0ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a61d77f0c504d473f85376ddce8bd2163">const_reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#afed788d8db665532545478186925b3a6">crend</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a <code>const_reverse_iterator</code> pointing at the beginning of the collection.  <a href="#afed788d8db665532545478186925b3a6"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Insertion operations.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpc4ff45e64b9f41cc82677be76808116c"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#aaa71855a58852e9c5ffa61a555ed581f">push_back</a> (<a class="el" href="../../d1/def/classT.html">value_type</a> pElem)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add an element to the end of the collection.  <a href="#aaa71855a58852e9c5ffa61a555ed581f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a54e962bbda1ab83d0b892a0be604c0e9">emplace_back</a> (<a class="el" href="../../d1/def/classT.html">value_type</a> pElem)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add an element to the end of the collection.  <a href="#a54e962bbda1ab83d0b892a0be604c0e9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a250b3c680672ec28ec9938239bc9328a">insert</a> (<a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a> position, <a class="el" href="../../d1/def/classT.html">value_type</a> pElem)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a new element to the collection.  <a href="#a250b3c680672ec28ec9938239bc9328a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a728e46d92c5d2d0cdce9e2ce51bab6d1">emplace</a> (<a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a> position, <a class="el" href="../../d1/def/classT.html">value_type</a> pElem)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a new element to the collection.  <a href="#a728e46d92c5d2d0cdce9e2ce51bab6d1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#ae2dd1670bab9846009d870a77d04d582">insert</a> (<a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a> position, InputIterator first, InputIterator last)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a group of new elements to the collection.  <a href="#ae2dd1670bab9846009d870a77d04d582"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Erasure operations.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp5dd35913d37b538bffc58eac1d7946e3"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a5e41132c55010e688115f1ed6cc0edab">erase</a> (<a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a> position)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove element at a given position.  <a href="#a5e41132c55010e688115f1ed6cc0edab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#ae16b6a23080b04529edbcaede4c3b121">erase</a> (<a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a> first, <a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a> last)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove a range of elements.  <a href="#ae16b6a23080b04529edbcaede4c3b121"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a5435f79346220ac80c41bdc3adf9803c">pop_back</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove the last element from the collection.  <a href="#a5435f79346220ac80c41bdc3adf9803c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a3292a55621ae0171766b2f8e9d067436">clear</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase all the elements in the collection.  <a href="#a3292a55621ae0171766b2f8e9d067436"></a><br/></td></tr>
<tr><td colspan="2"><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#aa9b859c5e4d9bb75d44cba2e72690238">has_virtual</a> = false</td></tr>
<tr><td colspan="2"><h2>Internal operations.</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp18fcc315290ab5188be82cc8bf66dc29"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2cf6a773e2f312ccade13b686b8f01d6"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::DataModel_detail::ElementProxy&lt; DataVector &gt;" ref="a2cf6a773e2f312ccade13b686b8f01d6" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a2cf6a773e2f312ccade13b686b8f01d6">DataModel_detail::ElementProxy&lt; DataVector &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a872beca4ae4bd23ae0ca85253466b96b"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::ConstDataVector&lt; DataVector &gt;" ref="a872beca4ae4bd23ae0ca85253466b96b" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a872beca4ae4bd23ae0ca85253466b96b">ConstDataVector&lt; DataVector &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1119a539ef95e66a83ed73e65ce4acb9"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::test2_assignelement1" ref="a1119a539ef95e66a83ed73e65ce4acb9" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>test2_assignelement1</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d549df8562ac32795e7bebf440b830d"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::test2_assignelement2" ref="a5d549df8562ac32795e7bebf440b830d" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>test2_assignelement2</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">SG::OwnershipPolicy</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a205453f4c7420d058d1179766b292c87">m_ownPolicy</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01f75d3161735bae23b4b0018f5dbef2"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::m_pCont" ref="a01f75d3161735bae23b4b0018f5dbef2" args="" -->
<a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a9037cb597ab293dcf843bd9f5d88699f">PtrVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a01f75d3161735bae23b4b0018f5dbef2">m_pCont</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This actually holds the elements. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#ab4de50491cb3c3dc239fd4d52c7151d7">resortAux</a> (<a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a> beg, <a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a> end)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset indices / reorder aux data after elements have been permuted.  <a href="#ab4de50491cb3c3dc239fd4d52c7151d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a191f1812d1e0bfab56d0ecb4e1902138">testInsert</a> (const char *op)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if we can insert; raise an exception if not.  <a href="#a191f1812d1e0bfab56d0ecb4e1902138"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a64c19881e3c41eb3a9ebbb24627ba7bf">testInsertOol</a> (const char *op)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if we can insert; raise an exception if not.  <a href="#a64c19881e3c41eb3a9ebbb24627ba7bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a162843eb42a30aa266bb3053af9e7abb">baseOffset1</a> (const char *p, const <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a> &amp;dv, const std::type_info &amp;ti)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper for <code>baseOffset</code>.  <a href="#a162843eb42a30aa266bb3053af9e7abb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="../../d1/def/classT.html">T</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a31431efcf2f87c3775b7c7c5e5e7081d">do_cast</a> (const typename PtrVector::value_type p)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper to shorten calls to <code><a class="el" href="../../de/d59/structDataModel__detail_1_1DVLCast.html" title="casting operations for DataVector/DataList. ">DataModel_detail::DVLCast</a></code>.  <a href="#a31431efcf2f87c3775b7c7c5e5e7081d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PtrVector::iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a0208dd537831fad033198a40aa0fcaf3">erase_base</a> (typename PtrVector::iterator position)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper for <code><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a5e41132c55010e688115f1ed6cc0edab" title="Remove element at a given position.">erase()</a></code>. Remove element at a given position.  <a href="#a0208dd537831fad033198a40aa0fcaf3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PtrVector::iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a9b1da673ca3bba86c926acd40f986e6a">erase_base</a> (typename PtrVector::iterator first, typename PtrVector::iterator last)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper for <code><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a5e41132c55010e688115f1ed6cc0edab" title="Remove element at a given position.">erase()</a></code>. Remove a range of elements.  <a href="#a9b1da673ca3bba86c926acd40f986e6a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a74c23e2aba33eb2ce6817c563b6c8917">clearMostDerived</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear <code>m_isMostDerived</code> for this instance and for all bases.  <a href="#a74c23e2aba33eb2ce6817c563b6c8917"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#abfc9461741ecfa4b568e91b3e79abe1d">setMostDerived</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set <code>m_isMostDerived</code> for this instance and clear it for all bases.  <a href="#abfc9461741ecfa4b568e91b3e79abe1d"></a><br/></td></tr>
<tr><td colspan="2"><h2>Swap and sort.</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp48740572230bf871bbbe3f4450b8e26c"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#ace0665d0ab6fd551aeee44eca9a29a40">swap</a> (<a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swap this collection with another.  <a href="#ace0665d0ab6fd551aeee44eca9a29a40"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#ab3b8b5064b52bcb7921b973abad09a8f">sort</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sort the container.  <a href="#ab3b8b5064b52bcb7921b973abad09a8f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class COMPARE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a42b5a010f599505eccc8858c94d5b0c1">sort</a> (COMPARE comp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sort the container with a user-specified comparison operator.  <a href="#a42b5a010f599505eccc8858c94d5b0c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a1a1ee3a77f7504b7a8f3d475f7cdd003">iter_swap</a> (<a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a> a, <a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a> b)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swap the referents of two <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> iterators.  <a href="#a1a1ee3a77f7504b7a8f3d475f7cdd003"></a><br/></td></tr>
<tr><td colspan="2"><h2>Non-standard operations.</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp67b3645f65a6afd377578740fa3b4ed2"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#abff69b3413c3e0a912f9d5589f4257e9">swapElement</a> (size_type index, <a class="el" href="../../d1/def/classT.html">value_type</a> newElem, <a class="el" href="../../d1/def/classT.html">reference</a> oldElem)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swap one element out of the container.  <a href="#abff69b3413c3e0a912f9d5589f4257e9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a88d41d8c4ab49f649b4fd20dbe648abd">swapElement</a> (<a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a> pos, <a class="el" href="../../d1/def/classT.html">value_type</a> newElem, <a class="el" href="../../d1/def/classT.html">reference</a> oldElem)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swap one element out of the container.  <a href="#a88d41d8c4ab49f649b4fd20dbe648abd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a9037cb597ab293dcf843bd9f5d88699f">PtrVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#adc7f275d2bc73e00c010828a4a5224f9">stdcont</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the underlying <code>std::vector</code> of the container.  <a href="#adc7f275d2bc73e00c010828a4a5224f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0f040ba00e37768ecf92319cf7edcf0"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::ownPolicy" ref="af0f040ba00e37768ecf92319cf7edcf0" args="() const " -->
<a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">SG::OwnershipPolicy</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#af0f040ba00e37768ecf92319cf7edcf0">ownPolicy</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the ownership policy setting for this container. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#aab8e11d10424034b008a627825e8093d">clear</a> (<a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">SG::OwnershipPolicy</a> ownPolicy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase all the elements in the collection, and reset the ownership mode.  <a href="#aab8e11d10424034b008a627825e8093d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#aa047639d69932b1f94bf7016a6a2c4b7">clear</a> (<a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">SG::OwnershipPolicy</a> ownPolicy, <a class="el" href="../../dd/d59/namespaceSG.html#a9f3d699f65390b7f8baf54d9cd634573">SG::IndexTrackingPolicy</a> trackIndices)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase all the elements in the collection, and reset the ownership mode.  <a href="#aa047639d69932b1f94bf7016a6a2c4b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <br class="typebreak"/>
<a class="el" href="../../da/d8a/classDataModel__detail_1_1DVLInfoBase.html">DataModel_detail::DVLInfoBase</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#abd040d558ec4796705c57c66acfeacd3">dvlinfo_v</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the DV/DL info struct for this class.  <a href="#abd040d558ec4796705c57c66acfeacd3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html">SG::AuxVectorBase</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#ae40b46f3b01ddc62478a0d98663325f0">auxbase</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert to <code>AuxVectorBase</code>.  <a href="#ae40b46f3b01ddc62478a0d98663325f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <br class="typebreak"/>
<a class="el" href="../../da/d8a/classDataModel__detail_1_1DVLInfoBase.html">DataModel_detail::DVLInfoBase</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#af01f7224a0d87d4c8d10678a80b39d27">dvlinfo</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the DV/DL info struct for this class.  <a href="#af01f7224a0d87d4c8d10678a80b39d27"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a54a54329e84fd2c5fcc780fc2a43ead6">baseOffset</a> (const std::type_info &amp;ti)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the offset of a base <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> class.  <a href="#a54a54329e84fd2c5fcc780fc2a43ead6"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class T&gt;<br/>
 class DataVector&lt; T, DataModel_detail::NoBase &gt;</h3>

<p>Base specialization for <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a>&lt;<a class="el" href="../../d1/def/classT.html">T</a>&gt;</code>. </p>
<p>This is used for the case where <code><a class="el" href="../../d1/def/classT.html">T</a></code> does not derive from other classes. This is the class which actually holds the vector of pointers.</p>
<p>See the file comments for full details. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="adc2ad3e5de641d68b5490651f15d9448"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::base_value_type" ref="adc2ad3e5de641d68b5490651f15d9448" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="../../d1/def/classT.html">T</a> <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::<a class="el" href="../../d1/def/classT.html">base_value_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The <code><a class="el" href="../../d1/def/classT.html">T</a></code> value used as the template parameter. Note that this is different from <code>value_type</code> (that's <code>T*</code>). </p>

</div>
</div>
<a class="anchor" id="a99ab9c1706c2cd3273ec27a4b218ccfa"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::ElementProxy" ref="a99ab9c1706c2cd3273ec27a4b218ccfa" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="../../d7/d05/classDataModel__detail_1_1ElementProxy.html">DataModel_detail::ElementProxy</a>&lt;<a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&gt; <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::<a class="el" href="../../d7/d05/classDataModel__detail_1_1ElementProxy.html">ElementProxy</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This type is used to proxy lvalue accesses to <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> elements, in order to handle ownership. </p>

</div>
</div>
<a class="anchor" id="a0a24970f8d3743d873f69407fbf76872"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::iterator" ref="a0a24970f8d3743d873f69407fbf76872" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">DataModel_detail::iterator</a>&lt;<a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&gt; <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::<a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Standard <code>iterator</code>. Note that lvalue references here will yield an <code>ElementProxy</code>, not a <code>reference</code>. </p>

</div>
</div>
<a class="anchor" id="a9037cb597ab293dcf843bd9f5d88699f"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::PtrVector" ref="a9037cb597ab293dcf843bd9f5d88699f" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="../../d1/def/classT.html">T</a>*&gt; <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::<a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a9037cb597ab293dcf843bd9f5d88699f">PtrVector</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is the type of the underlying <code>std::vector</code> (what <code>stdcont</code> returns). </p>

</div>
</div>
<a class="anchor" id="a3551d2e1bdbe02ade11f731cfb976f4f"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::reverse_iterator" ref="a3551d2e1bdbe02ade11f731cfb976f4f" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::reverse_iterator&lt;<a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&gt; <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::<a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a3551d2e1bdbe02ade11f731cfb976f4f">reverse_iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Standard <code>reverse_iterator</code>. Note that lvalue references here will yield an <code>ElementProxy</code>, not a <code>reference</code>. </p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a51d310761242622f1b5329a6fe398e51"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::DataVector" ref="a51d310761242622f1b5329a6fe398e51" args="(SG::OwnershipPolicy ownPolicy=SG::OWN_ELEMENTS, SG::IndexTrackingPolicy trackIndices=SG::DEFAULT_TRACK_INDICES)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::<a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">SG::OwnershipPolicy</a>&nbsp;</td>
          <td class="paramname"> <em>ownPolicy</em> = <code>SG::OWN_ELEMENTS</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d59/namespaceSG.html#a9f3d699f65390b7f8baf54d9cd634573">SG::IndexTrackingPolicy</a>&nbsp;</td>
          <td class="paramname"> <em>trackIndices</em> = <code>SG::DEFAULT_TRACK_INDICES</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default constructor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ownPolicy</em>&nbsp;</td><td>The ownership mode for the container. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>trackIndices</em>&nbsp;</td><td>The index tracking policy.</td></tr>
  </table>
  </dd>
</dl>
<p>By default, a <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> will own its elements. To avoid this, pass <code><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8ad7d4cf2303700f0966e4140f236c4bf1" title="this data object is a view, it does not own its elmts">SG::VIEW_ELEMENTS</a></code> for <em>ownPolicy</em>. </p>

</div>
</div>
<a class="anchor" id="acd6dcc16e6805765bd3b11f9124d4e76"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::DataVector" ref="acd6dcc16e6805765bd3b11f9124d4e76" args="(size_type n, SG::OwnershipPolicy ownPolicy=SG::OWN_ELEMENTS, SG::IndexTrackingPolicy trackIndices=SG::DEFAULT_TRACK_INDICES)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::<a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a> </td>
          <td>(</td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">SG::OwnershipPolicy</a>&nbsp;</td>
          <td class="paramname"> <em>ownPolicy</em> = <code>SG::OWN_ELEMENTS</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d59/namespaceSG.html#a9f3d699f65390b7f8baf54d9cd634573">SG::IndexTrackingPolicy</a>&nbsp;</td>
          <td class="paramname"> <em>trackIndices</em> = <code>SG::DEFAULT_TRACK_INDICES</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sized constructor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>The size of the container. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ownPolicy</em>&nbsp;</td><td>The ownership mode for the container. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>trackIndices</em>&nbsp;</td><td>The index tracking policy.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that unlike the standard vector constructor, you can't specify an initial value here. The container will be initialized with 0's.</p>
<p>By default, a <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> will own its elements. To avoid this, pass <code><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8ad7d4cf2303700f0966e4140f236c4bf1" title="this data object is a view, it does not own its elmts">SG::VIEW_ELEMENTS</a></code> for <em>ownPolicy</em>. </p>

</div>
</div>
<a class="anchor" id="a507c03514b600a8808c0d50e5f2292ec"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::DataVector" ref="a507c03514b600a8808c0d50e5f2292ec" args="(const DataVector &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::<a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>The container from which to copy.</td></tr>
  </table>
  </dd>
</dl>
<p>This is a `shallow' copy; the new container will not own its elements. </p>

</div>
</div>
<a class="anchor" id="af9d46e1bf3b98f7910fcde5ad4dc7b7a"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::DataVector" ref="af9d46e1bf3b98f7910fcde5ad4dc7b7a" args="(InputIterator first, InputIterator last, SG::OwnershipPolicy ownPolicy=SG::VIEW_ELEMENTS, SG::IndexTrackingPolicy trackIndices=SG::DEFAULT_TRACK_INDICES, SG::IAuxStore *store=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::<a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a> </td>
          <td>(</td>
          <td class="paramtype">InputIterator&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">SG::OwnershipPolicy</a>&nbsp;</td>
          <td class="paramname"> <em>ownPolicy</em> = <code>SG::VIEW_ELEMENTS</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d59/namespaceSG.html#a9f3d699f65390b7f8baf54d9cd634573">SG::IndexTrackingPolicy</a>&nbsp;</td>
          <td class="paramname"> <em>trackIndices</em> = <code>SG::DEFAULT_TRACK_INDICES</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d05/classSG_1_1IAuxStore.html">SG::IAuxStore</a> *&nbsp;</td>
          <td class="paramname"> <em>store</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor from iterators. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>The start of the range to put in the new container. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>last</em>&nbsp;</td><td>The end of the range to put in the new container. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ownPolicy</em>&nbsp;</td><td>The ownership mode for the container. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>trackIndices</em>&nbsp;</td><td>The index tracking policy. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>store</em>&nbsp;</td><td>An associated auxiliary data store.</td></tr>
  </table>
  </dd>
</dl>
<p>By default, a <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> will own its elements (and take ownership of the pointers passed to this constructor). To avoid this, pass <code><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8ad7d4cf2303700f0966e4140f236c4bf1" title="this data object is a view, it does not own its elmts">SG::VIEW_ELEMENTS</a></code> for <em>ownPolicy</em>. </p>

</div>
</div>
<a class="anchor" id="ab824ffa2d0adf0efec55d86c236e069c"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::~DataVector" ref="ab824ffa2d0adf0efec55d86c236e069c" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::~<a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. </p>
<p>If this container owns its elements, the contained elements will be deleted as well. Before doing this, the destructor will scan for duplicate pointers (takes <img class="formulaInl" alt="$n \log n$" src="../../form_1.png"/> time); duplicates are only destroyed once. Duplicates should, however, be considered an error; don't rely on this behavior. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="abbf0f556cf535ba01907867cfe6ddca8"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::assign" ref="abbf0f556cf535ba01907867cfe6ddca8" args="(InputIterator first, InputIterator last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">InputIterator&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assign from iterators. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>The start of the range to put in the container. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>last</em>&nbsp;</td><td>The end of the range to put in the container.</td></tr>
  </table>
  </dd>
</dl>
<p>Any existing owned elements will be released. The <code>DataVector's</code> ownership policy determines whether it will take ownership of the new elements. </p>

</div>
</div>
<a class="anchor" id="a3744541d5aee9f68ea81cbe58e474fec"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::at" ref="a3744541d5aee9f68ea81cbe58e474fec" args="(size_type n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d7/d05/classDataModel__detail_1_1ElementProxy.html">ElementProxy</a> <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access an element, as an lvalue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>Array index to access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Proxy to the element at <em>n</em>.</dd></dl>
<p>Will raise <code>std::out_of_range</code> if the index is out-of-bounds. Note that we return a proxy object rather than a reference; the proxy will handle deleting an owned element if it's assigned to. </p>

</div>
</div>
<a class="anchor" id="aa8ea77da44d88c17ebb3ab9c3f6d78e1"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::at" ref="aa8ea77da44d88c17ebb3ab9c3f6d78e1" args="(size_type n) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d1/def/classT.html">T</a>* <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access an element, as an rvalue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>Array index to access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The element at <em>n</em>.</dd></dl>
<p>Will raise <code>std::out_of_range</code> if the index is out-of-bounds. Note that we return a <code>const</code> <code>T*</code> rather than a reference. </p>

</div>
</div>
<a class="anchor" id="ae40b46f3b01ddc62478a0d98663325f0"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::auxbase" ref="ae40b46f3b01ddc62478a0d98663325f0" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html">SG::AuxVectorBase</a>&amp; <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::auxbase </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert to <code>AuxVectorBase</code>. </p>
<p>Needed to get  AuxVectorBase from a <code><a class="el" href="../../de/db1/classConstDataVector.html" title="DataVector adapter that acts like it holds const pointers.">ConstDataVector</a></code>. Present in <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> as well for consistency. </p>

</div>
</div>
<a class="anchor" id="a0ded16015ae169fe929ab34eda1c079a"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::back" ref="a0ded16015ae169fe929ab34eda1c079a" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d7/d05/classDataModel__detail_1_1ElementProxy.html">ElementProxy</a> <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access the last element in the collection as an lvalue. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Proxy to the last element in the collection.</dd></dl>
<p>No checking is done to ensure that the container is not empty. Note that we return a proxy object rather than a reference; the proxy will handle deleting an owned element if it's assigned to. </p>

</div>
</div>
<a class="anchor" id="a94471e13ddf6ee1c7808d032b60d40a5"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::back" ref="a94471e13ddf6ee1c7808d032b60d40a5" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d1/def/classT.html">T</a>* <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access the last element in the collection as an rvalue. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The last element in the collection.</dd></dl>
<p>No checking is done to ensure that the container is not empty. Note that we return a <code>const</code> <code>T*</code> rather than a reference. </p>

</div>
</div>
<a class="anchor" id="a54a54329e84fd2c5fcc780fc2a43ead6"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::baseOffset" ref="a54a54329e84fd2c5fcc780fc2a43ead6" args="(const std::type_info &amp;ti)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::baseOffset </td>
          <td>(</td>
          <td class="paramtype">const std::type_info &amp;&nbsp;</td>
          <td class="paramname"> <em>ti</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the offset of a base <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> class. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ti</em>&nbsp;</td><td><code>std::type_info</code> of the desired class.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>ti</code> represents a <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> base class of this one, then return the offset of that base class. Otherwise, return -1.</p>
<p>This function is here due to limitations of root 6, which can't calculate these offsets correctly from the dictionary if virtual derivation is used. </p>

</div>
</div>
<a class="anchor" id="a162843eb42a30aa266bb3053af9e7abb"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::baseOffset1" ref="a162843eb42a30aa266bb3053af9e7abb" args="(const char *p, const DataVector &amp;dv, const std::type_info &amp;ti)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::baseOffset1 </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>dv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::type_info &amp;&nbsp;</td>
          <td class="paramname"> <em>ti</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper for <code>baseOffset</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>Pointer to the start of the top-level object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dv</em>&nbsp;</td><td>Reference to the <a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a> object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ti</em>&nbsp;</td><td><code>std::type_info</code> of the desired class.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>ti</code> represents a <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> base class of this one, then return the offset of that base class. Otherwise, return -1. </p>

</div>
</div>
<a class="anchor" id="a016e07a7a7a825f01214a03d136381cb"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::begin" ref="a016e07a7a7a825f01214a03d136381cb" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a> <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return an <code>iterator</code> pointing at the beginning of the collection. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>An <code>iterator</code>.</dd></dl>
<p>Note that dereferencing the iterator will yield a proxy rather than a reference; the proxy will handle deleting an owned element if it's assigned to. </p>

</div>
</div>
<a class="anchor" id="a31fc0611d6e14e7dc95a7444b5389786"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::begin" ref="a31fc0611d6e14e7dc95a7444b5389786" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#ad14d8fa936e56241eea1626b464c3b8c">const_iterator</a> <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a <code>const_iterator</code> pointing at the beginning of the collection. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="../../d4/dc4/structA.html">A</a> <code>const_iterator</code>.</dd></dl>
<p>Note that dereferencing the iterator will yield a <code>const</code> <code>T*</code> rather than a reference. </p>

</div>
</div>
<a class="anchor" id="a236a9f58b14de59ef54c5107dfcff5dc"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::capacity_v" ref="a236a9f58b14de59ef54c5107dfcff5dc" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual size_type <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::capacity_v </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the total number of elements that the collection can hold before needing to allocate more memory. </p>
<p>This version is virtual, to be callable from the AuxData base class. </p>

<p>Reimplemented from <a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html#ad2ff11b7c4c2099a845990132dd76e4f">SG::AuxVectorBase</a>.</p>

</div>
</div>
<a class="anchor" id="a865ba4448ebb8fcb61ed2ebe69a900fc"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::cbegin" ref="a865ba4448ebb8fcb61ed2ebe69a900fc" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#ad14d8fa936e56241eea1626b464c3b8c">const_iterator</a> <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a <code>const_iterator</code> pointing at the beginning of the collection. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="../../d4/dc4/structA.html">A</a> <code>const_iterator</code>.</dd></dl>
<p>Note that dereferencing the iterator will yield a <code>const</code> <code>T*</code> rather than a reference. </p>

</div>
</div>
<a class="anchor" id="a87f60ec41043c1ef5dfb5b50dd4b08d8"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::cend" ref="a87f60ec41043c1ef5dfb5b50dd4b08d8" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#ad14d8fa936e56241eea1626b464c3b8c">const_iterator</a> <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a <code>const_iterator</code> pointing past the end of the collection. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="../../d4/dc4/structA.html">A</a> <code>const_iterator</code>.</dd></dl>
<p>Note that dereferencing the iterator will yield a <code>const</code> <code>T*</code> rather than a reference. </p>

</div>
</div>
<a class="anchor" id="aa047639d69932b1f94bf7016a6a2c4b7"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::clear" ref="aa047639d69932b1f94bf7016a6a2c4b7" args="(SG::OwnershipPolicy ownPolicy, SG::IndexTrackingPolicy trackIndices)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">SG::OwnershipPolicy</a>&nbsp;</td>
          <td class="paramname"> <em>ownPolicy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d59/namespaceSG.html#a9f3d699f65390b7f8baf54d9cd634573">SG::IndexTrackingPolicy</a>&nbsp;</td>
          <td class="paramname"> <em>trackIndices</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Erase all the elements in the collection, and reset the ownership mode. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ownPolicy</em>&nbsp;</td><td>The new ownership policy of the container. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>trackIndices</em>&nbsp;</td><td>The index tracking policy.</td></tr>
  </table>
  </dd>
</dl>
<p>If the container owns its elements, then the removed elements will be deleted. Any duplicates will be removed in this process, but don't rely on this. </p>

</div>
</div>
<a class="anchor" id="aab8e11d10424034b008a627825e8093d"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::clear" ref="aab8e11d10424034b008a627825e8093d" args="(SG::OwnershipPolicy ownPolicy)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">SG::OwnershipPolicy</a>&nbsp;</td>
          <td class="paramname"> <em>ownPolicy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Erase all the elements in the collection, and reset the ownership mode. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ownPolicy</em>&nbsp;</td><td>The new ownership policy of the container.</td></tr>
  </table>
  </dd>
</dl>
<p>If the container owns its elements, then the removed elements will be deleted. Any duplicates will be removed in this process, but don't rely on this. </p>

</div>
</div>
<a class="anchor" id="a3292a55621ae0171766b2f8e9d067436"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::clear" ref="a3292a55621ae0171766b2f8e9d067436" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Erase all the elements in the collection. </p>
<p>If the container owns its elements, then the removed elements will be deleted. Any duplicates will be removed in this process, but don't rely on this. </p>

</div>
</div>
<a class="anchor" id="a74c23e2aba33eb2ce6817c563b6c8917"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::clearMostDerived" ref="a74c23e2aba33eb2ce6817c563b6c8917" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::clearMostDerived </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clear <code>m_isMostDerived</code> for this instance and for all bases. </p>
<p>Called from the constructor after setting <code>m_isMostDerived</code>. </p>

</div>
</div>
<a class="anchor" id="a1d1064401af7c90703d0a2f79136e0ec"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::crbegin" ref="a1d1064401af7c90703d0a2f79136e0ec" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a61d77f0c504d473f85376ddce8bd2163">const_reverse_iterator</a> <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a <code>const_reverse_iterator</code> pointing past the end of the collection. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="../../d4/dc4/structA.html">A</a> <code>const_reverse_iterator</code>.</dd></dl>
<p>Note that dereferencing the iterator will yield a <code>const</code> <code>T*</code> rather than a reference. </p>

</div>
</div>
<a class="anchor" id="afed788d8db665532545478186925b3a6"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::crend" ref="afed788d8db665532545478186925b3a6" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a61d77f0c504d473f85376ddce8bd2163">const_reverse_iterator</a> <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a <code>const_reverse_iterator</code> pointing at the beginning of the collection. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="../../d4/dc4/structA.html">A</a> <code>const_reverse_iterator</code>.</dd></dl>
<p>Note that dereferencing the iterator will yield a <code>const</code> <code>T*</code> rather than a reference. </p>

</div>
</div>
<a class="anchor" id="a31431efcf2f87c3775b7c7c5e5e7081d"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::do_cast" ref="a31431efcf2f87c3775b7c7c5e5e7081d" args="(const typename PtrVector::value_type p)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="../../d1/def/classT.html">T</a>* <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::do_cast </td>
          <td>(</td>
          <td class="paramtype">const typename PtrVector::value_type&nbsp;</td>
          <td class="paramname"> <em>p</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper to shorten calls to <code><a class="el" href="../../de/d59/structDataModel__detail_1_1DVLCast.html" title="casting operations for DataVector/DataList. ">DataModel_detail::DVLCast</a></code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>The value to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value as a <code>const</code> <code>T*</code>.</dd></dl>
<p>This is a no-op for the base class. </p>

</div>
</div>
<a class="anchor" id="af01f7224a0d87d4c8d10678a80b39d27"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::dvlinfo" ref="af01f7224a0d87d4c8d10678a80b39d27" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="../../da/d8a/classDataModel__detail_1_1DVLInfoBase.html">DataModel_detail::DVLInfoBase</a>&amp; <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::dvlinfo </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the DV/DL info struct for this class. </p>
<p>This can be used to make sure that it's instantiated. </p>

</div>
</div>
<a class="anchor" id="abd040d558ec4796705c57c66acfeacd3"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::dvlinfo_v" ref="abd040d558ec4796705c57c66acfeacd3" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="../../da/d8a/classDataModel__detail_1_1DVLInfoBase.html">DataModel_detail::DVLInfoBase</a>&amp; <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::dvlinfo_v </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the DV/DL info struct for this class. </p>
<p>This can be used to make sure that it's instantiated. </p>

</div>
</div>
<a class="anchor" id="a728e46d92c5d2d0cdce9e2ce51bab6d1"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::emplace" ref="a728e46d92c5d2d0cdce9e2ce51bab6d1" args="(iterator position, value_type pElem)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a> <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d1/def/classT.html">value_type</a>&nbsp;</td>
          <td class="paramname"> <em>pElem</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a new element to the collection. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>position</em>&nbsp;</td><td>Iterator before which the element will be added. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pElem</em>&nbsp;</td><td>The element to add to the collection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An iterator that points to the inserted data.</dd></dl>
<p>The container's ownership policy will determine if it takes ownership of the new element.</p>
<p>Note: this method may only be called using the most derived <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> in the hierarchy.</p>
<p>For <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code>, this is just the same as <code>insert</code>. It's included just for interface compatibility with `stdvector`. </p>

</div>
</div>
<a class="anchor" id="a54e962bbda1ab83d0b892a0be604c0e9"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::emplace_back" ref="a54e962bbda1ab83d0b892a0be604c0e9" args="(value_type pElem)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::emplace_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/def/classT.html">value_type</a>&nbsp;</td>
          <td class="paramname"> <em>pElem</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add an element to the end of the collection. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pElem</em>&nbsp;</td><td>The element to add to the collection.</td></tr>
  </table>
  </dd>
</dl>
<p>The container's ownership policy will determine if it takes ownership of the new element.</p>
<p>Note: this method may only be called using the most derived <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> in the hierarchy.</p>
<p>For <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code>, this is just the same as <code>push_back</code>. It's included just for interface compatibility with `stdvector`. </p>

</div>
</div>
<a class="anchor" id="a084ec53b556ed4283f598bdd33398943"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::end" ref="a084ec53b556ed4283f598bdd33398943" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a> <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return an <code>iterator</code> pointing past the end of the collection. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>An <code>iterator</code>.</dd></dl>
<p>Note that dereferencing the iterator will yield a proxy rather than a reference; the proxy will handle deleting an owned element if it's assigned to. </p>

</div>
</div>
<a class="anchor" id="a4c31b486a1b577d581bcded32f8c0d4a"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::end" ref="a4c31b486a1b577d581bcded32f8c0d4a" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#ad14d8fa936e56241eea1626b464c3b8c">const_iterator</a> <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a <code>const_iterator</code> pointing past the end of the collection. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="../../d4/dc4/structA.html">A</a> <code>const_iterator</code>.</dd></dl>
<p>Note that dereferencing the iterator will yield a <code>const</code> <code>T*</code> rather than a reference. </p>

</div>
</div>
<a class="anchor" id="ae16b6a23080b04529edbcaede4c3b121"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::erase" ref="ae16b6a23080b04529edbcaede4c3b121" args="(iterator first, iterator last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a> <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove a range of elements. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>Iterator pointing to the first element to be removed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>last</em>&nbsp;</td><td>Iterator pointing one past the last element to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An iterator pointing to the element pointed to by <em>last</em> prior to erasing (or <code><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a084ec53b556ed4283f598bdd33398943" title="Return an iterator pointing past the end of the collection.">end()</a></code>).</dd></dl>
<p>If the container owns its elements, then the removed elements will be deleted. Any duplicates will be removed in this process, but don't rely on this. </p>

</div>
</div>
<a class="anchor" id="a5e41132c55010e688115f1ed6cc0edab"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::erase" ref="a5e41132c55010e688115f1ed6cc0edab" args="(iterator position)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a> <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove element at a given position. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>position</em>&nbsp;</td><td>Iterator pointing to the element to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An iterator pointing to the next element (or <code><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a084ec53b556ed4283f598bdd33398943" title="Return an iterator pointing past the end of the collection.">end()</a></code>).</dd></dl>
<p>If the container owns its elements, then the pointed-to element will be deleted. </p>

</div>
</div>
<a class="anchor" id="a9b1da673ca3bba86c926acd40f986e6a"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::erase_base" ref="a9b1da673ca3bba86c926acd40f986e6a" args="(typename PtrVector::iterator first, typename PtrVector::iterator last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PtrVector::iterator <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::erase_base </td>
          <td>(</td>
          <td class="paramtype">typename PtrVector::iterator&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename PtrVector::iterator&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper for <code><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a5e41132c55010e688115f1ed6cc0edab" title="Remove element at a given position.">erase()</a></code>. Remove a range of elements. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>Iterator pointing to the first element to be removed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>last</em>&nbsp;</td><td>Iterator pointing one past the last element to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An iterator pointing to the element pointed to by <em>last</em> prior to erasing (or <code><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a084ec53b556ed4283f598bdd33398943" title="Return an iterator pointing past the end of the collection.">end()</a></code>).</dd></dl>
<p>This function factors out common code between <code><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a5e41132c55010e688115f1ed6cc0edab" title="Remove element at a given position.">erase()</a></code> in the base and derived <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> classes. It deals with the <code>std::vector</code> iterators directly. </p>

</div>
</div>
<a class="anchor" id="a0208dd537831fad033198a40aa0fcaf3"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::erase_base" ref="a0208dd537831fad033198a40aa0fcaf3" args="(typename PtrVector::iterator position)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PtrVector::iterator <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::erase_base </td>
          <td>(</td>
          <td class="paramtype">typename PtrVector::iterator&nbsp;</td>
          <td class="paramname"> <em>position</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper for <code><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a5e41132c55010e688115f1ed6cc0edab" title="Remove element at a given position.">erase()</a></code>. Remove element at a given position. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>position</em>&nbsp;</td><td>Iterator pointing to the element to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An iterator pointing to the next element (or <code><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a084ec53b556ed4283f598bdd33398943" title="Return an iterator pointing past the end of the collection.">end()</a></code>).</dd></dl>
<p>This function factors out common code between <code><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a5e41132c55010e688115f1ed6cc0edab" title="Remove element at a given position.">erase()</a></code> in the base and derived <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> classes. It deals with the <code>std::vector</code> iterators directly. </p>

</div>
</div>
<a class="anchor" id="a12489c7ded0c123b55d5b4d8ff5386ae"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::front" ref="a12489c7ded0c123b55d5b4d8ff5386ae" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d7/d05/classDataModel__detail_1_1ElementProxy.html">ElementProxy</a> <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access the first element in the collection as an lvalue. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Proxy to the first element in the collection.</dd></dl>
<p>No checking is done to ensure that the container is not empty. Note that we return a proxy object rather than a reference; the proxy will handle deleting an owned element if it's assigned to. </p>

</div>
</div>
<a class="anchor" id="a8b4e4253e25498a4aed16cf5fd19176b"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::front" ref="a8b4e4253e25498a4aed16cf5fd19176b" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d1/def/classT.html">T</a>* <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access the first element in the collection as an rvalue. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The first element in the collection.</dd></dl>
<p>No checking is done to ensure that the container is not empty. Note that we return a <code>const</code> <code>T*</code> rather than a reference. </p>

</div>
</div>
<a class="anchor" id="a4c53dc5625a660a87187d033194dad02"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::get" ref="a4c53dc5625a660a87187d033194dad02" args="(size_type n) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d1/def/classT.html">T</a>* <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::get </td>
          <td>(</td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access an element, as an rvalue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>Array index to access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The element at <em>n</em>.</dd></dl>
<p>This is a synonym for operator[] const, to be used when calling from root (where we can't readily call just the const version of a method). </p>

</div>
</div>
<a class="anchor" id="ae2dd1670bab9846009d870a77d04d582"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::insert" ref="ae2dd1670bab9846009d870a77d04d582" args="(iterator position, InputIterator first, InputIterator last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a group of new elements to the collection. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>position</em>&nbsp;</td><td>Iterator before which the element will be added. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>The start of the range to put in the container. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>last</em>&nbsp;</td><td>The end of the range to put in the container.</td></tr>
  </table>
  </dd>
</dl>
<p>The container's ownership policy will determine if it takes ownership of the new element.</p>
<p>Note: this method may only be called using the most derived <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> in the hierarchy. </p>

</div>
</div>
<a class="anchor" id="a250b3c680672ec28ec9938239bc9328a"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::insert" ref="a250b3c680672ec28ec9938239bc9328a" args="(iterator position, value_type pElem)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a> <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d1/def/classT.html">value_type</a>&nbsp;</td>
          <td class="paramname"> <em>pElem</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a new element to the collection. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>position</em>&nbsp;</td><td>Iterator before which the element will be added. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pElem</em>&nbsp;</td><td>The element to add to the collection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An iterator that points to the inserted data.</dd></dl>
<p>The container's ownership policy will determine if it takes ownership of the new element.</p>
<p>Note: this method may only be called using the most derived <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> in the hierarchy. </p>

</div>
</div>
<a class="anchor" id="a1a1ee3a77f7504b7a8f3d475f7cdd003"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::iter_swap" ref="a1a1ee3a77f7504b7a8f3d475f7cdd003" args="(iterator a, iterator b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::iter_swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swap the referents of two <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> iterators. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>The first iterator for the swap. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>The second iterator for the swap/ </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad7e3dcf0a187de3ad9091d75e4e27d15"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::operator=" ref="ad7e3dcf0a187de3ad9091d75e4e27d15" args="(const DataVector &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&amp; <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assignment operator. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>The <a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a> from which to assign. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>This object.</dd></dl>
<p>This is a `shallow' copy; after the completion of this, the <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> will not own its elements. Any elements it owned prior to this call will be released.</p>
<p>Note: this method may only be called using the most derived <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> in the hierarchy. </p>

</div>
</div>
<a class="anchor" id="a9dfa8e78005f6ba076fa4fd8f89905cc"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::operator[]" ref="a9dfa8e78005f6ba076fa4fd8f89905cc" args="(size_type n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d7/d05/classDataModel__detail_1_1ElementProxy.html">ElementProxy</a> <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access an element, as an lvalue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>Array index to access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Proxy to the element at <em>n</em>.</dd></dl>
<p>No bounds checking is done. Note that we return a proxy object rather than a reference; the proxy will handle deleting an owned element if it's assigned to. </p>

</div>
</div>
<a class="anchor" id="ad3eba15a4069718475af38248a3d0d2e"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::operator[]" ref="ad3eba15a4069718475af38248a3d0d2e" args="(size_type n) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d1/def/classT.html">T</a>* <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access an element, as an rvalue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>Array index to access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The element at <em>n</em>.</dd></dl>
<p>No bounds checking is done. Note that we return a <code>const</code> <code>T*</code> rather than a reference. </p>

</div>
</div>
<a class="anchor" id="a5435f79346220ac80c41bdc3adf9803c"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::pop_back" ref="a5435f79346220ac80c41bdc3adf9803c" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove the last element from the collection. </p>
<p>If the container owns its elements, then the removed element will be deleted. </p>

</div>
</div>
<a class="anchor" id="aaa71855a58852e9c5ffa61a555ed581f"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::push_back" ref="aaa71855a58852e9c5ffa61a555ed581f" args="(value_type pElem)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/def/classT.html">value_type</a>&nbsp;</td>
          <td class="paramname"> <em>pElem</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add an element to the end of the collection. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pElem</em>&nbsp;</td><td>The element to add to the collection.</td></tr>
  </table>
  </dd>
</dl>
<p>The container's ownership policy will determine if it takes ownership of the new element.</p>
<p>Note: this method may only be called using the most derived <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> in the hierarchy. </p>

</div>
</div>
<a class="anchor" id="a2b47037798be81db90016ad9584899e9"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::rbegin" ref="a2b47037798be81db90016ad9584899e9" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a3551d2e1bdbe02ade11f731cfb976f4f">reverse_iterator</a> <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a <code>reverse_iterator</code> pointing past the end of the collection. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="../../d4/dc4/structA.html">A</a> <code>reverse_iterator</code>.</dd></dl>
<p>Note that dereferencing the iterator will yield a proxy rather than a reference; the proxy will handle deleting an owned element if it's assigned to. </p>

</div>
</div>
<a class="anchor" id="a6225bfe9a292ddead10cec769022a2ce"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::rbegin" ref="a6225bfe9a292ddead10cec769022a2ce" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a61d77f0c504d473f85376ddce8bd2163">const_reverse_iterator</a> <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a <code>const_reverse_iterator</code> pointing past the end of the collection. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="../../d4/dc4/structA.html">A</a> <code>const_reverse_iterator</code>.</dd></dl>
<p>Note that dereferencing the iterator will yield a <code>const</code> <code>T*</code> rather than a reference. </p>

</div>
</div>
<a class="anchor" id="a3346ad4e2fe7f416b8c1b7f62a838076"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::rend" ref="a3346ad4e2fe7f416b8c1b7f62a838076" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a3551d2e1bdbe02ade11f731cfb976f4f">reverse_iterator</a> <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a <code>reverse_iterator</code> pointing at the beginning of the collection. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="../../d4/dc4/structA.html">A</a> <code>reverse_iterator</code>.</dd></dl>
<p>Note that dereferencing the iterator will yield a proxy rather than a reference; the proxy will handle deleting an owned element if it's assigned to. </p>

</div>
</div>
<a class="anchor" id="acfa741d2f764cf729035ce630c542d43"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::rend" ref="acfa741d2f764cf729035ce630c542d43" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a61d77f0c504d473f85376ddce8bd2163">const_reverse_iterator</a> <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a <code>const_reverse_iterator</code> pointing at the beginning of the collection. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="../../d4/dc4/structA.html">A</a> <code>const_reverse_iterator</code>.</dd></dl>
<p>Note that dereferencing the iterator will yield a <code>const</code> <code>T*</code> rather than a reference. </p>

</div>
</div>
<a class="anchor" id="ad057592307e2749e25a3970ed6426b17"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::reserve" ref="ad057592307e2749e25a3970ed6426b17" args="(size_type n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attempt to preallocate enough memory for a specified number of elements. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>Number of elements required. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a43652bda389a83f437300f0f1de68e05"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::resize" ref="a43652bda389a83f437300f0f1de68e05" args="(size_type sz)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>sz</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resizes the collection to the specified number of elements. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sz</em>&nbsp;</td><td>The new size of the collection.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that this function differs from the standard in that it does not allow specifying the value of any inserted elements. They will always be 0.</p>
<p>If the container is shrunk, elements will be deleted as with <code><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a5e41132c55010e688115f1ed6cc0edab" title="Remove element at a given position.">erase()</a></code>. </p>

</div>
</div>
<a class="anchor" id="ab4de50491cb3c3dc239fd4d52c7151d7"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::resortAux" ref="ab4de50491cb3c3dc239fd4d52c7151d7" args="(iterator beg, iterator end)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::resortAux </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reset indices / reorder aux data after elements have been permuted. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>beg</em>&nbsp;</td><td>Start of the range of elements to process. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>End of the range of elements to process.</td></tr>
  </table>
  </dd>
</dl>
<p>Call this after some operation that has permuted the elements in the container (such as sort). The index information in the elements will be used to permute all auxiliary data in the same way. Finally, all the indices will be reset in the correct order. </p>

</div>
</div>
<a class="anchor" id="abfc9461741ecfa4b568e91b3e79abe1d"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::setMostDerived" ref="abfc9461741ecfa4b568e91b3e79abe1d" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::setMostDerived </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set <code>m_isMostDerived</code> for this instance and clear it for all bases. </p>
<p>Called from <code>testInsert</code> if the test fails. The flag may not have been set if this container was made via copy construction, so set it appropriately now so we can test again. </p>

</div>
</div>
<a class="anchor" id="a258f5c8833dc8e1d659960784c468f25"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::size_v" ref="a258f5c8833dc8e1d659960784c468f25" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual size_type <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::size_v </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the number of elements in the collection. </p>
<p>This version is virtual, to be callable from the AuxData base class. </p>

<p>Reimplemented from <a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html#acb5fc1c8f606bd9fe52610b48ebb4c34">SG::AuxVectorBase</a>.</p>

</div>
</div>
<a class="anchor" id="a42b5a010f599505eccc8858c94d5b0c1"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::sort" ref="a42b5a010f599505eccc8858c94d5b0c1" args="(COMPARE comp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;class COMPARE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::sort </td>
          <td>(</td>
          <td class="paramtype">COMPARE&nbsp;</td>
          <td class="paramname"> <em>comp</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sort the container with a user-specified comparison operator. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>comp</em>&nbsp;</td><td>Functional to compare two values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab3b8b5064b52bcb7921b973abad09a8f"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::sort" ref="ab3b8b5064b52bcb7921b973abad09a8f" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::sort </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sort the container. </p>
<p>This just sorts by pointer value, so it's probably not very useful. </p>

</div>
</div>
<a class="anchor" id="adc7f275d2bc73e00c010828a4a5224f9"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::stdcont" ref="adc7f275d2bc73e00c010828a4a5224f9" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a9037cb597ab293dcf843bd9f5d88699f">PtrVector</a>&amp; <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::stdcont </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the underlying <code>std::vector</code> of the container. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Reference to the <code>std::vector</code> actually holding the collection.</dd></dl>
<p>Note that <code><a class="el" href="../../d0/d4d/classDataVector.html#a0e2e64a35d842a206c96ccfec265df21" title="Return the underlying std::vector of the container.">DataVector&lt;T&gt;::stdcont</a></code> does not necessarily return a <code>std::vector&lt;T*&gt;</code> if <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> inheritance is being used. </p>

</div>
</div>
<a class="anchor" id="ace0665d0ab6fd551aeee44eca9a29a40"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::swap" ref="ace0665d0ab6fd551aeee44eca9a29a40" args="(DataVector &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swap this collection with another. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>The collection with which to swap.</td></tr>
  </table>
  </dd>
</dl>
<p>Ownership is swapped along with the collection content.</p>
<p>Note: this method may only be called using the most-derived <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> in the hierarchy. The <em>rhs</em> must also be referenced using the most-derived <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code>. </p>

</div>
</div>
<a class="anchor" id="a88d41d8c4ab49f649b4fd20dbe648abd"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::swapElement" ref="a88d41d8c4ab49f649b4fd20dbe648abd" args="(iterator pos, value_type newElem, reference oldElem)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::swapElement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d1/def/classT.html">value_type</a>&nbsp;</td>
          <td class="paramname"> <em>newElem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d1/def/classT.html">reference</a>&nbsp;</td>
          <td class="paramname"> <em>oldElem</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swap one element out of the container. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>The element in the container to swap. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newElem</em>&nbsp;</td><td>New element to put in the container. May be 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>oldElem</em>&nbsp;</td><td>Reference to receive the element removed from the container.</td></tr>
  </table>
  </dd>
</dl>
<p>Reference <em>oldElem</em> is initialized with element <em>pos</em> of the collection (no bounds checking). Then element <em>index</em> is set to <code>newElem</code>. If the collection owns its elements, then it will take ownership of <em>newElem</em> and release (without deleting) the element returned through <em>oldElem</em>.</p>
<p>Note: this method may only be called using the most derived <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> in the hierarchy. </p>

</div>
</div>
<a class="anchor" id="abff69b3413c3e0a912f9d5589f4257e9"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::swapElement" ref="abff69b3413c3e0a912f9d5589f4257e9" args="(size_type index, value_type newElem, reference oldElem)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::swapElement </td>
          <td>(</td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d1/def/classT.html">value_type</a>&nbsp;</td>
          <td class="paramname"> <em>newElem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d1/def/classT.html">reference</a>&nbsp;</td>
          <td class="paramname"> <em>oldElem</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swap one element out of the container. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>Index of the element in the container to swap. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newElem</em>&nbsp;</td><td>New element to put in the container. May be 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>oldElem</em>&nbsp;</td><td>Reference to receive the element removed from the container.</td></tr>
  </table>
  </dd>
</dl>
<p>Reference <em>oldElem</em> is initialized with element <em>index</em> of the collection (no bounds checking). Then element <em>index</em> is set to <code>newElem</code>. If the collection owns its elements, then it will take ownership of <em>newElem</em> and release (without deleting) the element returned through <em>oldElem</em>.</p>
<p>Note: this method may only be called using the most derived <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> in the hierarchy. </p>

</div>
</div>
<a class="anchor" id="a191f1812d1e0bfab56d0ecb4e1902138"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::testInsert" ref="a191f1812d1e0bfab56d0ecb4e1902138" args="(const char *op)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::testInsert </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>op</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if we can insert; raise an exception if not. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>op</em>&nbsp;</td><td>Description of the attempted operation.</td></tr>
  </table>
  </dd>
</dl>
<p>In order to maintain type-safety, we can only allow insertions using the most-derived instance of <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code>. This checks this by testing the <code>m_isMostDerived</code>, which is set by the constructors to true only for the most-derived instance. If the test fails, we call to potentially out-of-line code to continue. </p>

</div>
</div>
<a class="anchor" id="a64c19881e3c41eb3a9ebbb24627ba7bf"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::testInsertOol" ref="a64c19881e3c41eb3a9ebbb24627ba7bf" args="(const char *op)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::testInsertOol </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>op</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if we can insert; raise an exception if not. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>op</em>&nbsp;</td><td>Description of the attempted operation.</td></tr>
  </table>
  </dd>
</dl>
<p>This continues the test of <code>testInsert</code>. There is one case where <code>m_isMostDerived</code> may not be set correctly. If this container was made via copy construction, then all the <code>m_isMostDerived</code> flags will be false. So we call <code>setMostDerived</code> to set the flags correctly and test again. If the test fails again, then we raise an exception. </p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="aa9b859c5e4d9bb75d44cba2e72690238"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::has_virtual" ref="aa9b859c5e4d9bb75d44cba2e72690238" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::<a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#aa9b859c5e4d9bb75d44cba2e72690238">has_virtual</a> = false<code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is true for any <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> class if we need to use virtual derivation to get to the base <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> class. Since this <em>is</em> the base <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> class, set this unconditionally to <code>false</code>. </p>

</div>
</div>
<a class="anchor" id="a205453f4c7420d058d1179766b292c87"></a><!-- doxytag: member="DataVector&lt; T, DataModel_detail::NoBase &gt;::m_ownPolicy" ref="a205453f4c7420d058d1179766b292c87" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">SG::OwnershipPolicy</a> <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a>, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::<a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a205453f4c7420d058d1179766b292c87">m_ownPolicy</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The ownership policy of this container --- either SG::OWNS_ELEMENTS or <a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8ad7d4cf2303700f0966e4140f236c4bf1" title="this data object is a view, it does not own its elmts">SG::VIEW_ELEMENTS</a>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.29/AthContainers/AthContainers/<a class="el" href="../../d7/dd6/DataVector_8h_source.html">DataVector.h</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 15 Apr 2017 for RootCore Packages by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
