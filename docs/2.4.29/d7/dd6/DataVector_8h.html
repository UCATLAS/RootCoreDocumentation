<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>RootCore Packages: /cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.29/AthContainers/AthContainers/DataVector.h File Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="../../index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="../../search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="../../files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="../../globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.29/AthContainers/AthContainers/DataVector.h File Reference</h1>
<p>An STL vector of pointers that by default owns its pointed-to elements.  
<a href="#_details">More...</a></p>
<code>#include &quot;<a class="el" href="../../d4/d03/exceptions_8h_source.html">AthContainers/exceptions.h</a>&quot;</code><br/>
<code>#include &quot;AthContainers/OwnershipPolicy.h&quot;</code><br/>
<code>#include &quot;<a class="el" href="../../d0/da5/IndexTrackingPolicy_8h_source.html">AthContainers/IndexTrackingPolicy.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="../../d7/d18/AuxVectorBase_8h_source.html">AthContainers/AuxVectorBase.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="../../d7/d92/DVLNoBase_8h_source.html">AthContainers/tools/DVLNoBase.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="../../d3/d2e/DVLInfo_8h_source.html">AthContainers/tools/DVLInfo.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="../../df/d5c/DVLCast_8h_source.html">AthContainers/tools/DVLCast.h</a>&quot;</code><br/>
<code>#include &quot;AthContainers/tools/DVLIterator.h&quot;</code><br/>
<code>#include &quot;<a class="el" href="../../d6/ddb/DVL__iter__swap_8h_source.html">AthContainers/tools/DVL_iter_swap.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="../../d0/d7a/DVL__algorithms_8h_source.html">AthContainers/tools/DVL_algorithms.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="../../db/d26/ElementProxy_8h_source.html">AthContainers/tools/ElementProxy.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="../../d5/dfa/IsMostDerivedFlag_8h_source.html">AthContainers/tools/IsMostDerivedFlag.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="../../d3/dec/selection__ns_8h_source.html">AthLinks/tools/selection_ns.h</a>&quot;</code><br/>
<code>#include &lt;boost/static_assert.hpp&gt;</code><br/>
<code>#include &lt;boost/type_traits.hpp&gt;</code><br/>
<code>#include &lt;boost/iterator/iterator_adaptor.hpp&gt;</code><br/>
<code>#include &lt;vector&gt;</code><br/>
<code>#include &lt;typeinfo&gt;</code><br/>
<code>#include &lt;functional&gt;</code><br/>
<code>#include &lt;iostream&gt;</code><br/>
<code>#include &lt;algorithm&gt;</code><br/>
<code>#include &lt;stdexcept&gt;</code><br/>
<code>#include &lt;iterator&gt;</code><br/>
<code>#include &quot;SGTools/BaseInfo.h&quot;</code><br/>
<code>#include &quot;AthContainers/ClassName.h&quot;</code><br/>
<code>#include &quot;<a class="el" href="../../d4/d16/DVLDataBucket_8h_source.html">AthContainers/tools/DVLDataBucket.h</a>&quot;</code><br/>
<code>#include &quot;SGTools/DataBucketTraitFwd.h&quot;</code><br/>
<code>#include &quot;<a class="el" href="../../da/de6/DataVector_8icc.html">AthContainers/DataVector.icc</a>&quot;</code><br/>

<p><a href="../../d7/dd6/DataVector_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d4c/structDataVectorBase.html">DataVectorBase&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Derivation information for <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code>.  <a href="../../dd/d4c/structDataVectorBase.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d4d/classDataVector.html">DataVector&lt; T, BASE &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Derived <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a>&lt;<a class="el" href="../../d1/def/classT.html">T</a>&gt;</code>.  <a href="../../d0/d4d/classDataVector.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html">DataVector&lt; T, DataModel_detail::NoBase &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base specialization for <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a>&lt;<a class="el" href="../../d1/def/classT.html">T</a>&gt;</code>.  <a href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d4d/classDataVector.html">DataVector&lt; T, BASE &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Derived <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a>&lt;<a class="el" href="../../d1/def/classT.html">T</a>&gt;</code>.  <a href="../../d0/d4d/classDataVector.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/de8/classClassName_3_01DataVector_3_01T_01_4_01_4.html">ClassName&lt; DataVector&lt; T &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of <code>ClassName</code> for <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code>.  <a href="../../dd/de8/classClassName_3_01DataVector_3_01T_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d25/structSG_1_1DataBucketTrait_3_01DataVector_3_01T_01_4_00_01U_01_4.html">SG::DataBucketTrait&lt; DataVector&lt; T &gt;, U &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Metafunction to find the proper <code><a class="el" href="../../d7/d54/classSG_1_1DataBucket.html">DataBucket</a></code> class for <code><a class="el" href="../../d1/def/classT.html">T</a></code>.  <a href="../../d2/d25/structSG_1_1DataBucketTrait_3_01DataVector_3_01T_01_4_00_01U_01_4.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d59/namespaceSG.html">SG</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Constructor from a payload object. </p>
<br/></td></tr>
</p>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a29fa6695c3cb02dbb0faf32c779d54"></a><!-- doxytag: member="DataVector.h::HAVE_CONSTDATAVECTOR" ref="a7a29fa6695c3cb02dbb0faf32c779d54" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>HAVE_CONSTDATAVECTOR</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dd6/DataVector_8h.html#a7ee2c7ff8209815d164658289e0981ea">DATAVECTOR_BASE</a>(<a class="el" href="../../d1/def/classT.html">T</a>, BASE)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Declare base class info to <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code>. Single, non-virtual derivation.  <a href="#a7ee2c7ff8209815d164658289e0981ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dd6/DataVector_8h.html#aa01aa8e8d0c3a89feeb5e92e4e811ee3">DATAVECTOR_BASE_FWD</a>(<a class="el" href="../../d1/def/classT.html">T</a>, BASE)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Version of <code>DATAVECTOR_BASE</code> that can be used in forward declarations.  <a href="#aa01aa8e8d0c3a89feeb5e92e4e811ee3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dd6/DataVector_8h.html#abf92e4ab5c7811adc4e57e4997641636">DATAVECTOR_VIRTBASES1</a>(<a class="el" href="../../d1/def/classT.html">T</a>, B1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Declare base class info to <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code>. Single, virtual derivation.  <a href="#abf92e4ab5c7811adc4e57e4997641636"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dd6/DataVector_8h.html#a4f8af7c98cccdb3c1696a3cf2acf499f">DATAVECTOR_VIRTBASES1_FWD</a>(<a class="el" href="../../d1/def/classT.html">T</a>, B1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Version of <code>DATAVECTOR_VIRTBASES1</code> that can be used in forward declarations.  <a href="#a4f8af7c98cccdb3c1696a3cf2acf499f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dd6/DataVector_8h.html#a2ca8baa62a0521d1a8fe71e41dd854f8">DATAVECTOR_VIRTBASES2</a>(<a class="el" href="../../d1/def/classT.html">T</a>, B1, B2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Declare base class info to <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code>. Multiple derivation.  <a href="#a2ca8baa62a0521d1a8fe71e41dd854f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dd6/DataVector_8h.html#a171d8143c2b62c326f68e377d2fdb13c">DATAVECTOR_VIRTBASES2_FWD</a>(<a class="el" href="../../d1/def/classT.html">T</a>, B1, B2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Version of <code>DATAVECTOR_VIRTBASES2</code> that can be used in forward declarations.  <a href="#a171d8143c2b62c326f68e377d2fdb13c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dd6/DataVector_8h.html#a8b51182afbfb18b07c5565f35eaf9205">DATAVECTOR_VIRTBASES3</a>(<a class="el" href="../../d1/def/classT.html">T</a>, B1, B2, B3)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Declare base class info to <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code>. Multiple derivation.  <a href="#a8b51182afbfb18b07c5565f35eaf9205"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dd6/DataVector_8h.html#a3394597d90b55c7ef80d96a3a084daf9">DATAVECTOR_VIRTBASES3_FWD</a>(<a class="el" href="../../d1/def/classT.html">T</a>, B1, B2, B3)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Version of <code>DATAVECTOR_VIRTBASES3</code> that can be used in forward declarations.  <a href="#a3394597d90b55c7ef80d96a3a084daf9"></a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a1119a539ef95e66a83ed73e65ce4acb9"></a><!-- doxytag: member="DataVector.h::test2_assignelement1" ref="a1119a539ef95e66a83ed73e65ce4acb9" args="()" -->
template&lt;class DV &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>test2_assignelement1</b> ()</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a5d549df8562ac32795e7bebf440b830d"></a><!-- doxytag: member="DataVector.h::test2_assignelement2" ref="a5d549df8562ac32795e7bebf440b830d" args="()" -->
template&lt;class DV &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>test2_assignelement2</b> ()</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/dd6/DataVector_8h.html#add37f632107bc4141f40b517e65e9177">operator==</a> (const <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a> &gt; &amp;a, const <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a> &gt; &amp;b)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Vector equality comparison.  <a href="#add37f632107bc4141f40b517e65e9177"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="af854c118e3d6abbcbec3ab2a971b7fe7"></a><!-- doxytag: member="DataVector.h::operator!=" ref="af854c118e3d6abbcbec3ab2a971b7fe7" args="(const DataVector&lt; T &gt; &amp;a, const DataVector&lt; T &gt; &amp;b)" -->
template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/dd6/DataVector_8h.html#af854c118e3d6abbcbec3ab2a971b7fe7">operator!=</a> (const <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a> &gt; &amp;a, const <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a> &gt; &amp;b)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Based on operator==. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/dd6/DataVector_8h.html#a7afc44aa98a1f612fde6a688635b5984">operator&lt;</a> (const <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a> &gt; &amp;a, const <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a> &gt; &amp;b)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Vector ordering relation.  <a href="#a7afc44aa98a1f612fde6a688635b5984"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="aabaca5e61fd0dacf39989531e37035db"></a><!-- doxytag: member="DataVector.h::operator&gt;" ref="aabaca5e61fd0dacf39989531e37035db" args="(const DataVector&lt; T &gt; &amp;a, const DataVector&lt; T &gt; &amp;b)" -->
template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/dd6/DataVector_8h.html#aabaca5e61fd0dacf39989531e37035db">operator&gt;</a> (const <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a> &gt; &amp;a, const <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a> &gt; &amp;b)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Based on operator&lt;. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="aa2ab1fcd28acaadef8a84cdbe14587e1"></a><!-- doxytag: member="DataVector.h::operator&lt;=" ref="aa2ab1fcd28acaadef8a84cdbe14587e1" args="(const DataVector&lt; T &gt; &amp;a, const DataVector&lt; T &gt; &amp;b)" -->
template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/dd6/DataVector_8h.html#aa2ab1fcd28acaadef8a84cdbe14587e1">operator&lt;=</a> (const <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a> &gt; &amp;a, const <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a> &gt; &amp;b)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Based on operator&lt;. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a30679eaaa1bb60146be35e222951c75a"></a><!-- doxytag: member="DataVector.h::operator&gt;=" ref="a30679eaaa1bb60146be35e222951c75a" args="(const DataVector&lt; T &gt; &amp;a, const DataVector&lt; T &gt; &amp;b)" -->
template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/dd6/DataVector_8h.html#a30679eaaa1bb60146be35e222951c75a">operator&gt;=</a> (const <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a> &gt; &amp;a, const <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a> &gt; &amp;b)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Based on operator&lt;. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a1079c131662b9513373e300cbdcfade0"></a><!-- doxytag: member="DataVector.h::swap" ref="a1079c131662b9513373e300cbdcfade0" args="(DataVector&lt; T &gt; &amp;a, DataVector&lt; T &gt; &amp;b)" -->
template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/dd6/DataVector_8h.html#a1079c131662b9513373e300cbdcfade0">swap</a> (<a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a> &gt; &amp;a, <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a> &gt; &amp;b)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">See <code><a class="el" href="../../db/ded/ConstDataList_8h.html#a67766f262856f1e197e15fec33b60bac" title="See DataList&lt;T, BASE&gt;::swap().">DataVector&lt;T, BASE&gt;::swap()</a></code>. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>An STL vector of pointers that by default owns its pointed-to elements. </p>
<dl class="author"><dt><b>Author:</b></dt><dd>scott snyder, Paolo Calafiura, etc </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>May 2005; rewritten from earlier version. For further information, see &lt;<a href="https://twiki.cern.ch/twiki/bin/viewauth/AtlasComputing/DataVector">https://twiki.cern.ch/twiki/bin/viewauth/AtlasComputing/DataVector</a>&gt;</dd></dl>
<p>Introduction ============</p>
<p><a class="el" href="../../d4/dc4/structA.html">A</a> <code>DataVector&lt;T&gt;</code> acts like a <code>std::vector&lt;T*&gt;</code>, except that it can optionally manage the memory that it contains. The constructors take an (optional) extra argument, which can be either <code><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8a1f65f0fb55784cfd27d9d4d6d7986d4d" title="this data object owns its elements">SG::OWN_ELEMENTS</a></code> or <code><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8ad7d4cf2303700f0966e4140f236c4bf1" title="this data object is a view, it does not own its elmts">SG::VIEW_ELEMENTS</a></code> (defaulting to <code><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8a1f65f0fb55784cfd27d9d4d6d7986d4d" title="this data object owns its elements">SG::OWN_ELEMENTS</a></code>, except for a copy constructor). This tells whether the <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> owns its contained elements or not.</p>
<p>Ownership issues ================</p>
<p>If a <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> owns its elements, then they are deleted when the container itself is. Further, they are deleted by actions which erase elements from the container (i.e, <code>erase()</code>, <code>pop_back()</code>). <a class="el" href="../../d4/dc4/structA.html">A</a> replacement (such as <code> v[0] = new <a class="el" href="../../d1/def/classT.html">T</a> </code>) will result in the old element being deleted and the container taking ownership of the new element. It is an error to assign directly between two owning containers (<code>v1[0] = v2[0]</code>). To remove an element from a container and acquire ownership, use <code>swapElement</code>.</p>
<p>Beware of ownership issues when you modify a <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code>. Obviously you should not delete explicitly a <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> element. <a class="el" href="../../d4/dc4/structA.html">A</a> <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> should never have two elements pointing to the same object. This may seem obvious but certain std algorithms (e.g. <code>remove_if</code>) may leave a <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> with two copies of the same element in the "left-over" range. To avoid a crash when clearing the vector (e.g. in the destructor we have introduced a <img class="formulaInl" alt="$n\log n$" src="../../form_2.png"/> helper function that searches and removes duplicates in the <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code>. This is used by the destructor by <code>clear()</code> and by <code>erase(first, last)</code>. As this may change in the future to improve performance, do not rely on this functionality and do avoid introducing duplicated elements in a <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code>.</p>
<p>All these cautions do not apply when a <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> it is created with the flag <code><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8ad7d4cf2303700f0966e4140f236c4bf1" title="this data object is a view, it does not own its elmts">SG::VIEW_ELEMENTS</a></code> (see <code>enum OwnershipPolicy</code>) and hence does not own its elements. This is typically used to have <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> elements allocated by <code>DataPool</code>. Otherwise consider the cleaner alternative of using a <code>vector&lt;T*&gt;</code>.</p>
<p>The interface for <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> should be mostly compatible with that of <code>std::vector</code>. There are a few differences which should not make much difference in practice. For example, methods which would return a reference return a proxy object instead. Also <code>value_type</code> is used instead of <code>const_reference</code>; this is justified by the fact that the elements are always pointers.</p>
<p>Note that algorithms which modify their range may not work correctly if the container owns its contents. Specializations that work properly for <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> are available for some algorithms. These include:</p>
<ul>
<li><code>std::sort</code> </li>
<li><code>std::stable_sort</code> </li>
<li><code>std::partial_sort</code> </li>
<li><code>std::remove</code> </li>
<li><code>std::remove_if</code> </li>
<li><code>std::unique</code> </li>
<li><code>std::reverse</code> </li>
<li><code>std::rotate</code> </li>
<li><code>std::random_shuffle</code> </li>
<li><code>std::partition</code> </li>
<li><code>std::stable_partition</code> </li>
</ul>
<p>Alternately, for <code>sort()</code>, the <code>sort()</code> methods defined in <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> may be used. Or do the sorting in a view <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> or a plain <code>std::vector</code>.</p>
<p>There are a few other additions to the standard <code>std::vector</code> interface.</p>
<ul>
<li>The method <code>stdcont</code> may be used to get access to the underlying <code>std::vector</code> representation.</li>
<li>The type <code>PtrVector</code> is the type of the underlying <code>std::vector</code>. <code>BaseContainer</code> is a synonym for this.</li>
<li>The method <code>swapElement</code> may be used to get ownership of an element back from a <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code>.</li>
<li>The method <code>sort</code> provides an interface to <code>std::sort</code> that works even if the container owns its contents.</li>
<li>The method <code>ownPolicy</code> returns the ownership policy of the container.</li>
<li>An additional overload of <code>clear()</code> is provided that takes as an argument a new ownership policy for the container. This is the only way to change the ownership policy, save for swapping or moving the container.</li>
</ul>
<p>Note that since <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a>&lt;<a class="el" href="../../d1/def/classT.html">T</a>&gt;</code> has an element type of <code>T*</code>, it is not possible to directly insert a <code>const T*</code>. If you want to do that, see <code><a class="el" href="../../de/db1/classConstDataVector.html" title="DataVector adapter that acts like it holds const pointers.">ConstDataVector</a></code>. (In some cases, such as if the destination container is not being recorded in StoreGate, it may be more appropriate to simply use a <code>std::vector&lt;const T*&gt;</code>.) Don't just use a <code>const_cast!</code> </p>
<p>Inheritance ===========</p>
<p><code>DataVector's</code> may inherit from one another. If you have class <code><a class="el" href="../../d7/db3/structD.html">D</a></code> which derives from class <code><a class="el" href="../../d9/db3/structB.html">B</a></code>, you can set things up so that <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a>&lt;<a class="el" href="../../d7/db3/structD.html">D</a>&gt;</code> derives from <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a>&lt;<a class="el" href="../../d9/db3/structB.html">B</a>&gt;</code>. This allows you do to the same sort of conversions on the <code>DataVector's</code> as on the element pointers themselves. The key to doing this is to add the declaration</p>
<div class="fragment"><pre class="fragment">   <a class="code" href="../../d7/dd6/DataVector_8h.html#a7ee2c7ff8209815d164658289e0981ea" title="Declare base class info to DataVector. Single, non-virtual derivation.">DATAVECTOR_BASE</a> (<a class="code" href="../../d7/db3/structD.html">D</a>, <a class="code" href="../../d9/db3/structB.html">B</a>);
</pre></div><p>before using <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a>&lt;<a class="el" href="../../d7/db3/structD.html">D</a>&gt;</code>. <a class="el" href="../../d4/dc4/structA.html">A</a> few caveats about doing this. The pointers are actually stored in the base <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> instance, and the type that <code>stdcont</code> returns will reflect this. For example, in the example given above, <code><a class="el" href="../../d0/d4d/classDataVector.html#a0e2e64a35d842a206c96ccfec265df21" title="Return the underlying std::vector of the container.">DataVector&lt;D&gt;::stdcont()</a></code> will return a reference to std::vector&lt;B*&gt;. Second, in order to preserve the invariant that a <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a>&lt;<a class="el" href="../../d7/db3/structD.html">D</a>&gt;</code> contains only elements that actually derive from <code><a class="el" href="../../d7/db3/structD.html">D</a></code>, while at the same time not requiring that the contained objects be polymorphic, there is a restriction that you cannot insert into a <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> if you're not referring to it as the most derived type (even if such an insertion would not actually break the invariant). This is implemented as a runtime check.</p>
<p>Example:</p>
<div class="fragment"><pre class="fragment">   <a class="code" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&amp;lt;T&amp;gt;.">DataVector&lt;D&gt;</a> vd;
   vd.<a class="code" href="../../d0/d4d/classDataVector.html#a486aeb4868e7c29331717adb06ea0df2" title="Add an element to the end of the collection.">push_back</a> (<span class="keyword">new</span> <a class="code" href="../../d7/db3/structD.html">D</a>);  <span class="comment">// This is ok.</span>
   vd.<a class="code" href="../../d0/d4d/classDataVector.html#a486aeb4868e7c29331717adb06ea0df2" title="Add an element to the end of the collection.">push_back</a> (<span class="keyword">new</span> <a class="code" href="../../d9/db3/structB.html">B</a>);  <span class="comment">// This will give a compilation error</span>
                             (it would <span class="keywordflow">break</span> the invariant).
   <a class="code" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&amp;lt;T&amp;gt;.">DataVector&lt;B&gt;</a>&amp; vb = vd;
   vb.<a class="code" href="../../d0/d4d/classDataVector.html#a486aeb4868e7c29331717adb06ea0df2" title="Add an element to the end of the collection.">push_back</a> (<span class="keyword">new</span> <a class="code" href="../../d9/db3/structB.html">B</a>);  <span class="comment">// This will give a run-time error</span>
                             (it breaks the invariant).
   vb.push_back (<span class="keyword">new</span> <a class="code" href="../../d7/db3/structD.html">D</a>);  <span class="comment">// This will also give a run-time error.</span>
                             (It<span class="stringliteral">&apos;s actually ok, but there&apos;</span>s no good way
                             to distinguish it from the previous <span class="keywordflow">case</span>.)
</pre></div><p>Note also this (related to a common atlas idiom). If we have the above, and also:</p>
<div class="fragment"><pre class="fragment">   <span class="keyword">class </span>B_Vector : <span class="keyword">public</span> <a class="code" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&amp;lt;T&amp;gt;.">DataVector</a>&lt;B&gt; { ... };
   <span class="keyword">class </span>D_Vector : <span class="keyword">public</span> <a class="code" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&amp;lt;T&amp;gt;.">DataVector</a>&lt;D&gt; { ... };
</pre></div><p>Then a <code>D_Vector</code> will be convertible to a <a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a>&lt;<a class="el" href="../../d9/db3/structB.html">B</a>&gt;, but _not_ to a <code>B_Vector</code>.</p>
<p>Multiple and virtual inheritance are also supported. In this case, use <code>DATAVECTOR_VIRTBASES</code><em>n</em> (where <em>n</em> is 1, 2, or 3) instead of <code>DATAVECTOR_BASE</code>. Example: Given:</p>
<div class="fragment"><pre class="fragment">   <span class="keyword">class </span><a class="code" href="../../d8/d55/structM.html">M</a> { ... };
   <span class="keyword">class </span><a class="code" href="../../da/deb/structN.html">N</a> : <span class="keyword">virtual</span> <span class="keyword">public</span> <a class="code" href="../../d8/d55/structM.html">M</a> { ... };
   <span class="keyword">class </span><a class="code" href="../../d1/d78/structO.html">O</a> : <span class="keyword">virtual</span> <span class="keyword">public</span> <a class="code" href="../../d8/d55/structM.html">M</a> { ... };
   <span class="keyword">class </span><a class="code" href="../../dc/dec/structP.html">P</a> : <span class="keyword">virtual</span> <span class="keyword">public</span> <a class="code" href="../../da/deb/structN.html">N</a>, <span class="keyword">virtual</span> <span class="keyword">public</span> <a class="code" href="../../d1/d78/structO.html">O</a> { ... };
</pre></div><p>declare this with</p>
<div class="fragment"><pre class="fragment">   <a class="code" href="../../d7/dd6/DataVector_8h.html#abf92e4ab5c7811adc4e57e4997641636" title="Declare base class info to DataVector. Single, virtual derivation.">DATAVECTOR_VIRTBASES1</a>(<a class="code" href="../../da/deb/structN.html">N</a>, <a class="code" href="../../d8/d55/structM.html">M</a>);
   <a class="code" href="../../d7/dd6/DataVector_8h.html#abf92e4ab5c7811adc4e57e4997641636" title="Declare base class info to DataVector. Single, virtual derivation.">DATAVECTOR_VIRTBASES1</a>(<a class="code" href="../../d1/d78/structO.html">O</a>, <a class="code" href="../../d8/d55/structM.html">M</a>);
   <a class="code" href="../../d7/dd6/DataVector_8h.html#a2ca8baa62a0521d1a8fe71e41dd854f8" title="Declare base class info to DataVector. Multiple derivation.">DATAVECTOR_VIRTBASES2</a>(<a class="code" href="../../dc/dec/structP.html">P</a>, <a class="code" href="../../da/deb/structN.html">N</a>, <a class="code" href="../../d1/d78/structO.html">O</a>);
</pre></div><p>There is a restriction that there must be a unique base class that does not derive from anything else. For example, the diamond configuration above is ok, but this would not be:</p>
<div class="fragment"><pre class="fragment">   <span class="keyword">class </span>L { ... };
   <span class="keyword">class </span><a class="code" href="../../d8/d55/structM.html">M</a> { ... };
   <span class="keyword">class </span><a class="code" href="../../da/deb/structN.html">N</a> : <span class="keyword">virtual</span> <span class="keyword">public</span> <a class="code" href="../../d8/d55/structM.html">M</a>, <span class="keyword">virtual</span> <span class="keyword">public</span> L { ... };
   <span class="keyword">class </span><a class="code" href="../../d1/d78/structO.html">O</a> : <span class="keyword">virtual</span> <span class="keyword">public</span> <a class="code" href="../../d8/d55/structM.html">M</a> { ... };
   <span class="keyword">class </span><a class="code" href="../../dc/dec/structP.html">P</a> : <span class="keyword">virtual</span> <span class="keyword">public</span> <a class="code" href="../../da/deb/structN.html">N</a>, <span class="keyword">virtual</span> <span class="keyword">public</span> <a class="code" href="../../d1/d78/structO.html">O</a> { ... };

   <a class="code" href="../../d7/dd6/DataVector_8h.html#a2ca8baa62a0521d1a8fe71e41dd854f8" title="Declare base class info to DataVector. Multiple derivation.">DATAVECTOR_VIRTBASES2</a>(<a class="code" href="../../da/deb/structN.html">N</a>, <a class="code" href="../../d8/d55/structM.html">M</a>, L);
   <a class="code" href="../../d7/dd6/DataVector_8h.html#abf92e4ab5c7811adc4e57e4997641636" title="Declare base class info to DataVector. Single, virtual derivation.">DATAVECTOR_VIRTBASES1</a>(<a class="code" href="../../d1/d78/structO.html">O</a>, <a class="code" href="../../d8/d55/structM.html">M</a>);
   <a class="code" href="../../d7/dd6/DataVector_8h.html#a2ca8baa62a0521d1a8fe71e41dd854f8" title="Declare base class info to DataVector. Multiple derivation.">DATAVECTOR_VIRTBASES2</a>(<a class="code" href="../../dc/dec/structP.html">P</a>, <a class="code" href="../../da/deb/structN.html">N</a>, <a class="code" href="../../d1/d78/structO.html">O</a>);
</pre></div><p>Note, however, that you don't have to tell <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> about the complete hierarchy; leaving the <code>L</code> out of <code>DATAVECTOR_VIRTBASES</code> would work (you just wouldn't be able to convert to <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a>&lt;L&gt;</code>).</p>
<p>If you use <code>DATAVECTOR_VIRTBASES</code>, there is an additional time penalty to retrieve elements from the collection. This does not apply for <code>DATAVECTOR_BASES</code>.</p>
<p>All applicable <code>DATAVECTOR_*</code> macros must be visible at the point at which a <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> is instantiated. <a class="el" href="../../d4/dc4/structA.html">A</a> confusing compilation error is likely to result otherwise. Note that this means that if you have the <code>DATAVECTOR_*</code> macros within a container header file, then the header for the derived container must include the header for the base container. Be alert to this when converting existing code to use the inheritance scheme. For example, if class D2 derives from <a class="el" href="../../d7/db3/structD.html">D</a> which derives from <a class="el" href="../../d9/db3/structB.html">B</a>:</p>
<p>BVec.h: </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &quot;B.h&quot;</span>
<span class="preprocessor">  #include &quot;<a class="code" href="../../d7/dd6/DataVector_8h.html" title="An STL vector of pointers that by default owns its pointed-to elements.">DataVector.h</a>&quot;</span>
  <span class="keyword">typedef</span> <a class="code" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&amp;lt;T&amp;gt;.">DataVector&lt;B&gt;</a> BVec;
</pre></div><p>DVec.h: </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &quot;D.h&quot;</span>
<span class="preprocessor">  #include &quot;<a class="code" href="../../d7/dd6/DataVector_8h.html" title="An STL vector of pointers that by default owns its pointed-to elements.">DataVector.h</a>&quot;</span>
  <a class="code" href="../../d7/dd6/DataVector_8h.html#a7ee2c7ff8209815d164658289e0981ea" title="Declare base class info to DataVector. Single, non-virtual derivation.">DATAVECTOR_BASE</a>(<a class="code" href="../../d7/db3/structD.html">D</a>,<a class="code" href="../../d9/db3/structB.html">B</a>);
  <span class="keyword">typedef</span> <a class="code" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&amp;lt;T&amp;gt;.">DataVector&lt;D&gt;</a> DVec;
</pre></div><p>D2Vec.h: </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &quot;D2.h&quot;</span>
<span class="preprocessor">  #include &quot;<a class="code" href="../../d7/dd6/DataVector_8h.html" title="An STL vector of pointers that by default owns its pointed-to elements.">DataVector.h</a>&quot;</span>
<span class="preprocessor">  #include &quot;DVec.h&quot;</span> <span class="comment">// This is required</span>
  <a class="code" href="../../d7/dd6/DataVector_8h.html#a7ee2c7ff8209815d164658289e0981ea" title="Declare base class info to DataVector. Single, non-virtual derivation.">DATAVECTOR_BASE</a>(D2,<a class="code" href="../../d7/db3/structD.html">D</a>);
  <span class="keyword">typedef</span> <a class="code" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&amp;lt;T&amp;gt;.">DataVector&lt;D2&gt;</a> DVec;
</pre></div><p>Using <code>DATAVECTOR_BASE</code> will also set up the corresponding <code>SG::BaseInfo</code> definitions, both for the vectors themselves and for the contained objects.</p>
<p>Auxiliary data ==============</p>
<p><a class="el" href="../../d4/dc4/structA.html">A</a> <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> may also have `auxiliary data' associated with it. This is a set of name/value pairs that can be attached to each element of the vector. These data are stored in vectors that exist parallel to the <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code>; the exact way in which this managed is hidden behind an abstract interface.</p>
<p>We'll start with an example, and then go into more <a class="el" href="../../dd/d39/namespacedetail.html">detail</a>.</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">class </span><a class="code" href="../../db/d10/classMyClass.html">MyClass</a>
   : <span class="keyword">public</span> SG::AuxElement  <span class="comment">// Derive from AuxElement to allow for aux data</span>
 {
 <span class="keyword">public</span>:
   <span class="comment">// A getter for an aux data item.</span>
   <span class="keywordtype">float</span> foo()<span class="keyword"> const</span>
<span class="keyword">   </span>{ <span class="keyword">static</span> ConstAccessor&lt;float&gt; acc (<span class="stringliteral">&quot;foo&quot;</span>);  <span class="keywordflow">return</span> acc(*<span class="keyword">this</span>); }

   <span class="comment">// A setter for an aux data item.</span>
   <span class="keywordtype">void</span> foo(<span class="keywordtype">float</span> x)
   { <span class="keyword">static</span> Accessor&lt;float&gt; acc (<span class="stringliteral">&quot;foo&quot;</span>);  acc(*<span class="keyword">this</span>) = x; }
 };

 ...

 <span class="comment">// Create the vector and associate a store.</span>
 <a class="code" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&amp;lt;T&amp;gt;.">DataVector&lt;MyClass&gt;</a>* v = <span class="keyword">new</span> <a class="code" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&amp;lt;T&amp;gt;.">DataVector&lt;MyClass&gt;</a>;
 <a class="code" href="../../d1/d1c/classSG_1_1AuxStoreInternal.html" title="An auxiliary data store that holds data internally.">SG::AuxStoreInternal</a>* store = <span class="keyword">new</span> <a class="code" href="../../d1/d1c/classSG_1_1AuxStoreInternal.html" title="An auxiliary data store that holds data internally.">SG::AuxStoreInternal</a>;
 v-&gt;setStore (store);

 <span class="comment">// Add an item to the vector and set aux data on it.</span>
 v-&gt;<a class="code" href="../../d0/d4d/classDataVector.html#a486aeb4868e7c29331717adb06ea0df2" title="Add an element to the end of the collection.">push_back</a> (<span class="keyword">new</span> <a class="code" href="../../db/d10/classMyClass.html">MyClass</a>);
 v[0]-&gt;foo() = 3;

 <span class="comment">// Add a user-defined aux data item.</span>
 MyClass::Accessor&lt;int&gt; x (<span class="stringliteral">&quot;x&quot;</span>);
 x(*v[0]) = 10;

 <span class="comment">// Add a standalone store to an object.</span>
 <a class="code" href="../../db/d10/classMyClass.html">MyClass</a>* c = <span class="keyword">new</span> <a class="code" href="../../db/d10/classMyClass.html">MyClass</a>;
 c-&gt;makePrivateStore();
 c-&gt;foo() = 4;
 c-&gt;push_back (c); <span class="comment">// Aux data will be transferred to the container.</span>
</pre></div><p>In order to be able store auxiliary data in a container three things must hold. First, the container's payload type must derive from <code><a class="el" href="../../dc/db0/classSG_1_1AuxElement.html" title="Base class for elements of a container that can have aux data.">SG::AuxElement</a></code>. Second, the container must have index tracking enabled. Third, the container must have an associated auxiliary data store. More about these below.</p>
<p><a class="el" href="../../dc/db0/classSG_1_1AuxElement.html" title="Base class for elements of a container that can have aux data.">SG::AuxElement</a> --------------</p>
<p><a class="el" href="../../d4/dc4/structA.html">A</a> type which may have associated auxiliary data must derive from the base class <code><a class="el" href="../../dc/db0/classSG_1_1AuxElement.html" title="Base class for elements of a container that can have aux data.">SG::AuxElement</a></code>. This does a several things.</p>
<p>First, in order to be able to find auxiliary data from a pointer to a container element, the element must be able to know both the container that it's a member of and its index within that container. <code><a class="el" href="../../dc/db0/classSG_1_1AuxElement.html" title="Base class for elements of a container that can have aux data.">SG::AuxElement</a></code> makes this information available with the <code>container()</code> and <code>index()</code> methods. This information is maintained as long as the container has index tracking enabled (see below).</p>
<p>Second, it provides an interface for getting/setting auxiliary data. The recommended way of doing this is through the nested <code>Accessor</code> and <code>ConstAccessor</code> classes; these allows caching the translation from attribute names to the internal representation. The difference between these two is that <code>ConstAccessor</code> allows only const access to the element, while <code>Accessor</code>, which derives from it, allows non-const access as well. Create an <code>Accessor</code> or <code>ConstAccessor</code> object with the data type (which can be anything that can be used within a <code>std::vector</code>) and a name. For <code>Accessor</code>, the resulting object can then be used both as an rvalue and a lvalue; for <code>ConstAccessor</code>, it can be used only as an rvalue.</p>
<div class="fragment"><pre class="fragment">  <a class="code" href="../../db/d10/classMyClass.html">MyClass</a>* c = ...;
  MyClass::Accessor&lt;double&gt; y (<span class="stringliteral">&quot;y&quot;</span>);
  y(*c) = 4;  <span class="comment">// assign attribute.</span>
  <span class="keywordflow">return</span> y(*c);  <span class="comment">// read attribute.</span>
</pre></div><p><a class="el" href="../../d4/dc4/structA.html">A</a> given name must always be used with the same type, otherwise an exception will be thrown. In the case that you want to use the same name for different types in different classes, the name may be qualified with an optional class name:</p>
<div class="fragment"><pre class="fragment">  MyClass::ConstAccessor&lt;double&gt; y (<span class="stringliteral">&quot;y&quot;</span>, <span class="stringliteral">&quot;MyClass&quot;</span>);
</pre></div><p>If you have some auxiliary data items that are to be regarded as members of a class, it is recommended to define a setter and getter as in the example above.</p>
<p>If you need to operate on a particular auxiliary data item for all elements in a container, it will be more efficient to access the auxiliary data directly by index, rather than through the elements. This can be done like:</p>
<div class="fragment"><pre class="fragment">  <a class="code" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&amp;lt;T&amp;gt;.">DataVector&lt;MyClass&gt;</a>* v = ...;
  MyClass::ConstAccesor&lt;float&gt; x (<span class="stringliteral">&quot;x&quot;</span>);
  <span class="keywordtype">size_t</span> sz = v-&gt;<a class="code" href="../../d0/d4d/classDataVector.html#aa4d259c267222003a6d2592fbe9809af" title="Returns the number of elements in the collection.">size</a>();
  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; sz; i++)
    do_something (x(*v, i));
</pre></div><p><code>Accessor</code> and <code>ConstAccessor</code> also have <code>getDataArray</code> methods to directly return a pointer to the start of the auxiliary data array.</p>
<p>It is also possible to use the <code>auxdata</code> method to access auxiliary data directly. However, it is not recommended to do this inside a loop or anywhere where performance is important.</p>
<div class="fragment"><pre class="fragment">  c-&gt;auxdata&lt;<span class="keywordtype">int</span>&gt; (<span class="stringliteral">&quot;aux&quot;</span>) = 5;  <span class="comment">// set</span>
  <span class="keywordflow">return</span> c-&gt;auxdata&lt;<span class="keywordtype">int</span>&gt; (<span class="stringliteral">&quot;aux&quot;</span>);  <span class="comment">// retrieve</span>
</pre></div><p>Decorations -----------</p>
<p>In addition, sometimes one wants to add additional auxiliary data to an existing, const container; this is called `decorating' it. For example, you might want to retrieve a const container from StoreGate, run some algorithm on it, and attach additional data to the object that can be accessed by downstream algorithms or written to a file. To support this, there is a <code>Decorator</code> object analogous to <code>Accessor</code> and <code>ConstAccessor</code>. The difference is that <code>Decorator</code> can operate on a const object and return a non-const reference.</p>
<p>To prevent modifying existing data, the contents of a container may be locked with the <code>lock()</code> call; this happens automatically when the container is made const with <code>StoreGateSvc::setConst</code>. Once a container is locked, <code>Decorator</code> will only succeed if either the variable does not yet exist (in which case it is created and marked as a decoration) or it is marked as a decoration.</p>
<p>Calling <code>clearDecorations</code> will erase all variables marked as decorations, restoring the state back to where it was when <code>lock</code> was called.</p>
<p>An <code>auxdecor</code> method is also available, analogous to  auxdata.</p>
<p>Index tracking --------------</p>
<p>Recall that a <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> either owns its elements or not. By default, a <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> that owns its elements will update the container and index fields of the elements that it contains, while a view <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> will not.</p>
<p>This rule does not always suffice, though. In particular, a <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> that gets filled with elements from a <code>DataPool</code> does not own its elements but should track indices. For this reason, one can specify an index tracking policy separate from the ownership policy. Where <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> takes an ownership policy, it can also take as the next argument an index tracking policy. This policy defaults to <code><a class="el" href="../../dd/d59/namespaceSG.html#a9f3d699f65390b7f8baf54d9cd634573ad08b3b1af2cb1dd45428b131f9f05ad7">SG::DEFAULT_TRACK_INDICES</a></code>, which means to set the indexing policy based on the ownership policy. But it can also be set to <code><a class="el" href="../../dd/d59/namespaceSG.html#a9f3d699f65390b7f8baf54d9cd634573a3fef24c7e616865bef9cfc1ecd85b67d" title="Always track indices, regardless of the setting of the ownership policy.">SG::ALWAYS_TRACK_INDICES</a></code> or <code><a class="el" href="../../dd/d59/namespaceSG.html#a9f3d699f65390b7f8baf54d9cd634573a6e7a344e9aac93f8a793eebda3c608a8" title="Never track indices, regardless of the setting of the ownership policy.">SG::NEVER_TRACK_INDICES</a></code> to override this.</p>
<p>The current state of index tracking for a <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> is returned by the <code>trackIndices</code> method. Like the ownership policy, it may be changed with the <code>clear</code> method.</p>
<p>Auxiliary store ---------------</p>
<p><code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> does not itself manage the storage for auxiliary data. Instead, this is done by a separate _auxiliary store_ object. This store object implements either the interface <code><a class="el" href="../../d3/dd5/classSG_1_1IConstAuxStore.html" title="Interface for const operations on an auxiliary store.">SG::IConstAuxStore</a></code> or <code><a class="el" href="../../dc/d05/classSG_1_1IAuxStore.html" title="Interface for non-const operations on an auxiliary store.">SG::IAuxStore</a></code> (which derives from it). The first of these provides operations needed to read data from the store, while the second adds operations needed to add to and modify the data in the store.</p>
<p>When you are create a <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> object that is to have auxiliary data, you will also need to create the store object. <a class="el" href="../../d4/dc4/structA.html">A</a> generic store object, which manages dynamic auxiliary data, is available, <code><a class="el" href="../../d1/d1c/classSG_1_1AuxStoreInternal.html" title="An auxiliary data store that holds data internally.">SG::AuxStoreInternal</a></code>. There may also be specialized store implementations for particular data classes. Store implementations also exist that are specialized for use in root; in that case, the data are managed as part of a root tree, and the store object manages access to it.</p>
<div class="fragment"><pre class="fragment">  <a class="code" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&amp;lt;T&amp;gt;.">DataVector&lt;MyClass&gt;</a>* v = <span class="keyword">new</span> <a class="code" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&amp;lt;T&amp;gt;.">DataVector&lt;MyClass&gt;</a>;
  CHECK( evtStore-&gt;record (v, <span class="stringliteral">&quot;mykey&quot;</span>) );
  <a class="code" href="../../d1/d1c/classSG_1_1AuxStoreInternal.html" title="An auxiliary data store that holds data internally.">SG::AuxStoreInternal</a>* store = <span class="keyword">new</span> <a class="code" href="../../d1/d1c/classSG_1_1AuxStoreInternal.html" title="An auxiliary data store that holds data internally.">SG::AuxStoreInternal</a>;
  CHECK( evtStore-&gt;record (store, <span class="stringliteral">&quot;mykeyAux.&quot;</span>) );
  v-&gt;setStore (store);
</pre></div><p>You can only set a store if the container has index tracking enabled; otherwise, an exception will be thrown.</p>
<p>You should not have to explicitly deal with the auxiliary store for objects that are read from a file. The I/O system is responsible for getting the store association correct in that case.</p>
<p>Standalone objects ------------------</p>
<p>Normally, an element can only have associated auxiliary data if it is a member of a container; otherwise, there is no store in which to store the auxiliary data. However, it is possible to request that a store be created for an individual element not part of a container by calling the method <code>makePrivateStore</code>. You can then add auxiliary data to the object:</p>
<div class="fragment"><pre class="fragment">  <a class="code" href="../../db/d10/classMyClass.html">MyClass</a>* c = <span class="keyword">new</span> <a class="code" href="../../db/d10/classMyClass.html">MyClass</a>;
  c-&gt;makePrivateStore();
  MyClass::Accessor&lt;int&gt; x (<span class="stringliteral">&quot;x&quot;</span>);
  x(*c) = 5;
</pre></div><p>If the element is then added to a container, the auxiliary data will be copied to the container's store, and the private store the was associated with the element will be released. The fact that there was a private store is remembered, however; if the element is later removed from the container (in a way that doesn't delete the element), the private store will be remade and the auxiliary data copied back from the container to the private store.</p>
<p><code>makePrivateStore</code> can also take an argument. If provided, auxiliary data will be copied from it. This can be used to properly implement copy constructors:</p>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>MyStandaloneClass
    : <span class="keyword">public</span> SG::AuxElement
  {
  <span class="keyword">public</span>:
    MyStandaloneClass() { this-&gt;makePrivateStore(); }

    MyStandaloneClass (<span class="keyword">const</span> MyStandaloneClass&amp; other)
      <a class="code" href="../../dc/db0/classSG_1_1AuxElement.html" title="Base class for elements of a container that can have aux data.">SG::AuxElement</a> (other)
    {
      this-&gt;makePrivateStore (other);
    }
</pre></div><p>As a shorthand, one can use the wrapper class <code><a class="el" href="../../df/dbd/classSG_1_1AuxElementComplete.html" title="Wrapper to automatically create a private store for an element.">SG::AuxElementComplete</a></code>. This will add constructors that automatically make a private store:</p>
<div class="fragment"><pre class="fragment">  <span class="keyword">typedef</span> <a class="code" href="../../df/dbd/classSG_1_1AuxElementComplete.html" title="Wrapper to automatically create a private store for an element.">SG::AuxElementComplete&lt;MyClass&gt;</a> MyStandaloneClass;
</pre></div><p><a class="el" href="../../d4/dc4/structA.html">A</a> standalone object also has <code>setStore</code> methods that can be used to associate an external store with a since object, in the same manner as for containers. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="a7ee2c7ff8209815d164658289e0981ea"></a><!-- doxytag: member="DataVector.h::DATAVECTOR_BASE" ref="a7ee2c7ff8209815d164658289e0981ea" args="(T, BASE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DATAVECTOR_BASE</td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/def/classT.html">T</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BASE&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="../../d7/dd6/DataVector_8h.html#aa01aa8e8d0c3a89feeb5e92e4e811ee3" title="Version of DATAVECTOR_BASE that can be used in forward declarations.">DATAVECTOR_BASE_FWD</a>(<a class="code" href="../../d1/def/classT.html">T</a>, BASE);             \
<span class="keyword">template</span> <span class="keyword">struct </span>DataVector_detail::DVLEltBaseInit&lt;T&gt;
</pre></div>
<p>Declare base class info to <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code>. Single, non-virtual derivation. </p>
<p><code><a class="el" href="../../d7/dd6/DataVector_8h.html#a7ee2c7ff8209815d164658289e0981ea" title="Declare base class info to DataVector. Single, non-virtual derivation.">DATAVECTOR_BASE(D, B)</a></code> says that <code><a class="el" href="../../d7/db3/structD.html">D</a></code> derives non-virtually from <code><a class="el" href="../../d9/db3/structB.html">B</a></code>.</p>
<p>This macro creates an appropriate specialization of <code><a class="el" href="../../dd/d4c/structDataVectorBase.html" title="Derivation information for DataVector.">DataVectorBase</a></code>. </p>

</div>
</div>
<a class="anchor" id="aa01aa8e8d0c3a89feeb5e92e4e811ee3"></a><!-- doxytag: member="DataVector.h::DATAVECTOR_BASE_FWD" ref="aa01aa8e8d0c3a89feeb5e92e4e811ee3" args="(T, BASE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DATAVECTOR_BASE_FWD</td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/def/classT.html">T</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BASE&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span><a class="code" href="../../dd/d4c/structDataVectorBase.html" title="Derivation information for DataVector.">DataVectorBase</a>&lt;<a class="code" href="../../d1/def/classT.html">T</a>&gt;      \
{ <span class="keyword">typedef</span> <a class="code" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&amp;lt;T&amp;gt;.">DataVector&lt;BASE&gt;</a> <a class="code" href="../../d5/dd9/classtypename_01DataVectorBase_1_1Base.html">Base</a>; };       \
SG_BASE(<a class="code" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&amp;lt;T&amp;gt;.">DataVector&lt;T&gt;</a>, <a class="code" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&amp;lt;T&amp;gt;.">DataVector&lt;BASE&gt;</a>)
</pre></div>
<p>Version of <code>DATAVECTOR_BASE</code> that can be used in forward declarations. </p>

</div>
</div>
<a class="anchor" id="abf92e4ab5c7811adc4e57e4997641636"></a><!-- doxytag: member="DataVector.h::DATAVECTOR_VIRTBASES1" ref="abf92e4ab5c7811adc4e57e4997641636" args="(T, B1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DATAVECTOR_VIRTBASES1</td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/def/classT.html">T</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B1&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="../../d7/dd6/DataVector_8h.html#a4f8af7c98cccdb3c1696a3cf2acf499f" title="Version of DATAVECTOR_VIRTBASES1 that can be used in forward declarations.">DATAVECTOR_VIRTBASES1_FWD</a>(<a class="code" href="../../d1/def/classT.html">T</a>, B1);                     \
<span class="keyword">template</span> <span class="keyword">struct </span>DataVector_detail::DVLEltBaseInit&lt;T&gt;
</pre></div>
<p>Declare base class info to <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code>. Single, virtual derivation. </p>
<p><code><a class="el" href="../../d7/dd6/DataVector_8h.html#abf92e4ab5c7811adc4e57e4997641636" title="Declare base class info to DataVector. Single, virtual derivation.">DATAVECTOR_VIRTBASES1(D, B1)</a></code> says that <code><a class="el" href="../../d7/db3/structD.html">D</a></code> derives virtually from <code>B1</code>.</p>
<p>This macro creates an appropriate specialization of <code><a class="el" href="../../dd/d4c/structDataVectorBase.html" title="Derivation information for DataVector.">DataVectorBase</a></code>. </p>

</div>
</div>
<a class="anchor" id="a4f8af7c98cccdb3c1696a3cf2acf499f"></a><!-- doxytag: member="DataVector.h::DATAVECTOR_VIRTBASES1_FWD" ref="a4f8af7c98cccdb3c1696a3cf2acf499f" args="(T, B1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DATAVECTOR_VIRTBASES1_FWD</td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/def/classT.html">T</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B1&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span><a class="code" href="../../dd/d4c/structDataVectorBase.html" title="Derivation information for DataVector.">DataVectorBase</a>&lt;<a class="code" href="../../d1/def/classT.html">T</a>&gt;                  \
{ <span class="keyword">typedef</span> <a class="code" href="../../df/d07/structDataVector__detail_1_1VirtBases.html" title="VirtBases for three classes.">DataVector_detail::VirtBases&lt;B1&gt;</a> <a class="code" href="../../d5/dd9/classtypename_01DataVectorBase_1_1Base.html">Base</a>; };   \
SG_BASES1(<a class="code" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&amp;lt;T&amp;gt;.">DataVector&lt;T&gt;</a>, SG_VIRTUAL(<a class="code" href="../../d0/d4d/classDataVector.html">DataVector&lt;B1&gt;</a>))
</pre></div>
<p>Version of <code>DATAVECTOR_VIRTBASES1</code> that can be used in forward declarations. </p>

</div>
</div>
<a class="anchor" id="a2ca8baa62a0521d1a8fe71e41dd854f8"></a><!-- doxytag: member="DataVector.h::DATAVECTOR_VIRTBASES2" ref="a2ca8baa62a0521d1a8fe71e41dd854f8" args="(T, B1, B2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DATAVECTOR_VIRTBASES2</td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/def/classT.html">T</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B2&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="../../d7/dd6/DataVector_8h.html#a171d8143c2b62c326f68e377d2fdb13c" title="Version of DATAVECTOR_VIRTBASES2 that can be used in forward declarations.">DATAVECTOR_VIRTBASES2_FWD</a>(<a class="code" href="../../d1/def/classT.html">T</a>, B1, B2);                   \
<span class="keyword">template</span> <span class="keyword">struct </span>DataVector_detail::DVLEltBaseInit&lt;T&gt;
</pre></div>
<p>Declare base class info to <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code>. Multiple derivation. </p>
<p><code><a class="el" href="../../d7/dd6/DataVector_8h.html#a2ca8baa62a0521d1a8fe71e41dd854f8" title="Declare base class info to DataVector. Multiple derivation.">DATAVECTOR_VIRTBASES2(D, B1, B2)</a></code> says that <code><a class="el" href="../../d7/db3/structD.html">D</a></code> derives from both <code>B1</code> and <code>B2</code>.</p>
<p>This macro creates an appropriate specialization of <code><a class="el" href="../../dd/d4c/structDataVectorBase.html" title="Derivation information for DataVector.">DataVectorBase</a></code>. </p>

</div>
</div>
<a class="anchor" id="a171d8143c2b62c326f68e377d2fdb13c"></a><!-- doxytag: member="DataVector.h::DATAVECTOR_VIRTBASES2_FWD" ref="a171d8143c2b62c326f68e377d2fdb13c" args="(T, B1, B2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DATAVECTOR_VIRTBASES2_FWD</td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/def/classT.html">T</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B2&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span><a class="code" href="../../dd/d4c/structDataVectorBase.html" title="Derivation information for DataVector.">DataVectorBase</a>&lt;<a class="code" href="../../d1/def/classT.html">T</a>&gt;                    \
{ <span class="keyword">typedef</span> <a class="code" href="../../df/d07/structDataVector__detail_1_1VirtBases.html" title="VirtBases for three classes.">DataVector_detail::VirtBases&lt;B1, B2&gt;</a> <a class="code" href="../../d5/dd9/classtypename_01DataVectorBase_1_1Base.html">Base</a>; }; \
SG_BASES2(<a class="code" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&amp;lt;T&amp;gt;.">DataVector&lt;T&gt;</a>, SG_VIRTUAL(<a class="code" href="../../d0/d4d/classDataVector.html">DataVector&lt;B1&gt;</a>),    \
                         SG_VIRTUAL(<a class="code" href="../../d0/d4d/classDataVector.html">DataVector&lt;B2&gt;</a>))
</pre></div>
<p>Version of <code>DATAVECTOR_VIRTBASES2</code> that can be used in forward declarations. </p>

</div>
</div>
<a class="anchor" id="a8b51182afbfb18b07c5565f35eaf9205"></a><!-- doxytag: member="DataVector.h::DATAVECTOR_VIRTBASES3" ref="a8b51182afbfb18b07c5565f35eaf9205" args="(T, B1, B2, B3)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DATAVECTOR_VIRTBASES3</td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/def/classT.html">T</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B2, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B3&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="../../d7/dd6/DataVector_8h.html#a3394597d90b55c7ef80d96a3a084daf9" title="Version of DATAVECTOR_VIRTBASES3 that can be used in forward declarations.">DATAVECTOR_VIRTBASES3_FWD</a>(<a class="code" href="../../d1/def/classT.html">T</a>, B1, B2, B3);               \
<span class="keyword">template</span> <span class="keyword">struct </span>DataVector_detail::DVLEltBaseInit&lt;T&gt;
</pre></div>
<p>Declare base class info to <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code>. Multiple derivation. </p>
<p><code><a class="el" href="../../d7/dd6/DataVector_8h.html#a8b51182afbfb18b07c5565f35eaf9205" title="Declare base class info to DataVector. Multiple derivation.">DATAVECTOR_VIRTBASES3(D, B1, B2, B3)</a></code> says that <code><a class="el" href="../../d7/db3/structD.html">D</a></code> derives from all of <code>B1</code>, <code>B2</code>, and <code>B3</code>.</p>
<p>This macro creates an appropriate specialization of <code><a class="el" href="../../dd/d4c/structDataVectorBase.html" title="Derivation information for DataVector.">DataVectorBase</a></code>. </p>

</div>
</div>
<a class="anchor" id="a3394597d90b55c7ef80d96a3a084daf9"></a><!-- doxytag: member="DataVector.h::DATAVECTOR_VIRTBASES3_FWD" ref="a3394597d90b55c7ef80d96a3a084daf9" args="(T, B1, B2, B3)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DATAVECTOR_VIRTBASES3_FWD</td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/def/classT.html">T</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B2, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B3&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span><a class="code" href="../../dd/d4c/structDataVectorBase.html" title="Derivation information for DataVector.">DataVectorBase</a>&lt;<a class="code" href="../../d1/def/classT.html">T</a>&gt;                        \
{ <span class="keyword">typedef</span> <a class="code" href="../../df/d07/structDataVector__detail_1_1VirtBases.html" title="VirtBases for three classes.">DataVector_detail::VirtBases&lt;B1, B2, B3&gt;</a> <a class="code" href="../../d5/dd9/classtypename_01DataVectorBase_1_1Base.html">Base</a>; }; \
SG_BASES3(<a class="code" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&amp;lt;T&amp;gt;.">DataVector&lt;T&gt;</a>, SG_VIRTUAL(<a class="code" href="../../d0/d4d/classDataVector.html">DataVector&lt;B1&gt;</a>),        \
                         SG_VIRTUAL(<a class="code" href="../../d0/d4d/classDataVector.html">DataVector&lt;B2&gt;</a>),        \
                         SG_VIRTUAL(<a class="code" href="../../d0/d4d/classDataVector.html">DataVector&lt;B3&gt;</a>))
</pre></div>
<p>Version of <code>DATAVECTOR_VIRTBASES3</code> that can be used in forward declarations. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a7afc44aa98a1f612fde6a688635b5984"></a><!-- doxytag: member="DataVector.h::operator&lt;" ref="a7afc44aa98a1f612fde6a688635b5984" args="(const DataVector&lt; T &gt; &amp;a, const DataVector&lt; T &gt; &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Vector ordering relation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td><a class="el" href="../../d4/dc4/structA.html">A</a> <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td><a class="el" href="../../d4/dc4/structA.html">A</a> <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> of the same type as <em>x</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True iff <em>x</em> is lexicographically less than <em>y</em>.</dd></dl>
<p>This is a total ordering relation. It is linear in the size of the vectors. Comparisons are done on the pointer values of the elements.</p>
<p>See <code>std::lexicographical_compare()</code> for how the determination is made. </p>

</div>
</div>
<a class="anchor" id="add37f632107bc4141f40b517e65e9177"></a><!-- doxytag: member="DataVector.h::operator==" ref="add37f632107bc4141f40b517e65e9177" args="(const DataVector&lt; T &gt; &amp;a, const DataVector&lt; T &gt; &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Vector equality comparison. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td><a class="el" href="../../d4/dc4/structA.html">A</a> <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td><a class="el" href="../../d4/dc4/structA.html">A</a> <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> of the same type as <em>x</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True iff the size and elements of the vectors are equal.</dd></dl>
<p>This is an equivalence relation. It is linear in the size of the vectors. Vectors are considered equivalent if their sizes are equal, and if corresponding elements compare equal. </p>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 15 Apr 2017 for RootCore Packages by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
