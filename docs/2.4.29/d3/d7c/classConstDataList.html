<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>RootCore Packages: ConstDataList&lt; DL &gt; Class Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="../../index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="../../search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="../../annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="../../classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="../../hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="../../functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>ConstDataList&lt; DL &gt; Class Template Reference</h1><!-- doxytag: class="ConstDataList" -->
<p><code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a></code> adapter that acts like it holds const pointers.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../db/ded/ConstDataList_8h_source.html">ConstDataList.h</a>&gt;</code></p>

<p><a href="../../da/d74/classConstDataList-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28ce8eda8aea0cec78c8cc4e08809c17"></a><!-- doxytag: member="ConstDataList::size_type" ref="a28ce8eda8aea0cec78c8cc4e08809c17" args="" -->
typedef DL::size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7c/classConstDataList.html#a28ce8eda8aea0cec78c8cc4e08809c17">size_type</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Basic types, forwarded from the base. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9036c65257aed5b63c02463ac37df9a3"></a><!-- doxytag: member="ConstDataList::difference_type" ref="a9036c65257aed5b63c02463ac37df9a3" args="" -->
typedef DL::difference_type&nbsp;</td><td class="memItemRight" valign="bottom"><b>difference_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add936ac8711961c765219ab9dbb908d1"></a><!-- doxytag: member="ConstDataList::allocator_type" ref="add936ac8711961c765219ab9dbb908d1" args="" -->
typedef DL::allocator_type&nbsp;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19cbcdf7e7675e8d1bdd1d03f5496090"></a><!-- doxytag: member="ConstDataList::base_value_type" ref="a19cbcdf7e7675e8d1bdd1d03f5496090" args="" -->
typedef DL::base_value_type&nbsp;</td><td class="memItemRight" valign="bottom"><b>base_value_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a87f4420e82087b7319835a299b08608b"></a><!-- doxytag: member="ConstDataList::BaseContainer" ref="a87f4420e82087b7319835a299b08608b" args="" -->
typedef DL::BaseContainer&nbsp;</td><td class="memItemRight" valign="bottom"><b>BaseContainer</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2070c5ac5732290c26c7e1642009a650"></a><!-- doxytag: member="ConstDataList::DVL_BASE" ref="a2070c5ac5732290c26c7e1642009a650" args="" -->
typedef DL::DVL_BASE&nbsp;</td><td class="memItemRight" valign="bottom"><b>DVL_BASE</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3717be48197bc3ffebba314e992b5b31"></a><!-- doxytag: member="ConstDataList::const_iterator" ref="a3717be48197bc3ffebba314e992b5b31" args="" -->
typedef DL::const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38cbe58d11c3596ab32a19f68bde3bc2"></a><!-- doxytag: member="ConstDataList::const_reverse_iterator" ref="a38cbe58d11c3596ab32a19f68bde3bc2" args="" -->
typedef DL::const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_reverse_iterator</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef DL::const_value_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7c/classConstDataList.html#afbd8897e570093eb839750370fb1c904">value_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a206ca26e2f53a19d358a7bd714b17a48"></a><!-- doxytag: member="ConstDataList::const_value_type" ref="a206ca26e2f53a19d358a7bd714b17a48" args="" -->
typedef DL::const_value_type&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_value_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c07288f349a4f76458835c1c6d9aaa0"></a><!-- doxytag: member="ConstDataList::reference" ref="a5c07288f349a4f76458835c1c6d9aaa0" args="" -->
typedef DL::const_value_type &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>reference</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52fc77360f68de84b59d8958a653c335"></a><!-- doxytag: member="ConstDataList::const_reference" ref="a52fc77360f68de84b59d8958a653c335" args="" -->
typedef DL::const_value_type <br class="typebreak"/>
const &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_reference</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66a3c13c39e02d953109b285b2baa9ab"></a><!-- doxytag: member="ConstDataList::pointer" ref="a66a3c13c39e02d953109b285b2baa9ab" args="" -->
typedef DL::const_value_type *&nbsp;</td><td class="memItemRight" valign="bottom"><b>pointer</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a558a661883d6fc7dafd205322f7647"></a><!-- doxytag: member="ConstDataList::const_pointer" ref="a5a558a661883d6fc7dafd205322f7647" args="" -->
typedef DL::const_value_type <br class="typebreak"/>
const *&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="../../d7/d05/classDataModel__detail_1_1ElementProxy.html">DataModel_detail::ElementProxy</a><br class="typebreak"/>
&lt; <a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7c/classConstDataList.html#af84acc7a30d354ac6bd80f1f65d1431e">ElementProxy</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a974b2c9af8f296c8ce652ed4760d6f35"></a><!-- doxytag: member="ConstDataList::iterator" ref="a974b2c9af8f296c8ce652ed4760d6f35" args="" -->
typedef <br class="typebreak"/>
<a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">DataModel_detail::iterator</a><br class="typebreak"/>
&lt; <a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7c/classConstDataList.html#a974b2c9af8f296c8ce652ed4760d6f35">iterator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The iterator for this type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::reverse_iterator<br class="typebreak"/>
&lt; <a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7c/classConstDataList.html#a028da3e06465b1480067d55a59cffdac">reverse_iterator</a></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors, destructors, assignment.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpb39bb9cb1bc18cddc74e7f363d4e2167"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7c/classConstDataList.html#afb1e74a8172dcb25956590ce0eacb962">ConstDataList</a> (<a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">SG::OwnershipPolicy</a> ownPolicy=SG::OWN_ELEMENTS)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor.  <a href="#afb1e74a8172dcb25956590ce0eacb962"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7c/classConstDataList.html#a39b996815adf60a0a13cfb3751f3dd4c">ConstDataList</a> (<a class="el" href="../../d3/d7c/classConstDataList.html#a28ce8eda8aea0cec78c8cc4e08809c17">size_type</a> n, <a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">SG::OwnershipPolicy</a> ownPolicy=SG::OWN_ELEMENTS)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sized constructor.  <a href="#a39b996815adf60a0a13cfb3751f3dd4c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d7c/classConstDataList.html#ac87c178f5612029de23e929e1dab7954">ConstDataList</a> (InputIterator first, InputIterator last, <a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">SG::OwnershipPolicy</a> ownPolicy=SG::VIEW_ELEMENTS)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor from iterators.  <a href="#ac87c178f5612029de23e929e1dab7954"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7c/classConstDataList.html#ad9251f196b1aebb16e047d7280b1823c">operator=</a> (const <a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment operator.  <a href="#ad9251f196b1aebb16e047d7280b1823c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d7c/classConstDataList.html#ac0c08c41c7ebc0b2c523523e85e7c3a2">assign</a> (InputIterator first, InputIterator last)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assign from iterators.  <a href="#ac0c08c41c7ebc0b2c523523e85e7c3a2"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Element access.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp03f08060dbcda9a05f3dd6a98ff9f981"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d7/d05/classDataModel__detail_1_1ElementProxy.html">ElementProxy</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7c/classConstDataList.html#acfdf1abac9c271dedf043a5921b09449">front</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access the first element in the collection as an lvalue.  <a href="#acfdf1abac9c271dedf043a5921b09449"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d7/d05/classDataModel__detail_1_1ElementProxy.html">ElementProxy</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7c/classConstDataList.html#a32b3ec7e4346932f507bcd8a94bb7939">back</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access the last element in the collection as an lvalue.  <a href="#a32b3ec7e4346932f507bcd8a94bb7939"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Iterator creation.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp04fea93d7622927e954392dcd5690674"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7c/classConstDataList.html#a1edb94e7a0cdb6c5be73eced7327537e">begin</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return an <code>iterator</code> pointing at the beginning of the collection.  <a href="#a1edb94e7a0cdb6c5be73eced7327537e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7c/classConstDataList.html#a31ee3602aa3eef896962945b7c667b44">end</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return an <code>iterator</code> pointing past the end of the collection.  <a href="#a31ee3602aa3eef896962945b7c667b44"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d3/d7c/classConstDataList.html#a028da3e06465b1480067d55a59cffdac">reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7c/classConstDataList.html#a16dc5885f7ce298aa50957e33b33cb7f">rbegin</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a <code>reverse_iterator</code> pointing past the end of the collection.  <a href="#a16dc5885f7ce298aa50957e33b33cb7f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d3/d7c/classConstDataList.html#a028da3e06465b1480067d55a59cffdac">reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7c/classConstDataList.html#a69f1437665f9f391e66741f7e6e3df2f">rend</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a <code>reverse_iterator</code> pointing at the beginning of the collection.  <a href="#a69f1437665f9f391e66741f7e6e3df2f"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Insertion operations.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpc4ff45e64b9f41cc82677be76808116c"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7c/classConstDataList.html#aeea2c88b84cbd273e03fb618b50bca73">push_front</a> (<a class="el" href="../../d3/d7c/classConstDataList.html#afbd8897e570093eb839750370fb1c904">value_type</a> pElem)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add an element at the beginning of the collection.  <a href="#aeea2c88b84cbd273e03fb618b50bca73"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7c/classConstDataList.html#a998045e29b9246d5d4ee4b3576be63d0">push_back</a> (<a class="el" href="../../d3/d7c/classConstDataList.html#afbd8897e570093eb839750370fb1c904">value_type</a> pElem)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add an element to the end of the collection.  <a href="#a998045e29b9246d5d4ee4b3576be63d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7c/classConstDataList.html#a9fb7c36dbe43b9b18df9f0c01b72b710">insert</a> (<a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a> position, <a class="el" href="../../d3/d7c/classConstDataList.html#afbd8897e570093eb839750370fb1c904">value_type</a> pElem)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a new element to the collection.  <a href="#a9fb7c36dbe43b9b18df9f0c01b72b710"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d7c/classConstDataList.html#a797d5d530929d4de6213cddfaf647129">insert</a> (<a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a> position, InputIterator first, InputIterator last)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a group of new elements to the collection.  <a href="#a797d5d530929d4de6213cddfaf647129"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Erasure operations.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp5dd35913d37b538bffc58eac1d7946e3"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7c/classConstDataList.html#aabafc4d3f83f205d63dab57c10792fbe">erase</a> (<a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a> position)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove element at a given position.  <a href="#aabafc4d3f83f205d63dab57c10792fbe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7c/classConstDataList.html#af61ef0b84f1177c6d81e7face9e52fe7">erase</a> (<a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a> first, <a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a> last)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove a range of elements.  <a href="#af61ef0b84f1177c6d81e7face9e52fe7"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">List operations.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp543a41302df2bfd847db57ca041c7b35"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7c/classConstDataList.html#a492b529115f5d654c41943b178d3ae57">splice</a> (<a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a> position, <a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a> &amp;l)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert contents of another list.  <a href="#a492b529115f5d654c41943b178d3ae57"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7c/classConstDataList.html#aad90d48e222ba238ae112c88a1ab8c21">splice</a> (<a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a> position, <a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a> &amp;l, <a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a> i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert element from another list.  <a href="#aad90d48e222ba238ae112c88a1ab8c21"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7c/classConstDataList.html#a127d3469b64aa1f0566cb50851d1b954">splice</a> (<a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a> position, <a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a> &amp;l, <a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a> first, <a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a> last)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert range from another list.  <a href="#a127d3469b64aa1f0566cb50851d1b954"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7c/classConstDataList.html#a73653a365812f88e4ee5cd6eef1941c2">remove</a> (const <a class="el" href="../../d3/d7c/classConstDataList.html#afbd8897e570093eb839750370fb1c904">value_type</a> &amp;value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove all elements equal to value.  <a href="#a73653a365812f88e4ee5cd6eef1941c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7c/classConstDataList.html#aae112b3acc86d27dfd222bd9ada73c67">merge</a> (<a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a> &amp;l)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Merge sorted lists.  <a href="#aae112b3acc86d27dfd222bd9ada73c67"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename COMPARE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d7c/classConstDataList.html#a9d8161a3ce773260f6ad01da1c4dd583">merge</a> (<a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a> &amp;l, COMPARE predicate)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Merge sorted lists according to comparison function.  <a href="#a9d8161a3ce773260f6ad01da1c4dd583"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Non-standard operations.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp67b3645f65a6afd377578740fa3b4ed2"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7c/classConstDataList.html#a439d1898975457653b5e0e07f83d8de9">swapElement</a> (<a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a> pos, <a class="el" href="../../d3/d7c/classConstDataList.html#afbd8897e570093eb839750370fb1c904">value_type</a> newElem, reference oldElem)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swap one element out of the container.  <a href="#a439d1898975457653b5e0e07f83d8de9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const DL *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7c/classConstDataList.html#a5ecbdc336fe36cffafe71d3f54735901">asDataList</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a pointer to this object, as a const <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a></code>.  <a href="#a5ecbdc336fe36cffafe71d3f54735901"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7c/classConstDataList.html#ad8df5a10d717e6ed3e686581fb8f2bf6">resortAux</a> (<a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a> beg, <a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a> end)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset indices / reorder aux data after elements have been permuted.  <a href="#ad8df5a10d717e6ed3e686581fb8f2bf6"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Relational operators.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp2dfb2a28709c2d057d20a41ab65c066f"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7c/classConstDataList.html#a750bfd459a188b4a9ec969dc840d0af6">operator&lt;</a> (const <a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a> &amp;b) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">List ordering relation.  <a href="#a750bfd459a188b4a9ec969dc840d0af6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac38ddeff504d2d2581cbfa6ec3cfb8cf"></a><!-- doxytag: member="ConstDataList::operator&gt;" ref="ac38ddeff504d2d2581cbfa6ec3cfb8cf" args="(const ConstDataList &amp;b) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7c/classConstDataList.html#ac38ddeff504d2d2581cbfa6ec3cfb8cf">operator&gt;</a> (const <a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a> &amp;b) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Based on operator&lt;. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad92f2e272b4d06b801f66474b5e33c6a"></a><!-- doxytag: member="ConstDataList::operator&lt;=" ref="ad92f2e272b4d06b801f66474b5e33c6a" args="(const ConstDataList &amp;b) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7c/classConstDataList.html#ad92f2e272b4d06b801f66474b5e33c6a">operator&lt;=</a> (const <a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a> &amp;b) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Based on operator&lt;. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d17dec912b0e58ad3671df9f405bdb5"></a><!-- doxytag: member="ConstDataList::operator&gt;=" ref="a9d17dec912b0e58ad3671df9f405bdb5" args="(const ConstDataList &amp;b) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7c/classConstDataList.html#a9d17dec912b0e58ad3671df9f405bdb5">operator&gt;=</a> (const <a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a> &amp;b) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Based on operator&lt;. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7c/classConstDataList.html#affdee6e680364931593625b26f90ab6b">operator==</a> (const <a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a> &amp;b) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">List equality comparison.  <a href="#affdee6e680364931593625b26f90ab6b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4a7a9341453b16d3391a69eb51a22595"></a><!-- doxytag: member="ConstDataList::operator!=" ref="a4a7a9341453b16d3391a69eb51a22595" args="(const ConstDataList &amp;b) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7c/classConstDataList.html#a4a7a9341453b16d3391a69eb51a22595">operator!=</a> (const <a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a> &amp;b) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Based on operator==. <br/></td></tr>
<tr><td colspan="2"><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2800438170494904c77ffedf0168a180"></a><!-- doxytag: member="ConstDataList::has_virtual" ref="a2800438170494904c77ffedf0168a180" args="" -->
static const bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7c/classConstDataList.html#a2800438170494904c77ffedf0168a180">has_virtual</a> = DL::has_virtual</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This needs to be forwarded from the base as well. <br/></td></tr>
<tr><td colspan="2"><h2>Private helpers.</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrpe5a69a01ae6824427c974a9ce34af1a7"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ecef4b58caf361cf45043385e92a021"></a><!-- doxytag: member="ConstDataList::DataModel_detail::ElementProxy&lt; ConstDataList &gt;" ref="a3ecef4b58caf361cf45043385e92a021" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7c/classConstDataList.html#a3ecef4b58caf361cf45043385e92a021">DataModel_detail::ElementProxy&lt; ConstDataList &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1119a539ef95e66a83ed73e65ce4acb9"></a><!-- doxytag: member="ConstDataList::test2_assignelement1" ref="a1119a539ef95e66a83ed73e65ce4acb9" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>test2_assignelement1</b> ()</td></tr>
<tr><td colspan="2"><h2>Swap and sort.</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp48740572230bf871bbbe3f4450b8e26c"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7c/classConstDataList.html#a655f54075595ed86221b36b68a19d567">swap</a> (<a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swap this collection with another.  <a href="#a655f54075595ed86221b36b68a19d567"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7c/classConstDataList.html#a12cfc85b3bf78b3e09b1c42646a722f1">iter_swap</a> (<a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a> a, <a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a> b)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swap the referents of two <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> iterators.  <a href="#a12cfc85b3bf78b3e09b1c42646a722f1"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class DL&gt;<br/>
 class ConstDataList&lt; DL &gt;</h3>

<p><code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a></code> adapter that acts like it holds const pointers. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="af84acc7a30d354ac6bd80f1f65d1431e"></a><!-- doxytag: member="ConstDataList::ElementProxy" ref="af84acc7a30d354ac6bd80f1f65d1431e" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DL&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="../../d7/d05/classDataModel__detail_1_1ElementProxy.html">DataModel_detail::ElementProxy</a>&lt;<a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a>&gt; <a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a>&lt; DL &gt;::<a class="el" href="../../d7/d05/classDataModel__detail_1_1ElementProxy.html">ElementProxy</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This type is used to proxy lvalue accesses to <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a></code> elements, in order to handle ownership. </p>

</div>
</div>
<a class="anchor" id="a028da3e06465b1480067d55a59cffdac"></a><!-- doxytag: member="ConstDataList::reverse_iterator" ref="a028da3e06465b1480067d55a59cffdac" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DL&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::reverse_iterator&lt;<a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&gt; <a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a>&lt; DL &gt;::<a class="el" href="../../d3/d7c/classConstDataList.html#a028da3e06465b1480067d55a59cffdac">reverse_iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Standard <code>reverse_iterator</code>. Note that lvalue references here will yield an <code>ElementProxy</code>, not a <code>reference</code>. </p>

</div>
</div>
<a class="anchor" id="afbd8897e570093eb839750370fb1c904"></a><!-- doxytag: member="ConstDataList::value_type" ref="afbd8897e570093eb839750370fb1c904" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DL&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef DL::const_value_type <a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a>&lt; DL &gt;::<a class="el" href="../../d3/d7c/classConstDataList.html#afbd8897e570093eb839750370fb1c904">value_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>These types get modified so that the base's <code>const_value_type</code> becomes our <code>value_type</code>. </p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="afb1e74a8172dcb25956590ce0eacb962"></a><!-- doxytag: member="ConstDataList::ConstDataList" ref="afb1e74a8172dcb25956590ce0eacb962" args="(SG::OwnershipPolicy ownPolicy=SG::OWN_ELEMENTS)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a>&lt; DL &gt;::<a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">SG::OwnershipPolicy</a>&nbsp;</td>
          <td class="paramname"> <em>ownPolicy</em> = <code>SG::OWN_ELEMENTS</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default constructor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ownPolicy</em>&nbsp;</td><td>The ownership mode for the container.</td></tr>
  </table>
  </dd>
</dl>
<p>By default, a <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a></code> will own its elements. To avoid this, pass <code><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8ad7d4cf2303700f0966e4140f236c4bf1" title="this data object is a view, it does not own its elmts">SG::VIEW_ELEMENTS</a></code> for <em>ownPolicy</em>. </p>

</div>
</div>
<a class="anchor" id="a39b996815adf60a0a13cfb3751f3dd4c"></a><!-- doxytag: member="ConstDataList::ConstDataList" ref="a39b996815adf60a0a13cfb3751f3dd4c" args="(size_type n, SG::OwnershipPolicy ownPolicy=SG::OWN_ELEMENTS)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a>&lt; DL &gt;::<a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d7c/classConstDataList.html#a28ce8eda8aea0cec78c8cc4e08809c17">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">SG::OwnershipPolicy</a>&nbsp;</td>
          <td class="paramname"> <em>ownPolicy</em> = <code>SG::OWN_ELEMENTS</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sized constructor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>The size of the container. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ownPolicy</em>&nbsp;</td><td>The ownership mode for the container.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that unlike the standard list constructor, you can't specify an initial value here. The container will be initialized with 0's.</p>
<p>By default, a <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a></code> will own its elements. To avoid this, pass <code><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8ad7d4cf2303700f0966e4140f236c4bf1" title="this data object is a view, it does not own its elmts">SG::VIEW_ELEMENTS</a></code> for <em>ownPolicy</em>. </p>

</div>
</div>
<a class="anchor" id="ac87c178f5612029de23e929e1dab7954"></a><!-- doxytag: member="ConstDataList::ConstDataList" ref="ac87c178f5612029de23e929e1dab7954" args="(InputIterator first, InputIterator last, SG::OwnershipPolicy ownPolicy=SG::VIEW_ELEMENTS)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DL &gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a>&lt; DL &gt;::<a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a> </td>
          <td>(</td>
          <td class="paramtype">InputIterator&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">SG::OwnershipPolicy</a>&nbsp;</td>
          <td class="paramname"> <em>ownPolicy</em> = <code>SG::VIEW_ELEMENTS</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor from iterators. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>The start of the range to put in the new container. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>last</em>&nbsp;</td><td>The end of the range to put in the new container. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ownPolicy</em>&nbsp;</td><td>The ownership mode for the container.</td></tr>
  </table>
  </dd>
</dl>
<p>By default, a <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a></code> will own its elements (and take ownership of the pointers passed to this constructor). To avoid this, pass <code><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8ad7d4cf2303700f0966e4140f236c4bf1" title="this data object is a view, it does not own its elmts">SG::VIEW_ELEMENTS</a></code> for <em>ownPolicy</em>. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a5ecbdc336fe36cffafe71d3f54735901"></a><!-- doxytag: member="ConstDataList::asDataList" ref="a5ecbdc336fe36cffafe71d3f54735901" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const DL * <a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a>&lt; DL &gt;::asDataList </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a pointer to this object, as a const <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a></code>. </p>
<p>Return a pointer to this object, as a const <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code>. </p>

</div>
</div>
<a class="anchor" id="ac0c08c41c7ebc0b2c523523e85e7c3a2"></a><!-- doxytag: member="ConstDataList::assign" ref="ac0c08c41c7ebc0b2c523523e85e7c3a2" args="(InputIterator first, InputIterator last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DL &gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a>&lt; DL &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">InputIterator&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assign from iterators. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>The start of the range to put in the container. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>last</em>&nbsp;</td><td>The end of the range to put in the container.</td></tr>
  </table>
  </dd>
</dl>
<p>Any existing owned elements will be released. The <code>DataList's</code> ownership policy determines whether it will take ownership of the new elements. </p>

</div>
</div>
<a class="anchor" id="a32b3ec7e4346932f507bcd8a94bb7939"></a><!-- doxytag: member="ConstDataList::back" ref="a32b3ec7e4346932f507bcd8a94bb7939" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a>&lt; DL &gt;::<a class="el" href="../../d7/d05/classDataModel__detail_1_1ElementProxy.html">ElementProxy</a> <a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a>&lt; DL &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access the last element in the collection as an lvalue. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Proxy to the last element in the collection.</dd></dl>
<p>No checking is done to ensure that the container is not empty. Note that we return a proxy object rather than a reference; the proxy will handle deleting an owned element if it's assigned to. </p>

</div>
</div>
<a class="anchor" id="a1edb94e7a0cdb6c5be73eced7327537e"></a><!-- doxytag: member="ConstDataList::begin" ref="a1edb94e7a0cdb6c5be73eced7327537e" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a>&lt; DL &gt;::<a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a> <a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a>&lt; DL &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return an <code>iterator</code> pointing at the beginning of the collection. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>An <code>iterator</code>.</dd></dl>
<p>Note that dereferencing the iterator will yield a proxy rather than a reference; the proxy will handle deleting an owned element if it's assigned to. </p>

</div>
</div>
<a class="anchor" id="a31ee3602aa3eef896962945b7c667b44"></a><!-- doxytag: member="ConstDataList::end" ref="a31ee3602aa3eef896962945b7c667b44" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a>&lt; DL &gt;::<a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a> <a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a>&lt; DL &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return an <code>iterator</code> pointing past the end of the collection. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>An <code>iterator</code>.</dd></dl>
<p>Note that dereferencing the iterator will yield a proxy rather than a reference; the proxy will handle deleting an owned element if it's assigned to. </p>

</div>
</div>
<a class="anchor" id="af61ef0b84f1177c6d81e7face9e52fe7"></a><!-- doxytag: member="ConstDataList::erase" ref="af61ef0b84f1177c6d81e7face9e52fe7" args="(iterator first, iterator last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a>&lt; DL &gt;::<a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a> <a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a>&lt; DL &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove a range of elements. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>Iterator pointing to the first element to be removed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>last</em>&nbsp;</td><td>Iterator pointing one past the last element to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An iterator pointing to the element pointed to by <em>last</em> prior to erasing (or <code><a class="el" href="../../d3/d7c/classConstDataList.html#a31ee3602aa3eef896962945b7c667b44" title="Return an iterator pointing past the end of the collection.">end()</a></code>).</dd></dl>
<p>If the container owns its elements, then the removed elements will be deleted. Any duplicates will be removed in this process, but don't rely on this. </p>

</div>
</div>
<a class="anchor" id="aabafc4d3f83f205d63dab57c10792fbe"></a><!-- doxytag: member="ConstDataList::erase" ref="aabafc4d3f83f205d63dab57c10792fbe" args="(iterator position)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a>&lt; DL &gt;::<a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a> <a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a>&lt; DL &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove element at a given position. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>position</em>&nbsp;</td><td>Iterator pointing to the element to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An iterator pointing to the next element (or <code><a class="el" href="../../d3/d7c/classConstDataList.html#a31ee3602aa3eef896962945b7c667b44" title="Return an iterator pointing past the end of the collection.">end()</a></code>).</dd></dl>
<p>If the container owns its elements, then the pointed-to element will be deleted. </p>

</div>
</div>
<a class="anchor" id="acfdf1abac9c271dedf043a5921b09449"></a><!-- doxytag: member="ConstDataList::front" ref="acfdf1abac9c271dedf043a5921b09449" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a>&lt; DL &gt;::<a class="el" href="../../d7/d05/classDataModel__detail_1_1ElementProxy.html">ElementProxy</a> <a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a>&lt; DL &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access the first element in the collection as an lvalue. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Proxy to the first element in the collection.</dd></dl>
<p>No checking is done to ensure that the container is not empty. Note that we return a proxy object rather than a reference; the proxy will handle deleting an owned element if it's assigned to. </p>

</div>
</div>
<a class="anchor" id="a797d5d530929d4de6213cddfaf647129"></a><!-- doxytag: member="ConstDataList::insert" ref="a797d5d530929d4de6213cddfaf647129" args="(iterator position, InputIterator first, InputIterator last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DL &gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a>&lt; DL &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a group of new elements to the collection. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>position</em>&nbsp;</td><td>Iterator before which the element will be added. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>The start of the range to put in the container. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>last</em>&nbsp;</td><td>The end of the range to put in the container.</td></tr>
  </table>
  </dd>
</dl>
<p>The container's ownership policy will determine if it takes ownership of the new element.</p>
<p>Note: this method may only be called using the most derived <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a></code> in the hierarchy. </p>

</div>
</div>
<a class="anchor" id="a9fb7c36dbe43b9b18df9f0c01b72b710"></a><!-- doxytag: member="ConstDataList::insert" ref="a9fb7c36dbe43b9b18df9f0c01b72b710" args="(iterator position, value_type pElem)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a>&lt; DL &gt;::<a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a> <a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a>&lt; DL &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d3/d7c/classConstDataList.html#afbd8897e570093eb839750370fb1c904">value_type</a>&nbsp;</td>
          <td class="paramname"> <em>pElem</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a new element to the collection. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>position</em>&nbsp;</td><td>Iterator before which the element will be added. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pElem</em>&nbsp;</td><td>The element to add to the collection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An iterator that points to the inserted data.</dd></dl>
<p>The container's ownership policy will determine if it takes ownership of the new element.</p>
<p>Note: this method may only be called using the most derived <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a></code> in the hierarchy. </p>

</div>
</div>
<a class="anchor" id="a12cfc85b3bf78b3e09b1c42646a722f1"></a><!-- doxytag: member="ConstDataList::iter_swap" ref="a12cfc85b3bf78b3e09b1c42646a722f1" args="(iterator a, iterator b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a>&lt; DL &gt;::iter_swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swap the referents of two <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> iterators. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>The first iterator for the swap. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>The second iterator for the swap/ </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9d8161a3ce773260f6ad01da1c4dd583"></a><!-- doxytag: member="ConstDataList::merge" ref="a9d8161a3ce773260f6ad01da1c4dd583" args="(ConstDataList &amp;l, COMPARE predicate)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DL &gt; </div>
<div class="memtemplate">
template&lt;typename COMPARE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a>&lt; DL &gt;::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a>&lt; DL &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">COMPARE&nbsp;</td>
          <td class="paramname"> <em>predicate</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Merge sorted lists according to comparison function. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>Sorted list to merge. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>predicate</em>&nbsp;</td><td>Comparison function defining a sort order (which must be strictly weak ordering).</td></tr>
  </table>
  </dd>
</dl>
<p>Assumes that both <em>l</em> and this <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a></code> are sorted according to COMPARE predicate. Merges elements of <em>l</em> into this list in sorted order, leaving <em>l</em> empty when complete. Elements in this list precede elements in <em>x</em> that are equivalent according to StrictWeakOrdering(). </p>

</div>
</div>
<a class="anchor" id="aae112b3acc86d27dfd222bd9ada73c67"></a><!-- doxytag: member="ConstDataList::merge" ref="aae112b3acc86d27dfd222bd9ada73c67" args="(ConstDataList &amp;l)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a>&lt; DL &gt;::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a>&lt; DL &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>l</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Merge sorted lists. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>Sorted list to merge.</td></tr>
  </table>
  </dd>
</dl>
<p>Assumes that both <em>l</em> and this list are sorted according to <a class="el" href="../../d3/d7c/classConstDataList.html#a750bfd459a188b4a9ec969dc840d0af6" title="List ordering relation.">operator&lt;()</a>. Merges elements of <em>l</em> into this list in sorted order, leaving <em>l</em> empty when complete. Elements in this list precede elements in <em>l</em> that are equal. </p>

</div>
</div>
<a class="anchor" id="a750bfd459a188b4a9ec969dc840d0af6"></a><!-- doxytag: member="ConstDataList::operator&lt;" ref="a750bfd459a188b4a9ec969dc840d0af6" args="(const ConstDataList &amp;b) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a>&lt; DL &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a>&lt; DL &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>List ordering relation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td><a class="el" href="../../d4/dc4/structA.html">A</a> <code><a class="el" href="../../d3/d7c/classConstDataList.html" title="DataList adapter that acts like it holds const pointers.">ConstDataList</a></code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td><a class="el" href="../../d4/dc4/structA.html">A</a> <code><a class="el" href="../../d3/d7c/classConstDataList.html" title="DataList adapter that acts like it holds const pointers.">ConstDataList</a></code> of the same type as <em>x</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True iff <em>x</em> is lexicographically less than <em>y</em>.</dd></dl>
<p>This is a total ordering relation. It is linear in the size of the lists. Comparisons are done on the pointer values of the elements.</p>
<p>See <code>std::lexicographical_compare()</code> for how the determination is made. </p>

</div>
</div>
<a class="anchor" id="ad9251f196b1aebb16e047d7280b1823c"></a><!-- doxytag: member="ConstDataList::operator=" ref="ad9251f196b1aebb16e047d7280b1823c" args="(const ConstDataList &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a>&lt; DL &gt; &amp; <a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a>&lt; DL &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a>&lt; DL &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assignment operator. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>The <a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a> from which to assign. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>This object.</dd></dl>
<p>This is a `shallow' copy; after the completion of this, the <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a></code> will not own its elements. Any elements it owned prior to this call will be released.</p>
<p>Note: this method may only be called using the most derived <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a></code> in the hierarchy. </p>

</div>
</div>
<a class="anchor" id="affdee6e680364931593625b26f90ab6b"></a><!-- doxytag: member="ConstDataList::operator==" ref="affdee6e680364931593625b26f90ab6b" args="(const ConstDataList &amp;b) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a>&lt; DL &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a>&lt; DL &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>List equality comparison. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td><a class="el" href="../../d4/dc4/structA.html">A</a> <code><a class="el" href="../../d3/d7c/classConstDataList.html" title="DataList adapter that acts like it holds const pointers.">ConstDataList</a></code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td><a class="el" href="../../d4/dc4/structA.html">A</a> <code><a class="el" href="../../d3/d7c/classConstDataList.html" title="DataList adapter that acts like it holds const pointers.">ConstDataList</a></code> of the same type as <em>x</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True iff the size and elements of the lists are equal.</dd></dl>
<p>This is an equivalence relation. It is linear in the size of the lists. Lists are considered equivalent if their sizes are equal, and if corresponding elements compare equal. </p>

</div>
</div>
<a class="anchor" id="a998045e29b9246d5d4ee4b3576be63d0"></a><!-- doxytag: member="ConstDataList::push_back" ref="a998045e29b9246d5d4ee4b3576be63d0" args="(value_type pElem)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a>&lt; DL &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d7c/classConstDataList.html#afbd8897e570093eb839750370fb1c904">value_type</a>&nbsp;</td>
          <td class="paramname"> <em>pElem</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add an element to the end of the collection. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pElem</em>&nbsp;</td><td>The element to add to the collection.</td></tr>
  </table>
  </dd>
</dl>
<p>The container's ownership policy will determine if it takes ownership of the new element.</p>
<p>Note: this method may only be called using the most derived <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a></code> in the hierarchy. </p>

</div>
</div>
<a class="anchor" id="aeea2c88b84cbd273e03fb618b50bca73"></a><!-- doxytag: member="ConstDataList::push_front" ref="aeea2c88b84cbd273e03fb618b50bca73" args="(value_type pElem)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a>&lt; DL &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d7c/classConstDataList.html#afbd8897e570093eb839750370fb1c904">value_type</a>&nbsp;</td>
          <td class="paramname"> <em>pElem</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add an element at the beginning of the collection. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pElem</em>&nbsp;</td><td>The element to add to the collection.</td></tr>
  </table>
  </dd>
</dl>
<p>The container's ownership policy will determine if it takes ownership of the new element.</p>
<p>Note: this method may only be called using the most derived <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a></code> in the hierarchy. </p>

</div>
</div>
<a class="anchor" id="a16dc5885f7ce298aa50957e33b33cb7f"></a><!-- doxytag: member="ConstDataList::rbegin" ref="a16dc5885f7ce298aa50957e33b33cb7f" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a>&lt; DL &gt;::<a class="el" href="../../d3/d7c/classConstDataList.html#a028da3e06465b1480067d55a59cffdac">reverse_iterator</a> <a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a>&lt; DL &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a <code>reverse_iterator</code> pointing past the end of the collection. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="../../d4/dc4/structA.html">A</a> <code>reverse_iterator</code>.</dd></dl>
<p>Note that dereferencing the iterator will yield a proxy rather than a reference; the proxy will handle deleting an owned element if it's assigned to. </p>

</div>
</div>
<a class="anchor" id="a73653a365812f88e4ee5cd6eef1941c2"></a><!-- doxytag: member="ConstDataList::remove" ref="a73653a365812f88e4ee5cd6eef1941c2" args="(const value_type &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a>&lt; DL &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d7c/classConstDataList.html#afbd8897e570093eb839750370fb1c904">value_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove all elements equal to value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The value to remove.</td></tr>
  </table>
  </dd>
</dl>
<p>Removes every element in the list equal to <em>value</em>. Remaining elements stay in list order. </p>

</div>
</div>
<a class="anchor" id="a69f1437665f9f391e66741f7e6e3df2f"></a><!-- doxytag: member="ConstDataList::rend" ref="a69f1437665f9f391e66741f7e6e3df2f" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a>&lt; DL &gt;::<a class="el" href="../../d3/d7c/classConstDataList.html#a028da3e06465b1480067d55a59cffdac">reverse_iterator</a> <a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a>&lt; DL &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a <code>reverse_iterator</code> pointing at the beginning of the collection. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="../../d4/dc4/structA.html">A</a> <code>reverse_iterator</code>.</dd></dl>
<p>Note that dereferencing the iterator will yield a proxy rather than a reference; the proxy will handle deleting an owned element if it's assigned to. </p>

</div>
</div>
<a class="anchor" id="ad8df5a10d717e6ed3e686581fb8f2bf6"></a><!-- doxytag: member="ConstDataList::resortAux" ref="ad8df5a10d717e6ed3e686581fb8f2bf6" args="(iterator beg, iterator end)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a>&lt; DL &gt;::resortAux </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reset indices / reorder aux data after elements have been permuted. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>beg</em>&nbsp;</td><td>Start of the range of elements to process. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>End of the range of elements to process.</td></tr>
  </table>
  </dd>
</dl>
<p>This is a no-op for <code><a class="el" href="../../d3/d7c/classConstDataList.html" title="DataList adapter that acts like it holds const pointers.">ConstDataList</a></code>. </p>

</div>
</div>
<a class="anchor" id="a127d3469b64aa1f0566cb50851d1b954"></a><!-- doxytag: member="ConstDataList::splice" ref="a127d3469b64aa1f0566cb50851d1b954" args="(iterator position, ConstDataList &amp;l, iterator first, iterator last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a>&lt; DL &gt;::splice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a>&lt; DL &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert range from another list. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>position</em>&nbsp;</td><td>Iterator referencing the element to insert before. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>Source list. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>Iterator referencing the start of range in <em>l</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>last</em>&nbsp;</td><td>Iterator referencing the end of range in <em>l</em>.</td></tr>
  </table>
  </dd>
</dl>
<p>Removes elements in the range [<em>first</em>, <em>last</em> ) and inserts them before <em>position</em> in constant time.</p>
<p>Undefined if <em>position</em> is in [<em>first</em>, <em>last</em> ). </p>

</div>
</div>
<a class="anchor" id="aad90d48e222ba238ae112c88a1ab8c21"></a><!-- doxytag: member="ConstDataList::splice" ref="aad90d48e222ba238ae112c88a1ab8c21" args="(iterator position, ConstDataList &amp;l, iterator i)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a>&lt; DL &gt;::splice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a>&lt; DL &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>i</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert element from another list. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>position</em>&nbsp;</td><td>Iterator referencing the element to insert before. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>Source list. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>Iterator referencing the element to move.</td></tr>
  </table>
  </dd>
</dl>
<p>Removes the element in list <em>l</em> referenced by <em>i</em> and inserts it into the current list before <em>position</em>. </p>

</div>
</div>
<a class="anchor" id="a492b529115f5d654c41943b178d3ae57"></a><!-- doxytag: member="ConstDataList::splice" ref="a492b529115f5d654c41943b178d3ae57" args="(iterator position, ConstDataList &amp;l)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a>&lt; DL &gt;::splice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a>&lt; DL &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>l</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert contents of another list. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>position</em>&nbsp;</td><td>Iterator referencing the element to insert before. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>Source list.</td></tr>
  </table>
  </dd>
</dl>
<p>The elements of <em>l</em> are inserted in constant time in front of the element referenced by <em>position</em>. <em>l</em> becomes an empty list. </p>

</div>
</div>
<a class="anchor" id="a655f54075595ed86221b36b68a19d567"></a><!-- doxytag: member="ConstDataList::swap" ref="a655f54075595ed86221b36b68a19d567" args="(ConstDataList &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a>&lt; DL &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a>&lt; DL &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swap this collection with another. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>The collection with which to swap.</td></tr>
  </table>
  </dd>
</dl>
<p>Ownership is swapped along with the collection content.</p>
<p>Note: this method may only be called using the most-derived <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a></code> in the hierarchy. The <em>rhs</em> must also be referenced using the most-derived <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a></code>. </p>

</div>
</div>
<a class="anchor" id="a439d1898975457653b5e0e07f83d8de9"></a><!-- doxytag: member="ConstDataList::swapElement" ref="a439d1898975457653b5e0e07f83d8de9" args="(iterator pos, value_type newElem, reference oldElem)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList</a>&lt; DL &gt;::swapElement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d3/d7c/classConstDataList.html#afbd8897e570093eb839750370fb1c904">value_type</a>&nbsp;</td>
          <td class="paramname"> <em>newElem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reference&nbsp;</td>
          <td class="paramname"> <em>oldElem</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swap one element out of the container. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>The element in the container to swap. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newElem</em>&nbsp;</td><td>New element to put in the container. May be 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>oldElem</em>&nbsp;</td><td>Reference to receive the element removed from the container.</td></tr>
  </table>
  </dd>
</dl>
<p>Reference <em>oldElem</em> is initialized with element <em>pos</em> of the collection (no bounds checking). Then element <em>index</em> is set to <code>newElem</code>. If the collection owns its elements, then it will take ownership of <em>newElem</em> and release (without deleting) the element returned through <em>oldElem</em>.</p>
<p>Note: this method may only be called using the most derived <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a></code> in the hierarchy. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.29/AthContainers/AthContainers/<a class="el" href="../../db/ded/ConstDataList_8h_source.html">ConstDataList.h</a></li>
<li>/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.29/AthContainers/AthContainers/<a class="el" href="../../db/d38/ConstDataList_8icc.html">ConstDataList.icc</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 15 Apr 2017 for RootCore Packages by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
