<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>RootCore Packages: SG::AuxVectorBase Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="../../index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="../../search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="../../annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="../../classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="../../hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="../../functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="../../dd/d59/namespaceSG.html">SG</a>::<a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html">AuxVectorBase</a>
  </div>
</div>
<div class="contents">
<h1>SG::AuxVectorBase Class Reference</h1><!-- doxytag: class="SG::AuxVectorBase" --><!-- doxytag: inherits="SG::AuxVectorData" -->
<p>Manage index tracking and synchronization of auxiliary data.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d7/d18/AuxVectorBase_8h_source.html">AuxVectorBase.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SG::AuxVectorBase:</div>
<div class="dynsection">
 <div class="center">
  <img src="../../dd/da5/classSG_1_1AuxVectorBase.gif" usemap="#SG::AuxVectorBase_map" alt=""/>
  <map id="SG::AuxVectorBase_map" name="SG::AuxVectorBase_map">
<area href="../../db/dd6/classSG_1_1AuxVectorData.html" alt="SG::AuxVectorData" shape="rect" coords="0,0,264,24"/>
<area href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html" alt="DataVector&lt; T, DataModel_detail::NoBase &gt;" shape="rect" coords="0,112,264,136"/>
</map>
 </div>
</div>

<p><a href="../../dc/d39/classSG_1_1AuxVectorBase-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>ResortAuxHelper</b></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper to factor out template-independent part of <code>resortAux</code>. <br/></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html#a0393c7e87efbe788419774c662cba5a2">AuxVectorBase</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor.  <a href="#a0393c7e87efbe788419774c662cba5a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a863ff9b970004c403c1398d24b1f60e7"></a><!-- doxytag: member="SG::AuxVectorBase::~AuxVectorBase" ref="a863ff9b970004c403c1398d24b1f60e7" args="()" -->
virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html#a863ff9b970004c403c1398d24b1f60e7">~AuxVectorBase</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae905757bbac29e780e4010eaf52ea01e"></a><!-- doxytag: member="SG::AuxVectorBase::trackIndices" ref="ae905757bbac29e780e4010eaf52ea01e" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html#ae905757bbac29e780e4010eaf52ea01e">trackIndices</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if index tracking is enabled for this container. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html#aa21603645adb97780ff75af26630bfad">setStore</a> (const <a class="el" href="../../d3/dd5/classSG_1_1IConstAuxStore.html">SG::IConstAuxStore</a> *store)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the store associated with this object.  <a href="#aa21603645adb97780ff75af26630bfad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html#a58659470f0f2e27560cbe691eefce9c3">setStore</a> (<a class="el" href="../../dc/d05/classSG_1_1IAuxStore.html">SG::IAuxStore</a> *store)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the store associated with this object.  <a href="#a58659470f0f2e27560cbe691eefce9c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html#a2893a7ee3b1f5c7bc7d5cc5ce65d6e16">setStore</a> (const <a class="el" href="../../da/da2/classDataLink.html">DataLink</a>&lt; <a class="el" href="../../d3/dd5/classSG_1_1IConstAuxStore.html">SG::IConstAuxStore</a> &gt; &amp;store)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the store associated with this object.  <a href="#a2893a7ee3b1f5c7bc7d5cc5ce65d6e16"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html#a8223a5c9a9af0a9dbb8fc268cd0ea832">setConstStore</a> (const <a class="el" href="../../d3/dd5/classSG_1_1IConstAuxStore.html">SG::IConstAuxStore</a> *store)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Synonym for <code>setStore</code> with <code><a class="el" href="../../d3/dd5/classSG_1_1IConstAuxStore.html" title="Interface for const operations on an auxiliary store.">IConstAuxStore</a></code>.  <a href="#a8223a5c9a9af0a9dbb8fc268cd0ea832"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html#a4786cd7b376a4a33d840715f44b3d01f">setNonConstStore</a> (<a class="el" href="../../dc/d05/classSG_1_1IAuxStore.html">SG::IAuxStore</a> *store)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Synonym for <code>setStore</code> with <code><a class="el" href="../../dc/d05/classSG_1_1IAuxStore.html" title="Interface for non-const operations on an auxiliary store.">IAuxStore</a></code>.  <a href="#a4786cd7b376a4a33d840715f44b3d01f"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class DVL &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html#ae1de1c541f5642e2241a22c8d20fc9f5">initAuxVectorBase</a> (<a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">SG::OwnershipPolicy</a> ownPolicy, <a class="el" href="../../dd/d59/namespaceSG.html#a9f3d699f65390b7f8baf54d9cd634573">SG::IndexTrackingPolicy</a> indexTrackingPolicy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize index tracking mode.  <a href="#ae1de1c541f5642e2241a22c8d20fc9f5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html#a1413cec813bba2f0cba00cd3136e7131">swap</a> (<a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html">AuxVectorBase</a> &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swap with another container.  <a href="#a1413cec813bba2f0cba00cd3136e7131"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html#a235d711b1dc6ccd3147d1e55b6d9b2a9">setIndices</a> (ForwardIterator beg, ForwardIterator end, size_t first=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set container/index for all elements within a range.  <a href="#a235d711b1dc6ccd3147d1e55b6d9b2a9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html#adb19fc133c31c74e245d65646e8e99a6">clearIndex</a> (ForwardIterator elt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear the container / index for element <code>elt</code>.  <a href="#adb19fc133c31c74e245d65646e8e99a6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html#aea8774b45a413ba19af7709a03d80278">clearIndices</a> (ForwardIterator beg, ForwardIterator end)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear the container / index for a range of elements.  <a href="#aea8774b45a413ba19af7709a03d80278"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class DVL &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html#aab61a29d68cb3876b1e6a5f06b8320e2">resize</a> (size_t size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resize the aux data associated with this container.  <a href="#aab61a29d68cb3876b1e6a5f06b8320e2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class DVL &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html#ad2c7feb935ffe7cfc1b3a80d9ad4b414">reserve</a> (size_t size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change the capacity of the aux data associated with this container.  <a href="#ad2c7feb935ffe7cfc1b3a80d9ad4b414"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class DVL &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html#a1b5a71b56431f1010d8cdb846dd35bfa">shift</a> (DVL &amp;cont, size_t pos, ptrdiff_t offs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shift the elements of the container.  <a href="#a1b5a71b56431f1010d8cdb846dd35bfa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html#ad4be9ca08792014774acdd5218bd27a0">moveAux</a> (size_t index, <a class="el" href="../../dc/db0/classSG_1_1AuxElement.html">SG::AuxElement</a> *p, bool clear=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set index on an element and copy auxiliary data.  <a href="#ad4be9ca08792014774acdd5218bd27a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html#a8f4139a7242cdcce76a9cbff3bfd9ca2">moveAux</a> (size_t index, const void *p, bool clear=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set index on an element and copy auxiliary data.  <a href="#a8f4139a7242cdcce76a9cbff3bfd9ca2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html#a84fdf68a4d13674c4ff8da2534e98251">moveAux</a> (size_t index, ForwardIterator beg, ForwardIterator end)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set index on a range of elements and copy auxiliary data.  <a href="#a84fdf68a4d13674c4ff8da2534e98251"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html#a3105544a00e10c72e45ca7367bb43e87">swapElementsAux</a> (size_t aindex, size_t bindex, <a class="el" href="../../dc/db0/classSG_1_1AuxElement.html">SG::AuxElement</a> *a, <a class="el" href="../../dc/db0/classSG_1_1AuxElement.html">SG::AuxElement</a> *b, <a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html">AuxVectorBase</a> *bcont)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swap indices and auxiliary data between two elements.  <a href="#a3105544a00e10c72e45ca7367bb43e87"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html#a3e040f5014d7e5f77bfa8a1ae866dddc">swapElementsAux</a> (size_t aindex, size_t bindex, const void *a, const void *b, <a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html">AuxVectorBase</a> *bcont)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swap indices and auxiliary data between two elements.  <a href="#a3e040f5014d7e5f77bfa8a1ae866dddc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html#a2513e17b33c0b9715553416e19e23810">resortAux</a> (size_t index, ForwardIterator beg, ForwardIterator end)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset indices / reorder aux data after elements have been permuted.  <a href="#a2513e17b33c0b9715553416e19e23810"></a><br/></td></tr>
<tr><td colspan="2"><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59270f0234bd8fc66a0ee5e564556bc1"></a><!-- doxytag: member="SG::AuxVectorBase::ResortAuxHelper" ref="a59270f0234bd8fc66a0ee5e564556bc1" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>ResortAuxHelper</b></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Manage index tracking and synchronization of auxiliary data. </p>
<p>An object, usually a <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code>, can have vectors of auxiliary data associated with it. In order to be able to find the auxiliary data for a given container element, the elements must hold their indices within the container (done by the <code><a class="el" href="../../dc/db0/classSG_1_1AuxElement.html" title="Base class for elements of a container that can have aux data.">AuxElement</a></code> class).</p>
<p>When the container changes, this information must be updated. Indices need to be changed, and corresponding changes need to be made in the vectors of associated auxiliary data. Most of the code in this class consists of helpers that effect these changes. These are intended to be called only by the deriving container class.</p>
<p>This class also contains a flag to control whether or not indices should be tracked like this. This is controlled by the type of the payload and by the selected ownership and indexing policies.</p>
<p>If the payload type does not derive from <code><a class="el" href="../../dc/db0/classSG_1_1AuxElement.html" title="Base class for elements of a container that can have aux data.">SG::AuxElement</a></code>, then no index tracking is possible, and the flag is always false.</p>
<p>Otherwise, it depends on the setting of the policies. The default value for the index tracking policy is DEFAULT_TRACK_INDICES. In that case, we track indices if this container owns its elements (OWN_ELEMENTS) and we don't if the container does not down its elements (VIEW_ELEMENTS). This is the usual case. However, the index tracking policy may also be set to ALWAYS_TRACK_INDICES or NEVER_TRACK_INDICES to override this. (The major foreseen use case for this is to allow index tracking for a view container populated with objects allocated from a <code>DataPool</code>.)</p>
<p>The derived container should initialize this class by calling <code>initAuxVectorBase</code>. The derived container class is passed as a template argument; the ownership and index tracking policies are also passed. This method can be called again if the policies change.</p>
<p>There are only a couple user-callable methods. The <code>trackIndices</code> method returns the current state of the index tracking flag. There are also wrappers for <code>setStore</code> method, which enforce the condition that one can't set a store for a container that does not do index tracking.</p>
<p>The remaining methods are intended to be called only from the derived container class (and thus they are declared as protected). Besides a <code>swap</code> method, these include</p>
<ul>
<li><code>setIndices</code>, to reset the indices within a range to sequential values.</li>
<li><code>clearIndex</code>, to clear the index / container for a single element.</li>
<li><code>clearIndices</code>, to clear the index / container for elements within a range.</li>
<li><code>resize</code>, to change the size of the aux data.</li>
<li><code>reserve</code>, to change the capacity of the aux data.</li>
<li><code>shift</code>, to shift a range of aux data up or down, to track insertions or deletions from within the container.</li>
<li><code>moveAux</code>, to be used when an element or range of elements is moved into the container.</li>
<li><code>swapElementsAux</code>, to swap aux data for two elements, possibly in different containers.</li>
<li><code>resortAux</code>, to rearrange indices and aux data correctly after an operation that permuted the elements of the container. </li>
</ul>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a0393c7e87efbe788419774c662cba5a2"></a><!-- doxytag: member="SG::AuxVectorBase::AuxVectorBase" ref="a0393c7e87efbe788419774c662cba5a2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SG::AuxVectorBase::AuxVectorBase </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default constructor. </p>
<p>This will disable index tracking by default. The constructor should be followed by a call to <code>initAuxVectorBase</code>. (This is separated from the constructor because calling non-default constructors of <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> base classes can be awkward in the case of virtual derivation.) </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="adb19fc133c31c74e245d65646e8e99a6"></a><!-- doxytag: member="SG::AuxVectorBase::clearIndex" ref="adb19fc133c31c74e245d65646e8e99a6" args="(ForwardIterator elt)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SG::AuxVectorBase::clearIndex </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&nbsp;</td>
          <td class="paramname"> <em>elt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clear the container / index for element <code>elt</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>elt</em>&nbsp;</td><td>Iterator to the element to clear.</td></tr>
  </table>
  </dd>
</dl>
<p><code>ForwardIterator</code> should be an iterator over the <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> (not a base iterator). </p>

</div>
</div>
<a class="anchor" id="aea8774b45a413ba19af7709a03d80278"></a><!-- doxytag: member="SG::AuxVectorBase::clearIndices" ref="aea8774b45a413ba19af7709a03d80278" args="(ForwardIterator beg, ForwardIterator end)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SG::AuxVectorBase::clearIndices </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&nbsp;</td>
          <td class="paramname"> <em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clear the container / index for a range of elements. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>beg</em>&nbsp;</td><td>Beginning of the range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>End of the range.</td></tr>
  </table>
  </dd>
</dl>
<p><code>ForwardIterator</code> should be an iterator over the <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> (not a base iterator). </p>

</div>
</div>
<a class="anchor" id="ae1de1c541f5642e2241a22c8d20fc9f5"></a><!-- doxytag: member="SG::AuxVectorBase::initAuxVectorBase" ref="ae1de1c541f5642e2241a22c8d20fc9f5" args="(SG::OwnershipPolicy ownPolicy, SG::IndexTrackingPolicy indexTrackingPolicy)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DVL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SG::AuxVectorBase::initAuxVectorBase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">SG::OwnershipPolicy</a>&nbsp;</td>
          <td class="paramname"> <em>ownPolicy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d59/namespaceSG.html#a9f3d699f65390b7f8baf54d9cd634573">SG::IndexTrackingPolicy</a>&nbsp;</td>
          <td class="paramname"> <em>indexTrackingPolicy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize index tracking mode. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ownPolicy</em>&nbsp;</td><td>The container ownership policy. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>indexTrackingPolicy</em>&nbsp;</td><td>The requested index tracking policy.</td></tr>
  </table>
  </dd>
</dl>
<p>DVL should be the most-derived class for this container.</p>
<p>This handles the logic for setting the state of index tracking. If this container does not handle aux data, then index tracking is always off. Otherwise, it depends on the requested policies. In any case, it is an error to turn off index tracking for a container that has an associated aux store. </p>

</div>
</div>
<a class="anchor" id="a84fdf68a4d13674c4ff8da2534e98251"></a><!-- doxytag: member="SG::AuxVectorBase::moveAux" ref="a84fdf68a4d13674c4ff8da2534e98251" args="(size_t index, ForwardIterator beg, ForwardIterator end)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SG::AuxVectorBase::moveAux </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&nbsp;</td>
          <td class="paramname"> <em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set index on a range of elements and copy auxiliary data. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>Container index at which the first new element is being added. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>beg</em>&nbsp;</td><td>The start of the range of new elements. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>The end of the range of new elements.</td></tr>
  </table>
  </dd>
</dl>
<p>The elements in the range are being a added to the container at <code>index</code>. If the new elements have associated auxiliary data, copy it to the container starting at <code>index</code>. Then set the container / index on the elements in the range.</p>
<p><code>ForwardIterator</code> should be an iterator over the <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> (not a base iterator). </p>

</div>
</div>
<a class="anchor" id="a8f4139a7242cdcce76a9cbff3bfd9ca2"></a><!-- doxytag: member="SG::AuxVectorBase::moveAux" ref="a8f4139a7242cdcce76a9cbff3bfd9ca2" args="(size_t index, const void *p, bool clear=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SG::AuxVectorBase::moveAux </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>clear</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set index on an element and copy auxiliary data. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>Container index at which the new element is being added. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>The new element being added. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clear</em>&nbsp;</td><td>If true, then any auxiliary data initially associated with <code>p</code> are cleared after being copied.</td></tr>
  </table>
  </dd>
</dl>
<p>Overload for the no-auxdata case. </p>

</div>
</div>
<a class="anchor" id="ad4be9ca08792014774acdd5218bd27a0"></a><!-- doxytag: member="SG::AuxVectorBase::moveAux" ref="ad4be9ca08792014774acdd5218bd27a0" args="(size_t index, SG::AuxElement *p, bool clear=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SG::AuxVectorBase::moveAux </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/db0/classSG_1_1AuxElement.html">SG::AuxElement</a> *&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>clear</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set index on an element and copy auxiliary data. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>Container index at which the new element is being added. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>The new element being added. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clear</em>&nbsp;</td><td>If true, then any auxiliary data initially associated with <code>p</code> are cleared after being copied.</td></tr>
  </table>
  </dd>
</dl>
<p>Element <code>p</code> is being added to the container at <code>index</code>. If <code>p</code> has associated auxiliary data, copy it to the container at <code>index</code>. Then set the container / index on <code>p</code>. </p>

</div>
</div>
<a class="anchor" id="ad2c7feb935ffe7cfc1b3a80d9ad4b414"></a><!-- doxytag: member="SG::AuxVectorBase::reserve" ref="ad2c7feb935ffe7cfc1b3a80d9ad4b414" args="(size_t size)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DVL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SG::AuxVectorBase::reserve </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change the capacity of the aux data associated with this container. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The new container size.</td></tr>
  </table>
  </dd>
</dl>
<p>DVL should be the most-derived class for this container. </p>

</div>
</div>
<a class="anchor" id="aab61a29d68cb3876b1e6a5f06b8320e2"></a><!-- doxytag: member="SG::AuxVectorBase::resize" ref="aab61a29d68cb3876b1e6a5f06b8320e2" args="(size_t size)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DVL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SG::AuxVectorBase::resize </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resize the aux data associated with this container. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The new container size.</td></tr>
  </table>
  </dd>
</dl>
<p>DVL should be the most-derived class for this container. </p>

</div>
</div>
<a class="anchor" id="a2513e17b33c0b9715553416e19e23810"></a><!-- doxytag: member="SG::AuxVectorBase::resortAux" ref="a2513e17b33c0b9715553416e19e23810" args="(size_t index, ForwardIterator beg, ForwardIterator end)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SG::AuxVectorBase::resortAux </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&nbsp;</td>
          <td class="paramname"> <em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reset indices / reorder aux data after elements have been permuted. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>Index in the container of the start of the range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>beg</em>&nbsp;</td><td>Start of the range of elements to process. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>End of the range of elements to process.</td></tr>
  </table>
  </dd>
</dl>
<p>Call this after some operation that has permuted the elements in the container (such as sort). The index information in the elements will be used to permute all auxiliary data in the same way. Finally, all the indices will be reset in the correct order.</p>
<p><code>ForwardIterator</code> should be an iterator over the <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> (not a base iterator). </p>

</div>
</div>
<a class="anchor" id="a8223a5c9a9af0a9dbb8fc268cd0ea832"></a><!-- doxytag: member="SG::AuxVectorBase::setConstStore" ref="a8223a5c9a9af0a9dbb8fc268cd0ea832" args="(const SG::IConstAuxStore *store)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SG::AuxVectorBase::setConstStore </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/dd5/classSG_1_1IConstAuxStore.html">SG::IConstAuxStore</a> *&nbsp;</td>
          <td class="paramname"> <em>store</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Synonym for <code>setStore</code> with <code><a class="el" href="../../d3/dd5/classSG_1_1IConstAuxStore.html" title="Interface for const operations on an auxiliary store.">IConstAuxStore</a></code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>store</em>&nbsp;</td><td>The new store. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a235d711b1dc6ccd3147d1e55b6d9b2a9"></a><!-- doxytag: member="SG::AuxVectorBase::setIndices" ref="a235d711b1dc6ccd3147d1e55b6d9b2a9" args="(ForwardIterator beg, ForwardIterator end, size_t first=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SG::AuxVectorBase::setIndices </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&nbsp;</td>
          <td class="paramname"> <em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&nbsp;</td>
          <td class="paramname"> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>first</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set container/index for all elements within a range. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>beg</em>&nbsp;</td><td>Beginning of the range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>End of the range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>Index to set for the first element in the range.</td></tr>
  </table>
  </dd>
</dl>
<p>For all elements in the range, the container will be set to this container, and indices will be set sequentially, starting with <code>first</code>.</p>
<p><code>ForwardIterator</code> should be an iterator over the <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> (not a base iterator). </p>

</div>
</div>
<a class="anchor" id="a4786cd7b376a4a33d840715f44b3d01f"></a><!-- doxytag: member="SG::AuxVectorBase::setNonConstStore" ref="a4786cd7b376a4a33d840715f44b3d01f" args="(SG::IAuxStore *store)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SG::AuxVectorBase::setNonConstStore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d05/classSG_1_1IAuxStore.html">SG::IAuxStore</a> *&nbsp;</td>
          <td class="paramname"> <em>store</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Synonym for <code>setStore</code> with <code><a class="el" href="../../dc/d05/classSG_1_1IAuxStore.html" title="Interface for non-const operations on an auxiliary store.">IAuxStore</a></code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>store</em>&nbsp;</td><td>The new store. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2893a7ee3b1f5c7bc7d5cc5ce65d6e16"></a><!-- doxytag: member="SG::AuxVectorBase::setStore" ref="a2893a7ee3b1f5c7bc7d5cc5ce65d6e16" args="(const DataLink&lt; SG::IConstAuxStore &gt; &amp;store)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SG::AuxVectorBase::setStore </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/da2/classDataLink.html">DataLink</a>&lt; <a class="el" href="../../d3/dd5/classSG_1_1IConstAuxStore.html">SG::IConstAuxStore</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>store</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the store associated with this object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>store</em>&nbsp;</td><td>The new store.</td></tr>
  </table>
  </dd>
</dl>
<p>This will clear the non-const store pointer, and also clear the cache.</p>
<p>It is an error to set a store for a container for which index tracking is disabled. That will raise an <code><a class="el" href="../../d4/d77/classSG_1_1ExcUntrackedSetStore.html" title="Exception --- Attempt to set aux data store on container that doesn&#39;t track indices...">ExcUntrackedSetStore</a></code> exception. </p>

<p>Reimplemented from <a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#a49c013e89eb83e984483ee34fc91d68c">SG::AuxVectorData</a>.</p>

</div>
</div>
<a class="anchor" id="a58659470f0f2e27560cbe691eefce9c3"></a><!-- doxytag: member="SG::AuxVectorBase::setStore" ref="a58659470f0f2e27560cbe691eefce9c3" args="(SG::IAuxStore *store)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SG::AuxVectorBase::setStore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d05/classSG_1_1IAuxStore.html">SG::IAuxStore</a> *&nbsp;</td>
          <td class="paramname"> <em>store</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the store associated with this object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>store</em>&nbsp;</td><td>The new store.</td></tr>
  </table>
  </dd>
</dl>
<p>This will set both the const and non-const store pointers, and also clear the cache.</p>
<p>It is an error to set a store for a container for which index tracking is disabled. That will raise an <code><a class="el" href="../../d4/d77/classSG_1_1ExcUntrackedSetStore.html" title="Exception --- Attempt to set aux data store on container that doesn&#39;t track indices...">ExcUntrackedSetStore</a></code> exception. </p>

<p>Reimplemented from <a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#a1980ceb02ed996944d1f2508d128d91c">SG::AuxVectorData</a>.</p>

</div>
</div>
<a class="anchor" id="aa21603645adb97780ff75af26630bfad"></a><!-- doxytag: member="SG::AuxVectorBase::setStore" ref="aa21603645adb97780ff75af26630bfad" args="(const SG::IConstAuxStore *store)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SG::AuxVectorBase::setStore </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/dd5/classSG_1_1IConstAuxStore.html">SG::IConstAuxStore</a> *&nbsp;</td>
          <td class="paramname"> <em>store</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the store associated with this object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>store</em>&nbsp;</td><td>The new store.</td></tr>
  </table>
  </dd>
</dl>
<p>This will clear the non-const store pointer, and also clear the cache.</p>
<p>It is an error to set a store for a container for which index tracking is disabled. That will raise an <code><a class="el" href="../../d4/d77/classSG_1_1ExcUntrackedSetStore.html" title="Exception --- Attempt to set aux data store on container that doesn&#39;t track indices...">ExcUntrackedSetStore</a></code> exception. </p>

<p>Reimplemented from <a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#af6e2da3c14ea74935120cd1b5a37f021">SG::AuxVectorData</a>.</p>

</div>
</div>
<a class="anchor" id="a1b5a71b56431f1010d8cdb846dd35bfa"></a><!-- doxytag: member="SG::AuxVectorBase::shift" ref="a1b5a71b56431f1010d8cdb846dd35bfa" args="(DVL &amp;cont, size_t pos, ptrdiff_t offs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DVL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SG::AuxVectorBase::shift </td>
          <td>(</td>
          <td class="paramtype">DVL &amp;&nbsp;</td>
          <td class="paramname"> <em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&nbsp;</td>
          <td class="paramname"> <em>offs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Shift the elements of the container. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cont</em>&nbsp;</td><td>The container that's being shifted. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>The starting index for the shift. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offs</em>&nbsp;</td><td>The (signed) amount of the shift.</td></tr>
  </table>
  </dd>
</dl>
<p>The container should be the derived container. The elements in the container should have already been shifted; this operation will then adjust the element indices and also shift the elements in the vectors for all aux data items. <code>offs</code> may be either positive or negative.</p>
<p>If <code>offs</code> is positive, then the container is growing. The container size should be increased by <code>offs</code>, the element at <code>pos</code> moved to <code>pos</code> + <code>offs</code>, and similarly for following elements. The elements between <code>pos</code> and <code>pos</code> + <code>offs</code> should be default-initialized.</p>
<p>If <code>offs</code> is negative, then the container is shrinking. The element at <code>pos</code> should be moved to <code>pos</code> + <code>offs</code>, and similarly for following elements. The container should then be shrunk by <code>-offs</code> elements (running destructors as appropriate). </p>

</div>
</div>
<a class="anchor" id="a1413cec813bba2f0cba00cd3136e7131"></a><!-- doxytag: member="SG::AuxVectorBase::swap" ref="a1413cec813bba2f0cba00cd3136e7131" args="(AuxVectorBase &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SG::AuxVectorBase::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html">AuxVectorBase</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swap with another container. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>other</em>&nbsp;</td><td>The container with which to swap. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#aea4d64e4a85beda13d1243ece5d210e2">SG::AuxVectorData</a>.</p>

</div>
</div>
<a class="anchor" id="a3e040f5014d7e5f77bfa8a1ae866dddc"></a><!-- doxytag: member="SG::AuxVectorBase::swapElementsAux" ref="a3e040f5014d7e5f77bfa8a1ae866dddc" args="(size_t aindex, size_t bindex, const void *a, const void *b, AuxVectorBase *bcont)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SG::AuxVectorBase::swapElementsAux </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>aindex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>bindex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html">AuxVectorBase</a> *&nbsp;</td>
          <td class="paramname"> <em>bcont</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swap indices and auxiliary data between two elements. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aindex</em>&nbsp;</td><td>Index of the first element, in this container. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bindex</em>&nbsp;</td><td>Index of the second element, in <code>bcont</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>Pointer to the first element. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>Pointer to the second element. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bcont</em>&nbsp;</td><td>Container holding the second element. (May be the same as this, but doesn't have to be.)</td></tr>
  </table>
  </dd>
</dl>
<p>This is the no-auxdata case; it is a no-op except for checking <code>m_trackIndices</code>. </p>

</div>
</div>
<a class="anchor" id="a3105544a00e10c72e45ca7367bb43e87"></a><!-- doxytag: member="SG::AuxVectorBase::swapElementsAux" ref="a3105544a00e10c72e45ca7367bb43e87" args="(size_t aindex, size_t bindex, SG::AuxElement *a, SG::AuxElement *b, AuxVectorBase *bcont)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SG::AuxVectorBase::swapElementsAux </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>aindex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>bindex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/db0/classSG_1_1AuxElement.html">SG::AuxElement</a> *&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/db0/classSG_1_1AuxElement.html">SG::AuxElement</a> *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html">AuxVectorBase</a> *&nbsp;</td>
          <td class="paramname"> <em>bcont</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swap indices and auxiliary data between two elements. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aindex</em>&nbsp;</td><td>Index of the first element, in this container. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bindex</em>&nbsp;</td><td>Index of the second element, in <code>bcont</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>Pointer to the first element. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>Pointer to the second element. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bcont</em>&nbsp;</td><td>Container holding the second element. (May be the same as this, but doesn't have to be.)</td></tr>
  </table>
  </dd>
</dl>
<p>Elements <code>a</code> at <code>aindex</code> in <code>this</code> and <code>b</code> at <code>bindex</code> in <code>bcont</code> are being swapped. Swap the index / container references between the elements and also swap the auxiliary data if it exists. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.30/AthContainers/AthContainers/<a class="el" href="../../d7/d18/AuxVectorBase_8h_source.html">AuxVectorBase.h</a></li>
<li>/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.30/AthContainers/AthContainers/<a class="el" href="../../d4/d50/AuxVectorBase_8icc.html">AuxVectorBase.icc</a></li>
<li>/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.30/AthContainers/Root/AuxVectorBase.cxx</li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 15 Apr 2017 for RootCore Packages by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
