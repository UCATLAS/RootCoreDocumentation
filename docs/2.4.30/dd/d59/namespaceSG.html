<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>RootCore Packages: SG Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="../../index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="../../search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="../../namespaces.html"><span>Namespace&nbsp;List</span></a></li>
      <li><a href="../../namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>SG Namespace Reference</h1>
<p>Constructor from a payload object.  
<a href="#_details">More...</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/db0/classSG_1_1AuxElement.html">AuxElement</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class for elements of a container that can have aux data.  <a href="../../dc/db0/classSG_1_1AuxElement.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbd/classSG_1_1AuxElementComplete.html">AuxElementComplete</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrapper to automatically create a private store for an element.  <a href="../../df/dbd/classSG_1_1AuxElementComplete.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d1c/classSG_1_1AuxStoreInternal.html">AuxStoreInternal</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An auxiliary data store that holds data internally.  <a href="../../d1/d1c/classSG_1_1AuxStoreInternal.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d55/classSG_1_1AuxStoreStandalone.html">AuxStoreStandalone</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Auxiliary data store for standalone objects.  <a href="../../dd/d55/classSG_1_1AuxStoreStandalone.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d33/classSG_1_1AuxTypeRegistry.html">AuxTypeRegistry</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Handle mappings between names and auxid_t.  <a href="../../db/d33/classSG_1_1AuxTypeRegistry.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html">AuxVectorBase</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Manage index tracking and synchronization of auxiliary data.  <a href="../../dd/da5/classSG_1_1AuxVectorBase.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html">AuxVectorData</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Manage lookup of vectors of auxiliary data.  <a href="../../db/dd6/classSG_1_1AuxVectorData.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d27/classSG_1_1DVLConstDataListBucket.html">DVLConstDataListBucket</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><code><a class="el" href="../../d7/d54/classSG_1_1DataBucket.html">DataBucket</a></code> class for <code><a class="el" href="../../d3/d7c/classConstDataList.html" title="DataList adapter that acts like it holds const pointers.">ConstDataList</a></code>.  <a href="../../de/d27/classSG_1_1DVLConstDataListBucket.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dfa/structSG_1_1DataBucketTrait_3_01ConstDataList_3_01T_01_4_00_01U_01_4.html">DataBucketTrait&lt; ConstDataList&lt; T &gt;, U &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Metafunction to find the proper <code><a class="el" href="../../d7/d54/classSG_1_1DataBucket.html">DataBucket</a></code> class for the first template argument.  <a href="../../d7/dfa/structSG_1_1DataBucketTrait_3_01ConstDataList_3_01T_01_4_00_01U_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d43/classSG_1_1BaseInfo_3_01ConstDataList_3_01T_01_4_01_4.html">BaseInfo&lt; ConstDataList&lt; T &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Let the <code>BaseInfo</code> for <code><a class="el" href="../../d3/d7c/classConstDataList.html" title="DataList adapter that acts like it holds const pointers.">ConstDataList</a></code> forward to that of the base <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a></code>.  <a href="../../da/d43/classSG_1_1BaseInfo_3_01ConstDataList_3_01T_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d46/classSG_1_1DVLConstDataVectorBucket.html">DVLConstDataVectorBucket</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><code><a class="el" href="../../d7/d54/classSG_1_1DataBucket.html">DataBucket</a></code> class for <code><a class="el" href="../../de/db1/classConstDataVector.html" title="DataVector adapter that acts like it holds const pointers.">ConstDataVector</a></code>.  <a href="../../d3/d46/classSG_1_1DVLConstDataVectorBucket.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d86/structSG_1_1DataBucketTrait_3_01ConstDataVector_3_01DV_01_4_00_01U_01_4.html">DataBucketTrait&lt; ConstDataVector&lt; DV &gt;, U &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Metafunction to find the proper <code><a class="el" href="../../d7/d54/classSG_1_1DataBucket.html">DataBucket</a></code> class for the first template argument.  <a href="../../d6/d86/structSG_1_1DataBucketTrait_3_01ConstDataVector_3_01DV_01_4_00_01U_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dc5/classSG_1_1BaseInfo_3_01ConstDataVector_3_01DV_01_4_01_4.html">BaseInfo&lt; ConstDataVector&lt; DV &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Let the <code>BaseInfo</code> for <code><a class="el" href="../../de/db1/classConstDataVector.html" title="DataVector adapter that acts like it holds const pointers.">ConstDataVector</a></code> forward to that of the base <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code>.  <a href="../../d4/dc5/classSG_1_1BaseInfo_3_01ConstDataVector_3_01DV_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d34/structSG_1_1DataBucketTrait_3_01DataList_3_01T_01_4_00_01U_01_4.html">DataBucketTrait&lt; DataList&lt; T &gt;, U &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Metafunction to find the proper <code><a class="el" href="../../d7/d54/classSG_1_1DataBucket.html">DataBucket</a></code> class for <code><a class="el" href="../../d1/def/classT.html">T</a></code>.  <a href="../../dc/d34/structSG_1_1DataBucketTrait_3_01DataList_3_01T_01_4_00_01U_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d25/structSG_1_1DataBucketTrait_3_01DataVector_3_01T_01_4_00_01U_01_4.html">DataBucketTrait&lt; DataVector&lt; T &gt;, U &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Metafunction to find the proper <code><a class="el" href="../../d7/d54/classSG_1_1DataBucket.html">DataBucket</a></code> class for <code><a class="el" href="../../d1/def/classT.html">T</a></code>.  <a href="../../d2/d25/structSG_1_1DataBucketTrait_3_01DataVector_3_01T_01_4_00_01U_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d45/classSG_1_1ExcNoAuxStore.html">ExcNoAuxStore</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception --- Aux data requested from object with no store.  <a href="../../d0/d45/classSG_1_1ExcNoAuxStore.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/da7/classSG_1_1ExcBadAuxVar.html">ExcBadAuxVar</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception --- Attempt to retrieve nonexistent aux data item.  <a href="../../d8/da7/classSG_1_1ExcBadAuxVar.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/ddd/classSG_1_1ExcConstAuxData.html">ExcConstAuxData</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception --- Non-const operation performed on const aux data.  <a href="../../da/ddd/classSG_1_1ExcConstAuxData.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d77/classSG_1_1ExcUntrackedSetStore.html">ExcUntrackedSetStore</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception --- Attempt to set aux data store on container that doesn't track indices, or disable index tracking for a container with aux data.  <a href="../../d4/d77/classSG_1_1ExcUntrackedSetStore.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/ded/classSG_1_1ExcBadPrivateStore.html">ExcBadPrivateStore</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception --- Bad use of private store.  <a href="../../d8/ded/classSG_1_1ExcBadPrivateStore.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d74/classSG_1_1ExcAuxTypeMismatch.html">ExcAuxTypeMismatch</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception --- Type mismatch for aux variable.  <a href="../../df/d74/classSG_1_1ExcAuxTypeMismatch.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dde/classSG_1_1ExcInsertionInBaseClass.html">ExcInsertionInBaseClass</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception --- Attempted to do OP on a BASE base class of COMPLETE; can only be done on the most-derived class.  <a href="../../df/dde/classSG_1_1ExcInsertionInBaseClass.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d41/classSG_1_1ExcStoreLocked.html">ExcStoreLocked</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception --- Attempted to modify auxiliary data in a locked store.  <a href="../../d5/d41/classSG_1_1ExcStoreLocked.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/db6/classSG_1_1ExcNonowningContainer.html">ExcNonowningContainer</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception --- Attempted to insert a unique_ptr to a non-owning container.  <a href="../../db/db6/classSG_1_1ExcNonowningContainer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d63/classSG_1_1ExcUnknownAuxItem.html">ExcUnknownAuxItem</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception --- Unknown aux data item.  <a href="../../d9/d63/classSG_1_1ExcUnknownAuxItem.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d01/classSG_1_1PackedContainer.html">PackedContainer</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Container to hold aux data to be stored in a packed form.  <a href="../../dd/d01/classSG_1_1PackedContainer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dd6/structSG_1_1inner__type.html">inner_type</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Metafunction to extract the innermost element type from a nested vector type.  <a href="../../d6/dd6/structSG_1_1inner__type.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/db2/structSG_1_1inner__type_3_01std_1_1vector_3_01T_01_4_01_4.html">inner_type&lt; std::vector&lt; T &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d4e/classSG_1_1PackedConverter.html">PackedConverter</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper for packing/unpacking a <code><a class="el" href="../../dd/d01/classSG_1_1PackedContainer.html" title="Container to hold aux data to be stored in a packed form.">PackedContainer</a></code> to/from a stream.  <a href="../../d9/d4e/classSG_1_1PackedConverter.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc1/classSG_1_1PackedParameters.html">PackedParameters</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Describe how the contents of a <code><a class="el" href="../../dd/d01/classSG_1_1PackedContainer.html" title="Container to hold aux data to be stored in a packed form.">PackedContainer</a></code> are to be saved.  <a href="../../d5/dc1/classSG_1_1PackedParameters.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6e/classSG_1_1AuxDataTraits.html">AuxDataTraits</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allow customizing how aux data types are treated.  <a href="../../d0/d6e/classSG_1_1AuxDataTraits.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d97/classSG_1_1AuxDataTraits_3_01bool_01_4.html">AuxDataTraits&lt; bool &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allow customizing how aux data types are treated.  <a href="../../de/d97/classSG_1_1AuxDataTraits_3_01bool_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d68/classSG_1_1AuxTypeVector.html">AuxTypeVector</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of <code><a class="el" href="../../de/d12/classSG_1_1IAuxTypeVector.html" title="Abstract interface for manipulating vectors of arbitrary types.">IAuxTypeVector</a></code> for specific types.  <a href="../../d5/d68/classSG_1_1AuxTypeVector.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d8c/classSG_1_1AuxTypeVectorFactory.html">AuxTypeVectorFactory</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory objects that creates vectors using <code><a class="el" href="../../d5/d68/classSG_1_1AuxTypeVector.html" title="Implementation of IAuxTypeVector for specific types.">AuxTypeVector</a></code>.  <a href="../../d6/d8c/classSG_1_1AuxTypeVectorFactory.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d33/classSG_1_1DVLDataBucket.html">DVLDataBucket</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="../../d4/dc4/structA.html">A</a> <code><a class="el" href="../../d7/d54/classSG_1_1DataBucket.html">DataBucket</a></code> specialized for <code>DataVector/<code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a></code>.</code>  <a href="../../d6/d33/classSG_1_1DVLDataBucket.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d76/classSG_1_1IsMostDerivedFlag.html">IsMostDerivedFlag</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Holder for the is-most-derived flag.  <a href="../../df/d76/classSG_1_1IsMostDerivedFlag.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dfb/classSG_1_1AuxElementData.html">AuxElementData</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal data container.  <a href="../../dc/dfb/classSG_1_1AuxElementData.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d62/classSG_1_1AuxElementPrivateData.html">AuxElementPrivateData</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal data container for private store.  <a href="../../da/d62/classSG_1_1AuxElementPrivateData.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dde/classSG_1_1AuxElementStandaloneData.html">AuxElementStandaloneData</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal data container for standalone store.  <a href="../../d5/dde/classSG_1_1AuxElementStandaloneData.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db7/classSG_1_1PackedContainerStreamer.html">PackedContainerStreamer</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Streamer for reading/writing <a class="el" href="../../dd/d01/classSG_1_1PackedContainer.html" title="Container to hold aux data to be stored in a packed form.">SG::PackedContainer</a> instances.  <a href="../../d5/db7/classSG_1_1PackedContainerStreamer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/db3/classSG_1_1AuxVectorBase__test.html">AuxVectorBase_test</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d6d/structSG_1_1AuxStore__traits_3_01std_1_1vector_3_01B_01_5_01_4_01_4.html">AuxStore_traits&lt; std::vector&lt; B * &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d93/structSG_1_1AuxStore__traits_3_01std_1_1vector_3_01C_01_5_01_4_01_4.html">AuxStore_traits&lt; std::vector&lt; C * &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d8d/classSG_1_1AuxVectorData__test.html">AuxVectorData_test</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d31/classSG_1_1AuxDataOption.html">AuxDataOption</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Hold information about an option setting request.  <a href="../../d7/d31/classSG_1_1AuxDataOption.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/da5/classSG_1_1NoAuxStore.html">NoAuxStore</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mark that there's no associated AuxStore class.  <a href="../../d1/da5/classSG_1_1NoAuxStore.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d5b/structSG_1_1AuxStore__traits__AuxDefault.html">AuxStore_traits_AuxDefault</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default traits values for aux data case.  <a href="../../d7/d5b/structSG_1_1AuxStore__traits__AuxDefault.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc7/structSG_1_1AuxStore__traits__NoAuxDefault.html">AuxStore_traits_NoAuxDefault</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default traits values for no-aux data case.  <a href="../../db/dc7/structSG_1_1AuxStore__traits__NoAuxDefault.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d82/structSG_1_1AuxStore__traits1.html">AuxStore_traits1</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d16/structSG_1_1AuxStore__traits1_3_01DOBJ_00_01typename_01SG__STD__OR__BOOST_1_1is__base__of_3_01IA91c0103f32d2bbc942c9589741f17571.html">AuxStore_traits1&lt; DOBJ, typename SG_STD_OR_BOOST::is_base_of&lt; IAuxElement, typename DOBJ::base_value_type &gt;::type &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/da6/structSG_1_1AuxStore__traits.html">AuxStore_traits</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Associate <code>AuxStore</code> classes with EDM container classes (default implementation).  <a href="../../db/da6/structSG_1_1AuxStore__traits.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/de0/structSG_1_1AuxStore__traits_3_01DOBJ_01_5_01_4.html">AuxStore_traits&lt; DOBJ * &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Associate <code>AuxStore</code> classes with EDM container classes. This specialization allows using pointer types directly as an argument.  <a href="../../db/de0/structSG_1_1AuxStore__traits_3_01DOBJ_01_5_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d24/classSG_1_1AuxTypePlaceholder.html">AuxTypePlaceholder</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dca/classSG_1_1IAuxElement.html">IAuxElement</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flag that a class may have auxiliary data associated with it.  <a href="../../df/dca/classSG_1_1IAuxElement.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd2/classSG_1_1IAuxSetOption.html">IAuxSetOption</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abstract interface for setting a option on a aux data container.  <a href="../../db/dd2/classSG_1_1IAuxSetOption.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d05/classSG_1_1IAuxStore.html">IAuxStore</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interface for non-const operations on an auxiliary store.  <a href="../../dc/d05/classSG_1_1IAuxStore.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d42/classSG_1_1IAuxStoreHolder.html">IAuxStoreHolder</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interface for objects taking part in direct ROOT I/O.  <a href="../../dc/d42/classSG_1_1IAuxStoreHolder.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d37/classSG_1_1IAuxStoreIO.html">IAuxStoreIO</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interface providing I/O for a generic auxiliary store.  <a href="../../db/d37/classSG_1_1IAuxStoreIO.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d12/classSG_1_1IAuxTypeVector.html">IAuxTypeVector</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abstract interface for manipulating vectors of arbitrary types.  <a href="../../de/d12/classSG_1_1IAuxTypeVector.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d9f/classSG_1_1IAuxTypeVectorFactory.html">IAuxTypeVectorFactory</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interface for factory objects that create vectors.  <a href="../../d9/d9f/classSG_1_1IAuxTypeVectorFactory.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd5/classSG_1_1IConstAuxStore.html">IConstAuxStore</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interface for const operations on an auxiliary store.  <a href="../../d3/dd5/classSG_1_1IConstAuxStore.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d7d/structSG_1_1hash_3_01T_01_5_01_4.html">hash&lt; T * &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d91/structSG_1_1Fnv__hash.html">Fnv_hash</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d87/structSG_1_1Fnv__hash_3_014_01_4.html">Fnv_hash&lt; 4 &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d49/structSG_1_1Fnv__hash_3_018_01_4.html">Fnv_hash&lt; 8 &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dbc/structSG_1_1hash_3_01std_1_1string_01_4.html">hash&lt; std::string &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d59/structSG_1_1hash_3_01float_01_4.html">hash&lt; float &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d80/structSG_1_1hash_3_01double_01_4.html">hash&lt; double &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d76/structSG_1_1hash_3_01long_01double_01_4.html">hash&lt; long double &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d63/classSG_1_1hashtable.html">hashtable</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d3b/classSG_1_1unordered__map.html">unordered_map</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d54/classSG_1_1unordered__multimap.html">unordered_multimap</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/dac/classSG_1_1unordered__set.html">unordered_set</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d21/classSG_1_1unordered__multiset.html">unordered_multiset</a></td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="affee481ab18822e03866e0a0d3ff011c"></a><!-- doxytag: member="SG::auxid_t" ref="affee481ab18822e03866e0a0d3ff011c" args="" -->
typedef size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d59/namespaceSG.html#affee481ab18822e03866e0a0d3ff011c">auxid_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Identifier for a particular aux data item. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a8bcc4ee42936e2b794bac38e0f6de0"></a><!-- doxytag: member="SG::auxid_set_t" ref="a1a8bcc4ee42936e2b794bac38e0f6de0" args="" -->
typedef <a class="el" href="../../dd/dac/classSG_1_1unordered__set.html">SG::unordered_set</a>&lt; size_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d59/namespaceSG.html#a1a8bcc4ee42936e2b794bac38e0f6de0">auxid_set_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="../../d4/dc4/structA.html">A</a> set of aux data identifiers. <br/></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d59/namespaceSG.html#a9f3d699f65390b7f8baf54d9cd634573">IndexTrackingPolicy</a> { <a class="el" href="../../dd/d59/namespaceSG.html#a9f3d699f65390b7f8baf54d9cd634573ad08b3b1af2cb1dd45428b131f9f05ad7">DEFAULT_TRACK_INDICES</a>, 
<a class="el" href="../../dd/d59/namespaceSG.html#a9f3d699f65390b7f8baf54d9cd634573a3fef24c7e616865bef9cfc1ecd85b67d">ALWAYS_TRACK_INDICES</a>, 
<a class="el" href="../../dd/d59/namespaceSG.html#a9f3d699f65390b7f8baf54d9cd634573a6e7a344e9aac93f8a793eebda3c608a8">NEVER_TRACK_INDICES</a>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">OwnershipPolicy</a> { <a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8a1f65f0fb55784cfd27d9d4d6d7986d4d">OWN_ELEMENTS</a>, 
<a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8ad7d4cf2303700f0966e4140f236c4bf1">VIEW_ELEMENTS</a>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>describes the possible element ownership policies (see e.g. <a class="el" href="d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a>) </p>
 <a href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4a311cda5628ef02cd71b41da344bd4"></a><!-- doxytag: member="SG::ATH_NORETURN" ref="af4a311cda5628ef02cd71b41da344bd4" args="(void throwExcNonowningContainer())" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d59/namespaceSG.html#af4a311cda5628ef02cd71b41da344bd4">ATH_NORETURN</a> (void throwExcNonowningContainer())</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Throw a <a class="el" href="../../db/db6/classSG_1_1ExcNonowningContainer.html" title="Exception --- Attempted to insert a unique_ptr to a non-owning container.">SG::ExcNonowningContainer</a> exception. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d59/namespaceSG.html#ad66bd37b91df23bca5c092987bae6b86">ATH_NORETURN</a> (void throwExcUnknownAuxItem(const std::string &amp;name, const std::string &amp;clsname=&quot;&quot;, const std::type_info *typ=0))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Throw a <a class="el" href="../../d9/d63/classSG_1_1ExcUnknownAuxItem.html" title="Exception --- Unknown aux data item.">SG::ExcUnknownAuxItem</a> exception.  <a href="#ad66bd37b91df23bca5c092987bae6b86"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d59/namespaceSG.html#a1b43d42a3d7a635ea8b7e89ea4ed207e">normalizedTypeinfoName</a> (const std::type_info &amp;info)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a <code>type_info</code> to a normalized string representation (matching the names used in the root dictionary).  <a href="#a1b43d42a3d7a635ea8b7e89ea4ed207e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d59/namespaceSG.html#a38b539ad86491a55bf89748a05e7906a">copyAuxStoreThinned</a> (const <a class="el" href="../../d3/dd5/classSG_1_1IConstAuxStore.html">SG::IConstAuxStore</a> &amp;orig, <a class="el" href="../../dc/d05/classSG_1_1IAuxStore.html">SG::IAuxStore</a> &amp;copy, IThinningSvc *svc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper to copy an aux store while applying thinning.  <a href="#a38b539ad86491a55bf89748a05e7906a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CONTAINER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">CONTAINER *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d59/namespaceSG.html#a698cf63fca9debb795083d1e9fd7ee35">copyThinned</a> (const CONTAINER &amp;orig, IThinningSvc *svc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper to copy an object while applying thinning.  <a href="#a698cf63fca9debb795083d1e9fd7ee35"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CONTAINER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">CONTAINER *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d59/namespaceSG.html#a7657080dab6e0c36636f2ef30a689e83">copyThinned1</a> (const CONTAINER &amp;orig, const void *dummy, IThinningSvc *svc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper to copy an object while applying thinning.  <a href="#a7657080dab6e0c36636f2ef30a689e83"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CONTAINER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">CONTAINER *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d59/namespaceSG.html#a665fe27c0870bc351d867f8b0b65ecd7">copyThinned1</a> (const CONTAINER &amp;orig, const <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; typename CONTAINER::base_value_type &gt; *dummy, IThinningSvc *svc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper to copy an object while applying thinning.  <a href="#a665fe27c0870bc351d867f8b0b65ecd7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CONTAINER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">CONTAINER *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d59/namespaceSG.html#a055a3ae57de293f41d168c418cf27e6f">copyThinned1</a> (const CONTAINER &amp;orig, const <a class="el" href="../../dc/d05/classSG_1_1IAuxStore.html">SG::IAuxStore</a> *dummy, IThinningSvc *svc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper to copy an object while applying thinning.  <a href="#a055a3ae57de293f41d168c418cf27e6f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CONTAINER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d59/namespaceSG.html#a3ac6516722abaa699af584c9677b4142">getThinnedFlags</a> (IThinningSvc *svc, const CONTAINER &amp;container, size_t &amp;nremaining, std::vector&lt; unsigned char &gt; &amp;flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return vector of flags giving which container elements were thinned.  <a href="#a3ac6516722abaa699af584c9677b4142"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d59/namespaceSG.html#a01155fc796e93721d5a4004a7c7f6282">getThinnedFlags1</a> (IThinningSvc *svc, const void *container, size_t size, size_t &amp;nremaining, std::vector&lt; unsigned char &gt; &amp;flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return vector of flags giving which container elements were thinned.  <a href="#a01155fc796e93721d5a4004a7c7f6282"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d59/namespaceSG.html#a4cc237ae64b6624b127c8fdd9d8c8226">writePackedParameters</a> (TBuffer &amp;b, const <a class="el" href="../../d5/dc1/classSG_1_1PackedParameters.html">SG::PackedParameters</a> &amp;parms)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write a set of packed parameters to a buffer.  <a href="#a4cc237ae64b6624b127c8fdd9d8c8226"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/dc1/classSG_1_1PackedParameters.html">SG::PackedParameters</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d59/namespaceSG.html#a84d16a54a3ac43dc0a0a46db3ca9dc3d">readPackedParameters</a> (TBuffer &amp;b)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read a set of packed parameters from a buffer.  <a href="#a84d16a54a3ac43dc0a0a46db3ca9dc3d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf9df10af360478f2df041d31385af91"></a><!-- doxytag: member="SG::excFormatName" ref="abf9df10af360478f2df041d31385af91" args="(SG::auxid_t auxid)" -->
std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d59/namespaceSG.html#abf9df10af360478f2df041d31385af91">excFormatName</a> (<a class="el" href="../../dd/d59/namespaceSG.html#affee481ab18822e03866e0a0d3ff011c">SG::auxid_t</a> auxid)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper: format an aux data item name. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab4e9737528915950782111bcb863c3e0"></a><!-- doxytag: member="SG::excNoAuxStore_format" ref="ab4e9737528915950782111bcb863c3e0" args="(SG::auxid_t auxid)" -->
std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d59/namespaceSG.html#ab4e9737528915950782111bcb863c3e0">excNoAuxStore_format</a> (<a class="el" href="../../dd/d59/namespaceSG.html#affee481ab18822e03866e0a0d3ff011c">SG::auxid_t</a> auxid)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper: format exception error string. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8372f12b45e7ab56073759d1bbffc02"></a><!-- doxytag: member="SG::excNoAuxStore_format" ref="ae8372f12b45e7ab56073759d1bbffc02" args="(const char *op)" -->
std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d59/namespaceSG.html#ae8372f12b45e7ab56073759d1bbffc02">excNoAuxStore_format</a> (const char *op)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper: format exception error string. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a51ed3a2adc11a7edcd88f76d30c7eb"></a><!-- doxytag: member="SG::excBadAuxVar_format" ref="a6a51ed3a2adc11a7edcd88f76d30c7eb" args="(SG::auxid_t auxid)" -->
std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d59/namespaceSG.html#a6a51ed3a2adc11a7edcd88f76d30c7eb">excBadAuxVar_format</a> (<a class="el" href="../../dd/d59/namespaceSG.html#affee481ab18822e03866e0a0d3ff011c">SG::auxid_t</a> auxid)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper: format exception error string. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9966a2b7a15cb3d11a4041642e370ae"></a><!-- doxytag: member="SG::excConstAuxData_format" ref="ab9966a2b7a15cb3d11a4041642e370ae" args="(const std::string &amp;op, SG::auxid_t auxid)" -->
std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d59/namespaceSG.html#ab9966a2b7a15cb3d11a4041642e370ae">excConstAuxData_format</a> (const std::string &amp;op, <a class="el" href="../../dd/d59/namespaceSG.html#affee481ab18822e03866e0a0d3ff011c">SG::auxid_t</a> auxid)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper: format exception error string. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8cf3e31b95b30a2a9c78fc60190174e7"></a><!-- doxytag: member="SG::excAuxTypeMismatch_format" ref="a8cf3e31b95b30a2a9c78fc60190174e7" args="(SG::auxid_t auxid, const std::type_info &amp;new_type, const std::type_info &amp;old_type)" -->
std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d59/namespaceSG.html#a8cf3e31b95b30a2a9c78fc60190174e7">excAuxTypeMismatch_format</a> (<a class="el" href="../../dd/d59/namespaceSG.html#affee481ab18822e03866e0a0d3ff011c">SG::auxid_t</a> auxid, const std::type_info &amp;new_type, const std::type_info &amp;old_type)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper: format exception error string. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb46eb75b76b176f05d8b52a7e474999"></a><!-- doxytag: member="SG::excInsertionInBaseClass_format" ref="adb46eb75b76b176f05d8b52a7e474999" args="(const char *op, const std::type_info &amp;base_type, const std::type_info &amp;complete_type)" -->
std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d59/namespaceSG.html#adb46eb75b76b176f05d8b52a7e474999">excInsertionInBaseClass_format</a> (const char *op, const std::type_info &amp;base_type, const std::type_info &amp;complete_type)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper: format exception error string. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9bba82c6becf2bad1045a52a3dab4fdf"></a><!-- doxytag: member="SG::excStoreLocked_format" ref="a9bba82c6becf2bad1045a52a3dab4fdf" args="(SG::auxid_t auxid)" -->
std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d59/namespaceSG.html#a9bba82c6becf2bad1045a52a3dab4fdf">excStoreLocked_format</a> (<a class="el" href="../../dd/d59/namespaceSG.html#affee481ab18822e03866e0a0d3ff011c">SG::auxid_t</a> auxid)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper: format exception error string. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a03190d5872cae1bbae9920bcc1d43cb2"></a><!-- doxytag: member="SG::excStoreLocked_format" ref="a03190d5872cae1bbae9920bcc1d43cb2" args="(const char *op)" -->
std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d59/namespaceSG.html#a03190d5872cae1bbae9920bcc1d43cb2">excStoreLocked_format</a> (const char *op)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper: format exception error string. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5c859198d7bd7a8ec1e94a1139759ee"></a><!-- doxytag: member="SG::throwExcNonowningContainer" ref="ab5c859198d7bd7a8ec1e94a1139759ee" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d59/namespaceSG.html#ab5c859198d7bd7a8ec1e94a1139759ee">throwExcNonowningContainer</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Throw a <a class="el" href="../../db/db6/classSG_1_1ExcNonowningContainer.html" title="Exception --- Attempted to insert a unique_ptr to a non-owning container.">SG::ExcNonowningContainer</a> exception. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb157461ff61b0eeb3a50ae6c2620bed"></a><!-- doxytag: member="SG::excUnknownAuxItem_format" ref="aeb157461ff61b0eeb3a50ae6c2620bed" args="(const std::string &amp;name, const std::string &amp;clsname, const std::type_info *typ)" -->
std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d59/namespaceSG.html#aeb157461ff61b0eeb3a50ae6c2620bed">excUnknownAuxItem_format</a> (const std::string &amp;name, const std::string &amp;clsname, const std::type_info *typ)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper: format exception error string. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d59/namespaceSG.html#ad21304bfff9901fb3e07fb205b4325d8">throwExcUnknownAuxItem</a> (const std::string &amp;name, const std::string &amp;clsname, const std::type_info *typ)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Throw a <a class="el" href="../../db/db6/classSG_1_1ExcNonowningContainer.html" title="Exception --- Attempted to insert a unique_ptr to a non-owning container.">SG::ExcNonowningContainer</a> exception.  <a href="#ad21304bfff9901fb3e07fb205b4325d8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1858fed3b49849ae35582f6aa319d93f"></a><!-- doxytag: member="SG::tr1_hashtable_define_trivial_hash" ref="a1858fed3b49849ae35582f6aa319d93f" args="(bool)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>tr1_hashtable_define_trivial_hash</b> (bool)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb4d19eeb6d6aa21d50ee7d13b331baf"></a><!-- doxytag: member="SG::tr1_hashtable_define_trivial_hash" ref="adb4d19eeb6d6aa21d50ee7d13b331baf" args="(char)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>tr1_hashtable_define_trivial_hash</b> (char)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3fd4ed494625ec1480d4e5847cb07e1a"></a><!-- doxytag: member="SG::tr1_hashtable_define_trivial_hash" ref="a3fd4ed494625ec1480d4e5847cb07e1a" args="(signed char)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>tr1_hashtable_define_trivial_hash</b> (signed char)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3418a7bd4dd729c6c5b28beb4dbc21e6"></a><!-- doxytag: member="SG::tr1_hashtable_define_trivial_hash" ref="a3418a7bd4dd729c6c5b28beb4dbc21e6" args="(unsigned char)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>tr1_hashtable_define_trivial_hash</b> (unsigned char)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acbe35935f43e47e94faff86c61dc34eb"></a><!-- doxytag: member="SG::tr1_hashtable_define_trivial_hash" ref="acbe35935f43e47e94faff86c61dc34eb" args="(wchar_t)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>tr1_hashtable_define_trivial_hash</b> (wchar_t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f37bd39ffe31c172f7116663c3bd153"></a><!-- doxytag: member="SG::tr1_hashtable_define_trivial_hash" ref="a7f37bd39ffe31c172f7116663c3bd153" args="(short)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>tr1_hashtable_define_trivial_hash</b> (short)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa482cc78d9a7312c94a364c5aba5d284"></a><!-- doxytag: member="SG::tr1_hashtable_define_trivial_hash" ref="aa482cc78d9a7312c94a364c5aba5d284" args="(int)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>tr1_hashtable_define_trivial_hash</b> (int)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a213b88200816b263f46e995da2be042e"></a><!-- doxytag: member="SG::tr1_hashtable_define_trivial_hash" ref="a213b88200816b263f46e995da2be042e" args="(long)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>tr1_hashtable_define_trivial_hash</b> (long)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a1ec6b46e6e9e0c4e683eb8ea104d6a07"></a><!-- doxytag: member="SG::swap" ref="a1ec6b46e6e9e0c4e683eb8ea104d6a07" args="(unordered_map&lt; Key, T, Hash, Pred, Alloc, cache_hash_code &gt; &amp;x, unordered_map&lt; Key, T, Hash, Pred, Alloc, cache_hash_code &gt; &amp;y)" -->
template&lt;class Key , class T , class Hash , class Pred , class Alloc , bool cache_hash_code&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="../../d1/d3b/classSG_1_1unordered__map.html">unordered_map</a>&lt; Key, <a class="el" href="../../d1/def/classT.html">T</a>, Hash, <a class="el" href="../../df/d97/structPred.html">Pred</a>, Alloc, cache_hash_code &gt; &amp;x, <a class="el" href="../../d1/d3b/classSG_1_1unordered__map.html">unordered_map</a>&lt; Key, <a class="el" href="../../d1/def/classT.html">T</a>, Hash, <a class="el" href="../../df/d97/structPred.html">Pred</a>, Alloc, cache_hash_code &gt; &amp;y)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a4e26cfcfe2813a8131743ecb01c718b6"></a><!-- doxytag: member="SG::swap" ref="a4e26cfcfe2813a8131743ecb01c718b6" args="(unordered_multimap&lt; Key, T, Hash, Pred, Alloc, cache_hash_code &gt; &amp;x, unordered_multimap&lt; Key, T, Hash, Pred, Alloc, cache_hash_code &gt; &amp;y)" -->
template&lt;class Key , class T , class Hash , class Pred , class Alloc , bool cache_hash_code&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="../../d1/d54/classSG_1_1unordered__multimap.html">unordered_multimap</a>&lt; Key, <a class="el" href="../../d1/def/classT.html">T</a>, Hash, <a class="el" href="../../df/d97/structPred.html">Pred</a>, Alloc, cache_hash_code &gt; &amp;x, <a class="el" href="../../d1/d54/classSG_1_1unordered__multimap.html">unordered_multimap</a>&lt; Key, <a class="el" href="../../d1/def/classT.html">T</a>, Hash, <a class="el" href="../../df/d97/structPred.html">Pred</a>, Alloc, cache_hash_code &gt; &amp;y)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ab0f7b8f99e5d800c6cdd7e691ff68500"></a><!-- doxytag: member="SG::swap" ref="ab0f7b8f99e5d800c6cdd7e691ff68500" args="(unordered_set&lt; Value, Hash, Pred, Alloc, cache_hash_code &gt; &amp;x, unordered_set&lt; Value, Hash, Pred, Alloc, cache_hash_code &gt; &amp;y)" -->
template&lt;class Value , class Hash , class Pred , class Alloc , bool cache_hash_code&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="../../dd/dac/classSG_1_1unordered__set.html">unordered_set</a>&lt; Value, Hash, <a class="el" href="../../df/d97/structPred.html">Pred</a>, Alloc, cache_hash_code &gt; &amp;x, <a class="el" href="../../dd/dac/classSG_1_1unordered__set.html">unordered_set</a>&lt; Value, Hash, <a class="el" href="../../df/d97/structPred.html">Pred</a>, Alloc, cache_hash_code &gt; &amp;y)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a4b45293ad5bf7181a64c0e2e1dcfc443"></a><!-- doxytag: member="SG::swap" ref="a4b45293ad5bf7181a64c0e2e1dcfc443" args="(unordered_multiset&lt; Value, Hash, Pred, Alloc, cache_hash_code &gt; &amp;x, unordered_multiset&lt; Value, Hash, Pred, Alloc, cache_hash_code &gt; &amp;y)" -->
template&lt;class Value , class Hash , class Pred , class Alloc , bool cache_hash_code&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="../../df/d21/classSG_1_1unordered__multiset.html">unordered_multiset</a>&lt; Value, Hash, <a class="el" href="../../df/d97/structPred.html">Pred</a>, Alloc, cache_hash_code &gt; &amp;x, <a class="el" href="../../df/d21/classSG_1_1unordered__multiset.html">unordered_multiset</a>&lt; Value, Hash, <a class="el" href="../../df/d97/structPred.html">Pred</a>, Alloc, cache_hash_code &gt; &amp;y)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Constructor from a payload object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>Object to hold in the bucket.</td></tr>
  </table>
  </dd>
</dl>
<p>Namespace used by StoreGate for some of its internal structures/classes </p>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a9f3d699f65390b7f8baf54d9cd634573"></a><!-- doxytag: member="SG::IndexTrackingPolicy" ref="a9f3d699f65390b7f8baf54d9cd634573" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../dd/d59/namespaceSG.html#a9f3d699f65390b7f8baf54d9cd634573">SG::IndexTrackingPolicy</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a9f3d699f65390b7f8baf54d9cd634573ad08b3b1af2cb1dd45428b131f9f05ad7"></a><!-- doxytag: member="DEFAULT_TRACK_INDICES" ref="a9f3d699f65390b7f8baf54d9cd634573ad08b3b1af2cb1dd45428b131f9f05ad7" args="" -->DEFAULT_TRACK_INDICES</em>&nbsp;</td><td>
<p>Default value. Set index tracking based on the ownership policy. If this container owns its elements, then track indices; otherwise do not. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9f3d699f65390b7f8baf54d9cd634573a3fef24c7e616865bef9cfc1ecd85b67d"></a><!-- doxytag: member="ALWAYS_TRACK_INDICES" ref="a9f3d699f65390b7f8baf54d9cd634573a3fef24c7e616865bef9cfc1ecd85b67d" args="" -->ALWAYS_TRACK_INDICES</em>&nbsp;</td><td>
<p>Always track indices, regardless of the setting of the ownership policy. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9f3d699f65390b7f8baf54d9cd634573a6e7a344e9aac93f8a793eebda3c608a8"></a><!-- doxytag: member="NEVER_TRACK_INDICES" ref="a9f3d699f65390b7f8baf54d9cd634573a6e7a344e9aac93f8a793eebda3c608a8" args="" -->NEVER_TRACK_INDICES</em>&nbsp;</td><td>
<p>Never track indices, regardless of the setting of the ownership policy. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="acd9d1a31242c6243cc1c6fab0fbc7cd8"></a><!-- doxytag: member="SG::OwnershipPolicy" ref="acd9d1a31242c6243cc1c6fab0fbc7cd8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">SG::OwnershipPolicy</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>describes the possible element ownership policies (see e.g. <a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a>) </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Paolo Calafiura &lt;<a href="mailto:pcalafiura@lbl.gov">pcalafiura@lbl.gov</a>&gt; - ATLAS Collaboration </dd></dl>
<dl class="rcs"><dt><b>Id</b></dt><dd><a class="el" href="../../d3/da4/OwnershipPolicy_8h_source.html">OwnershipPolicy.h</a> 581165 2014-02-03 10:42:54Z krasznaa </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="acd9d1a31242c6243cc1c6fab0fbc7cd8a1f65f0fb55784cfd27d9d4d6d7986d4d"></a><!-- doxytag: member="OWN_ELEMENTS" ref="acd9d1a31242c6243cc1c6fab0fbc7cd8a1f65f0fb55784cfd27d9d4d6d7986d4d" args="" -->OWN_ELEMENTS</em>&nbsp;</td><td>
<p>this data object owns its elements </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acd9d1a31242c6243cc1c6fab0fbc7cd8ad7d4cf2303700f0966e4140f236c4bf1"></a><!-- doxytag: member="VIEW_ELEMENTS" ref="acd9d1a31242c6243cc1c6fab0fbc7cd8ad7d4cf2303700f0966e4140f236c4bf1" args="" -->VIEW_ELEMENTS</em>&nbsp;</td><td>
<p>this data object is a view, it does not own its elmts </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ad66bd37b91df23bca5c092987bae6b86"></a><!-- doxytag: member="SG::ATH_NORETURN" ref="ad66bd37b91df23bca5c092987bae6b86" args="(void throwExcUnknownAuxItem(const std::string &amp;name, const std::string &amp;clsname=&quot;&quot;, const std::type_info *typ=0))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SG::ATH_NORETURN </td>
          <td>(</td>
          <td class="paramtype">void &nbsp;</td>
          <td class="paramname"> <em>throwExcUnknownAuxItem</em>const std::string &amp;name, const std::string &amp;clsname=&quot;&quot;, const std::type_info *typ=0</td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Throw a <a class="el" href="../../d9/d63/classSG_1_1ExcUnknownAuxItem.html" title="Exception --- Unknown aux data item.">SG::ExcUnknownAuxItem</a> exception. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of the aux data item. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clsname</em>&nbsp;</td><td>Class name of the aux data item, or an empty string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>typ</em>&nbsp;</td><td>Type of the item, if provided. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a38b539ad86491a55bf89748a05e7906a"></a><!-- doxytag: member="SG::copyAuxStoreThinned" ref="a38b539ad86491a55bf89748a05e7906a" args="(const SG::IConstAuxStore &amp;orig, SG::IAuxStore &amp;copy, IThinningSvc *svc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SG::copyAuxStoreThinned </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/dd5/classSG_1_1IConstAuxStore.html">SG::IConstAuxStore</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>orig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d05/classSG_1_1IAuxStore.html">SG::IAuxStore</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>copy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IThinningSvc *&nbsp;</td>
          <td class="paramname"> <em>svc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper to copy an aux store while applying thinning. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>orig</em>&nbsp;</td><td>Source aux store from which to coy. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>copy</em>&nbsp;</td><td>Destination aux store to which to copy. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>svc</em>&nbsp;</td><td>The thinning service.</td></tr>
  </table>
  </dd>
</dl>
<p><code>orig</code> and <code>copy</code> are both auxiliary store objects. The data from <code>orig</code> will be copied to <code>copy</code>, with individual elements removed according to thinning recorded for <code>orig</code> in <code>svc</code>. </p>

</div>
</div>
<a class="anchor" id="a698cf63fca9debb795083d1e9fd7ee35"></a><!-- doxytag: member="SG::copyThinned" ref="a698cf63fca9debb795083d1e9fd7ee35" args="(const CONTAINER &amp;orig, IThinningSvc *svc)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CONTAINER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CONTAINER * SG::copyThinned </td>
          <td>(</td>
          <td class="paramtype">const CONTAINER &amp;&nbsp;</td>
          <td class="paramname"> <em>orig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IThinningSvc *&nbsp;</td>
          <td class="paramname"> <em>svc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper to copy an object while applying thinning. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>orig</em>&nbsp;</td><td>The object to copy. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>svc</em>&nbsp;</td><td>The thinning service.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns a new copy of <code>orig</code> with elements removed according to the thinning defined in <code>svc</code>. Ownership of the new object is passed back to the caller.</p>
<p>The code here handles <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> and <code><a class="el" href="../../dc/d05/classSG_1_1IAuxStore.html" title="Interface for non-const operations on an auxiliary store.">IAuxStore</a></code> objects. Support for additional object types may be added by adding overloads for <code>copyThinned1</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>orig</em>&nbsp;</td><td>The object to copy. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>svc</em>&nbsp;</td><td>The thinning service.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns a new copy of <code>orig</code> with elements removed according to the thinning defined in <code>svc</code>. Ownership of the new object is passed back to the caller. </p>

</div>
</div>
<a class="anchor" id="a055a3ae57de293f41d168c418cf27e6f"></a><!-- doxytag: member="SG::copyThinned1" ref="a055a3ae57de293f41d168c418cf27e6f" args="(const CONTAINER &amp;orig, const SG::IAuxStore *dummy, IThinningSvc *svc)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CONTAINER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CONTAINER * SG::copyThinned1 </td>
          <td>(</td>
          <td class="paramtype">const CONTAINER &amp;&nbsp;</td>
          <td class="paramname"> <em>orig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/d05/classSG_1_1IAuxStore.html">SG::IAuxStore</a> *&nbsp;</td>
          <td class="paramname"> <em>dummy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IThinningSvc *&nbsp;</td>
          <td class="paramname"> <em>svc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper to copy an object while applying thinning. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>orig</em>&nbsp;</td><td>The object to copy. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dummy</em>&nbsp;</td><td>Dummy argument for overload resolution. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>svc</em>&nbsp;</td><td>The thinning service.</td></tr>
  </table>
  </dd>
</dl>
<p>This overload handles <code><a class="el" href="../../dc/d05/classSG_1_1IAuxStore.html" title="Interface for non-const operations on an auxiliary store.">IAuxStore</a></code> types. It returns a new copy of the store, with any thinned elements removed. </p>

</div>
</div>
<a class="anchor" id="a665fe27c0870bc351d867f8b0b65ecd7"></a><!-- doxytag: member="SG::copyThinned1" ref="a665fe27c0870bc351d867f8b0b65ecd7" args="(const CONTAINER &amp;orig, const DataVector&lt; typename CONTAINER::base_value_type &gt; *dummy, IThinningSvc *svc)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CONTAINER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CONTAINER * SG::copyThinned1 </td>
          <td>(</td>
          <td class="paramtype">const CONTAINER &amp;&nbsp;</td>
          <td class="paramname"> <em>orig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; typename CONTAINER::base_value_type &gt; *&nbsp;</td>
          <td class="paramname"> <em>dummy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IThinningSvc *&nbsp;</td>
          <td class="paramname"> <em>svc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper to copy an object while applying thinning. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>orig</em>&nbsp;</td><td>The object to copy. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dummy</em>&nbsp;</td><td>Dummy argument for overload resolution. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>svc</em>&nbsp;</td><td>The thinning service.</td></tr>
  </table>
  </dd>
</dl>
<p>This overload handles <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> types. It returns a view container copy of <code>orig</code>, from which any thinned elements are removed. </p>

</div>
</div>
<a class="anchor" id="a7657080dab6e0c36636f2ef30a689e83"></a><!-- doxytag: member="SG::copyThinned1" ref="a7657080dab6e0c36636f2ef30a689e83" args="(const CONTAINER &amp;orig, const void *dummy, IThinningSvc *svc)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CONTAINER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CONTAINER * SG::copyThinned1 </td>
          <td>(</td>
          <td class="paramtype">const CONTAINER &amp;&nbsp;</td>
          <td class="paramname"> <em>orig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>dummy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IThinningSvc *&nbsp;</td>
          <td class="paramname"> <em>svc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper to copy an object while applying thinning. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>orig</em>&nbsp;</td><td>The object to copy. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dummy</em>&nbsp;</td><td>Dummy argument for overload resolution. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>svc</em>&nbsp;</td><td>The thinning service.</td></tr>
  </table>
  </dd>
</dl>
<p>This is the generic version of <code>copyThinned</code>, which matches types for which there is not a more specific overload. It simply makes a copy of <code>orig</code> using the copy constructor. </p>

</div>
</div>
<a class="anchor" id="a3ac6516722abaa699af584c9677b4142"></a><!-- doxytag: member="SG::getThinnedFlags" ref="a3ac6516722abaa699af584c9677b4142" args="(IThinningSvc *svc, const CONTAINER &amp;container, size_t &amp;nremaining, std::vector&lt; unsigned char &gt; &amp;flags)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CONTAINER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool SG::getThinnedFlags </td>
          <td>(</td>
          <td class="paramtype">IThinningSvc *&nbsp;</td>
          <td class="paramname"> <em>svc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CONTAINER &amp;&nbsp;</td>
          <td class="paramname"> <em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&nbsp;</td>
          <td class="paramname"> <em>nremaining</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return vector of flags giving which container elements were thinned. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>svc</em>&nbsp;</td><td>The thinning service (or 0). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>container</em>&nbsp;</td><td>The container for which to find thinning information. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nremaining[out]</em>&nbsp;</td><td>The number of elements in the container not thinned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags[out]</em>&nbsp;</td><td>Array telling which elements were thinned.</td></tr>
  </table>
  </dd>
</dl>
<p>If no thinning is done on <code>CONTAINER</code>, then return false with <code>nremaining</code> equal to `container.size()`. <code>flags</code> may be empty in this case.</p>
<p>Otherwise, the container was thinned, and the function returns true. The size of <code>flags</code> will equal the container size; each element of <code>flags</code> is non-zero if the corresponding container element has been thinned. <code>nremaining</code> will be set to the count of elements that have _not_ been thinned. </p>

</div>
</div>
<a class="anchor" id="a01155fc796e93721d5a4004a7c7f6282"></a><!-- doxytag: member="SG::getThinnedFlags1" ref="a01155fc796e93721d5a4004a7c7f6282" args="(IThinningSvc *svc, const void *container, size_t size, size_t &amp;nremaining, std::vector&lt; unsigned char &gt; &amp;flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SG::getThinnedFlags1 </td>
          <td>(</td>
          <td class="paramtype">IThinningSvc *&nbsp;</td>
          <td class="paramname"> <em>svc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&nbsp;</td>
          <td class="paramname"> <em>nremaining</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return vector of flags giving which container elements were thinned. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>svc</em>&nbsp;</td><td>The thinning service (or 0). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>container</em>&nbsp;</td><td>The container for which to find thinning information. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size of the container. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nremaining[out]</em>&nbsp;</td><td>The number of elements in the container not thinned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags[out]</em>&nbsp;</td><td>Array telling which elements were thinned.</td></tr>
  </table>
  </dd>
</dl>
<p>This is and out-of-line helper for <code>getThinnedFlags</code>. </p>

</div>
</div>
<a class="anchor" id="a1b43d42a3d7a635ea8b7e89ea4ed207e"></a><!-- doxytag: member="SG::normalizedTypeinfoName" ref="a1b43d42a3d7a635ea8b7e89ea4ed207e" args="(const std::type_info &amp;info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string SG::normalizedTypeinfoName </td>
          <td>(</td>
          <td class="paramtype">const std::type_info &amp;&nbsp;</td>
          <td class="paramname"> <em>info</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a <code>type_info</code> to a normalized string representation (matching the names used in the root dictionary). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>info</em>&nbsp;</td><td>The type to convert.</td></tr>
  </table>
  </dd>
</dl>
<p>The function `AthContainer_detailtypeinfoName` may be used to convert a C++ `type_info` to a string representing the name of the class; this handles platform-dependent details such as performing demangling.</p>
<p>However, the name you get as a result of this does not necessarily match the name by which the class is known in the ROOT dictionary. In particular, defaulted template arguments for STL containers and <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a></code> are suppressed in the dictionary. So, for example, for a vector class <code>typeinfoName</code> may produce `stdvector&lt;int, std::allocator&lt;T&gt; &gt;`, while in the dictionary it is known as `stdvector&lt;int&gt;`. Using <code>normalizedTypeinfoName</code> instead will transform the names to match what's in the dictionary. This function will also cache the typeinfo -&gt; string conversions. </p>

</div>
</div>
<a class="anchor" id="a84d16a54a3ac43dc0a0a46db3ca9dc3d"></a><!-- doxytag: member="SG::readPackedParameters" ref="a84d16a54a3ac43dc0a0a46db3ca9dc3d" args="(TBuffer &amp;b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/dc1/classSG_1_1PackedParameters.html">SG::PackedParameters</a> SG::readPackedParameters </td>
          <td>(</td>
          <td class="paramtype">TBuffer &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read a set of packed parameters from a buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>Buffer from which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad21304bfff9901fb3e07fb205b4325d8"></a><!-- doxytag: member="SG::throwExcUnknownAuxItem" ref="ad21304bfff9901fb3e07fb205b4325d8" args="(const std::string &amp;name, const std::string &amp;clsname, const std::type_info *typ)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SG::throwExcUnknownAuxItem </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>clsname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::type_info *&nbsp;</td>
          <td class="paramname"> <em>typ</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Throw a <a class="el" href="../../db/db6/classSG_1_1ExcNonowningContainer.html" title="Exception --- Attempted to insert a unique_ptr to a non-owning container.">SG::ExcNonowningContainer</a> exception. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of the aux data item. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clsname</em>&nbsp;</td><td>Class name of the aux data item, or an empty string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>typ</em>&nbsp;</td><td>Type of the item, if provided. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4cc237ae64b6624b127c8fdd9d8c8226"></a><!-- doxytag: member="SG::writePackedParameters" ref="a4cc237ae64b6624b127c8fdd9d8c8226" args="(TBuffer &amp;b, const SG::PackedParameters &amp;parms)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SG::writePackedParameters </td>
          <td>(</td>
          <td class="paramtype">TBuffer &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/dc1/classSG_1_1PackedParameters.html">SG::PackedParameters</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>parms</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write a set of packed parameters to a buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>Buffer to which to write. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>param</em>&nbsp;</td><td>Parameters to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 15 Apr 2017 for RootCore Packages by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
