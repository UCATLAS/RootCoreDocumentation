<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>RootCore Packages: Athena::Signal Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
--></script>
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='../../open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='../../closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='../../closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="../../index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="../../search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="../../annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="../../classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="../../hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="../../functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="../../d5/dc5/namespaceAthena.html">Athena</a>::<a class="el" href="../../d9/d58/classAthena_1_1Signal.html">Signal</a>
  </div>
</div>
<div class="contents">
<h1>Athena::Signal Class Reference</h1><!-- doxytag: class="Athena::Signal" -->
<p><code>#include &lt;<a class="el" href="../../d0/dc2/SealSignal_8h_source.html">SealSignal.h</a>&gt;</code></p>

<p><a href="../../d2/d9f/classAthena_1_1Signal-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bool(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a580d4d8dab36af1b92760624a314fe10">QuitHook</a> )(int sig, <a class="el" href="../../dc/dbc/structsiginfo__t.html">siginfo_t</a> *info, void *x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bool(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#ad4933f5dea26508794985dc36879fd4f">FatalHook</a> )(int sig, <a class="el" href="../../dc/dbc/structsiginfo__t.html">siginfo_t</a> *info, void *x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a0a1d20177cf76b6f120d8f70fd547414">FatalReturn</a> )(int sig, <a class="el" href="../../dc/dbc/structsiginfo__t.html">siginfo_t</a> *info, void *x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a165a8a731e1c838d8fcbdc8e8a90672f">HandlerType</a> )(int sig, <a class="el" href="../../dc/dbc/structsiginfo__t.html">siginfo_t</a> *info, void *extra)</td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a0adbe38fd6bad8af8f01df2ebadd226a">name</a> (int sig)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a165a8a731e1c838d8fcbdc8e8a90672f">HandlerType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a03b798ab9f156df7c4201b8ca965fc7c">handler</a> (int sig, sigset_t *mask=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a165a8a731e1c838d8fcbdc8e8a90672f">HandlerType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#acb0930a18360698b9c20245fa140eba2">handle</a> (int sig, <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a165a8a731e1c838d8fcbdc8e8a90672f">HandlerType</a> handler, const sigset_t *blockMask=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a76c5c303a2f6cbf9af04709666f0e47c">revert</a> (int sig)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a7694b12f8ec856d8ece08fe5ffd46c3f">ignore</a> (int sig)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a641025898baba970dddb3806fe4d7024">block</a> (int sig, bool sense)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a50cde1da242d476e0fd35be113657121">block</a> (const sigset_t *mask, bool sense)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a4d98e5d67200d900fdc04abecb3d6911">mask</a> (const sigset_t *mask, sigset_t *old=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a08098f4712adf303e1308740a647b6fb">raise</a> (int sig)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a15848d5bc08689bda47833527c74512d">kill</a> (pid_t process, int sig)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a2320430a74b58f6a2180a794f3e6aaab">queue</a> (int sig, int value=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#ab440bbd5068c51676db72c90e2bd481f">queue</a> (int sig, void *value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a3cb61f4a6cee9302b5726f12acba6100">queue</a> (pid_t process, int sig, int value=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a3736a405678e733d4ab65217a19d6a3e">queue</a> (pid_t process, int sig, void *value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a9b3d452bd4db782ababb16856e502b4d">pending</a> (int sig)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#adc09b8c58ec8e5a11cec445fc8fc37bc">pending</a> (sigset_t *mask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a12d5227fb0b4627b25f75c80bbc97232">suspend</a> (const sigset_t *mask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a618af8c53f3f8942b558f712e12865ef">wait</a> (int sig, <a class="el" href="../../dc/dbc/structsiginfo__t.html">siginfo_t</a> *info=0, long msecs=-1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#ad6d376707953d3536cbbbf7350d385e4">wait</a> (const sigset_t *mask, <a class="el" href="../../dc/dbc/structsiginfo__t.html">siginfo_t</a> *info=0, long msecs=-1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a937b6ad470e18df2e2509f150fb92fd9"></a><!-- doxytag: member="Athena::Signal::handleQuit" ref="a937b6ad470e18df2e2509f150fb92fd9" args="(QuitHook hook=0)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>handleQuit</b> (<a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a580d4d8dab36af1b92760624a314fe10">QuitHook</a> hook=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a580d4d8dab36af1b92760624a314fe10">QuitHook</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#ae09161d0e01449d88a870c9ce33e48ab">handleQuitHook</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a98067924cbcf318e105b92c019acf33e">quit</a> (int sig, <a class="el" href="../../dc/dbc/structsiginfo__t.html">siginfo_t</a> *info, void *x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a91247206fb7476bfbc60ba82aed77309">handleFatal</a> (const char *applicationName=0, <a class="el" href="../../d1/dc7/SealCommon_8h.html#a98d936fe848403f33ff9cebfc9a38597">IOFD</a> fd=IOFD_INVALID, <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#ad4933f5dea26508794985dc36879fd4f">FatalHook</a> hook=0, <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a0a1d20177cf76b6f120d8f70fd547414">FatalReturn</a> mainreturn=0, unsigned options=<a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a0c47f0fc8e3ccd9ef3de3c2bc7ea39a3">FATAL_DEFAULT</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d1/dc7/SealCommon_8h.html#a98d936fe848403f33ff9cebfc9a38597">IOFD</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a531516a7bafb85ada87cc13df42be6c9">handleFatalFd</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#ad4933f5dea26508794985dc36879fd4f">FatalHook</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#acf9c12a42518c098bcdc03e2e1ec164a">handleFatalHook</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a0a1d20177cf76b6f120d8f70fd547414">FatalReturn</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a058d561130784cb3ff06f944dd2a642c">handleFatalReturn</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#aab22be0d7aa1e7034b2de5f158c74533">handleFatalOptions</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a29ed2239824de7084eec2096921df121">fatal</a> (int sig, <a class="el" href="../../dc/dbc/structsiginfo__t.html">siginfo_t</a> *info, void *x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a5b6e599feec0e6ea2e5d204c7accf7ab">fatalDump</a> (int sig, <a class="el" href="../../dc/dbc/structsiginfo__t.html">siginfo_t</a> *info, void *x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#ae19a24e2785bf4313373d693270a0318">fatalLevel</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#acb413f9b908ec38d19007f699679f8ab">crashed</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#aa686ec513eec1f5f9270a3093b536bcd">dumpInfo</a> (<a class="el" href="../../d1/dc7/SealCommon_8h.html#a98d936fe848403f33ff9cebfc9a38597">IOFD</a> fd, char *buf, int sig, const <a class="el" href="../../dc/dbc/structsiginfo__t.html">siginfo_t</a> *info)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#ab3650e5ddb5bdc899edac43d18446779">dumpMemory</a> (<a class="el" href="../../d1/dc7/SealCommon_8h.html#a98d936fe848403f33ff9cebfc9a38597">IOFD</a> fd, char *buf, const void *data, size_t n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#acb9b9ecebefba6d45ac6ec5e019b133b">dumpContext</a> (<a class="el" href="../../d1/dc7/SealCommon_8h.html#a98d936fe848403f33ff9cebfc9a38597">IOFD</a> fd, char *buf, const void *context)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a35d052097f8387d33e7b74d63008a3a3">describe</a> (int sig, int code)</td></tr>
<tr><td colspan="2"><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#aadde66d635b299a4f8f88d222855ce3b">USR1_DUMP_CORE</a> = 1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a369e40f96220b4e610c171a03e09bde1">FATAL_ON_QUIT</a> = 2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#afbce7583ec5181b33546721b78fe8f01">FATAL_ON_INT</a> = 4</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a6798ead5f4386eed186a5e8dd885e00f">FATAL_DUMP_CORE</a> = 8</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#ac52e36621c04bb27790397c43dba6343">FATAL_DUMP_SIG</a> = 16</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#adf0c99c485898916f19e5f3b20a92855">FATAL_DUMP_STACK</a> = 32</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#aa774d944e7b551a7f9e2a4ad7d3558b6">FATAL_DUMP_LIBS</a> = 64</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a09b1ac53de90bda7a0619f730531767b">FATAL_DUMP_CONTEXT</a> = 128</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a150e4c8e320da5b8a0690973b287890e">FATAL_AUTO_EXIT</a> = 256</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a0c47f0fc8e3ccd9ef3de3c2bc7ea39a3">FATAL_DEFAULT</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Utilities for handling signals and fatal errors.</p>
<p>FIXME: POSIX single-threaded vs. multi-threaded signals?</p>
<ul>
<li>all threads should block all the signals</li>
<li>one thread should do sigwait.</li>
</ul>
<p>The fatal error handling is largely inspired by code in DDD, the Data Display Debugger, and by the examples in GNU libc manual. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="ad4933f5dea26508794985dc36879fd4f"></a><!-- doxytag: member="Athena::Signal::FatalHook" ref="ad4933f5dea26508794985dc36879fd4f" args=")(int sig, siginfo_t *info, void *x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#ad4933f5dea26508794985dc36879fd4f">Athena::Signal::FatalHook</a>)(int sig, <a class="el" href="../../dc/dbc/structsiginfo__t.html">siginfo_t</a> *info, void *x)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Application hook to run in <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a29ed2239824de7084eec2096921df121">fatal()</a>. The hook should return <code>true</code> if the signal handler should proceed to die. <em>sig</em> is the signal number, or its negative if core was dumped and, as far as can determined, successfully produced.</p>
<p>The fatal hooks should, if possible, perform clean-ups similar to <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a580d4d8dab36af1b92760624a314fe10">QuitHook</a>. The application may achieve this by actually using the quit by setting <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a150e4c8e320da5b8a0690973b287890e">FATAL_AUTO_EXIT</a> for <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a91247206fb7476bfbc60ba82aed77309">handleFatal()</a>, or it could reuse an internal function in both handlers. </p>

</div>
</div>
<a class="anchor" id="a0a1d20177cf76b6f120d8f70fd547414"></a><!-- doxytag: member="Athena::Signal::FatalReturn" ref="a0a1d20177cf76b6f120d8f70fd547414" args=")(int sig, siginfo_t *info, void *x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a0a1d20177cf76b6f120d8f70fd547414">Athena::Signal::FatalReturn</a>)(int sig, <a class="el" href="../../dc/dbc/structsiginfo__t.html">siginfo_t</a> *info, void *x)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Application hook to jump back to the main program from a fatal signal, for example using siglongjmp. It must never return. <em>sig</em> is the signal number, or its negative if core was dumped and, as far as can determined, successfully produced. </p>

</div>
</div>
<a class="anchor" id="a165a8a731e1c838d8fcbdc8e8a90672f"></a><!-- doxytag: member="Athena::Signal::HandlerType" ref="a165a8a731e1c838d8fcbdc8e8a90672f" args=")(int sig, siginfo_t *info, void *extra)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a165a8a731e1c838d8fcbdc8e8a90672f">Athena::Signal::HandlerType</a>)(int sig, <a class="el" href="../../dc/dbc/structsiginfo__t.html">siginfo_t</a> *info, void *extra)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="../../d9/d58/classAthena_1_1Signal.html">Signal</a> handler type. This is defined explicitly and does not necessarily match the system's concept of signal handler type. If necessary, suitable trampolines are used internally to make sure the arguments make sense.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sig</em>&nbsp;</td><td>The signal number. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>info</em>&nbsp;</td><td>Pointer to signal info. This pointer will be null on platforms that do not support POSIX signals. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>extra</em>&nbsp;</td><td>Extra argument, e.g. the fault address. This pointer will be null on platforms that do not support POSIX signals. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a580d4d8dab36af1b92760624a314fe10"></a><!-- doxytag: member="Athena::Signal::QuitHook" ref="a580d4d8dab36af1b92760624a314fe10" args=")(int sig, siginfo_t *info, void *x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a580d4d8dab36af1b92760624a314fe10">Athena::Signal::QuitHook</a>)(int sig, <a class="el" href="../../dc/dbc/structsiginfo__t.html">siginfo_t</a> *info, void *x)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Application clean-up hook invoked before <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a98067924cbcf318e105b92c019acf33e">quit()</a> exits from program termination signals (SIGHUP, SIGTERM or SIGQUIT).</p>
<p>The handler should return <code>true</code> if the signal handler should proceed to exit the application. Note that certain options to handlFatal() cause this hook to be invoked for fatal signals. If such behaviour is enabled, be sure to check the <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#acb413f9b908ec38d19007f699679f8ab">crashed()</a> status before deciding to let the application to continue.</p>
<p>The quit hook should take care of resetting terminal modes, killing child processes, removing lock files, and so forth. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a50cde1da242d476e0fd35be113657121"></a><!-- doxytag: member="Athena::Signal::block" ref="a50cde1da242d476e0fd35be113657121" args="(const sigset_t *mask, bool sense)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Athena::Signal::block </td>
          <td>(</td>
          <td class="paramtype">const sigset_t *&nbsp;</td>
          <td class="paramname"> <em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>sense</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Block or unblock the signals specified by <em>mask</em>. The signals are blocked if <em>sense</em> is <code>true</code>, unblocked otherwise. This function is implemented only on systems with POSIX signals. </p>

</div>
</div>
<a class="anchor" id="a641025898baba970dddb3806fe4d7024"></a><!-- doxytag: member="Athena::Signal::block" ref="a641025898baba970dddb3806fe4d7024" args="(int sig, bool sense)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Athena::Signal::block </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>sense</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Block or unblock the signal number <em>sig</em>. The signal is blocked if <em>sense</em> is <code>true</code>, unblocked otherwise. This function is implemented only on systems with POSIX signals. </p>

</div>
</div>
<a class="anchor" id="acb413f9b908ec38d19007f699679f8ab"></a><!-- doxytag: member="Athena::Signal::crashed" ref="acb413f9b908ec38d19007f699679f8ab" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Athena::Signal::crashed </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the crash status indicator: <code>true</code> if a fatal signal has been received since the program started. Set if <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a29ed2239824de7084eec2096921df121">fatal()</a> is entered with a fatal signal. </p>

</div>
</div>
<a class="anchor" id="a35d052097f8387d33e7b74d63008a3a3"></a><!-- doxytag: member="Athena::Signal::describe" ref="a35d052097f8387d33e7b74d63008a3a3" args="(int sig, int code)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * Athena::Signal::describe </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>code</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the description for signal info code <em>code</em> for signal number <em>sig</em>. The code should come from <code>siginfo_t::si_code</code>. </p>

</div>
</div>
<a class="anchor" id="acb9b9ecebefba6d45ac6ec5e019b133b"></a><!-- doxytag: member="Athena::Signal::dumpContext" ref="acb9b9ecebefba6d45ac6ec5e019b133b" args="(IOFD fd, char *buf, const void *context)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Athena::Signal::dumpContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/dc7/SealCommon_8h.html#a98d936fe848403f33ff9cebfc9a38597">IOFD</a>&nbsp;</td>
          <td class="paramname"> <em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>context</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Utility function to dump the process context, as obtained for instance through signal handler parameters, unix <code>getcontext()</code> or Windows <code>GetThreadContext()</code>. The output is written directly to the file descriptor <em>fd</em>, using <em>buf</em> as the formatting buffer. </p>

</div>
</div>
<a class="anchor" id="aa686ec513eec1f5f9270a3093b536bcd"></a><!-- doxytag: member="Athena::Signal::dumpInfo" ref="aa686ec513eec1f5f9270a3093b536bcd" args="(IOFD fd, char *buf, int sig, const siginfo_t *info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Athena::Signal::dumpInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/dc7/SealCommon_8h.html#a98d936fe848403f33ff9cebfc9a38597">IOFD</a>&nbsp;</td>
          <td class="paramname"> <em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/dbc/structsiginfo__t.html">siginfo_t</a> *&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Utility function to dump the signal info descriptor for signal <em>sig</em>, as obtained for instance through signal handler parameters or <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a618af8c53f3f8942b558f712e12865ef">wait()</a>. The output is written directly to the file descriptor <em>fd</em>, using <em>buf</em> as the formatting buffer. </p>

</div>
</div>
<a class="anchor" id="ab3650e5ddb5bdc899edac43d18446779"></a><!-- doxytag: member="Athena::Signal::dumpMemory" ref="ab3650e5ddb5bdc899edac43d18446779" args="(IOFD fd, char *buf, const void *data, size_t n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Athena::Signal::dumpMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/dc7/SealCommon_8h.html#a98d936fe848403f33ff9cebfc9a38597">IOFD</a>&nbsp;</td>
          <td class="paramname"> <em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Utility function to dump memory section from <em>data</em> for <em>n</em> bytes. Used to dump machine context on platforms where we don't know any better. The output is written directly to the file descriptor <em>fd</em>, using <em>buf</em> as the formatting buffer. </p>

</div>
</div>
<a class="anchor" id="a29ed2239824de7084eec2096921df121"></a><!-- doxytag: member="Athena::Signal::fatal" ref="a29ed2239824de7084eec2096921df121" args="(int sig, siginfo_t *info, void *x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Athena::Signal::fatal </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dbc/structsiginfo__t.html">siginfo_t</a> *&nbsp;</td>
          <td class="paramname"> <em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The fatal signal handler.</p>
<p>This is the handler installed by <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a91247206fb7476bfbc60ba82aed77309">handleFatal()</a>. Please use <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a91247206fb7476bfbc60ba82aed77309">handleFatal()</a> and this method instead of installing your handlers with <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#acb0930a18360698b9c20245fa140eba2">handle()</a>. You should be able use the handler options to specify all the control you need.</p>
<p>The first thing this handler does is to reinstall itself for the benefit of platforms with single-delivery signals. Immediately after that it unblocks the delivery of that signal again, in case the signal handler itself gets in trouble. The next step is to check if the current crash level (the recursion of calls to <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a29ed2239824de7084eec2096921df121">fatal()</a>, see <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#ae19a24e2785bf4313373d693270a0318">fatalLevel()</a>) exceeds the predefined limit of 4; if so, we give up and let the application die with this this signal. The handler then determines whether the signal is fatal: everything except SIGINT is, and SIGINT is fatal if <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#afbce7583ec5181b33546721b78fe8f01">FATAL_ON_INT</a> was set. If the signal is fatal, crash indicator is set (see <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#acb413f9b908ec38d19007f699679f8ab">crashed()</a>).</p>
<p>If this is not a nested fatal signal, the signal is fatal, and <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a6798ead5f4386eed186a5e8dd885e00f">FATAL_DUMP_CORE</a> is set, the handler tries dump a core file. Then the handler will either attempt to quit or to return to the main program depending on <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a150e4c8e320da5b8a0690973b287890e">FATAL_AUTO_EXIT</a> option setting. If it is set or this is a nested fatal signal, the handler will attempt to exit as follows: the application hook (or <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a5b6e599feec0e6ea2e5d204c7accf7ab">fatalDump()</a> in its absence) is invoked. If the hook returns <code>true</code>, <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a98067924cbcf318e105b92c019acf33e">quit()</a> is called; otherwise the signal handler will return (and crash or get an infinite sequence of fatal signals). Note that if an application hook is registered, fataldump() is not called by default; the application hook must invoke it itself to get the dump.</p>
<p>If <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a150e4c8e320da5b8a0690973b287890e">FATAL_AUTO_EXIT</a> is not set, the application must have registered a main return hook, which will be invoked. The hook must not return, but do a <code>siglongjmp</code> back to the main program (it should not throw unless all code is built with options that allow exceptions to be thrown from signal handlers). Note that the fatal signal may be asynchronous and may have arisen in code left in unsafe state, so returning back to the main program may not buy you much. It may make sense for a few things like rogue null pointer dereferences or floating point exceptions.</p>
<p>An interactive application using a main return hook should do something like this when the <code>sigsetjmp</code> in the main loop returns:</p>
<ul>
<li>disable "main loop entered" status</li>
<li>inform the user about the fatal error (e.g. with a popup); the popup window should be precreated for best stability</li>
<li>reset any locks the application holds, especially for user interface, including status bars, wait icons etc.</li>
<li>suggest to run a debugger against the program right there</li>
<li>in a windowing system ungrab pointer, keyboard and the server</li>
<li>unblock the signal via block(sig, false) as the operating system may think the signal is still being processed</li>
<li>add an idle processor to re-return the "main loop entered" once all pending event queue events have been drained</li>
<li>go onto processing gui events</li>
</ul>
<p>Using a main return will most likely leak memory like a sieve, but in balance, the application just got a fatal signal and the leak is unlikely to be the greatest concern. </p>

</div>
</div>
<a class="anchor" id="a5b6e599feec0e6ea2e5d204c7accf7ab"></a><!-- doxytag: member="Athena::Signal::fatalDump" ref="a5b6e599feec0e6ea2e5d204c7accf7ab" args="(int sig, siginfo_t *info, void *x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Athena::Signal::fatalDump </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dbc/structsiginfo__t.html">siginfo_t</a> *&nbsp;</td>
          <td class="paramname"> <em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>extra</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Dump application state information on a fatal signal.</p>
<p>Use this method to dump program state on a delivery of a fatal signal. <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a29ed2239824de7084eec2096921df121">fatal()</a> uses this function automatically if no fatal handler hook has not been registered by the application.</p>
<p>This function attempts to be as maximally robust given that it runs in a signal handler in conditions where the program by definition is unstable. In other words, it allocates no memory and writes its output directly to a file descriptor with direct system calls. For this reason some initialisation is required; use <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a91247206fb7476bfbc60ba82aed77309">handleFatal()</a> to register the current application name and an output file descriptor, preferably as early in the program as possible.</p>
<p>The dump will consist of the following items:</p>
<ul>
<li>if <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#ac52e36621c04bb27790397c43dba6343">FATAL_DUMP_SIG</a> option is set:<ul>
<li>the application name if registered with <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a91247206fb7476bfbc60ba82aed77309">handleFatal()</a></li>
<li>a title describing telling which fatal signal has been received (defined by <em>sig</em>, the signal number, or its negative if core has been dumped)</li>
<li>information available from the <em>info</em> argument</li>
</ul>
</li>
<li>if <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a09b1ac53de90bda7a0619f730531767b">FATAL_DUMP_CONTEXT</a> option is set, all the available CPU context information like registers</li>
<li>if <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#adf0c99c485898916f19e5f3b20a92855">FATAL_DUMP_STACK</a> option is set, the stack trace</li>
<li>if <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#aa774d944e7b551a7f9e2a4ad7d3558b6">FATAL_DUMP_LIBS</a> option is set, the list of currently loaded shared libraries</li>
</ul>
<p>This always returns <code>true</code> so it is convenient for the application fatal hook to return with a call to this function.</p>
<p>Note that this function will not flush <code>std::cerr</code> or <code>stderr</code> before producing output, for stability reasons. If the streams have unflushed output in their buffers, that output may get mixed with unbuffered direct output from this function. If you wish to avoid this mixup and are willing to take the risk that those calls might crash, install an application hook that flushes the streams and then calls this function. </p>

</div>
</div>
<a class="anchor" id="ae19a24e2785bf4313373d693270a0318"></a><!-- doxytag: member="Athena::Signal::fatalLevel" ref="ae19a24e2785bf4313373d693270a0318" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Athena::Signal::fatalLevel </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the depth to which <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a29ed2239824de7084eec2096921df121">fatal()</a> is currently recursively entered, or zero if <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a29ed2239824de7084eec2096921df121">fatal()</a> is not currently active. Use this method in application fatal hook to decide which operations are safe to perform. For example, if the attempts to notify the user result in further signals, it is best to avoid such attempts at deeper recursion levels. Currently <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a29ed2239824de7084eec2096921df121">fatal()</a> ceases to call the application's hooks and forces termination if the nesting level reaches 4. </p>

</div>
</div>
<a class="anchor" id="acb0930a18360698b9c20245fa140eba2"></a><!-- doxytag: member="Athena::Signal::handle" ref="acb0930a18360698b9c20245fa140eba2" args="(int sig, HandlerType handler, const sigset_t *blockMask=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a165a8a731e1c838d8fcbdc8e8a90672f">Signal::HandlerType</a> Athena::Signal::handle </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a165a8a731e1c838d8fcbdc8e8a90672f">HandlerType</a>&nbsp;</td>
          <td class="paramname"> <em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sigset_t *&nbsp;</td>
          <td class="paramname"> <em>blockMask</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Install a new signal handler <em>handler</em> for signal number <em>sig</em> and returns the old handler.</p>
<p>This method uses the POSIX signal handling primitives if they are available, failing which falling back to the <a class="el" href="../../db/db2/structC.html">C</a> standard <code>signal()</code> function.</p>
<p>When POSIX signals are used, signals other than <em>sig</em> are blocked according to <em>blockMask</em> (if null, no change is made) during the execution of <em>handler</em>. Note that the signal itself is always blocked during the handler execution and need not be mentioned in the mask explicitly. System calls are made restartable although this has little impact as this library always restarts interrupted system calls automatically despite the signal handling settings.</p>
<p>(FIXME: Expose option SA_NOCLDSTOP, SA_ONSTACK?) (FIXME: Threads vs. signals) </p>

</div>
</div>
<a class="anchor" id="a91247206fb7476bfbc60ba82aed77309"></a><!-- doxytag: member="Athena::Signal::handleFatal" ref="a91247206fb7476bfbc60ba82aed77309" args="(const char *applicationName=0, IOFD fd=IOFD_INVALID, FatalHook hook=0, FatalReturn mainreturn=0, unsigned options=FATAL_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Athena::Signal::handleFatal </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>applicationName</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d1/dc7/SealCommon_8h.html#a98d936fe848403f33ff9cebfc9a38597">IOFD</a>&nbsp;</td>
          <td class="paramname"> <em>fd</em> = <code>IOFD_INVALID</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#ad4933f5dea26508794985dc36879fd4f">FatalHook</a>&nbsp;</td>
          <td class="paramname"> <em>hook</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a0a1d20177cf76b6f120d8f70fd547414">FatalReturn</a>&nbsp;</td>
          <td class="paramname"> <em>mainreturn</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>options</em> = <code><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a0c47f0fc8e3ccd9ef3de3c2bc7ea39a3">FATAL_DEFAULT</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Install default handler for fatal signals.</p>
<p>This method installs a handler for fatal signals such as floating point exceptions, illegal instructions, and memory violations. The behaviour is more precisely determined by <em>options</em>, a bitwise or of the option constants defined in the class declaration.</p>
<p><em>applicationName</em> sets the application name to be used to report the signal in <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a5b6e599feec0e6ea2e5d204c7accf7ab">fatalDump()</a>. <em>fd</em> sets the file descriptor to which the fatal signal message is written; by default this will be the standard error output. <em>hook</em> sets the pre-exit application hook to invoke, <em>mainreturn</em> sets the hook to return to back to the application "main loop" (i.e. ignore the signal by jumping out of the signal back to the somewhere higher up in the application).</p>
<p>Options left to default values will not change the current state. This allows one to re-install signal handlers without disturbing already registered information. Use this to restore handlers after some other library has meddled with the handlers.</p>
<p>This installs <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a29ed2239824de7084eec2096921df121">fatal()</a> as the handler for fatal signals and on Windows for otherwise unhandled fatal structured exceptions. If <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a369e40f96220b4e610c171a03e09bde1">FATAL_ON_QUIT</a> is included in <em>options</em>, quitting related signals (see <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a98067924cbcf318e105b92c019acf33e">quit()</a>) are also considered fatal. If <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#afbce7583ec5181b33546721b78fe8f01">FATAL_ON_INT</a> is set, SIGINT is considered fatal---but see also <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a29ed2239824de7084eec2096921df121">fatal()</a> documentation. If <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#aadde66d635b299a4f8f88d222855ce3b">USR1_DUMP_CORE</a> is set, DebugAids::coredump is registered as a handler for SIGUSR1 (please note the security risks of this option in its documentation).</p>
<p><a class="el" href="../../d4/dc4/structA.html">A</a> multi-threaded application should call this method in each thread. (FIXME: Calling this in one thread and blocking signals in others won't work on Linux, and in any case will probably produce non-sense stack traces (unless stacktrace can be fixed to dump the stacks of all the threads). Since the handler is always the same, I am not sure it will make the slightest difference which thread catches the signals, and on the other hand, it is best to dump the problems in the faulting thread if possible.) </p>

</div>
</div>
<a class="anchor" id="a531516a7bafb85ada87cc13df42be6c9"></a><!-- doxytag: member="Athena::Signal::handleFatalFd" ref="a531516a7bafb85ada87cc13df42be6c9" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dc7/SealCommon_8h.html#a98d936fe848403f33ff9cebfc9a38597">IOFD</a> Athena::Signal::handleFatalFd </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the file descriptor fataldump() uses for output. Registered through <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a91247206fb7476bfbc60ba82aed77309">handleFatal()</a>. </p>

</div>
</div>
<a class="anchor" id="acf9c12a42518c098bcdc03e2e1ec164a"></a><!-- doxytag: member="Athena::Signal::handleFatalHook" ref="acf9c12a42518c098bcdc03e2e1ec164a" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#ad4933f5dea26508794985dc36879fd4f">Signal::FatalHook</a> Athena::Signal::handleFatalHook </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the application fatal signal hook. Registered through <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a91247206fb7476bfbc60ba82aed77309">handleFatal()</a>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a29ed2239824de7084eec2096921df121">fatal()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aab22be0d7aa1e7034b2de5f158c74533"></a><!-- doxytag: member="Athena::Signal::handleFatalOptions" ref="aab22be0d7aa1e7034b2de5f158c74533" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Athena::Signal::handleFatalOptions </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the current fatal signal handling options. Set on invocation to <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a91247206fb7476bfbc60ba82aed77309">handleFatal()</a>. </p>

</div>
</div>
<a class="anchor" id="a058d561130784cb3ff06f944dd2a642c"></a><!-- doxytag: member="Athena::Signal::handleFatalReturn" ref="a058d561130784cb3ff06f944dd2a642c" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a0a1d20177cf76b6f120d8f70fd547414">Signal::FatalReturn</a> Athena::Signal::handleFatalReturn </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the application fatal signal return hook. Registered through <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a91247206fb7476bfbc60ba82aed77309">handleFatal()</a>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a29ed2239824de7084eec2096921df121">fatal()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ae09161d0e01449d88a870c9ce33e48ab"></a><!-- doxytag: member="Athena::Signal::handleQuitHook" ref="ae09161d0e01449d88a870c9ce33e48ab" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a580d4d8dab36af1b92760624a314fe10">Signal::QuitHook</a> Athena::Signal::handleQuitHook </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the current application quit signal hook. Registered through handleQuit(). </p>

</div>
</div>
<a class="anchor" id="a03b798ab9f156df7c4201b8ca965fc7c"></a><!-- doxytag: member="Athena::Signal::handler" ref="a03b798ab9f156df7c4201b8ca965fc7c" args="(int sig, sigset_t *mask=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a165a8a731e1c838d8fcbdc8e8a90672f">Signal::HandlerType</a> Athena::Signal::handler </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sigset_t *&nbsp;</td>
          <td class="paramname"> <em>mask</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the current handler for signal number <em>sig</em> and its blocked signals in <em>mask</em> (if non-null). </p>

</div>
</div>
<a class="anchor" id="a7694b12f8ec856d8ece08fe5ffd46c3f"></a><!-- doxytag: member="Athena::Signal::ignore" ref="a7694b12f8ec856d8ece08fe5ffd46c3f" args="(int sig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Athena::Signal::ignore </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sig</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Ignore the signal number <em>sig</em>. </p>

</div>
</div>
<a class="anchor" id="a15848d5bc08689bda47833527c74512d"></a><!-- doxytag: member="Athena::Signal::kill" ref="a15848d5bc08689bda47833527c74512d" args="(pid_t process, int sig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Athena::Signal::kill </td>
          <td>(</td>
          <td class="paramtype">pid_t&nbsp;</td>
          <td class="paramname"> <em>process</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sig</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Send the signal <em>sig</em> to process identified by <em>process</em>. Implemented only on unixen. </p>

</div>
</div>
<a class="anchor" id="a4d98e5d67200d900fdc04abecb3d6911"></a><!-- doxytag: member="Athena::Signal::mask" ref="a4d98e5d67200d900fdc04abecb3d6911" args="(const sigset_t *mask, sigset_t *old=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Athena::Signal::mask </td>
          <td>(</td>
          <td class="paramtype">const sigset_t *&nbsp;</td>
          <td class="paramname"> <em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sigset_t *&nbsp;</td>
          <td class="paramname"> <em>old</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the list of currently blocked signals to <em>mask</em> and return the old setting in <em>old</em> (if non-null). This function is implemented only on systems with POSIX signals. </p>

</div>
</div>
<a class="anchor" id="a0adbe38fd6bad8af8f01df2ebadd226a"></a><!-- doxytag: member="Athena::Signal::name" ref="a0adbe38fd6bad8af8f01df2ebadd226a" args="(int sig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * Athena::Signal::name </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sig</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the name of the signal number <em>sig</em>. The returned memory is statically allocated and must not be freed. </p>

</div>
</div>
<a class="anchor" id="adc09b8c58ec8e5a11cec445fc8fc37bc"></a><!-- doxytag: member="Athena::Signal::pending" ref="adc09b8c58ec8e5a11cec445fc8fc37bc" args="(sigset_t *mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Athena::Signal::pending </td>
          <td>(</td>
          <td class="paramtype">sigset_t *&nbsp;</td>
          <td class="paramname"> <em>mask</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return in <em>mask</em> the list of signals pending for this process. </p>

</div>
</div>
<a class="anchor" id="a9b3d452bd4db782ababb16856e502b4d"></a><!-- doxytag: member="Athena::Signal::pending" ref="a9b3d452bd4db782ababb16856e502b4d" args="(int sig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Athena::Signal::pending </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sig</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check if <em>sig</em> is pending for this process. </p>

</div>
</div>
<a class="anchor" id="a3736a405678e733d4ab65217a19d6a3e"></a><!-- doxytag: member="Athena::Signal::queue" ref="a3736a405678e733d4ab65217a19d6a3e" args="(pid_t process, int sig, void *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Athena::Signal::queue </td>
          <td>(</td>
          <td class="paramtype">pid_t&nbsp;</td>
          <td class="paramname"> <em>process</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Queue signal <em>sig</em> with additional data <em>value</em> for <em>process</em>. Implemented only on systems with POSIX real-time signals. </p>

</div>
</div>
<a class="anchor" id="a3cb61f4a6cee9302b5726f12acba6100"></a><!-- doxytag: member="Athena::Signal::queue" ref="a3cb61f4a6cee9302b5726f12acba6100" args="(pid_t process, int sig, int value=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Athena::Signal::queue </td>
          <td>(</td>
          <td class="paramtype">pid_t&nbsp;</td>
          <td class="paramname"> <em>process</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>value</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Queue signal <em>sig</em> with additional data <em>value</em> for <em>process</em>. Implemented only on systems with POSIX real-time signals. </p>

</div>
</div>
<a class="anchor" id="ab440bbd5068c51676db72c90e2bd481f"></a><!-- doxytag: member="Athena::Signal::queue" ref="ab440bbd5068c51676db72c90e2bd481f" args="(int sig, void *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Athena::Signal::queue </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Queue signal <em>sig</em> for this process with additional data <em>value</em>. Implemented only on systems with POSIX real-time signals. </p>

</div>
</div>
<a class="anchor" id="a2320430a74b58f6a2180a794f3e6aaab"></a><!-- doxytag: member="Athena::Signal::queue" ref="a2320430a74b58f6a2180a794f3e6aaab" args="(int sig, int value=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Athena::Signal::queue </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>value</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Queue signal <em>sig</em> for this process with additional data <em>value</em>. Implemented only on systems with POSIX real-time signals. </p>

</div>
</div>
<a class="anchor" id="a98067924cbcf318e105b92c019acf33e"></a><!-- doxytag: member="Athena::Signal::quit" ref="a98067924cbcf318e105b92c019acf33e" args="(int sig, siginfo_t *info, void *x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Athena::Signal::quit </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dbc/structsiginfo__t.html">siginfo_t</a> *&nbsp;</td>
          <td class="paramname"> <em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The quit signal handler.</p>
<p>This is the handler installed by handleQuit(). Please use handleQuit() and this method instead of installing your own handlers with <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#acb0930a18360698b9c20245fa140eba2">handle()</a>.</p>
<p>This handler first invokes the application hook if one was given to handleQuit(). If the hook returns <code>true</code>, the signal handler for this signal (number <em>sig</em>) is reset to its default handler, and the signal is re-raised. This causes the program to exit via the signal and have a the correct exit status.</p>
<p>The application should do whatever is necessary for a graceful shutdown. Note however that this signal may arrive asynchronously at any time, hence it probably isn't safe to allocate memory, use the standard output streams, and so forth. What you can do is to set a flag, return <code>false</code> to return back to your application, detect the flag setting and drain your current event loop, and then quit. But do note that if <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a150e4c8e320da5b8a0690973b287890e">FATAL_AUTO_EXIT</a> was set in call to <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a91247206fb7476bfbc60ba82aed77309">handleFatal()</a>, <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a29ed2239824de7084eec2096921df121">fatal()</a> will call <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a98067924cbcf318e105b92c019acf33e">quit()</a> which in turn calls the application hook. Thus the hook should make sure it returns <code>true</code> if the application has crashed as noted in the documentation for &lt;&lt;QuitHook&gt;&gt;. </p>

</div>
</div>
<a class="anchor" id="a08098f4712adf303e1308740a647b6fb"></a><!-- doxytag: member="Athena::Signal::raise" ref="a08098f4712adf303e1308740a647b6fb" args="(int sig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Athena::Signal::raise </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sig</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Raise the signal number <em>sig</em>. Returns the exit code from the <code><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a08098f4712adf303e1308740a647b6fb">raise()</a></code> system call (or <code><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a15848d5bc08689bda47833527c74512d">kill()</a></code> if <code><a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a08098f4712adf303e1308740a647b6fb">raise()</a></code> does not exist). </p>

</div>
</div>
<a class="anchor" id="a76c5c303a2f6cbf9af04709666f0e47c"></a><!-- doxytag: member="Athena::Signal::revert" ref="a76c5c303a2f6cbf9af04709666f0e47c" args="(int sig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Athena::Signal::revert </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sig</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Revert the signal number <em>sig</em> back to its default behaviour. </p>

</div>
</div>
<a class="anchor" id="a12d5227fb0b4627b25f75c80bbc97232"></a><!-- doxytag: member="Athena::Signal::suspend" ref="a12d5227fb0b4627b25f75c80bbc97232" args="(const sigset_t *mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Athena::Signal::suspend </td>
          <td>(</td>
          <td class="paramtype">const sigset_t *&nbsp;</td>
          <td class="paramname"> <em>mask</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Temporarily replace the signal mask of the process with <em>mask</em> and then suspend until a signal is received. </p>

</div>
</div>
<a class="anchor" id="ad6d376707953d3536cbbbf7350d385e4"></a><!-- doxytag: member="Athena::Signal::wait" ref="ad6d376707953d3536cbbbf7350d385e4" args="(const sigset_t *mask, siginfo_t *info=0, long msecs=&#45;1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Athena::Signal::wait </td>
          <td>(</td>
          <td class="paramtype">const sigset_t *&nbsp;</td>
          <td class="paramname"> <em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dbc/structsiginfo__t.html">siginfo_t</a> *&nbsp;</td>
          <td class="paramname"> <em>info</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>msecs</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Suspend the thread waiting for signals specified by <em>mask</em> for at most <em>msecs</em> milliseconds. If <em>msecs</em> is negative (the default), waits until a signal is delivered. Otherwise waits up to the specified time limit. Returns the number of the signal that was received, or -1 if the time limit expired. If <em>info</em> is given, fills it with the information that the handler would have otherwise been given. Note that the signals must be blocked (in a multi-threaded application in all the threads, not just the calling one) and not be ignored before calling this function; if a handler is registered, it won't be called. Implemented only on systems with POSIX real-time signals. </p>

</div>
</div>
<a class="anchor" id="a618af8c53f3f8942b558f712e12865ef"></a><!-- doxytag: member="Athena::Signal::wait" ref="a618af8c53f3f8942b558f712e12865ef" args="(int sig, siginfo_t *info=0, long msecs=&#45;1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Athena::Signal::wait </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dbc/structsiginfo__t.html">siginfo_t</a> *&nbsp;</td>
          <td class="paramname"> <em>info</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>msecs</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Suspend the thread waiting for signal <em>sig</em> at most <em>msecs</em> milliseconds. If <em>msecs</em> is negative (the default), waits until a signal is delivered. Otherwise waits up to the specified time limit. Returns <code>true</code> if the signal was received. Note that the signal must be blocked (in a multi-threaded application in all the threads, not just the calling one) and not be ignored before calling this function; if a handler is registered, it won't be called. Implemented only on systems with POSIX real-time signals. </p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a150e4c8e320da5b8a0690973b287890e"></a><!-- doxytag: member="Athena::Signal::FATAL_AUTO_EXIT" ref="a150e4c8e320da5b8a0690973b287890e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a150e4c8e320da5b8a0690973b287890e">Athena::Signal::FATAL_AUTO_EXIT</a> = 256<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Option to make <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a29ed2239824de7084eec2096921df121">fatal()</a> exit via <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a98067924cbcf318e105b92c019acf33e">quit()</a>. This will cause all the application clean-up hook to run. </p>

</div>
</div>
<a class="anchor" id="a0c47f0fc8e3ccd9ef3de3c2bc7ea39a3"></a><!-- doxytag: member="Athena::Signal::FATAL_DEFAULT" ref="a0c47f0fc8e3ccd9ef3de3c2bc7ea39a3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a0c47f0fc8e3ccd9ef3de3c2bc7ea39a3">Athena::Signal::FATAL_DEFAULT</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment"> (<a class="code" href="../../d9/d58/classAthena_1_1Signal.html#aadde66d635b299a4f8f88d222855ce3b">USR1_DUMP_CORE</a>
                       | <a class="code" href="../../d9/d58/classAthena_1_1Signal.html#afbce7583ec5181b33546721b78fe8f01">FATAL_ON_INT</a>
                       | <a class="code" href="../../d9/d58/classAthena_1_1Signal.html#a6798ead5f4386eed186a5e8dd885e00f">FATAL_DUMP_CORE</a>
                       | <a class="code" href="../../d9/d58/classAthena_1_1Signal.html#ac52e36621c04bb27790397c43dba6343">FATAL_DUMP_SIG</a>
                       | <a class="code" href="../../d9/d58/classAthena_1_1Signal.html#adf0c99c485898916f19e5f3b20a92855">FATAL_DUMP_STACK</a>
                       | <a class="code" href="../../d9/d58/classAthena_1_1Signal.html#aa774d944e7b551a7f9e2a4ad7d3558b6">FATAL_DUMP_LIBS</a>
                       | <a class="code" href="../../d9/d58/classAthena_1_1Signal.html#a09b1ac53de90bda7a0619f730531767b">FATAL_DUMP_CONTEXT</a>
                       | <a class="code" href="../../d9/d58/classAthena_1_1Signal.html#a150e4c8e320da5b8a0690973b287890e">FATAL_AUTO_EXIT</a>)
</pre></div><p>Default options to <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a91247206fb7476bfbc60ba82aed77309">handleFatal()</a>. </p>

</div>
</div>
<a class="anchor" id="a09b1ac53de90bda7a0619f730531767b"></a><!-- doxytag: member="Athena::Signal::FATAL_DUMP_CONTEXT" ref="a09b1ac53de90bda7a0619f730531767b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a09b1ac53de90bda7a0619f730531767b">Athena::Signal::FATAL_DUMP_CONTEXT</a> = 128<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Option to make fataldump() (invoked by <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a29ed2239824de7084eec2096921df121">fatal()</a>) to dump the machine context (registers etc.) from the fault position. </p>

</div>
</div>
<a class="anchor" id="a6798ead5f4386eed186a5e8dd885e00f"></a><!-- doxytag: member="Athena::Signal::FATAL_DUMP_CORE" ref="a6798ead5f4386eed186a5e8dd885e00f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a6798ead5f4386eed186a5e8dd885e00f">Athena::Signal::FATAL_DUMP_CORE</a> = 8<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Option to make <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a29ed2239824de7084eec2096921df121">fatal()</a> dump a core file before crashing. </p>

</div>
</div>
<a class="anchor" id="aa774d944e7b551a7f9e2a4ad7d3558b6"></a><!-- doxytag: member="Athena::Signal::FATAL_DUMP_LIBS" ref="aa774d944e7b551a7f9e2a4ad7d3558b6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#aa774d944e7b551a7f9e2a4ad7d3558b6">Athena::Signal::FATAL_DUMP_LIBS</a> = 64<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Option to make fataldump() (invoked by <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a29ed2239824de7084eec2096921df121">fatal()</a>) to dump the list of currently loaded shared libraries. </p>

</div>
</div>
<a class="anchor" id="ac52e36621c04bb27790397c43dba6343"></a><!-- doxytag: member="Athena::Signal::FATAL_DUMP_SIG" ref="ac52e36621c04bb27790397c43dba6343" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#ac52e36621c04bb27790397c43dba6343">Athena::Signal::FATAL_DUMP_SIG</a> = 16<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Option to make fataldump() (invoked by <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a29ed2239824de7084eec2096921df121">fatal()</a>) to dump the signal name (as reported by <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a0adbe38fd6bad8af8f01df2ebadd226a">name()</a>). </p>

</div>
</div>
<a class="anchor" id="adf0c99c485898916f19e5f3b20a92855"></a><!-- doxytag: member="Athena::Signal::FATAL_DUMP_STACK" ref="adf0c99c485898916f19e5f3b20a92855" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#adf0c99c485898916f19e5f3b20a92855">Athena::Signal::FATAL_DUMP_STACK</a> = 32<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Option to make fataldump() (invoked by <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a29ed2239824de7084eec2096921df121">fatal()</a>) to dump stack backtrace for the offending code location. </p>

</div>
</div>
<a class="anchor" id="afbce7583ec5181b33546721b78fe8f01"></a><!-- doxytag: member="Athena::Signal::FATAL_ON_INT" ref="afbce7583ec5181b33546721b78fe8f01" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#afbce7583ec5181b33546721b78fe8f01">Athena::Signal::FATAL_ON_INT</a> = 4<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Option to make SIGINT fatal. It will still just quit, not crash. </p>

</div>
</div>
<a class="anchor" id="a369e40f96220b4e610c171a03e09bde1"></a><!-- doxytag: member="Athena::Signal::FATAL_ON_QUIT" ref="a369e40f96220b4e610c171a03e09bde1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a369e40f96220b4e610c171a03e09bde1">Athena::Signal::FATAL_ON_QUIT</a> = 2<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Option to make SIGHUP, SIGTERM and SIGQUIT fatal instead of just <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a98067924cbcf318e105b92c019acf33e">quit()</a> signals. </p>

</div>
</div>
<a class="anchor" id="aadde66d635b299a4f8f88d222855ce3b"></a><!-- doxytag: member="Athena::Signal::USR1_DUMP_CORE" ref="aadde66d635b299a4f8f88d222855ce3b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#aadde66d635b299a4f8f88d222855ce3b">Athena::Signal::USR1_DUMP_CORE</a> = 1<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Option that instructs <a class="el" href="../../d9/d58/classAthena_1_1Signal.html#a29ed2239824de7084eec2096921df121">fatal()</a> to call coredump() on SIGUSR1. This is merely a request to drop a <code>core</code>; no attempt is made to guarantee success. Failure may result for example for lack of permissions, for lack of disk space, or due to low resource limits. Please note that <code>core</code> files can only be created on unixen. Note also that dropping a core is a security risk and should never be enabled in setuid or setgid programs or for production applications. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.30/CxxUtils/CxxUtils/<a class="el" href="../../d0/dc2/SealSignal_8h_source.html">SealSignal.h</a></li>
<li>/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.30/CxxUtils/Root/SealSignal.cxx</li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 15 Apr 2017 for RootCore Packages by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
