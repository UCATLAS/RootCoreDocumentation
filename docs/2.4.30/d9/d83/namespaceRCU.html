<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>RootCore Packages: RCU Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='../../open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='../../closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='../../closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="contents">
<h1>RCU Namespace Reference</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d7c/classRCU_1_1ExceptionMsg.html">ExceptionMsg</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d42/structRCU_1_1Message.html">Message</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/da0/classRCU_1_1UnitTestDir.html">UnitTestDir</a></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d83/namespaceRCU.html#aead8fc78ddc262a6e40e8eb6bf71955e">MessageType</a> { <br/>
&nbsp;&nbsp;<a class="el" href="../../d9/d83/namespaceRCU.html#aead8fc78ddc262a6e40e8eb6bf71955ea882902888e75d9ddb501e6fc7b24b7dd">MESSAGE_REGULAR</a>, 
<a class="el" href="../../d9/d83/namespaceRCU.html#aead8fc78ddc262a6e40e8eb6bf71955ea1edabba6e7dbbed7408efb733e989bee">MESSAGE_WARNING</a>, 
<a class="el" href="../../d9/d83/namespaceRCU.html#aead8fc78ddc262a6e40e8eb6bf71955eafa35b6ca894da0c54255e12a0aad265d">MESSAGE_ERROR</a>, 
<a class="el" href="../../d9/d83/namespaceRCU.html#aead8fc78ddc262a6e40e8eb6bf71955ea3dbce95f8f4d8689e5df8f96f551a200">MESSAGE_EXCEPTION</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="../../d9/d83/namespaceRCU.html#aead8fc78ddc262a6e40e8eb6bf71955ea018bd98bb2d91f01ea292ea19a1bad85">MESSAGE_ABORT</a>, 
<a class="el" href="../../d9/d83/namespaceRCU.html#aead8fc78ddc262a6e40e8eb6bf71955ea1d604967fcc3a6e26acb00777c572d1e">MESSAGE_UNSPECIFIED</a>
<br/>
 }</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d83/namespaceRCU.html#a33d1aab649b47e38f72a19729a0ccbe7">check_root_version</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d83/namespaceRCU.html#abbcbf76aea12380b31878ea3872e7c03">disable_root_version_check</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d83/namespaceRCU.html#ad6b11c00605f529a1cde4fdc548dc128">hadd</a> (std::string output_file, std::vector&lt; std::string &gt; input_files, unsigned max_files)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d83/namespaceRCU.html#ac0d5d6a5fff1c4171252fea0ca4de8eb">hadd_core</a> (std::string output_file, std::vector&lt; std::string &gt; input_files, unsigned max_files)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d83/namespaceRCU.html#a87852c5888aefa40fff4a7a7bc493cec">locate</a> (const std::string &amp;locations)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86e1ef8c19f37c37bba0edc445540c5f"></a><!-- doxytag: member="RCU::send_message" ref="a86e1ef8c19f37c37bba0edc445540c5f" args="(const char *package, const char *file, unsigned line, MessageType type, const char *msg)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>send_message</b> (const char *package, const char *file, unsigned line, <a class="el" href="../../d9/d83/namespaceRCU.html#aead8fc78ddc262a6e40e8eb6bf71955e">MessageType</a> type, const char *msg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af392ba4cb2469048233c97efb98fe5c0"></a><!-- doxytag: member="RCU::send_message" ref="af392ba4cb2469048233c97efb98fe5c0" args="(const char *package, const char *file, unsigned line, MessageType type, const std::string &amp;msg)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>send_message</b> (const char *package, const char *file, unsigned line, <a class="el" href="../../d9/d83/namespaceRCU.html#aead8fc78ddc262a6e40e8eb6bf71955e">MessageType</a> type, const std::string &amp;msg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1113f30c8047adbd55d70a7952545f0"></a><!-- doxytag: member="RCU::send_message" ref="af1113f30c8047adbd55d70a7952545f0" args="(const char *package, const char *file, unsigned line, MessageType type, const TString &amp;msg)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>send_message</b> (const char *package, const char *file, unsigned line, <a class="el" href="../../d9/d83/namespaceRCU.html#aead8fc78ddc262a6e40e8eb6bf71955e">MessageType</a> type, const TString &amp;msg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4bdee95724528f85c9da6a83ccaa2db"></a><!-- doxytag: member="RCU::send_message_abort" ref="ad4bdee95724528f85c9da6a83ccaa2db" args="(const char *package, const char *file, unsigned line, MessageType type, const char *msg)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>send_message_abort</b> (const char *package, const char *file, unsigned line, <a class="el" href="../../d9/d83/namespaceRCU.html#aead8fc78ddc262a6e40e8eb6bf71955e">MessageType</a> type, const char *msg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4ba456f931eae366777efa92df5edae"></a><!-- doxytag: member="RCU::send_message_abort" ref="ad4ba456f931eae366777efa92df5edae" args="(const char *package, const char *file, unsigned line, MessageType type, const std::string &amp;msg)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>send_message_abort</b> (const char *package, const char *file, unsigned line, <a class="el" href="../../d9/d83/namespaceRCU.html#aead8fc78ddc262a6e40e8eb6bf71955e">MessageType</a> type, const std::string &amp;msg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d207c85a5395d068aeb2dce01de0ec9"></a><!-- doxytag: member="RCU::send_message_abort" ref="a5d207c85a5395d068aeb2dce01de0ec9" args="(const char *package, const char *file, unsigned line, MessageType type, const TString &amp;msg)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>send_message_abort</b> (const char *package, const char *file, unsigned line, <a class="el" href="../../d9/d83/namespaceRCU.html#aead8fc78ddc262a6e40e8eb6bf71955e">MessageType</a> type, const TString &amp;msg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d83/namespaceRCU.html#aea9c76ac79711b2f15e7823b72a63a4c">ranLoadPackages</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">whether load_packages.C has been run  <a href="#aea9c76ac79711b2f15e7823b72a63a4c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d83/namespaceRCU.html#a9b4f6416213f8a4bb0288c43860203bd">SetDirectory</a> (TObject *object, TDirectory *directory)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d83/namespaceRCU.html#ab1c54d25ffc26bd9784946bcda604b01">substitute</a> (const std::string &amp;str, const std::string &amp;pattern, const std::string &amp;with)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d83/namespaceRCU.html#aa110e4059664bce7be1f3d8ba4f3308d">match_expr</a> (const boost::regex &amp;expr, const std::string &amp;str)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d83/namespaceRCU.html#afd6cf303e6328f2fcaae645f40855a99">glob_to_regexp</a> (const std::string &amp;glob)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This module defines a variety of assert style macros. The interface in this module is indended for experts only. This module is considered to be in the pre-alpha stage. This module defines a variety of assert style macros for different situations, i.e. macros that test whether a particular condition has been met and that trigger an error if the condition is not met. The exact error behavior depends on the configuration options as well as the macro called. The main distinction is the purpose of the test: RCU_REQUIRE: checks on the arguments to a function RCU_PROVIDE: checks on the results of a function RCU_ASSERT: checks that happen in the middle of a function RCU_INVARIANT: checks that happen in the invariant test These can be further modified using postfixes: _SLOW: tests that are in the critical path of a program _SOFT: tests that are expected to fail in correctly implemented programs, i.e. should trigger an exception 2: tests that have a textual description of the condition 0: tests that always fail Furthermore there are also invariant tests in here (calling MyClass::testInvariant()): RCU_READ_INVARIANT: an invariant is read, but not modified RCU_CHANGE_INVARIANT: an invariant is read and modified RCU_NEW_INVARIANT: an invariant has been newly established RCU_DESTROY_INVARIANT: an invariant is about to be decomissioned</p>
<p>This module provides a lot of global definitions, forward declarations and includes that are used by all modules. As such it doesn't fall into the user vs. expert classification.</p>
<p>This module defines macros for reporting errors. The interface in this module is indended for experts only. This module is considered to be in the pre-alpha stage.</p>
<p>This module defines a class that manages a temporary directory for unit tests. The interface provided in this module is intended for experts only. The module is considered to be in the pre-alpha stage. </p>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="aead8fc78ddc262a6e40e8eb6bf71955e"></a><!-- doxytag: member="RCU::MessageType" ref="aead8fc78ddc262a6e40e8eb6bf71955e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../d9/d83/namespaceRCU.html#aead8fc78ddc262a6e40e8eb6bf71955e">RCU::MessageType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="aead8fc78ddc262a6e40e8eb6bf71955ea882902888e75d9ddb501e6fc7b24b7dd"></a><!-- doxytag: member="MESSAGE_REGULAR" ref="aead8fc78ddc262a6e40e8eb6bf71955ea882902888e75d9ddb501e6fc7b24b7dd" args="" -->MESSAGE_REGULAR</em>&nbsp;</td><td>
<p>description: print a regular message </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aead8fc78ddc262a6e40e8eb6bf71955ea1edabba6e7dbbed7408efb733e989bee"></a><!-- doxytag: member="MESSAGE_WARNING" ref="aead8fc78ddc262a6e40e8eb6bf71955ea1edabba6e7dbbed7408efb733e989bee" args="" -->MESSAGE_WARNING</em>&nbsp;</td><td>
<p>description: print a warning </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aead8fc78ddc262a6e40e8eb6bf71955eafa35b6ca894da0c54255e12a0aad265d"></a><!-- doxytag: member="MESSAGE_ERROR" ref="aead8fc78ddc262a6e40e8eb6bf71955eafa35b6ca894da0c54255e12a0aad265d" args="" -->MESSAGE_ERROR</em>&nbsp;</td><td>
<p>description: print an error </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aead8fc78ddc262a6e40e8eb6bf71955ea3dbce95f8f4d8689e5df8f96f551a200"></a><!-- doxytag: member="MESSAGE_EXCEPTION" ref="aead8fc78ddc262a6e40e8eb6bf71955ea3dbce95f8f4d8689e5df8f96f551a200" args="" -->MESSAGE_EXCEPTION</em>&nbsp;</td><td>
<p>description: send out an exception </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aead8fc78ddc262a6e40e8eb6bf71955ea018bd98bb2d91f01ea292ea19a1bad85"></a><!-- doxytag: member="MESSAGE_ABORT" ref="aead8fc78ddc262a6e40e8eb6bf71955ea018bd98bb2d91f01ea292ea19a1bad85" args="" -->MESSAGE_ABORT</em>&nbsp;</td><td>
<p>description: print and abort </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aead8fc78ddc262a6e40e8eb6bf71955ea1d604967fcc3a6e26acb00777c572d1e"></a><!-- doxytag: member="MESSAGE_UNSPECIFIED" ref="aead8fc78ddc262a6e40e8eb6bf71955ea1d604967fcc3a6e26acb00777c572d1e" args="" -->MESSAGE_UNSPECIFIED</em>&nbsp;</td><td>
<p>description: unspecified message type </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a33d1aab649b47e38f72a19729a0ccbe7"></a><!-- doxytag: member="RCU::check_root_version" ref="a33d1aab649b47e38f72a19729a0ccbe7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RCU::check_root_version </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>effects: check whether we are using a consistent root version guarantee: strong failures: version missmatch </p>

</div>
</div>
<a class="anchor" id="abbcbf76aea12380b31878ea3872e7c03"></a><!-- doxytag: member="RCU::disable_root_version_check" ref="abbcbf76aea12380b31878ea3872e7c03" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RCU::disable_root_version_check </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>effects: disable the root version check guarantee: no-fail </p>

</div>
</div>
<a class="anchor" id="afd6cf303e6328f2fcaae645f40855a99"></a><!-- doxytag: member="RCU::glob_to_regexp" ref="afd6cf303e6328f2fcaae645f40855a99" args="(const std::string &amp;glob)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string RCU::glob_to_regexp </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>glob</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>returns: a string that is the regular expression equivalent of the given glob expression guarantee: strong failures: out of memory II rationale: I am returning a TString instead of an std::string, so that this can be passed directly into regexp </p>

</div>
</div>
<a class="anchor" id="ad6b11c00605f529a1cde4fdc548dc128"></a><!-- doxytag: member="RCU::hadd" ref="ad6b11c00605f529a1cde4fdc548dc128" args="(std::string output_file, std::vector&lt; std::string &gt; input_files, unsigned max_files)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RCU::hadd </td>
          <td>(</td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>output_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&nbsp;</td>
          <td class="paramname"> <em>input_files</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>max_files</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>effects: perform the hadd functionality guarantee: basic failures: out of memory III failures: i/o errors </p>

</div>
</div>
<a class="anchor" id="ac0d5d6a5fff1c4171252fea0ca4de8eb"></a><!-- doxytag: member="RCU::hadd_core" ref="ac0d5d6a5fff1c4171252fea0ca4de8eb" args="(std::string output_file, std::vector&lt; std::string &gt; input_files, unsigned max_files)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RCU::hadd_core </td>
          <td>(</td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>output_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&nbsp;</td>
          <td class="paramname"> <em>input_files</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>max_files</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>effects: perform the core hadd functionality guarantee: basic failures: out of memory III failures: i/o errors </p>

</div>
</div>
<a class="anchor" id="a87852c5888aefa40fff4a7a7bc493cec"></a><!-- doxytag: member="RCU::locate" ref="a87852c5888aefa40fff4a7a7bc493cec" args="(const std::string &amp;locations)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string RCU::locate </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>locations</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>effects: find the file with the given name from a list of locations separated by "::". the list may contain either files or URLs starting with "http://". URLs will be downloaded into the data/ directory, where they will stay permanently. returns: the path in the local filesystem guarantee: strong failures: out of memory III failures: inconsistent file names failures: download errors rationale: depending on where you are executing your code, you may or may not have access to /cvmfs where important data files are kept. this mechanism allows to pick it up from various alternate places. </p>

</div>
</div>
<a class="anchor" id="aa110e4059664bce7be1f3d8ba4f3308d"></a><!-- doxytag: member="RCU::match_expr" ref="aa110e4059664bce7be1f3d8ba4f3308d" args="(const boost::regex &amp;expr, const std::string &amp;str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RCU::match_expr </td>
          <td>(</td>
          <td class="paramtype">const boost::regex &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>returns: whether we can match the entire string with the regular expression guarantee: strong failures: out of memory II </p>

</div>
</div>
<a class="anchor" id="aea9c76ac79711b2f15e7823b72a63a4c"></a><!-- doxytag: member="RCU::ranLoadPackages" ref="aea9c76ac79711b2f15e7823b72a63a4c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RCU::ranLoadPackages </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>whether load_packages.C has been run </p>
<p>This is mostly meant for the EventLoop PROOF driver, which need to know whether to run this again or not. </p>
<dl class="user"><dt><b>Guarantee</b></dt><dd>no-fail  this is the method that should be called to check this, as the exact mechanism for checking this may change </dd></dl>

</div>
</div>
<a class="anchor" id="a9b4f6416213f8a4bb0288c43860203bd"></a><!-- doxytag: member="RCU::SetDirectory" ref="a9b4f6416213f8a4bb0288c43860203bd" args="(TObject *object, TDirectory *directory)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RCU::SetDirectory </td>
          <td>(</td>
          <td class="paramtype">TObject *&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TDirectory *&nbsp;</td>
          <td class="paramname"> <em>directory</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>effects: set the directory this object is associated with returns: whether the object type actively knows its directory, otherwise this is a no-op guarantee: strong failures: directory add errors requires: object != 0 rationale: this is mainly meant to allow calling SetDirectory(0) on arbitrary objects, but it also tries to do the right thing when adding objects to a directory. For the most part it is a workaround for TH1 objects keeping track of which directory they belong to. </p>

</div>
</div>
<a class="anchor" id="ab1c54d25ffc26bd9784946bcda604b01"></a><!-- doxytag: member="RCU::substitute" ref="ab1c54d25ffc26bd9784946bcda604b01" args="(const std::string &amp;str, const std::string &amp;pattern, const std::string &amp;with)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string RCU::substitute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>with</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>effects: substitute all occurences of "pattern" with "with" in the string "str" returns: the substituted string guarantee: out of memory II requires: !pattern.empty() </p>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 15 Apr 2017 for RootCore Packages by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
