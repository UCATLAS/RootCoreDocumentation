<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>RootCore Packages: /cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.30/AthContainers/AthContainers/DataList.h File Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='../../open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='../../closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='../../closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="contents">
<h1>/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.30/AthContainers/AthContainers/DataList.h File Reference</h1>
<p>An STL list of pointers that by default owns its pointed-to elements.  
<a href="#_details">More...</a></p>
<code>#include &lt;list&gt;</code><br/>
<code>#include &lt;typeinfo&gt;</code><br/>
<code>#include &lt;functional&gt;</code><br/>
<code>#include &lt;iostream&gt;</code><br/>
<code>#include &lt;algorithm&gt;</code><br/>
<code>#include &lt;iterator&gt;</code><br/>
<code>#include &lt;boost/static_assert.hpp&gt;</code><br/>
<code>#include &lt;boost/type_traits.hpp&gt;</code><br/>
<code>#include &lt;boost/iterator/iterator_adaptor.hpp&gt;</code><br/>
<code>#include &quot;SGTools/BaseInfo.h&quot;</code><br/>
<code>#include &quot;SGTools/DataBucketTraitFwd.h&quot;</code><br/>
<code>#include &quot;SGTools/ClassName.h&quot;</code><br/>
<code>#include &quot;AthContainers/OwnershipPolicy.h&quot;</code><br/>
<code>#include &quot;<a class="el" href="../../d4/d03/exceptions_8h_source.html">AthContainers/exceptions.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="../../d7/d92/DVLNoBase_8h_source.html">AthContainers/tools/DVLNoBase.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="../../d3/d2e/DVLInfo_8h_source.html">AthContainers/tools/DVLInfo.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="../../d4/d16/DVLDataBucket_8h_source.html">AthContainers/tools/DVLDataBucket.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="../../df/d5c/DVLCast_8h_source.html">AthContainers/tools/DVLCast.h</a>&quot;</code><br/>
<code>#include &quot;AthContainers/tools/DVLIterator.h&quot;</code><br/>
<code>#include &quot;<a class="el" href="../../d6/ddb/DVL__iter__swap_8h_source.html">AthContainers/tools/DVL_iter_swap.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="../../d0/d7a/DVL__algorithms_8h_source.html">AthContainers/tools/DVL_algorithms.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="../../db/d26/ElementProxy_8h_source.html">AthContainers/tools/ElementProxy.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="../../d5/dfa/IsMostDerivedFlag_8h_source.html">AthContainers/tools/IsMostDerivedFlag.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="../../d3/dec/selection__ns_8h_source.html">AthLinks/tools/selection_ns.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="../../d5/ddf/DataList_8icc.html">AthContainers/DataList.icc</a>&quot;</code><br/>

<p><a href="../../d1/d43/DataList_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de9/structDataListBase.html">DataListBase&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Derivation information for <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a></code>.  <a href="../../d2/de9/structDataListBase.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dfb/classDataList.html">DataList&lt; T, BASE &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Derived <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a>&lt;<a class="el" href="../../d1/def/classT.html">T</a>&gt;</code>.  <a href="../../d9/dfb/classDataList.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html">DataList&lt; T, DataModel_detail::NoBase &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base specialization for <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a>&lt;<a class="el" href="../../d1/def/classT.html">T</a>&gt;</code>.  <a href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d9d/classClassName_3_01DataList_3_01T_01_4_01_4.html">ClassName&lt; DataList&lt; T &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of <code>ClassName</code> for <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a></code>.  <a href="../../df/d9d/classClassName_3_01DataList_3_01T_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dfb/classDataList.html">DataList&lt; T, BASE &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Derived <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a>&lt;<a class="el" href="../../d1/def/classT.html">T</a>&gt;</code>.  <a href="../../d9/dfb/classDataList.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d34/structSG_1_1DataBucketTrait_3_01DataList_3_01T_01_4_00_01U_01_4.html">SG::DataBucketTrait&lt; DataList&lt; T &gt;, U &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Metafunction to find the proper <code><a class="el" href="../../d7/d54/classSG_1_1DataBucket.html">DataBucket</a></code> class for <code><a class="el" href="../../d1/def/classT.html">T</a></code>.  <a href="../../dc/d34/structSG_1_1DataBucketTrait_3_01DataList_3_01T_01_4_00_01U_01_4.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d59/namespaceSG.html">SG</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Constructor from a payload object. </p>
<br/></td></tr>
</p>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a29fa6695c3cb02dbb0faf32c779d54"></a><!-- doxytag: member="DataList.h::HAVE_CONSTDATAVECTOR" ref="a7a29fa6695c3cb02dbb0faf32c779d54" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>HAVE_CONSTDATAVECTOR</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d43/DataList_8h.html#a9051b45fea61ed235640253b4efdb86b">DATALIST_BASE</a>(<a class="el" href="../../d1/def/classT.html">T</a>, BASE)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Declare base class info to <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a></code>. Single, non-virtual derivation.  <a href="#a9051b45fea61ed235640253b4efdb86b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d43/DataList_8h.html#abfa1a94e27e2aa31a9e5de856c459b41">DATALIST_VIRTBASES1</a>(<a class="el" href="../../d1/def/classT.html">T</a>, B1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Declare base class info to <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a></code>. Single, virtual derivation.  <a href="#abfa1a94e27e2aa31a9e5de856c459b41"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d43/DataList_8h.html#ad7ad3d1a23e99411007da14017fad6c8">DATALIST_VIRTBASES2</a>(<a class="el" href="../../d1/def/classT.html">T</a>, B1, B2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Declare base class info to <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a></code>. Multiple derivation.  <a href="#ad7ad3d1a23e99411007da14017fad6c8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d43/DataList_8h.html#a3c2f8a00c08d0ffcb32fc1592a4a52d3">DATALIST_VIRTBASES3</a>(<a class="el" href="../../d1/def/classT.html">T</a>, B1, B2, B3)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Declare base class info to <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a></code>. Multiple derivation.  <a href="#a3c2f8a00c08d0ffcb32fc1592a4a52d3"></a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a1119a539ef95e66a83ed73e65ce4acb9"></a><!-- doxytag: member="DataList.h::test2_assignelement1" ref="a1119a539ef95e66a83ed73e65ce4acb9" args="()" -->
template&lt;class DL &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>test2_assignelement1</b> ()</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d43/DataList_8h.html#a2f4af3db6bca5dc8d962d673635f0865">operator==</a> (const <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a> &gt; &amp;a, const <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a> &gt; &amp;b)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">List equality comparison.  <a href="#a2f4af3db6bca5dc8d962d673635f0865"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="aa7a25d1b36f44af915a534c124985c2b"></a><!-- doxytag: member="DataList.h::operator!=" ref="aa7a25d1b36f44af915a534c124985c2b" args="(const DataList&lt; T &gt; &amp;a, const DataList&lt; T &gt; &amp;b)" -->
template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d43/DataList_8h.html#aa7a25d1b36f44af915a534c124985c2b">operator!=</a> (const <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a> &gt; &amp;a, const <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a> &gt; &amp;b)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Based on operator==. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d43/DataList_8h.html#a331f1405e2b4323d37655e725a8f5b63">operator&lt;</a> (const <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a> &gt; &amp;a, const <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a> &gt; &amp;b)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">List ordering relation.  <a href="#a331f1405e2b4323d37655e725a8f5b63"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a4292484069a07bf3057169565d175df1"></a><!-- doxytag: member="DataList.h::operator&gt;" ref="a4292484069a07bf3057169565d175df1" args="(const DataList&lt; T &gt; &amp;a, const DataList&lt; T &gt; &amp;b)" -->
template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d43/DataList_8h.html#a4292484069a07bf3057169565d175df1">operator&gt;</a> (const <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a> &gt; &amp;a, const <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a> &gt; &amp;b)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Based on operator&lt;. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a8dfe0fab283df99f49e2e84acda68ad6"></a><!-- doxytag: member="DataList.h::operator&lt;=" ref="a8dfe0fab283df99f49e2e84acda68ad6" args="(const DataList&lt; T &gt; &amp;a, const DataList&lt; T &gt; &amp;b)" -->
template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d43/DataList_8h.html#a8dfe0fab283df99f49e2e84acda68ad6">operator&lt;=</a> (const <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a> &gt; &amp;a, const <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a> &gt; &amp;b)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Based on operator&lt;. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a9cd772f232193f4545efb136406153d5"></a><!-- doxytag: member="DataList.h::operator&gt;=" ref="a9cd772f232193f4545efb136406153d5" args="(const DataList&lt; T &gt; &amp;a, const DataList&lt; T &gt; &amp;b)" -->
template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d43/DataList_8h.html#a9cd772f232193f4545efb136406153d5">operator&gt;=</a> (const <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a> &gt; &amp;a, const <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a> &gt; &amp;b)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Based on operator&lt;. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a712da80007cfbb1207df094811f2a78b"></a><!-- doxytag: member="DataList.h::swap" ref="a712da80007cfbb1207df094811f2a78b" args="(DataList&lt; T &gt; &amp;a, DataList&lt; T &gt; &amp;b)" -->
template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d43/DataList_8h.html#a712da80007cfbb1207df094811f2a78b">swap</a> (<a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a> &gt; &amp;a, <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a> &gt; &amp;b)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">See <code><a class="el" href="../../db/ded/ConstDataList_8h.html#a67766f262856f1e197e15fec33b60bac" title="See DataList&lt;T, BASE&gt;::swap().">DataList&lt;T, BASE&gt;::swap()</a></code>. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>An STL list of pointers that by default owns its pointed-to elements. </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Srini Rajagopalan, Sebastien Binet - ATLAS Collaboration </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>February 2006; rewritten from earlier version. For further information, see &lt;<a href="https://twiki.cern.ch/twiki/bin/view/Atlas/DataVector">https://twiki.cern.ch/twiki/bin/view/Atlas/DataVector</a>&gt;</dd></dl>
<p><a class="el" href="../../d4/dc4/structA.html">A</a> <code>DataList&lt;T&gt;</code> acts like a <code>std::list&lt;T*&gt;</code>, except that it can optionally manage the memory that it contains. The constructors take an (optional) extra argument, which can be either <code><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8a1f65f0fb55784cfd27d9d4d6d7986d4d" title="this data object owns its elements">SG::OWN_ELEMENTS</a></code> or <code><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8ad7d4cf2303700f0966e4140f236c4bf1" title="this data object is a view, it does not own its elmts">SG::VIEW_ELEMENTS</a></code> (defaulting to <code><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8a1f65f0fb55784cfd27d9d4d6d7986d4d" title="this data object owns its elements">SG::OWN_ELEMENTS</a></code> except for a copy constructor). This tells whether the <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a></code> owns its contained elements or not.</p>
<p>If a <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a></code> owns its elements, then they are deleted when the container itself is. Further, they are deleted by actions which erase elements from the container (i.e.: <code>erase()</code>, <code>pop_back()</code> ). <a class="el" href="../../d4/dc4/structA.html">A</a> replacement (such as <code> (*l.front()) = new <a class="el" href="../../d1/def/classT.html">T</a>; </code>) will result in the old element being deleted and the container taking ownership of the new element. It is an error to assign directly between two owning containers (<code> (*list1.front()) = (*list2.front());</code>).</p>
<p>Beware of ownership issues when modify a <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a></code> . Obviously you should not delete explicitly a <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a></code> element (because this is already taken care of by this object). <a class="el" href="../../d4/dc4/structA.html">A</a> <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a></code> should never have two elements pointing to the same object. This may seem obvious but certain STL algorithms (eg: <code>remove_if</code> ) may leave a <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a></code> with two copies of the same element in the "left-over" range. To avoid a crash when clearing the list (eg: in the destructor we have introduced a <img class="formulaInl" alt="$ n\log n $" src="../../form_0.png"/> helper function that searches and removes duplicates in the <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a></code> . This is used by the destructor by <code>clear()</code> and by <code>erase(first, last)</code>. As this may change in the future to improve performance, do not rely on this functionality and do avoid introducing duplicated elements in a <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a></code> .</p>
<p>All these cautions do not apply when a <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a></code> it is created with the flag <code><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8ad7d4cf2303700f0966e4140f236c4bf1" title="this data object is a view, it does not own its elmts">SG::VIEW_ELEMENTS</a></code> (see <code>enum OwnershipPolicy</code>) and hence does not own its elements. This is typically used to have <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a></code> elements allocated by <code>DataPool</code>. Otherwise consider the cleaner alternative of using a <code>list&lt;T*&gt;</code>.</p>
<p>The interface for <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a></code> should be mostly compatible with that of <code>std::list</code>. There are a few differences which should not make much difference in practice. For example, methods which would return a reference return a proxy object instead. Also <code>value_type</code> is used instead of <code>const_reference</code>; this is justified by the fact that the elements are always pointers.</p>
<p>Note that algorithms which modify their range may not work correctly if the container owns its contents. Specializations that work properly for <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a></code> are available for some algorithms. These include:</p>
<ul>
<li><code>std::remove</code> </li>
<li><code>std::remove_if</code> </li>
<li><code>std::unique</code> </li>
<li><code>std::reverse</code> </li>
<li><code>std::rotate</code> </li>
<li><code>std::partition</code> </li>
<li><code>std::stable_partition</code> </li>
</ul>
<p>There are a few other additions to the standard <code>std::list</code> interface.</p>
<ul>
<li>The method <code>stdcont</code> may be used to get access to the underlying <code>std::list</code> representation.</li>
<li>The type <code>PtrList</code> is the type of the underlying <code>std::List</code>. <code>BaseContainer</code> is a synonym for this.</li>
<li>The method <code>ownPolicy</code> returns the ownership policy of the container.</li>
<li>An additional overload of <code>clear()</code> is provided that takes as an argument a new ownership policy for the container. This is the only way to change the ownership policy.</li>
</ul>
<p>Note that since <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a>&lt;<a class="el" href="../../d1/def/classT.html">T</a>&gt;</code> has an element type of <code>T*</code>, it is not possible to directly insert a <code>const T*</code>. If you want to do that, see <code><a class="el" href="../../d3/d7c/classConstDataList.html" title="DataList adapter that acts like it holds const pointers.">ConstDataList</a></code>. (In some cases, such as if the destination container is not being recorded in StoreGate, it may be more appropriate to simply use a <code>std::list&lt;const T*&gt;</code>.) Don't just use a <code>const_cast!</code> </p>
<p>Finally, <code>DataList's</code> may inherit from one another. If you have class <code><a class="el" href="../../d7/db3/structD.html">D</a></code> which derives from class <code><a class="el" href="../../d9/db3/structB.html">B</a></code>, you can set things up so that <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a>&lt;<a class="el" href="../../d7/db3/structD.html">D</a>&gt;</code> derives from <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a>&lt;<a class="el" href="../../d9/db3/structB.html">B</a>&gt;</code>. This allows you do to the same sort of conversions on the <code>DataList's</code> as on the element pointers themselves. The key to doing this is to add the declaration</p>
<div class="fragment"><pre class="fragment">   <a class="code" href="../../d1/d43/DataList_8h.html#a9051b45fea61ed235640253b4efdb86b" title="Declare base class info to DataList. Single, non-virtual derivation.">DATALIST_BASE</a> (<a class="code" href="../../d7/db3/structD.html">D</a>, <a class="code" href="../../d9/db3/structB.html">B</a>);
</pre></div><p>before using <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a>&lt;<a class="el" href="../../d7/db3/structD.html">D</a>&gt;</code>. <a class="el" href="../../d4/dc4/structA.html">A</a> few caveats about doing this. The pointers are actually stored in the base <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a></code> instance, and the type that <code>stdcont</code> returns will reflect this. For example, in the example given above, <code><a class="el" href="../../d9/dfb/classDataList.html#a4f0cca5ce1808d7e1c95a9c00b694007" title="Return the underlying std::list of the container.">DataList&lt;D&gt;::stdcont()</a></code> will return a reference to std::list&lt;B*&gt;. Second, in order to preserve the invariant that a <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a>&lt;<a class="el" href="../../d7/db3/structD.html">D</a>&gt;</code> contains only elements that actually derive from <code><a class="el" href="../../d7/db3/structD.html">D</a></code>, while at the same time not requiring that the contained objects be polymorphic, there is a restriction that you cannot insert into a <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a></code> if you're not referring to it as the most derived type (even if such an insertion would not actually break the invariant). This is implemented as a runtime check.</p>
<p>Example:</p>
<div class="fragment"><pre class="fragment">   <a class="code" href="../../d9/dfb/classDataList.html" title="Derived DataList&amp;lt;T&amp;gt;.">DataList&lt;D&gt;</a> ld;
   ld.<a class="code" href="../../d9/dfb/classDataList.html#a87c05187af67b866631aba4d5dab7f1e" title="Add an element to the end of the collection.">push_back</a> (<span class="keyword">new</span> <a class="code" href="../../d7/db3/structD.html">D</a>);  <span class="comment">// This is ok.</span>
   ld.<a class="code" href="../../d9/dfb/classDataList.html#a87c05187af67b866631aba4d5dab7f1e" title="Add an element to the end of the collection.">push_back</a> (<span class="keyword">new</span> <a class="code" href="../../d9/db3/structB.html">B</a>);  <span class="comment">// This will give a compilation error</span>
                             (it would <span class="keywordflow">break</span> the invariant).
   <a class="code" href="../../d9/dfb/classDataList.html" title="Derived DataList&amp;lt;T&amp;gt;.">DataList&lt;B&gt;</a>&amp; lb = ld;
   lb.<a class="code" href="../../d9/dfb/classDataList.html#a87c05187af67b866631aba4d5dab7f1e" title="Add an element to the end of the collection.">push_back</a> (<span class="keyword">new</span> <a class="code" href="../../d9/db3/structB.html">B</a>);  <span class="comment">// This will give a run-time error</span>
                             (it breaks the invariant).
   lb.push_back (<span class="keyword">new</span> <a class="code" href="../../d7/db3/structD.html">D</a>);  <span class="comment">// This will also give a run-time error.</span>
                             (It<span class="stringliteral">&apos;s actually ok, but there&apos;</span>s no good way
                             to distinguish it from the previous <span class="keywordflow">case</span>.)
</pre></div><p>Note also this (related to a common atlas idiom). If we have the above, and also:</p>
<div class="fragment"><pre class="fragment">   <span class="keyword">class </span>B_List : <span class="keyword">public</span> <a class="code" href="../../d9/dfb/classDataList.html" title="Derived DataList&amp;lt;T&amp;gt;.">DataList</a>&lt;B&gt; { ... };
   <span class="keyword">class </span>D_List : <span class="keyword">public</span> <a class="code" href="../../d9/dfb/classDataList.html" title="Derived DataList&amp;lt;T&amp;gt;.">DataList</a>&lt;D&gt; { ... };
</pre></div><p>Then a <code>D_List</code> will be convertible to a <a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a>&lt;<a class="el" href="../../d9/db3/structB.html">B</a>&gt;, but _not_ to a <code>B_List</code>.</p>
<p>Multiple and virtual inheritance are also supported. In this case, use <code>DATALIST_VIRTBASES</code><em>n</em> (where <em>n</em> is 1, 2, or 3) instead of <code>DATALIST_BASE</code>. Example: Given:</p>
<div class="fragment"><pre class="fragment">   <span class="keyword">class </span><a class="code" href="../../d8/d55/structM.html">M</a> { ... };
   <span class="keyword">class </span><a class="code" href="../../da/deb/structN.html">N</a> : <span class="keyword">virtual</span> <span class="keyword">public</span> <a class="code" href="../../d8/d55/structM.html">M</a> { ... };
   <span class="keyword">class </span><a class="code" href="../../d1/d78/structO.html">O</a> : <span class="keyword">virtual</span> <span class="keyword">public</span> <a class="code" href="../../d8/d55/structM.html">M</a> { ... };
   <span class="keyword">class </span><a class="code" href="../../dc/dec/structP.html">P</a> : <span class="keyword">virtual</span> <span class="keyword">public</span> <a class="code" href="../../da/deb/structN.html">N</a>, <span class="keyword">virtual</span> <span class="keyword">public</span> <a class="code" href="../../d1/d78/structO.html">O</a> { ... };
</pre></div><p>declare this with</p>
<div class="fragment"><pre class="fragment">   <a class="code" href="../../d1/d43/DataList_8h.html#abfa1a94e27e2aa31a9e5de856c459b41" title="Declare base class info to DataList. Single, virtual derivation.">DATALIST_VIRTBASES1</a>(<a class="code" href="../../da/deb/structN.html">N</a>, <a class="code" href="../../d8/d55/structM.html">M</a>);
   <a class="code" href="../../d1/d43/DataList_8h.html#abfa1a94e27e2aa31a9e5de856c459b41" title="Declare base class info to DataList. Single, virtual derivation.">DATALIST_VIRTBASES1</a>(<a class="code" href="../../d1/d78/structO.html">O</a>, <a class="code" href="../../d8/d55/structM.html">M</a>);
   <a class="code" href="../../d1/d43/DataList_8h.html#ad7ad3d1a23e99411007da14017fad6c8" title="Declare base class info to DataList. Multiple derivation.">DATALIST_VIRTBASES2</a>(<a class="code" href="../../dc/dec/structP.html">P</a>, <a class="code" href="../../da/deb/structN.html">N</a>, <a class="code" href="../../d1/d78/structO.html">O</a>);
</pre></div><p>There is a restriction that there must be a unique base class that does not derive from anything else. For example, the diamond configuration above is ok, but this would not be:</p>
<div class="fragment"><pre class="fragment">   <span class="keyword">class </span>L { ... };
   <span class="keyword">class </span><a class="code" href="../../d8/d55/structM.html">M</a> { ... };
   <span class="keyword">class </span><a class="code" href="../../da/deb/structN.html">N</a> : <span class="keyword">virtual</span> <span class="keyword">public</span> <a class="code" href="../../d8/d55/structM.html">M</a>, <span class="keyword">virtual</span> <span class="keyword">public</span> L { ... };
   <span class="keyword">class </span><a class="code" href="../../d1/d78/structO.html">O</a> : <span class="keyword">virtual</span> <span class="keyword">public</span> <a class="code" href="../../d8/d55/structM.html">M</a> { ... };
   <span class="keyword">class </span><a class="code" href="../../dc/dec/structP.html">P</a> : <span class="keyword">virtual</span> <span class="keyword">public</span> <a class="code" href="../../da/deb/structN.html">N</a>, <span class="keyword">virtual</span> <span class="keyword">public</span> <a class="code" href="../../d1/d78/structO.html">O</a> { ... };

   <a class="code" href="../../d1/d43/DataList_8h.html#ad7ad3d1a23e99411007da14017fad6c8" title="Declare base class info to DataList. Multiple derivation.">DATALIST_VIRTBASES2</a>(<a class="code" href="../../da/deb/structN.html">N</a>, <a class="code" href="../../d8/d55/structM.html">M</a>, L);
   <a class="code" href="../../d1/d43/DataList_8h.html#abfa1a94e27e2aa31a9e5de856c459b41" title="Declare base class info to DataList. Single, virtual derivation.">DATALIST_VIRTBASES1</a>(<a class="code" href="../../d1/d78/structO.html">O</a>, <a class="code" href="../../d8/d55/structM.html">M</a>);
   <a class="code" href="../../d1/d43/DataList_8h.html#ad7ad3d1a23e99411007da14017fad6c8" title="Declare base class info to DataList. Multiple derivation.">DATALIST_VIRTBASES2</a>(<a class="code" href="../../dc/dec/structP.html">P</a>, <a class="code" href="../../da/deb/structN.html">N</a>, <a class="code" href="../../d1/d78/structO.html">O</a>);
</pre></div><p>Note, however, that you don't have to tell <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a></code> about the complete hierarchy; leaving the <code>L</code> out of <code>DATALIST_VIRTBASES</code> would work (you just wouldn't be able to convert to <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a>&lt;L&gt;</code> ).</p>
<p>If you use <code>DATALIST_VIRTBASES</code>, there is an additional time penalty to retrieve elements from the collection. This does not apply for <code>DATALIST_BASES</code>.</p>
<p>All applicable <code>DATALIST_*</code> macros must be visible at the point at which a <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a></code> is instantiated. <a class="el" href="../../d4/dc4/structA.html">A</a> confusing compilation error is likely to result otherwise. Note that this means that if you have the <code>DATALIST_*</code> macros within a container header file, then the header for the derived container must include the header for the base container. Be alert to this when converting existing code to use the inheritance scheme. For example, if class D2 derives from <a class="el" href="../../d7/db3/structD.html">D</a> which derives from <a class="el" href="../../d9/db3/structB.html">B</a>:</p>
<p>BList.h: </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &quot;B.h&quot;</span>
<span class="preprocessor">  #include &quot;<a class="code" href="../../d1/d43/DataList_8h.html" title="An STL list of pointers that by default owns its pointed-to elements.">DataList.h</a>&quot;</span>
  <span class="keyword">typedef</span> <a class="code" href="../../d9/dfb/classDataList.html" title="Derived DataList&amp;lt;T&amp;gt;.">DataList&lt;B&gt;</a> BVec;
</pre></div><p>DList.h: </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &quot;D.h&quot;</span>
<span class="preprocessor">  #include &quot;<a class="code" href="../../d1/d43/DataList_8h.html" title="An STL list of pointers that by default owns its pointed-to elements.">DataList.h</a>&quot;</span>
  <a class="code" href="../../d1/d43/DataList_8h.html#a9051b45fea61ed235640253b4efdb86b" title="Declare base class info to DataList. Single, non-virtual derivation.">DATALIST_BASE</a>(<a class="code" href="../../d7/db3/structD.html">D</a>,<a class="code" href="../../d9/db3/structB.html">B</a>);
  <span class="keyword">typedef</span> <a class="code" href="../../d9/dfb/classDataList.html" title="Derived DataList&amp;lt;T&amp;gt;.">DataList&lt;D&gt;</a> DVec;
</pre></div><p>D2List.h: </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &quot;D2.h&quot;</span>
<span class="preprocessor">  #include &quot;<a class="code" href="../../d1/d43/DataList_8h.html" title="An STL list of pointers that by default owns its pointed-to elements.">DataList.h</a>&quot;</span>
<span class="preprocessor">  #include &quot;DList.h&quot;</span> <span class="comment">// This is required</span>
  <a class="code" href="../../d1/d43/DataList_8h.html#a9051b45fea61ed235640253b4efdb86b" title="Declare base class info to DataList. Single, non-virtual derivation.">DATALIST_BASE</a>(D2,<a class="code" href="../../d7/db3/structD.html">D</a>);
  <span class="keyword">typedef</span> <a class="code" href="../../d9/dfb/classDataList.html" title="Derived DataList&amp;lt;T&amp;gt;.">DataList&lt;D2&gt;</a> DVec;
</pre></div><p>Using <code>DATALIST_BASE</code> will also set up the corresponding <code>SG::BaseInfo</code> definitions, both for the vectors themselves and for the contained objects. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="a9051b45fea61ed235640253b4efdb86b"></a><!-- doxytag: member="DataList.h::DATALIST_BASE" ref="a9051b45fea61ed235640253b4efdb86b" args="(T, BASE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DATALIST_BASE</td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/def/classT.html">T</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BASE&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span><a class="code" href="../../d2/de9/structDataListBase.html" title="Derivation information for DataList.">DataListBase</a>&lt;<a class="code" href="../../d1/def/classT.html">T</a>&gt;      \
{ <span class="keyword">typedef</span> <a class="code" href="../../d9/dfb/classDataList.html" title="Derived DataList&amp;lt;T&amp;gt;.">DataList&lt;BASE&gt;</a> <a class="code" href="../../d5/dd9/classtypename_01DataVectorBase_1_1Base.html">Base</a>; };       \
SG_BASE(<a class="code" href="../../d9/dfb/classDataList.html" title="Derived DataList&amp;lt;T&amp;gt;.">DataList&lt;T&gt;</a>, <a class="code" href="../../d9/dfb/classDataList.html" title="Derived DataList&amp;lt;T&amp;gt;.">DataList&lt;BASE&gt;</a>); \
<span class="keyword">template</span> <span class="keyword">struct </span>DataList_detail::DVLEltBaseInit&lt;T&gt;
</pre></div>
<p>Declare base class info to <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a></code>. Single, non-virtual derivation. </p>
<p><code><a class="el" href="../../d1/d43/DataList_8h.html#a9051b45fea61ed235640253b4efdb86b" title="Declare base class info to DataList. Single, non-virtual derivation.">DATALIST_BASE(D, B)</a></code> says that <code><a class="el" href="../../d7/db3/structD.html">D</a></code> derives non-virtually from <code><a class="el" href="../../d9/db3/structB.html">B</a></code>.</p>
<p>This macro creates an appropriate specialization of <code><a class="el" href="../../d2/de9/structDataListBase.html" title="Derivation information for DataList.">DataListBase</a></code>. </p>

</div>
</div>
<a class="anchor" id="abfa1a94e27e2aa31a9e5de856c459b41"></a><!-- doxytag: member="DataList.h::DATALIST_VIRTBASES1" ref="abfa1a94e27e2aa31a9e5de856c459b41" args="(T, B1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DATALIST_VIRTBASES1</td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/def/classT.html">T</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B1&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span><a class="code" href="../../d2/de9/structDataListBase.html" title="Derivation information for DataList.">DataListBase</a>&lt;<a class="code" href="../../d1/def/classT.html">T</a>&gt;                  \
{ <span class="keyword">typedef</span> <a class="code" href="../../d5/dec/structDataList__detail_1_1VirtBases.html" title="VirtBases for three classes.">DataList_detail::VirtBases&lt;B1&gt;</a> <a class="code" href="../../d5/dd9/classtypename_01DataVectorBase_1_1Base.html">Base</a>; };   \
SG_BASES1(<a class="code" href="../../d9/dfb/classDataList.html" title="Derived DataList&amp;lt;T&amp;gt;.">DataList&lt;T&gt;</a>, SG_VIRTUAL(<a class="code" href="../../d9/dfb/classDataList.html">DataList&lt;B1&gt;</a>)); \
<span class="keyword">template</span> <span class="keyword">struct </span>DataList_detail::DVLEltBaseInit&lt;T&gt;
</pre></div>
<p>Declare base class info to <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a></code>. Single, virtual derivation. </p>
<p><code>DATALIST_VIRTBASES(D, B1)</code> says that <code><a class="el" href="../../d7/db3/structD.html">D</a></code> derives virtually from <code>B1</code>.</p>
<p>This macro creates an appropriate specialization of <code><a class="el" href="../../d2/de9/structDataListBase.html" title="Derivation information for DataList.">DataListBase</a></code>. </p>

</div>
</div>
<a class="anchor" id="ad7ad3d1a23e99411007da14017fad6c8"></a><!-- doxytag: member="DataList.h::DATALIST_VIRTBASES2" ref="ad7ad3d1a23e99411007da14017fad6c8" args="(T, B1, B2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DATALIST_VIRTBASES2</td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/def/classT.html">T</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B2&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span><a class="code" href="../../d2/de9/structDataListBase.html" title="Derivation information for DataList.">DataListBase</a>&lt;<a class="code" href="../../d1/def/classT.html">T</a>&gt;                    \
{ <span class="keyword">typedef</span> <a class="code" href="../../d5/dec/structDataList__detail_1_1VirtBases.html" title="VirtBases for three classes.">DataList_detail::VirtBases&lt;B1, B2&gt;</a> <a class="code" href="../../d5/dd9/classtypename_01DataVectorBase_1_1Base.html">Base</a>; }; \
SG_BASES2(<a class="code" href="../../d9/dfb/classDataList.html" title="Derived DataList&amp;lt;T&amp;gt;.">DataList&lt;T&gt;</a>, SG_VIRTUAL(<a class="code" href="../../d9/dfb/classDataList.html">DataList&lt;B1&gt;</a>),      \
                       SG_VIRTUAL(<a class="code" href="../../d9/dfb/classDataList.html">DataList&lt;B2&gt;</a>)); \
<span class="keyword">template</span> <span class="keyword">struct </span>DataList_detail::DVLEltBaseInit&lt;T&gt;
</pre></div>
<p>Declare base class info to <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a></code>. Multiple derivation. </p>
<p><code>DATALIST_VIRTBASES(D, B1)</code> says that <code><a class="el" href="../../d7/db3/structD.html">D</a></code> derives from both <code>B1</code> and <code>B2</code>.</p>
<p>This macro creates an appropriate specialization of <code><a class="el" href="../../d2/de9/structDataListBase.html" title="Derivation information for DataList.">DataListBase</a></code>. </p>

</div>
</div>
<a class="anchor" id="a3c2f8a00c08d0ffcb32fc1592a4a52d3"></a><!-- doxytag: member="DataList.h::DATALIST_VIRTBASES3" ref="a3c2f8a00c08d0ffcb32fc1592a4a52d3" args="(T, B1, B2, B3)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DATALIST_VIRTBASES3</td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/def/classT.html">T</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B2, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B3&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span><a class="code" href="../../d2/de9/structDataListBase.html" title="Derivation information for DataList.">DataListBase</a>&lt;<a class="code" href="../../d1/def/classT.html">T</a>&gt;                    \
{ <span class="keyword">typedef</span> <a class="code" href="../../d5/dec/structDataList__detail_1_1VirtBases.html" title="VirtBases for three classes.">DataList_detail::VirtBases&lt;B1, B2, B3&gt;</a> <a class="code" href="../../d5/dd9/classtypename_01DataVectorBase_1_1Base.html">Base</a>; }; \
SG_BASES3(<a class="code" href="../../d9/dfb/classDataList.html" title="Derived DataList&amp;lt;T&amp;gt;.">DataList&lt;T&gt;</a>, SG_VIRTUAL(<a class="code" href="../../d9/dfb/classDataList.html">DataList&lt;B1&gt;</a>),          \
               SG_VIRTUAL(<a class="code" href="../../d9/dfb/classDataList.html">DataList&lt;B2&gt;</a>),          \
               SG_VIRTUAL(<a class="code" href="../../d9/dfb/classDataList.html">DataList&lt;B3&gt;</a>)); \
<span class="keyword">template</span> <span class="keyword">struct </span>DataList_detail::DVLEltBaseInit&lt;T&gt;
</pre></div>
<p>Declare base class info to <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a></code>. Multiple derivation. </p>
<p><code>DATALIST_VIRTBASES(D, B1)</code> says that <code><a class="el" href="../../d7/db3/structD.html">D</a></code> derives from all of <code>B1</code>, <code>B2</code>, and <code>B3</code>.</p>
<p>This macro creates an appropriate specialization of <code><a class="el" href="../../d2/de9/structDataListBase.html" title="Derivation information for DataList.">DataListBase</a></code>. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a331f1405e2b4323d37655e725a8f5b63"></a><!-- doxytag: member="DataList.h::operator&lt;" ref="a331f1405e2b4323d37655e725a8f5b63" args="(const DataList&lt; T &gt; &amp;a, const DataList&lt; T &gt; &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>List ordering relation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td><a class="el" href="../../d4/dc4/structA.html">A</a> <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a></code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td><a class="el" href="../../d4/dc4/structA.html">A</a> <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a></code> of the same type as <em>a</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if <em>a</em> is lexicographically less than <em>b</em>.</dd></dl>
<p>This is a total ordering relation. It is linear in the size of the lists. Comparisons are done on the pointer values of the elements.</p>
<p>See <code>std::lexicographical_compare()</code> for how the determination is made.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td><a class="el" href="../../d4/dc4/structA.html">A</a> <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a></code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td><a class="el" href="../../d4/dc4/structA.html">A</a> <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a></code> of the same type as <em>x</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True iff <em>x</em> is lexicographically less than <em>y</em>.</dd></dl>
<p>This is a total ordering relation. It is linear in the size of the lists. Comparisons are done on the pointer values of the elements.</p>
<p>See <code>std::lexicographical_compare()</code> for how the determination is made. </p>

</div>
</div>
<a class="anchor" id="a2f4af3db6bca5dc8d962d673635f0865"></a><!-- doxytag: member="DataList.h::operator==" ref="a2f4af3db6bca5dc8d962d673635f0865" args="(const DataList&lt; T &gt; &amp;a, const DataList&lt; T &gt; &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; <a class="el" href="../../d1/def/classT.html">T</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>List equality comparison. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td><a class="el" href="../../d4/dc4/structA.html">A</a> <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a></code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td><a class="el" href="../../d4/dc4/structA.html">A</a> <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a></code> of the same type as <em>a</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the size and elements of the lists are equal.</dd></dl>
<p>This is an equivalence relation. It is linear in the size of the lists. Lists are considered equivalent if their sizes are equal, and if corresponding elements compare equal.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td><a class="el" href="../../d4/dc4/structA.html">A</a> <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a></code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td><a class="el" href="../../d4/dc4/structA.html">A</a> <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;.">DataList</a></code> of the same type as <em>x</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True iff the size and elements of the lists are equal.</dd></dl>
<p>This is an equivalence relation. It is linear in the size of the lists. Lists are considered equivalent if their sizes are equal, and if corresponding elements compare equal. </p>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 15 Apr 2017 for RootCore Packages by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
