<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>RootCore Packages: xAOD::TEvent Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="../../index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="../../search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="../../annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="../../classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="../../hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="../../functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="../../dd/d44/namespacexAOD.html">xAOD</a>::<a class="el" href="../../de/d95/classxAOD_1_1TEvent.html">TEvent</a>
  </div>
</div>
<div class="contents">
<h1>xAOD::TEvent Class Reference</h1><!-- doxytag: class="xAOD::TEvent" --><!-- doxytag: inherits="xAOD::TVirtualEvent" -->
<p>Tool for accessing <a class="el" href="../../dd/d44/namespacexAOD.html" title="Namespace holding all the xAOD EDM classes.">xAOD</a> files outside of <a class="el" href="../../d5/dc5/namespaceAthena.html">Athena</a>.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../de/d44/TEvent_8h_source.html">TEvent.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for xAOD::TEvent:</div>
<div class="dynsection">
 <div class="center">
  <img src="../../de/d95/classxAOD_1_1TEvent.gif" usemap="#xAOD::TEvent_map" alt=""/>
  <map id="xAOD::TEvent_map" name="xAOD::TEvent_map">
<area href="../../de/daf/classxAOD_1_1TVirtualEvent.html" alt="xAOD::TVirtualEvent" shape="rect" coords="69,0,197,24"/>
<area href="../../d9/d22/classTEventClass.html" alt="TEventClass" shape="rect" coords="0,112,128,136"/>
<area href="../../d1/ddf/classxAOD_1_1TPyEvent.html" alt="xAOD::TPyEvent" shape="rect" coords="138,112,266,136"/>
</map>
 </div>
</div>

<p><a href="../../d0/d9d/classxAOD_1_1TEvent-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a02e3b91306a978cdbe478a5bdf03b348">EAuxMode</a> { <a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a02e3b91306a978cdbe478a5bdf03b348af23745a46dccaeaa88c5adf53064ac85">kBranchAccess</a> =  0, 
<a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a02e3b91306a978cdbe478a5bdf03b348aeafc802359754d9d902f97791f20d9ec">kClassAccess</a> =  1, 
<a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a02e3b91306a978cdbe478a5bdf03b348a89f268521007c479d536d29ee506ee82">kAthenaAccess</a> =  2, 
<a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a02e3b91306a978cdbe478a5bdf03b348ac615fe9e9be98902506b3dd228718777">kUndefinedAccess</a> =  3
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Auxiliary store "mode". </p>
 <a href="../../de/d95/classxAOD_1_1TEvent.html#a02e3b91306a978cdbe478a5bdf03b348">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac03a76128877ca2a1868459e7aefb3ad"></a><!-- doxytag: member="xAOD::TEvent::TEvent" ref="ac03a76128877ca2a1868459e7aefb3ad" args="(EAuxMode mode=kUndefinedAccess)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#ac03a76128877ca2a1868459e7aefb3ad">TEvent</a> (<a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a02e3b91306a978cdbe478a5bdf03b348">EAuxMode</a> mode=kUndefinedAccess)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa1f6359cbe7f51d7e6d7429d1ec6246"></a><!-- doxytag: member="xAOD::TEvent::TEvent" ref="afa1f6359cbe7f51d7e6d7429d1ec6246" args="(::TFile *file, EAuxMode mode=kUndefinedAccess)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#afa1f6359cbe7f51d7e6d7429d1ec6246">TEvent</a> (::TFile *file, <a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a02e3b91306a978cdbe478a5bdf03b348">EAuxMode</a> mode=kUndefinedAccess)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor connecting the object to an input TFile. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a06a11c1af17642cd028fbe9aaab396f2"></a><!-- doxytag: member="xAOD::TEvent::TEvent" ref="a06a11c1af17642cd028fbe9aaab396f2" args="(::TTree *tree, EAuxMode mode=kUndefinedAccess)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a06a11c1af17642cd028fbe9aaab396f2">TEvent</a> (::TTree *tree, <a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a02e3b91306a978cdbe478a5bdf03b348">EAuxMode</a> mode=kUndefinedAccess)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor connecting the objects to an input TTree/TChain. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac47957dd21554ec6f330cfef7831f188"></a><!-- doxytag: member="xAOD::TEvent::~TEvent" ref="ac47957dd21554ec6f330cfef7831f188" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#ac47957dd21554ec6f330cfef7831f188">~TEvent</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a02e3b91306a978cdbe478a5bdf03b348">EAuxMode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#aabfff91ec84a5800dd2c3604b0c6cba8">auxMode</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get what auxiliary access mode the object was constructed with.  <a href="#aabfff91ec84a5800dd2c3604b0c6cba8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a4fd1eb020c74eb58022c9ae16acf055a">dump</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function creating a user-readable dump of the current input.  <a href="#a4fd1eb020c74eb58022c9ae16acf055a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#ab3b84f477bea7e6ce0f01bd5c80e3a84">printIOStats</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function printing the I/O statistics of the current process.  <a href="#ab3b84f477bea7e6ce0f01bd5c80e3a84"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Setup functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp148f5a910b58aab554d2c77cc8bf6ebc"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a373125b7b2774de9464afa65b8f413cb">readFrom</a> (::TFile *file, Bool_t useTreeCache=kTRUE, const char *treeName=<a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a3e39fc579b4d1f6c423334caf4fbdd90">EVENT_TREE_NAME</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connect the object to a new input file.  <a href="#a373125b7b2774de9464afa65b8f413cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a9aba64d79df826d8f9d1220f727b97ea">readFrom</a> (::TTree *tree, Bool_t useTreeCache=kTRUE)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connect the object to a new input tree/chain.  <a href="#a9aba64d79df826d8f9d1220f727b97ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a692abe196e60b809f2c57e7930d9401e">writeTo</a> (::TFile *file, Int_t autoFlush=200, const char *treeName=<a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a3e39fc579b4d1f6c423334caf4fbdd90">EVENT_TREE_NAME</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connect the object to an output file.  <a href="#a692abe196e60b809f2c57e7930d9401e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a4ac4ee0bf6d12a151be6e909e27e3fcf">finishWritingTo</a> (::TFile *file)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finish writing to an output file.  <a href="#a4ac4ee0bf6d12a151be6e909e27e3fcf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a5423ace77c19aaf271c63334e32b2174">setActive</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set this event object as the currently active one.  <a href="#a5423ace77c19aaf271c63334e32b2174"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#ab10bcece69a8bc7fb3f388f96feaacfd">setAuxItemList</a> (const std::string &amp;containerKey, const std::string &amp;itemList)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configure which dynamic variables to write out for a given store.  <a href="#ab10bcece69a8bc7fb3f388f96feaacfd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#accb2d6fd8b3886f4d66453de233d7615">addListener</a> (<a class="el" href="../../dc/d1b/classxAOD_1_1TVirtualIncidentListener.html">TVirtualIncidentListener</a> *listener)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register an incident listener object.  <a href="#accb2d6fd8b3886f4d66453de233d7615"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a7180825a285c43d7eefdf7f83f3b7854">removeListener</a> (<a class="el" href="../../dc/d1b/classxAOD_1_1TVirtualIncidentListener.html">TVirtualIncidentListener</a> *listener)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove an incident listener object.  <a href="#a7180825a285c43d7eefdf7f83f3b7854"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#af41ced199a022abb83fd90c9398a3703">clearListeners</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove all listeners from the object.  <a href="#af41ced199a022abb83fd90c9398a3703"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a73379b221c401b4e36bd5fda6ceb92a8">addNameRemap</a> (const std::string &amp;onfile, const std::string &amp;newName)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a name re-mapping rule.  <a href="#a73379b221c401b4e36bd5fda6ceb92a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#ad0b83b386f685df6f4d3d91a077916c9">clearNameRemap</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear the current name re-mapping.  <a href="#ad0b83b386f685df6f4d3d91a077916c9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#aa15c26c79f5b47394f678c34b2e18e66">printNameRemap</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print the current name re-mapping rules.  <a href="#aa15c26c79f5b47394f678c34b2e18e66"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Event data accessor/modifier functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpf8124c4e51f9708a3eb2942c90303691"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">::Bool_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a3b92c86df4409b99960328dd263792ed">contains</a> (const std::string &amp;key)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function checking if an object is available from the store.  <a href="#a3b92c86df4409b99960328dd263792ed"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">::Bool_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#aca57bfb6ea9448c94cadcd2456f82609">transientContains</a> (const std::string &amp;key) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function checking if an object is already in memory.  <a href="#aca57bfb6ea9448c94cadcd2456f82609"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a85e9bb280df774885102075cbf7b8e06">retrieve</a> (const <a class="el" href="../../d1/def/classT.html">T</a> *&amp;obj, const std::string &amp;key)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve either an input or an output object from the event.  <a href="#a85e9bb280df774885102075cbf7b8e06"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#aa602e807821e403a6443c11060174916">retrieve</a> (<a class="el" href="../../d1/def/classT.html">T</a> *&amp;obj, const std::string &amp;key)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve an output object from the event.  <a href="#aa602e807821e403a6443c11060174916"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#af90403dbebbccf4397b29191c4437cad">record</a> (<a class="el" href="../../d1/def/classT.html">T</a> *obj, const std::string &amp;key,::Int_t basketSize=32000,::Int_t splitLevel=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add an output object to the event.  <a href="#af90403dbebbccf4397b29191c4437cad"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#ad5cdd02952e6d42895a1cba88339a6f4">record</a> (std::unique_ptr&lt; <a class="el" href="../../d1/def/classT.html">T</a> &gt; obj, const std::string &amp;key,::Int_t basketSize=32000,::Int_t splitLevel=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add an output object to the event, explicitly taking ownership of it.  <a href="#ad5cdd02952e6d42895a1cba88339a6f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adfccdc9e624b57b3e4619e33c6034f7d"></a><!-- doxytag: member="xAOD::TEvent::recordAux" ref="adfccdc9e624b57b3e4619e33c6034f7d" args="(const std::string &amp;key, SG::IAuxStoreHolder::AuxStoreType type=SG::IAuxStoreHolder::AST_ContainerStore, Int_t basketSize=32000, Int_t splitLevel=0)" -->
<a class="el" href="../../dc/d05/classSG_1_1IAuxStore.html">SG::IAuxStore</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#adfccdc9e624b57b3e4619e33c6034f7d">recordAux</a> (const std::string &amp;key, <a class="el" href="../../dc/d42/classSG_1_1IAuxStoreHolder.html#a52b405d522a75932698443c3f01611f9">SG::IAuxStoreHolder::AuxStoreType</a> type=SG::IAuxStoreHolder::AST_ContainerStore, Int_t basketSize=32000, Int_t splitLevel=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add an auxiliary store object to the output. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a800c972b17c29c69253e2a80cf959621">copy</a> (const std::string &amp;key,::Int_t basketSize=32000,::Int_t splitLevel=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy an object directly from the input to the output.  <a href="#a800c972b17c29c69253e2a80cf959621"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a395b577a2d21f7b45c125539c7a3cf0d">copy</a> (::Int_t basketSize=32000,::Int_t splitLevel=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy all (ROOT readable) objects directly from the input to the output.  <a href="#a395b577a2d21f7b45c125539c7a3cf0d"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Metadata accessor/modifier functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp19f62ace08f2e25a52e5dc8ac8a87bd4"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">::Bool_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a2dbd8245101cc85a034a28ca4ca47701">containsMeta</a> (const std::string &amp;key)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function checking if a meta-object is available from the store.  <a href="#a2dbd8245101cc85a034a28ca4ca47701"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">::Bool_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#ac9868d2dcd71329f9f11ac3725a2ad16">transientContainsMeta</a> (const std::string &amp;key) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function checking if a meta-object is already in memory.  <a href="#ac9868d2dcd71329f9f11ac3725a2ad16"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a6eeaa9ae4eb9c2a91706f767de96ea45">retrieveMetaInput</a> (const <a class="el" href="../../d1/def/classT.html">T</a> *&amp;obj, const std::string &amp;key)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve an input metadata object.  <a href="#a6eeaa9ae4eb9c2a91706f767de96ea45"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#aa10977469fe765f8d9fe5acd0b064b8d">retrieveMetaOutput</a> (const <a class="el" href="../../d1/def/classT.html">T</a> *&amp;obj, const std::string &amp;key)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve an output metadata object.  <a href="#aa10977469fe765f8d9fe5acd0b064b8d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a2c562dc4d26e317f0e32221e07c20cd7">retrieveMetaOutput</a> (<a class="el" href="../../d1/def/classT.html">T</a> *&amp;obj, const std::string &amp;key)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve an output metadata object.  <a href="#a2c562dc4d26e317f0e32221e07c20cd7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a11dfdb955bd84935502353a0a7616b75">recordMeta</a> (<a class="el" href="../../d1/def/classT.html">T</a> *obj, const std::string &amp;key,::Int_t basketSize=32000,::Int_t splitLevel=1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add an object to the output file's metadata.  <a href="#a11dfdb955bd84935502353a0a7616b75"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#af23ea51439ea4c963a5d0ba8e4e9a2e8">recordMeta</a> (std::unique_ptr&lt; <a class="el" href="../../d1/def/classT.html">T</a> &gt; obj, const std::string &amp;key,::Int_t basketSize=32000,::Int_t splitLevel=1)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Persistent data accessor/modifier functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp05b38731af6ec43bbd3b5f40de550f00"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">::Long64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#abd190a2cfceeeb52c454ed8436c92540">getEntries</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get how many entries are available from the current input file(s).  <a href="#abd190a2cfceeeb52c454ed8436c92540"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">::Int_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#ab89adb4667489d2782dabd4b69203e32">getEntry</a> (::Long64_t entry,::Int_t getall=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function loading a given entry of the input TTree.  <a href="#ab89adb4667489d2782dabd4b69203e32"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">::Long64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a524c782f48073dc3bbabf6161b8f831d">getFiles</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get how many files are available on the currently defined input.  <a href="#a524c782f48073dc3bbabf6161b8f831d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">::Int_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a6090a27de542ccd6c8d87489732ce0d6">getFile</a> (::Long64_t file,::Int_t getall=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load the first event for a given file from the input TChain.  <a href="#a6090a27de542ccd6c8d87489732ce0d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">::Int_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a5bfccceade4a0564484eea0a9e092b80">fill</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function filling one event into the output tree.  <a href="#a5bfccceade4a0564484eea0a9e092b80"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d1f/classxAOD_1_1EventFormat__v1.html">EventFormat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a27fcd1edf34e12da56e514b70fb6e694">inputEventFormat</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get information about the input objects.  <a href="#a27fcd1edf34e12da56e514b70fb6e694"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d1f/classxAOD_1_1EventFormat__v1.html">EventFormat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a475b2d4560d9a0f6855ef9c0c26c32e5">outputEventFormat</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get information about the output objects.  <a href="#a475b2d4560d9a0f6855ef9c0c26c32e5"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f00f30ebeac247b31b9861705668d62"></a><!-- doxytag: member="xAOD::TEvent::Object_t" ref="a2f00f30ebeac247b31b9861705668d62" args="" -->
typedef std::map&lt; std::string, <br class="typebreak"/>
<a class="el" href="../../d1/db4/classxAOD_1_1TVirtualManager.html">TVirtualManager</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a2f00f30ebeac247b31b9861705668d62">Object_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Definition of the internal data structure type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a43414b3a090df7d3d74896ae1fffbecf"></a><!-- doxytag: member="xAOD::TEvent::Listener_t" ref="a43414b3a090df7d3d74896ae1fffbecf" args="" -->
typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="../../dc/d1b/classxAOD_1_1TVirtualIncidentListener.html">TVirtualIncidentListener</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a43414b3a090df7d3d74896ae1fffbecf">Listener_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Definition of the structure type holding on to listeners. <br/></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#acd034bd40657d54925b8ee5172cf5683">initStats</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function to initialise the statistics for all Tree content.  <a href="#acd034bd40657d54925b8ee5172cf5683"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a13f364fdccff9db65b7b1c75f92b129e">getOutputObject</a> (const std::string &amp;key, const std::type_info &amp;ti,::Bool_t metadata=kFALSE) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function for retrieving an output object in a non-template way.  <a href="#a13f364fdccff9db65b7b1c75f92b129e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a45544b1015d0baa8665db4b9b6be7c07">getInputObject</a> (const std::string &amp;key, const std::type_info &amp;ti,::Bool_t silent=kFALSE,::Bool_t metadata=kFALSE)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function for retrieving an input object in a non-template way.  <a href="#a45544b1015d0baa8665db4b9b6be7c07"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#ac4608877b90a9cd5e0b69b96e13d1537">record</a> (void *obj, const std::string &amp;typeName, const std::string &amp;key,::Int_t basketSize,::Int_t splitLevel,::Bool_t overwrite=kFALSE,::Bool_t metadata=kFALSE,::Bool_t isOwner=kTRUE)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal function for recording an object into the output.  <a href="#ac4608877b90a9cd5e0b69b96e13d1537"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a7c1f7efc453071b3ebdceb05f7428129">record</a> (<a class="el" href="../../d7/d77/classxAOD_1_1TAuxStore.html">TAuxStore</a> *store, const std::string &amp;key,::Int_t basketSize,::Int_t splitLevel,::Bool_t ownsStore=kFALSE)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal function for adding an auxiliary store object to the output.  <a href="#a7c1f7efc453071b3ebdceb05f7428129"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a18508911dd4e3f41edf596d628645300">connectBranch</a> (const std::string &amp;key,::Bool_t silent=kFALSE)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function setting up access to a particular branch.  <a href="#a18508911dd4e3f41edf596d628645300"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#ae433bd1c9085c34f565b8a76c0904903">connectMetaBranch</a> (const std::string &amp;key,::Bool_t silent=kFALSE)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function setting up access to a branch in the metadata tree.  <a href="#ae433bd1c9085c34f565b8a76c0904903"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#ad297f837defba9d9645eb7e721ec2cf7">connectAux</a> (const std::string &amp;prefix,::Bool_t standalone)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function setting up access to a set of auxiliary branches.  <a href="#ad297f837defba9d9645eb7e721ec2cf7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a50894896f849e66ae67bae010ba01a92">connectMetaAux</a> (const std::string &amp;prefix,::Bool_t standalone)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a86fb514054574fb9883bdd9b3ae761aa">setUpDynamicStore</a> (<a class="el" href="../../d9/d8e/classxAOD_1_1TObjectManager.html">TObjectManager</a> &amp;mgr,::TTree *tree)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#aa50ebfd4ab78b080eb845a20dc3bbb37">setAuxStore</a> (<a class="el" href="../../d9/d8e/classxAOD_1_1TObjectManager.html">TObjectManager</a> &amp;mgr,::Bool_t metadata=kFALSE)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function connecting a <a class="el" href="../../d3/d78/structDV.html">DV</a> object to its auxiliary store.  <a href="#aa50ebfd4ab78b080eb845a20dc3bbb37"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a970c28d37f542b3096e7ac2588fc21c8">putAux</a> (::TTree &amp;outTree, <a class="el" href="../../d1/db4/classxAOD_1_1TVirtualManager.html">TVirtualManager</a> &amp;mgr,::Int_t basketSize=32000,::Int_t splitLevel=0,::Bool_t metadata=kFALSE)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function saving the dynamically created auxiliary properties.  <a href="#a970c28d37f542b3096e7ac2588fc21c8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">::Bool_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a2d259a3afab00a5961ce1348b4602d8b">contains</a> (const std::string &amp;key, const std::type_info &amp;ti,::Bool_t metadata=kFALSE)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal function checking if an object is in the input.  <a href="#a2d259a3afab00a5961ce1348b4602d8b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">::Bool_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a1dbaade3e5b746d14c852a21bce9791e">transientContains</a> (const std::string &amp;key, const std::type_info &amp;ti,::Bool_t metadata=kFALSE) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal function checking if an object is already in memory.  <a href="#a1dbaade3e5b746d14c852a21bce9791e"></a><br/></td></tr>
<tr><td colspan="2"><h2>Static Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">::Bool_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#ab53119c4628eb7ecc7c66c08e5d85406">hasAuxStore</a> (const <a class="el" href="../../d9/d8e/classxAOD_1_1TObjectManager.html">TObjectManager</a> &amp;mgr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function checking if a given object may have an auxiliary store.  <a href="#ab53119c4628eb7ecc7c66c08e5d85406"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">::Bool_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a2431da212c47749feadfa4a8904f7ee6">isAuxStore</a> (const <a class="el" href="../../d9/d8e/classxAOD_1_1TObjectManager.html">TObjectManager</a> &amp;mgr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function checking if a given object may be an auxiliary store.  <a href="#a2431da212c47749feadfa4a8904f7ee6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">::Bool_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#ac3f5e026371a0cee2a7d833def66f800">isStandalone</a> (const <a class="el" href="../../d9/d8e/classxAOD_1_1TObjectManager.html">TObjectManager</a> &amp;mgr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function checking if an object is standalone (not a container).  <a href="#ac3f5e026371a0cee2a7d833def66f800"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba33525320422fe631fdffb6bfd8250e"></a><!-- doxytag: member="xAOD::TEvent::m_auxMode" ref="aba33525320422fe631fdffb6bfd8250e" args="" -->
<a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a02e3b91306a978cdbe478a5bdf03b348">EAuxMode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#aba33525320422fe631fdffb6bfd8250e">m_auxMode</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The auxiliary access mode. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0774c98c338f567726e476079bd68e0"></a><!-- doxytag: member="xAOD::TEvent::m_inTree" ref="af0774c98c338f567726e476079bd68e0" args="" -->
::TTree *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#af0774c98c338f567726e476079bd68e0">m_inTree</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The tree that we are reading from. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">::Bool_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a457ea1a0296188ab4c2683f413503e5b">m_inTreeMissing</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aafa9a2205929bde88ae711a11d586923"></a><!-- doxytag: member="xAOD::TEvent::m_inChain" ref="aafa9a2205929bde88ae711a11d586923" args="" -->
::TChain *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#aafa9a2205929bde88ae711a11d586923">m_inChain</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The (optional) chain provided as input. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56f8810830ad139a0b344cb1fee4a525"></a><!-- doxytag: member="xAOD::TEvent::m_inChainTracker" ref="a56f8810830ad139a0b344cb1fee4a525" args="" -->
<a class="el" href="../../d1/d3a/classxAOD_1_1TChainStateTracker.html">TChainStateTracker</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a56f8810830ad139a0b344cb1fee4a525">m_inChainTracker</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Optional object for tracking the state changes of an input TChain. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae3ae06f2fd647b0b0fe846662a331877"></a><!-- doxytag: member="xAOD::TEvent::m_inTreeNumber" ref="ae3ae06f2fd647b0b0fe846662a331877" args="" -->
::Int_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#ae3ae06f2fd647b0b0fe846662a331877">m_inTreeNumber</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The number of the currently open tree in the input chain. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0bf3238ce2963b019b4a6a2664c9a772"></a><!-- doxytag: member="xAOD::TEvent::m_inMetaTree" ref="a0bf3238ce2963b019b4a6a2664c9a772" args="" -->
::TTree *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a0bf3238ce2963b019b4a6a2664c9a772">m_inMetaTree</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to the metadata tree in the input file. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a87b756043440ee2b409f18dbe85b2661"></a><!-- doxytag: member="xAOD::TEvent::m_entry" ref="a87b756043440ee2b409f18dbe85b2661" args="" -->
::Long64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a87b756043440ee2b409f18dbe85b2661">m_entry</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The entry to look at from the input tree. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8df2448fd37047f8b3bbfc1314dfa6d"></a><!-- doxytag: member="xAOD::TEvent::m_outTree" ref="ab8df2448fd37047f8b3bbfc1314dfa6d" args="" -->
::TTree *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#ab8df2448fd37047f8b3bbfc1314dfa6d">m_outTree</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The tree that we are writing to. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f11f9c197313172dfbc3ab7d6fdd7a3"></a><!-- doxytag: member="xAOD::TEvent::m_inputObjects" ref="a5f11f9c197313172dfbc3ab7d6fdd7a3" args="" -->
<a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a2f00f30ebeac247b31b9861705668d62">Object_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a5f11f9c197313172dfbc3ab7d6fdd7a3">m_inputObjects</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Collection of all the managed input objects. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa73cbe561d2fd0825b0484b0fa76595a"></a><!-- doxytag: member="xAOD::TEvent::m_outputObjects" ref="aa73cbe561d2fd0825b0484b0fa76595a" args="" -->
<a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a2f00f30ebeac247b31b9861705668d62">Object_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#aa73cbe561d2fd0825b0484b0fa76595a">m_outputObjects</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Collection of all the managed output object. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d1ec20e0c86ab4a126c29bc6311cbdb"></a><!-- doxytag: member="xAOD::TEvent::m_inputMetaObjects" ref="a5d1ec20e0c86ab4a126c29bc6311cbdb" args="" -->
<a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a2f00f30ebeac247b31b9861705668d62">Object_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a5d1ec20e0c86ab4a126c29bc6311cbdb">m_inputMetaObjects</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Collection of all the managed input meta-objects. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af17643d5caadf331d8a225d0b16480a9"></a><!-- doxytag: member="xAOD::TEvent::m_outputMetaObjects" ref="af17643d5caadf331d8a225d0b16480a9" args="" -->
<a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a2f00f30ebeac247b31b9861705668d62">Object_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#af17643d5caadf331d8a225d0b16480a9">m_outputMetaObjects</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Collection of all the managed output meta-objects. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33fb279f8388adb372dc2fe6cee3853a"></a><!-- doxytag: member="xAOD::TEvent::m_inputEventFormat" ref="a33fb279f8388adb372dc2fe6cee3853a" args="" -->
<a class="el" href="../../d8/d1f/classxAOD_1_1EventFormat__v1.html">EventFormat</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a33fb279f8388adb372dc2fe6cee3853a">m_inputEventFormat</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Format of the current input file. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa73f670758ea2312e5a46578e2b54633"></a><!-- doxytag: member="xAOD::TEvent::m_outputEventFormat" ref="aa73f670758ea2312e5a46578e2b54633" args="" -->
<a class="el" href="../../d8/d1f/classxAOD_1_1EventFormat__v1.html">EventFormat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#aa73f670758ea2312e5a46578e2b54633">m_outputEventFormat</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Format of the current output file. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a924534d472b779bbba478398267b1492"></a><!-- doxytag: member="xAOD::TEvent::m_auxItemList" ref="a924534d472b779bbba478398267b1492" args="" -->
std::map&lt; std::string, <br class="typebreak"/>
std::set&lt; std::string &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a924534d472b779bbba478398267b1492">m_auxItemList</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rules for selecting which auxiliary branches to write. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ba74360390114e8403d10db4a06539a"></a><!-- doxytag: member="xAOD::TEvent::m_listeners" ref="a0ba74360390114e8403d10db4a06539a" args="" -->
<a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a43414b3a090df7d3d74896ae1fffbecf">Listener_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a0ba74360390114e8403d10db4a06539a">m_listeners</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Listeners who should be notified when certain incidents happen. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac4e32464c6c34f916579623adf15dff4"></a><!-- doxytag: member="xAOD::TEvent::m_nameRemapping" ref="ac4e32464c6c34f916579623adf15dff4" args="" -->
std::map&lt; std::string, <br class="typebreak"/>
std::string &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#ac4e32464c6c34f916579623adf15dff4">m_nameRemapping</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Container name re-mapping rules. <br/></td></tr>
<tr><td colspan="2"><h2>Static Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a177e76fe678eecd0466d7afb7ba562b2"></a><!-- doxytag: member="xAOD::TEvent::CACHE_SIZE" ref="a177e76fe678eecd0466d7afb7ba562b2" args="" -->
static const ::Int_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a177e76fe678eecd0466d7afb7ba562b2">CACHE_SIZE</a> = 30000000</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Size of a possible TTreeCache (30 MB). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e39fc579b4d1f6c423334caf4fbdd90"></a><!-- doxytag: member="xAOD::TEvent::EVENT_TREE_NAME" ref="a3e39fc579b4d1f6c423334caf4fbdd90" args="" -->
static const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a3e39fc579b4d1f6c423334caf4fbdd90">EVENT_TREE_NAME</a> = &quot;CollectionTree&quot;</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Name of the event tree. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97868adbe4c855aac493a884b7281342"></a><!-- doxytag: member="xAOD::TEvent::METADATA_TREE_NAME" ref="a97868adbe4c855aac493a884b7281342" args="" -->
static const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a97868adbe4c855aac493a884b7281342">METADATA_TREE_NAME</a> = &quot;MetaData&quot;</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Name of the metadata tree. <br/></td></tr>
<tr><td colspan="2"><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4bf8e6738fcd7c58a7e8a8c97833e303"></a><!-- doxytag: member="xAOD::TEvent::xAOD::TEventBranch" ref="a4bf8e6738fcd7c58a7e8a8c97833e303" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a4bf8e6738fcd7c58a7e8a8c97833e303">xAOD::TEventBranch</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab483a8c39e7e0bd70a3e59a2160f9e47"></a><!-- doxytag: member="xAOD::TEvent::xAOD::TMetaBranch" ref="ab483a8c39e7e0bd70a3e59a2160f9e47" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#ab483a8c39e7e0bd70a3e59a2160f9e47">xAOD::TMetaBranch</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7aca3125cb14b4f8f72426766a09521"></a><!-- doxytag: member="xAOD::TEvent::xAOD::TFileMerger" ref="aa7aca3125cb14b4f8f72426766a09521" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#aa7aca3125cb14b4f8f72426766a09521">xAOD::TFileMerger</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adfa6f5c012f86a7894310e2cc33c27f7"></a><!-- doxytag: member="xAOD::TEvent::xAOD::TTreeMgr" ref="adfa6f5c012f86a7894310e2cc33c27f7" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#adfa6f5c012f86a7894310e2cc33c27f7">xAOD::TTreeMgr</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc74b459fb5e6b2b739524be92ff7a3f"></a><!-- doxytag: member="xAOD::TEvent::MakeTransientTree" ref="adc74b459fb5e6b2b739524be92ff7a3f" args="(TEvent &amp;, const char *)" -->
friend::TTree *&nbsp;</td><td class="memItemRight" valign="bottom"><b>MakeTransientTree</b> (<a class="el" href="../../de/d95/classxAOD_1_1TEvent.html">TEvent</a> &amp;, const char *)</td></tr>
<tr><td colspan="2"><h2>Functions implementing the TVirtualEvent interface</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp908aa779f936c1e0530b23b9dc916d1e"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a7b3a78b610dd33ba349531486f958839">getHash</a> (const std::string &amp;key) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function returning the hash describing an object name.  <a href="#a7b3a78b610dd33ba349531486f958839"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#aa81f959071f880d07a04a09c0e6b0bbc">getKey</a> (const void *obj) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function returning the hash describing a known object.  <a href="#aa81f959071f880d07a04a09c0e6b0bbc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a8e4aabaa53c49136df759661ce08fb24">getName</a> (const void *obj) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function returning the key describing a known object.  <a href="#a8e4aabaa53c49136df759661ce08fb24"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#aaebd5a0daefc75bf086bd0c893ce67e3">getName</a> (uint32_t hash) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function returning the key describing a known object.  <a href="#aaebd5a0daefc75bf086bd0c893ce67e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a6531ff42179b78d04acf432a2b4c1e73">getOutputObject</a> (uint32_t key, const std::type_info &amp;ti)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function for retrieving an output object in a non-template way.  <a href="#a6531ff42179b78d04acf432a2b4c1e73"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a35fa4683373b12d39cb8b64a8535a8a6">getInputObject</a> (uint32_t key, const std::type_info &amp;ti, bool silent=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function for retrieving an input object in a non-template way.  <a href="#a35fa4683373b12d39cb8b64a8535a8a6"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Tool for accessing <a class="el" href="../../dd/d44/namespacexAOD.html" title="Namespace holding all the xAOD EDM classes.">xAOD</a> files outside of <a class="el" href="../../d5/dc5/namespaceAthena.html">Athena</a>. </p>
<p>Proper access to <a class="el" href="../../dd/d44/namespacexAOD.html" title="Namespace holding all the xAOD EDM classes.">xAOD</a> files in ROOT (outside of <a class="el" href="../../d5/dc5/namespaceAthena.html">Athena</a>) needs to be done through such an object. It takes care of reading and writing <a class="el" href="../../dd/d44/namespacexAOD.html" title="Namespace holding all the xAOD EDM classes.">xAOD</a> files together with their file format metadata, setting up smart pointers correctly, etc.</p>
<p>For a detailed description of the usage of this class, see: &lt;Link to be added here...&gt;</p>
<dl class="author"><dt><b>Author:</b></dt><dd>Attila Krasznahorkay &lt;<a href="mailto:Attila.Krasznahorkay@cern.ch">Attila.Krasznahorkay@cern.ch</a>&gt;</dd></dl>
<dl class="rcs"><dt><b>Revision</b></dt><dd>746122 </dd></dl>
<dl class="rcs"><dt><b>Date</b></dt><dd>2016-05-11 12:11:31 +0200 (Wed, 11 May 2016) </dd></dl>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a02e3b91306a978cdbe478a5bdf03b348"></a><!-- doxytag: member="xAOD::TEvent::EAuxMode" ref="a02e3b91306a978cdbe478a5bdf03b348" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a02e3b91306a978cdbe478a5bdf03b348">xAOD::TEvent::EAuxMode</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Auxiliary store "mode". </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a02e3b91306a978cdbe478a5bdf03b348af23745a46dccaeaa88c5adf53064ac85"></a><!-- doxytag: member="kBranchAccess" ref="a02e3b91306a978cdbe478a5bdf03b348af23745a46dccaeaa88c5adf53064ac85" args="" -->kBranchAccess</em>&nbsp;</td><td>
<p>Access auxiliary data branch-by-branch. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a02e3b91306a978cdbe478a5bdf03b348aeafc802359754d9d902f97791f20d9ec"></a><!-- doxytag: member="kClassAccess" ref="a02e3b91306a978cdbe478a5bdf03b348aeafc802359754d9d902f97791f20d9ec" args="" -->kClassAccess</em>&nbsp;</td><td>
<p>Access auxiliary data using the aux containers. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a02e3b91306a978cdbe478a5bdf03b348a89f268521007c479d536d29ee506ee82"></a><!-- doxytag: member="kAthenaAccess" ref="a02e3b91306a978cdbe478a5bdf03b348a89f268521007c479d536d29ee506ee82" args="" -->kAthenaAccess</em>&nbsp;</td><td>
<p>Access containers/objects like <a class="el" href="../../d5/dc5/namespaceAthena.html">Athena</a> does. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a02e3b91306a978cdbe478a5bdf03b348ac615fe9e9be98902506b3dd228718777"></a><!-- doxytag: member="kUndefinedAccess" ref="a02e3b91306a978cdbe478a5bdf03b348ac615fe9e9be98902506b3dd228718777" args="" -->kUndefinedAccess</em>&nbsp;</td><td>
<p>Undefined, to be selected by the object. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="accb2d6fd8b3886f4d66453de233d7615"></a><!-- doxytag: member="xAOD::TEvent::addListener" ref="accb2d6fd8b3886f4d66453de233d7615" args="(TVirtualIncidentListener *listener)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a> xAOD::TEvent::addListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d1b/classxAOD_1_1TVirtualIncidentListener.html">TVirtualIncidentListener</a> *&nbsp;</td>
          <td class="paramname"> <em>listener</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Register an incident listener object. </p>
<p>This function works pretty much like IIncidentSvc::addListener does in <a class="el" href="../../d5/dc5/namespaceAthena.html">Athena</a>. It tells the <a class="el" href="../../de/d95/classxAOD_1_1TEvent.html" title="Tool for accessing xAOD files outside of Athena.">TEvent</a> object that when certain "interesting
       incidents" happen, a given object should be notified about it.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>listener</em>&nbsp;</td><td>Pointer to the object that should be notified </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The usual <a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a> types </dd></dl>

</div>
</div>
<a class="anchor" id="a73379b221c401b4e36bd5fda6ceb92a8"></a><!-- doxytag: member="xAOD::TEvent::addNameRemap" ref="a73379b221c401b4e36bd5fda6ceb92a8" args="(const std::string &amp;onfile, const std::string &amp;newName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a> xAOD::TEvent::addNameRemap </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>onfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>newName</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a name re-mapping rule. </p>
<p>The names of containers can change during the lifetime of the experiment. One such change happened after the DC14 exercise, when many containers got a new name. (Like "ElectronCollection" became simply "Electrons".)</p>
<p>This function allows us to create aliases with which certain containers should be accessible. So that the analyser would be able to access older files, while using the latest container name(s).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>onfile</em>&nbsp;</td><td>The name of the container as it was saved into the input file </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newName</em>&nbsp;</td><td>The alias with which the object/container should be accessible </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The usual <a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a> types </dd></dl>

<p><p>Save the new name association: </p>
</p>

</div>
</div>
<a class="anchor" id="aabfff91ec84a5800dd2c3604b0c6cba8"></a><!-- doxytag: member="xAOD::TEvent::auxMode" ref="aabfff91ec84a5800dd2c3604b0c6cba8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a02e3b91306a978cdbe478a5bdf03b348">TEvent::EAuxMode</a> xAOD::TEvent::auxMode </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get what auxiliary access mode the object was constructed with. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The auxiliary data access mode currently in use </dd></dl>

</div>
</div>
<a class="anchor" id="af41ced199a022abb83fd90c9398a3703"></a><!-- doxytag: member="xAOD::TEvent::clearListeners" ref="af41ced199a022abb83fd90c9398a3703" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xAOD::TEvent::clearListeners </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove all listeners from the object. </p>
<p>This function can be used to remove all the listeners from the internal list. Should not be necessary under regular circumstances. </p>

</div>
</div>
<a class="anchor" id="ad0b83b386f685df6f4d3d91a077916c9"></a><!-- doxytag: member="xAOD::TEvent::clearNameRemap" ref="ad0b83b386f685df6f4d3d91a077916c9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xAOD::TEvent::clearNameRemap </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clear the current name re-mapping. </p>
<p>This function simply clears out any existing name remapping declarations. In case the remapping rules need to be changed in the code in some complicated way. </p>

</div>
</div>
<a class="anchor" id="ad297f837defba9d9645eb7e721ec2cf7"></a><!-- doxytag: member="xAOD::TEvent::connectAux" ref="ad297f837defba9d9645eb7e721ec2cf7" args="(const std::string &amp;prefix,::Bool_t standalone)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a> xAOD::TEvent::connectAux </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::Bool_t&nbsp;</td>
          <td class="paramname"> <em>standalone</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function setting up access to a set of auxiliary branches. </p>
<p>This function is used internally to connect an auxiliary object to the input. Based on the configuration of the object it will either use <a class="el" href="../../d7/d77/classxAOD_1_1TAuxStore.html" title="&quot;ROOT implementation&quot; of IAuxStore">TAuxStore</a>, or the EDM object that was used to write the auxiliary information in <a class="el" href="../../d5/dc5/namespaceAthena.html">Athena</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>prefix</em>&nbsp;</td><td>The prefix (main branch name) of the auxiliary data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>standalone</em>&nbsp;</td><td><a class="el" href="../../dd/dc8/namespacexAOD_1_1Type.html">Type</a> of the auxiliary store that should be created </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>kTRUE</code> if the connection was successful, or <code>kFALSE</code> if it was not </dd></dl>

</div>
</div>
<a class="anchor" id="a18508911dd4e3f41edf596d628645300"></a><!-- doxytag: member="xAOD::TEvent::connectBranch" ref="a18508911dd4e3f41edf596d628645300" args="(const std::string &amp;key,::Bool_t silent=kFALSE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a> xAOD::TEvent::connectBranch </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::Bool_t&nbsp;</td>
          <td class="paramname"> <em>silent</em> = <code>kFALSE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function setting up access to a particular branch. </p>
<p>This is one of the more important functions of the class. It connects the event object to a given branch of the input TTree.</p>
<p>The type that is read in to memory is not actually determined by the type written to the tree itself, but from the <a class="el" href="../../dd/d44/namespacexAOD.html#a256b02d21e647e351cc53c9370a068ef" title="Definition of the current event format version.">xAOD::EventFormat</a> object. Which is there to make it possible to possibly use ROOT read rules in the future to read a different type than what's on disk.</p>
<p>Everything else is fairly basic ROOT stuff, the code just has to make sure that the memory management is set up correctly for the created object.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The name of the branch to connect to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>silent</em>&nbsp;</td><td>Set to <code>kTRUE</code> to make the code fail silently in case the branch can't be connected to </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>kTRUE</code> if the connection was successful, or <code>kFALSE</code> if it was not </dd></dl>

</div>
</div>
<a class="anchor" id="a50894896f849e66ae67bae010ba01a92"></a><!-- doxytag: member="xAOD::TEvent::connectMetaAux" ref="a50894896f849e66ae67bae010ba01a92" args="(const std::string &amp;prefix,::Bool_t standalone)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a> xAOD::TEvent::connectMetaAux </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::Bool_t&nbsp;</td>
          <td class="paramname"> <em>standalone</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function setting up access to a set of auxiliary branches for a metadata object</p>
<p>This function is used internally to connect an auxiliary metadata object to the input. Based on the configuration of the object it will either use <a class="el" href="../../d7/d77/classxAOD_1_1TAuxStore.html" title="&quot;ROOT implementation&quot; of IAuxStore">TAuxStore</a>, or the EDM object that was used to write the auxiliary information in <a class="el" href="../../d5/dc5/namespaceAthena.html">Athena</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>prefix</em>&nbsp;</td><td>The prefix (main branch name) of the auxiliary data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>standalone</em>&nbsp;</td><td><a class="el" href="../../dd/dc8/namespacexAOD_1_1Type.html">Type</a> of the auxiliary store that should be created </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The usual <a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a> types </dd></dl>

</div>
</div>
<a class="anchor" id="ae433bd1c9085c34f565b8a76c0904903"></a><!-- doxytag: member="xAOD::TEvent::connectMetaBranch" ref="ae433bd1c9085c34f565b8a76c0904903" args="(const std::string &amp;key,::Bool_t silent=kFALSE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a> xAOD::TEvent::connectMetaBranch </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::Bool_t&nbsp;</td>
          <td class="paramname"> <em>silent</em> = <code>kFALSE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function setting up access to a branch in the metadata tree. </p>
<p>This is the function doing the heavy lifting with creating metadata objects in memory out of the payload of the input file.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key (branch name) of the metadata object to retrieve </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>silent</em>&nbsp;</td><td>Set to <code>kTRUE</code> to make the code fail silently in case the branch can't be connected to </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The usual <a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a> types </dd></dl>

</div>
</div>
<a class="anchor" id="a2d259a3afab00a5961ce1348b4602d8b"></a><!-- doxytag: member="xAOD::TEvent::contains" ref="a2d259a3afab00a5961ce1348b4602d8b" args="(const std::string &amp;key, const std::type_info &amp;ti,::Bool_t metadata=kFALSE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool_t xAOD::TEvent::contains </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::type_info &amp;&nbsp;</td>
          <td class="paramname"> <em>ti</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::Bool_t&nbsp;</td>
          <td class="paramname"> <em>metadata</em> = <code>kFALSE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal function checking if an object is in the input. </p>
<p>Created a non-template version of the call internally to be able to use it from xAOD::MakeTransientTree.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key to check </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ti</em>&nbsp;</td><td>The type of the object to check </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>metadata</em>&nbsp;</td><td>Flag deciding whether we are looking for a metadata object or not </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>kTRUE</code> if such an object is held by the event object at the moment, <code>kFALSE</code> otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a3b92c86df4409b99960328dd263792ed"></a><!-- doxytag: member="xAOD::TEvent::contains" ref="a3b92c86df4409b99960328dd263792ed" args="(const std::string &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Bool_t xAOD::TEvent::contains </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function checking if an object is available from the store. </p>
<p>This function works pretty much like StoreGateSvc::contains. It can be used to check if an object with a given type having a given key can be retrieved from the event.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key (branch name) of the object </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>kTRUE</code> if the object is available, <code>kFALSE</code> otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a2dbd8245101cc85a034a28ca4ca47701"></a><!-- doxytag: member="xAOD::TEvent::containsMeta" ref="a2dbd8245101cc85a034a28ca4ca47701" args="(const std::string &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Bool_t xAOD::TEvent::containsMeta </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function checking if a meta-object is available from the store. </p>
<p>This function works pretty much like StoreGateSvc::contains for metadata objects. It can be used to check if a metadata object with a given type having a given key can be (const) retrieved.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key (branch name) of the metadata object </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>kTRUE</code> if the object is available, <code>kFALSE</code> otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a395b577a2d21f7b45c125539c7a3cf0d"></a><!-- doxytag: member="xAOD::TEvent::copy" ref="a395b577a2d21f7b45c125539c7a3cf0d" args="(::Int_t basketSize=32000,::Int_t splitLevel=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a> xAOD::TEvent::copy </td>
          <td>(</td>
          <td class="paramtype">::Int_t&nbsp;</td>
          <td class="paramname"> <em>basketSize</em> = <code>32000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::Int_t&nbsp;</td>
          <td class="paramname"> <em>splitLevel</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy all (ROOT readable) objects directly from the input to the output. </p>
<p>This function is here to make it easy to write code that skims an input file into an output file without applying any modification to the events.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>basketSize</em>&nbsp;</td><td>Optional size for the basket associated with the output branch </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>splitLevel</em>&nbsp;</td><td>Optional split level of the output branch </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html#a8f212da971e112f15d8bd5bf49c4ed0aadf30f5028ade4d2f7dce8ab294d8400f">xAOD::TReturnCode::kSuccess</a></code> if the copy was successful, or <code><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html#a8f212da971e112f15d8bd5bf49c4ed0aa65103d5e226744ccf3bf1f920cac2075" title="The function call failed.">xAOD::TReturnCode::kFailure</a></code> if not </dd></dl>

</div>
</div>
<a class="anchor" id="a800c972b17c29c69253e2a80cf959621"></a><!-- doxytag: member="xAOD::TEvent::copy" ref="a800c972b17c29c69253e2a80cf959621" args="(const std::string &amp;key,::Int_t basketSize=32000,::Int_t splitLevel=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a> xAOD::TEvent::copy </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::Int_t&nbsp;</td>
          <td class="paramname"> <em>basketSize</em> = <code>32000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::Int_t&nbsp;</td>
          <td class="paramname"> <em>splitLevel</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy an object directly from the input to the output. </p>
<p>This function can be used to easily copy a given object/container to the output, without modifying the contents of it. It only needs to be called on the interface object/container, the copying of the auxiliary data is done automatically, and is steered by the SetAuxItemList function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key (branch name) of the object/container to copy </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>basketSize</em>&nbsp;</td><td>Optional size for the basket associated with the output branch </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>splitLevel</em>&nbsp;</td><td>Optional split level of the output branch </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4fd1eb020c74eb58022c9ae16acf055a"></a><!-- doxytag: member="xAOD::TEvent::dump" ref="a4fd1eb020c74eb58022c9ae16acf055a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string xAOD::TEvent::dump </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function creating a user-readable dump of the current input. </p>
<p>This function behaves exactly like StoreGateSvc::dump(). It doesn't actually print anything to the screen, it just returns a user readable dump of the contents of the current input file/chain.</p>
<p>It is a pretty dumb implementation for the moment. Should be made nicer later on.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The user-readable contents of the current input file/chain </dd></dl>

</div>
</div>
<a class="anchor" id="a5bfccceade4a0564484eea0a9e092b80"></a><!-- doxytag: member="xAOD::TEvent::fill" ref="a5bfccceade4a0564484eea0a9e092b80" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Int_t xAOD::TEvent::fill </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function filling one event into the output tree. </p>
<p>This function needs to be called by the user at the end of processing each event that is meant to be written out.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes written if successful, a negative number if not </dd></dl>

</div>
</div>
<a class="anchor" id="a4ac4ee0bf6d12a151be6e909e27e3fcf"></a><!-- doxytag: member="xAOD::TEvent::finishWritingTo" ref="a4ac4ee0bf6d12a151be6e909e27e3fcf" args="(::TFile *file)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a> xAOD::TEvent::finishWritingTo </td>
          <td>(</td>
          <td class="paramtype">::TFile *&nbsp;</td>
          <td class="paramname"> <em>file</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finish writing to an output file. </p>
<p>This function needs to be called when the user is done writing events to a file, before (s)he would close the file itself.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>file</em>&nbsp;</td><td>The file that the event data is written to </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>kTRUE</code> if successful, <code>kFALSE</code> otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="abd190a2cfceeeb52c454ed8436c92540"></a><!-- doxytag: member="xAOD::TEvent::getEntries" ref="abd190a2cfceeeb52c454ed8436c92540" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Long64_t xAOD::TEvent::getEntries </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get how many entries are available from the current input file(s). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of events in the input file(s) </dd></dl>

</div>
</div>
<a class="anchor" id="ab89adb4667489d2782dabd4b69203e32"></a><!-- doxytag: member="xAOD::TEvent::getEntry" ref="ab89adb4667489d2782dabd4b69203e32" args="(::Long64_t entry,::Int_t getall=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Int_t xAOD::TEvent::getEntry </td>
          <td>(</td>
          <td class="paramtype">::Long64_t&nbsp;</td>
          <td class="paramname"> <em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::Int_t&nbsp;</td>
          <td class="paramname"> <em>getall</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function loading a given entry of the input TTree. </p>
<p>This function is used to move to looking at a new entry from the input tree. It doesn't do any I/O operation at this point, it just remembers which entry the objects should be loaded from later on.</p>
<p>Unless one calls the function with <code>getall==1</code>. In that case all input is force-read. This is necessary when writing out an event that was processed in a load-on-request manner.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>entry</em>&nbsp;</td><td>The entry from the input tree to load </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>getall</em>&nbsp;</td><td>Parameter deciding if partial reading should be used or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes read, or a negative number in case of an error </dd></dl>

</div>
</div>
<a class="anchor" id="a6090a27de542ccd6c8d87489732ce0d6"></a><!-- doxytag: member="xAOD::TEvent::getFile" ref="a6090a27de542ccd6c8d87489732ce0d6" args="(::Long64_t file,::Int_t getall=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Int_t xAOD::TEvent::getFile </td>
          <td>(</td>
          <td class="paramtype">::Long64_t&nbsp;</td>
          <td class="paramname"> <em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::Int_t&nbsp;</td>
          <td class="paramname"> <em>getall</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load the first event for a given file from the input TChain. </p>
<p>This function can be used to iterate over the input files specified for the object. It should be most useful for collecting metadata about a set of input files, if there's no regular event loop done to process them.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>file</em>&nbsp;</td><td>The file number to load </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>getall</em>&nbsp;</td><td>If set to 1, all connected branches are loaded </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of read bytes on success, or a negative number on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a524c782f48073dc3bbabf6161b8f831d"></a><!-- doxytag: member="xAOD::TEvent::getFiles" ref="a524c782f48073dc3bbabf6161b8f831d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Long64_t xAOD::TEvent::getFiles </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get how many files are available on the currently defined input. </p>
<p>This function can be used to get the number of input files that the object currently knows about. This is meant to be used to collect the metadata from each of the input files, or to access the metadata using a transient tree. (<a class="el" href="../../dc/d70/classxAOD_1_1TMetaTree.html">xAOD::TMetaTree</a>)</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of input files when reading from a TChain, 1 when reading from a TFile, and 0 if the object is not connected to any input </dd></dl>

</div>
</div>
<a class="anchor" id="a7b3a78b610dd33ba349531486f958839"></a><!-- doxytag: member="xAOD::TEvent::getHash" ref="a7b3a78b610dd33ba349531486f958839" args="(const std::string &amp;key) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t xAOD::TEvent::getHash </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function returning the hash describing an object name. </p>
<p>This helper function is mostly needed by the smart pointers of the <a class="el" href="../../dd/d44/namespacexAOD.html" title="Namespace holding all the xAOD EDM classes.">xAOD</a> EDM. Right now it very simply just calculates the hash just based on the key given to the function. But later on it might be good to do some tests here, checking if the event format knows about the specified key or not. This is why it's not made to be a static function</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>String key to turn into a hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="../../d4/dc4/structA.html">A</a> hash corresponding to the specified string key </dd></dl>

<p>Implements <a class="el" href="../../de/daf/classxAOD_1_1TVirtualEvent.html#a20307a270fb83f3c5f1f2a968fbcb277">xAOD::TVirtualEvent</a>.</p>

</div>
</div>
<a class="anchor" id="a45544b1015d0baa8665db4b9b6be7c07"></a><!-- doxytag: member="xAOD::TEvent::getInputObject" ref="a45544b1015d0baa8665db4b9b6be7c07" args="(const std::string &amp;key, const std::type_info &amp;ti,::Bool_t silent=kFALSE,::Bool_t metadata=kFALSE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void * xAOD::TEvent::getInputObject </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::type_info &amp;&nbsp;</td>
          <td class="paramname"> <em>ti</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::Bool_t&nbsp;</td>
          <td class="paramname"> <em>silent</em> = <code>kFALSE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::Bool_t&nbsp;</td>
          <td class="paramname"> <em>metadata</em> = <code>kFALSE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function for retrieving an input object in a non-template way. </p>
<p>This is the function doing the heavy lifting to retrieve objects from the input file.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key (branch name) of the object to retrieve </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ti</em>&nbsp;</td><td>The type as which the object is to be retrieved </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>silent</em>&nbsp;</td><td>Set to <code>kTRUE</code> to make the code fail silently in case the object can't be retrieved </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>metadata</em>&nbsp;</td><td>Flag deciding whether we're looking for a metadata or event data object </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="../../d4/dc4/structA.html">A</a> pointer to the input object if successful, or a null pointer if not </dd></dl>

</div>
</div>
<a class="anchor" id="a35fa4683373b12d39cb8b64a8535a8a6"></a><!-- doxytag: member="xAOD::TEvent::getInputObject" ref="a35fa4683373b12d39cb8b64a8535a8a6" args="(uint32_t key, const std::type_info &amp;ti, bool silent=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void * xAOD::TEvent::getInputObject </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::type_info &amp;&nbsp;</td>
          <td class="paramname"> <em>ti</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>silent</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function for retrieving an input object in a non-template way. </p>
<p>This function is used by the <a class="el" href="../../de/daf/classxAOD_1_1TVirtualEvent.html" title="Base interface for getting objects out of the input file.">TVirtualEvent</a> interface to access an input object with a given hashed key. The function looks up the string key belonging to the hash, and then calls the other GetInputObject(...) function in the class with that parameter.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The hashed key of the input object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ti</em>&nbsp;</td><td>The type description of the object requested </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>silent</em>&nbsp;</td><td>Switch for being silent about failures or not </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="../../d4/dc4/structA.html">A</a> pointer to the requested object, or a null pointer in case of failure </dd></dl>

<p>Implements <a class="el" href="../../de/daf/classxAOD_1_1TVirtualEvent.html#ac3539de95ecf27c2b4de67b0aeffd5a4">xAOD::TVirtualEvent</a>.</p>

</div>
</div>
<a class="anchor" id="aa81f959071f880d07a04a09c0e6b0bbc"></a><!-- doxytag: member="xAOD::TEvent::getKey" ref="aa81f959071f880d07a04a09c0e6b0bbc" args="(const void *obj) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t xAOD::TEvent::getKey </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>obj</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function returning the hash describing a known object. </p>
<p>This function is used by the smart pointer code to find the identifier of an object that's already in the event in some way.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td>Pointer to the object that we want to look up </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The hashed identifier of the object, or 0 if the object was not found in the event </dd></dl>

<p>Implements <a class="el" href="../../de/daf/classxAOD_1_1TVirtualEvent.html#afeed4071e264f8f63b143559116f1414">xAOD::TVirtualEvent</a>.</p>

</div>
</div>
<a class="anchor" id="aaebd5a0daefc75bf086bd0c893ce67e3"></a><!-- doxytag: member="xAOD::TEvent::getName" ref="aaebd5a0daefc75bf086bd0c893ce67e3" args="(uint32_t hash) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; xAOD::TEvent::getName </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>hash</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function returning the key describing a known object. </p>
<p>This function is used primarily when getting the string key of a smart pointer that we read in from a file, or access it in memory.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hash</em>&nbsp;</td><td>The hashed key for the container/object </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The name of the object, or an empty string if the object was not found in the event </dd></dl>

<p>Implements <a class="el" href="../../de/daf/classxAOD_1_1TVirtualEvent.html#aaf5d7d2ba194607ec7e948ca6ec2c75c">xAOD::TVirtualEvent</a>.</p>

</div>
</div>
<a class="anchor" id="a8e4aabaa53c49136df759661ce08fb24"></a><!-- doxytag: member="xAOD::TEvent::getName" ref="a8e4aabaa53c49136df759661ce08fb24" args="(const void *obj) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; xAOD::TEvent::getName </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>obj</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function returning the key describing a known object. </p>
<p>This function is used by the smart pointer code to find the identifier of an object that's already in the event in some way.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td>Pointer to the object that we want to look up </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The name of the object, or an empty string if the object was not found in the event </dd></dl>

<p>Implements <a class="el" href="../../de/daf/classxAOD_1_1TVirtualEvent.html#aafb152ed0046dead3d38806ff9942321">xAOD::TVirtualEvent</a>.</p>

</div>
</div>
<a class="anchor" id="a13f364fdccff9db65b7b1c75f92b129e"></a><!-- doxytag: member="xAOD::TEvent::getOutputObject" ref="a13f364fdccff9db65b7b1c75f92b129e" args="(const std::string &amp;key, const std::type_info &amp;ti,::Bool_t metadata=kFALSE) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * xAOD::TEvent::getOutputObject </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::type_info &amp;&nbsp;</td>
          <td class="paramname"> <em>ti</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::Bool_t&nbsp;</td>
          <td class="paramname"> <em>metadata</em> = <code>kFALSE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function for retrieving an output object in a non-template way. </p>
<p>This function does the heavy lifting of retrieving object from the list of output objects. While it returns a typeless pointer, that pointer can be cast directly to the type described by the second parameter in the caller code.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key (branch name) of the object to retrieve </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ti</em>&nbsp;</td><td>The type as which the object is to be retrieved </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>metadata</em>&nbsp;</td><td>Flag deciding whether we're looking for a metadata or event data object </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="../../d4/dc4/structA.html">A</a> pointer to the output object if successful, or a null pointer if not </dd></dl>

</div>
</div>
<a class="anchor" id="a6531ff42179b78d04acf432a2b4c1e73"></a><!-- doxytag: member="xAOD::TEvent::getOutputObject" ref="a6531ff42179b78d04acf432a2b4c1e73" args="(uint32_t key, const std::type_info &amp;ti)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * xAOD::TEvent::getOutputObject </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::type_info &amp;&nbsp;</td>
          <td class="paramname"> <em>ti</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function for retrieving an output object in a non-template way. </p>
<p>This function is used by the <a class="el" href="../../de/daf/classxAOD_1_1TVirtualEvent.html" title="Base interface for getting objects out of the input file.">TVirtualEvent</a> interface to access an output object with a given hashed key. The function looks up the string key belonging to the hash, and then calls the other GetOutputObject(...) function in the class with that parameter.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The hashed key of the output object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ti</em>&nbsp;</td><td>The type description of the object requested </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="../../d4/dc4/structA.html">A</a> pointer to the requested object, or a null pointer in case of failure </dd></dl>

<p>Implements <a class="el" href="../../de/daf/classxAOD_1_1TVirtualEvent.html#a01237dfd919b5a35d3e92f129fb5251b">xAOD::TVirtualEvent</a>.</p>

</div>
</div>
<a class="anchor" id="ab53119c4628eb7ecc7c66c08e5d85406"></a><!-- doxytag: member="xAOD::TEvent::hasAuxStore" ref="ab53119c4628eb7ecc7c66c08e5d85406" args="(const TObjectManager &amp;mgr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool_t xAOD::TEvent::hasAuxStore </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d8e/classxAOD_1_1TObjectManager.html">TObjectManager</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mgr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function checking if a given object may have an auxiliary store. </p>
<p>Since the code needs to check in a few places whether a given object has an auxiliary store, and as this check may change slightly over time, it seemed to be a good idea to outsource this check into this function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mgr</em>&nbsp;</td><td>The manager of the object that should be checked </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>kTRUE</code> if the object can have an auxiliary store, <code>kFALSE</code> otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="acd034bd40657d54925b8ee5172cf5683"></a><!-- doxytag: member="xAOD::TEvent::initStats" ref="acd034bd40657d54925b8ee5172cf5683" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a> xAOD::TEvent::initStats </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function to initialise the statistics for all Tree content. </p>
<p>This function is used internally to initialise the reading of an input file. It prepares the "monitoring information" in memory that gets filled while the code is running, with information about <a class="el" href="../../dd/d44/namespacexAOD.html" title="Namespace holding all the xAOD EDM classes.">xAOD</a> I/O.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html#a8f212da971e112f15d8bd5bf49c4ed0aadf30f5028ade4d2f7dce8ab294d8400f">TReturnCode::kSuccess</a></code> if the function is successful, or <code>TReturnCode::kFaulure</code> if not </dd></dl>

</div>
</div>
<a class="anchor" id="a27fcd1edf34e12da56e514b70fb6e694"></a><!-- doxytag: member="xAOD::TEvent::inputEventFormat" ref="a27fcd1edf34e12da56e514b70fb6e694" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d8/d1f/classxAOD_1_1EventFormat__v1.html">EventFormat</a> * xAOD::TEvent::inputEventFormat </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get information about the input objects. </p>
<p>This function makes it possible for the user to investigate the contents of the input file that the object is currently connected to.</p>
<p>Notice that this doesn't necessarily mean that all the objects for which metadata is stored, would necessarily be part of the input TTree that this object is connected to.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The event format object if a file is being read, or a null pointer if no input file is connected at the moment. </dd></dl>

</div>
</div>
<a class="anchor" id="a2431da212c47749feadfa4a8904f7ee6"></a><!-- doxytag: member="xAOD::TEvent::isAuxStore" ref="a2431da212c47749feadfa4a8904f7ee6" args="(const TObjectManager &amp;mgr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool_t xAOD::TEvent::isAuxStore </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d8e/classxAOD_1_1TObjectManager.html">TObjectManager</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mgr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function checking if a given object may be an auxiliary store. </p>
<p>This function is used to decide if a given object is an auxiliary store type or not.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mgr</em>&nbsp;</td><td>The manager of the object that should be checked </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>kTRUE</code> if the object is an auxiliary store, <code>kFALSE</code> if it is not </dd></dl>

</div>
</div>
<a class="anchor" id="ac3f5e026371a0cee2a7d833def66f800"></a><!-- doxytag: member="xAOD::TEvent::isStandalone" ref="ac3f5e026371a0cee2a7d833def66f800" args="(const TObjectManager &amp;mgr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool_t xAOD::TEvent::isStandalone </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d8e/classxAOD_1_1TObjectManager.html">TObjectManager</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mgr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function checking if an object is standalone (not a container). </p>
<p>This function is used to figure out while setting up the reading of the TTree in kBranchAccess mode, what to tell the underlying <a class="el" href="../../d7/d77/classxAOD_1_1TAuxStore.html" title="&quot;ROOT implementation&quot; of IAuxStore">TAuxStore</a> object, what kind of store it needs to be. It's done in pretty much the same way in which hasAuxStore(...) decides if the object in question can have an auxiliary store.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mgr</em>&nbsp;</td><td>The manager of the object that should be checked </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>kTRUE</code> if the object is a standalone one, <code>kFALSE</code> if it is a container </dd></dl>

</div>
</div>
<a class="anchor" id="a475b2d4560d9a0f6855ef9c0c26c32e5"></a><!-- doxytag: member="xAOD::TEvent::outputEventFormat" ref="a475b2d4560d9a0f6855ef9c0c26c32e5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d8/d1f/classxAOD_1_1EventFormat__v1.html">EventFormat</a> * xAOD::TEvent::outputEventFormat </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get information about the output objects. </p>
<p>This function makes it possible for the user to investigate the content that is being written to the output file.</p>
<p>Notice that this doesn't necessarily mean that all the objects for which metadata is stored, would necessarily be part of the output TTree that this object is connected to.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The event format object if a file is being written, or a null pointer if not. </dd></dl>

</div>
</div>
<a class="anchor" id="ab3b84f477bea7e6ce0f01bd5c80e3a84"></a><!-- doxytag: member="xAOD::TEvent::printIOStats" ref="ab3b84f477bea7e6ce0f01bd5c80e3a84" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xAOD::TEvent::printIOStats </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function printing the I/O statistics of the current process. </p>
<p>This is a convenience function for printing basic I/O information about the current job. It can be called at the end of a job to get an overview of what the job did exactly I/O-wise. </p>

</div>
</div>
<a class="anchor" id="aa15c26c79f5b47394f678c34b2e18e66"></a><!-- doxytag: member="xAOD::TEvent::printNameRemap" ref="aa15c26c79f5b47394f678c34b2e18e66" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xAOD::TEvent::printNameRemap </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print the current name re-mapping rules. </p>
<p>This function can be used for debugging, to check what container/object name remapping rules are in place for the current <a class="el" href="../../de/d95/classxAOD_1_1TEvent.html" title="Tool for accessing xAOD files outside of Athena.">TEvent</a> object. </p>

</div>
</div>
<a class="anchor" id="a970c28d37f542b3096e7ac2588fc21c8"></a><!-- doxytag: member="xAOD::TEvent::putAux" ref="a970c28d37f542b3096e7ac2588fc21c8" args="(::TTree &amp;outTree, TVirtualManager &amp;mgr,::Int_t basketSize=32000,::Int_t splitLevel=0,::Bool_t metadata=kFALSE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a> xAOD::TEvent::putAux </td>
          <td>(</td>
          <td class="paramtype">::TTree &amp;&nbsp;</td>
          <td class="paramname"> <em>outTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d1/db4/classxAOD_1_1TVirtualManager.html">TVirtualManager</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vmgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::Int_t&nbsp;</td>
          <td class="paramname"> <em>basketSize</em> = <code>32000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::Int_t&nbsp;</td>
          <td class="paramname"> <em>splitLevel</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::Bool_t&nbsp;</td>
          <td class="paramname"> <em>metadata</em> = <code>kFALSE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function saving the dynamically created auxiliary properties. </p>
<p>This function is used internally to set up the writing of the auxiliary store variables that were dynamically created on an object. (And not statically defined to be part of that object.)</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>outTree</em>&nbsp;</td><td>The TTree to put the auxiliary branches into </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mgr</em>&nbsp;</td><td>The object manager of the output object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>basketSize</em>&nbsp;</td><td>Size of the buffer associated with the branches </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>splitLevel</em>&nbsp;</td><td>The split level to use for the created branches </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>metadata</em>&nbsp;</td><td>Flag specifying whether the info written is metadata or not </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>kTRUE</code> if the setup was successful, or <code>kFALSE</code> if it was not </dd></dl>

</div>
</div>
<a class="anchor" id="a9aba64d79df826d8f9d1220f727b97ea"></a><!-- doxytag: member="xAOD::TEvent::readFrom" ref="a9aba64d79df826d8f9d1220f727b97ea" args="(::TTree *tree, Bool_t useTreeCache=kTRUE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a> xAOD::TEvent::readFrom </td>
          <td>(</td>
          <td class="paramtype">::TTree *&nbsp;</td>
          <td class="paramname"> <em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool_t&nbsp;</td>
          <td class="paramname"> <em>useTreeCache</em> = <code>kTRUE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Connect the object to a new input tree/chain. </p>
<p>This version of the function sets up the object to readin information from a tree/chain. Using it with a TTree pointer makes not much sense, but using it with a TChain pointer could be a very valid usage mode.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tree</em>&nbsp;</td><td>The pointer to a TTree or a TChain </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>useTreeCache</em>&nbsp;</td><td>Flag for switching TTreeCache usage on/off </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>kTRUE</code> if successful, <code>kFALSE</code> when not </dd></dl>

</div>
</div>
<a class="anchor" id="a373125b7b2774de9464afa65b8f413cb"></a><!-- doxytag: member="xAOD::TEvent::readFrom" ref="a373125b7b2774de9464afa65b8f413cb" args="(::TFile *file, Bool_t useTreeCache=kTRUE, const char *treeName=EVENT_TREE_NAME)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a> xAOD::TEvent::readFrom </td>
          <td>(</td>
          <td class="paramtype">::TFile *&nbsp;</td>
          <td class="paramname"> <em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool_t&nbsp;</td>
          <td class="paramname"> <em>useTreeCache</em> = <code>kTRUE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>treeName</em> = <code><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a3e39fc579b4d1f6c423334caf4fbdd90">EVENT_TREE_NAME</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Connect the object to a new input file. </p>
<p>This function takes care of connecting the event object to a new input file. It reads in the metadata of the input file needed for reading the file.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>file</em>&nbsp;</td><td>Pointer to the file being read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>useTreeCache</em>&nbsp;</td><td>Flag for turning on/off the usage of TTreeCache </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>treeName</em>&nbsp;</td><td>Name of the input tree </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>kTRUE</code> if successful, <code>kFALSE</code> otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a7c1f7efc453071b3ebdceb05f7428129"></a><!-- doxytag: member="xAOD::TEvent::record" ref="a7c1f7efc453071b3ebdceb05f7428129" args="(TAuxStore *store, const std::string &amp;key,::Int_t basketSize,::Int_t splitLevel,::Bool_t ownsStore=kFALSE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a> xAOD::TEvent::record </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d77/classxAOD_1_1TAuxStore.html">TAuxStore</a> *&nbsp;</td>
          <td class="paramname"> <em>store</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::Int_t&nbsp;</td>
          <td class="paramname"> <em>basketSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::Int_t&nbsp;</td>
          <td class="paramname"> <em>splitLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::Bool_t&nbsp;</td>
          <td class="paramname"> <em>ownsStore</em> = <code>kFALSE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal function for adding an auxiliary store object to the output. </p>
<p>This function is used internally when copying an object with its auxiliary store from the input file, and branch access mode is activated for the event object.</p>
<p>The assumption is that the store object already knows what prefix it should be using. The key parameter only specifies under what ID the object should be handled in the output object list.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>store</em>&nbsp;</td><td>The store object to connect to the output </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The "key" with which to record the object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>basketSize</em>&nbsp;</td><td>The basket size of the output branches </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>splitLevel</em>&nbsp;</td><td>The split level of the output branches </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>kTRUE</code> if the operation was successful, or <code>kFALSE</code> if it was not </dd></dl>

</div>
</div>
<a class="anchor" id="ac4608877b90a9cd5e0b69b96e13d1537"></a><!-- doxytag: member="xAOD::TEvent::record" ref="ac4608877b90a9cd5e0b69b96e13d1537" args="(void *obj, const std::string &amp;typeName, const std::string &amp;key,::Int_t basketSize,::Int_t splitLevel,::Bool_t overwrite=kFALSE,::Bool_t metadata=kFALSE,::Bool_t isOwner=kTRUE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a> xAOD::TEvent::record </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>typeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::Int_t&nbsp;</td>
          <td class="paramname"> <em>basketSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::Int_t&nbsp;</td>
          <td class="paramname"> <em>splitLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::Bool_t&nbsp;</td>
          <td class="paramname"> <em>overwrite</em> = <code>kFALSE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::Bool_t&nbsp;</td>
          <td class="paramname"> <em>metadata</em> = <code>kFALSE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::Bool_t&nbsp;</td>
          <td class="paramname"> <em>isOwner</em> = <code>kTRUE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal function for recording an object into the output. </p>
<p>This is the function doing the heavy lifting when recording a new object into the output tree/file. It makes sure that the object is saved together with all of its dynamic auxiliary data if it has any.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td><a class="el" href="../../d4/dc4/structA.html">A</a> typeless pointer to the object that we want to record </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>typeName</em>&nbsp;</td><td>The type name of the output object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key (branch name) of the object to record </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>basketSize</em>&nbsp;</td><td>The basket size of the output branch </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>splitLevel</em>&nbsp;</td><td>The split level of the output branch </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>overwrite</em>&nbsp;</td><td>Flag selecting if it is allowed to overwrite an already existing object (used internally) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>metadata</em>&nbsp;</td><td>Flag selecting if we are writing an event or a metadata object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>isOwner</em>&nbsp;</td><td>Flag selecting if we should take ownership of the object or not </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>kTRUE</code> if the operation was successful, or <code>kFALSE</code> if it was not </dd></dl>

</div>
</div>
<a class="anchor" id="ad5cdd02952e6d42895a1cba88339a6f4"></a><!-- doxytag: member="xAOD::TEvent::record" ref="ad5cdd02952e6d42895a1cba88339a6f4" args="(std::unique_ptr&lt; T &gt; obj, const std::string &amp;key,::Int_t basketSize=32000,::Int_t splitLevel=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a> xAOD::TEvent::record </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="../../d1/def/classT.html">T</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::Int_t&nbsp;</td>
          <td class="paramname"> <em>basketSize</em> = <code>32000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::Int_t&nbsp;</td>
          <td class="paramname"> <em>splitLevel</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add an output object to the event, explicitly taking ownership of it. </p>
<p>This function is used to add an object to the output. As the interface clearly states, the function takes posession of the object given to it. Since the user must give up ownership of the object in order to call this function, it doesn't even need to be said that the user must not delete the object by hand after calling this function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td>Smart pointer to the object to tbe added to the event </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key (branch name) to give the object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>basketSize</em>&nbsp;</td><td>Basket size for the branch created from the object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>splitLevel</em>&nbsp;</td><td>The split level of the branch to create </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>kTRUE</code> if the operation was successful, <code>kFALSE</code> if it wasn't </dd></dl>

</div>
</div>
<a class="anchor" id="af90403dbebbccf4397b29191c4437cad"></a><!-- doxytag: member="xAOD::TEvent::record" ref="af90403dbebbccf4397b29191c4437cad" args="(T *obj, const std::string &amp;key,::Int_t basketSize=32000,::Int_t splitLevel=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a> xAOD::TEvent::record </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/def/classT.html">T</a> *&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::Int_t&nbsp;</td>
          <td class="paramname"> <em>basketSize</em> = <code>32000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::Int_t&nbsp;</td>
          <td class="paramname"> <em>splitLevel</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add an output object to the event. </p>
<p>This function can be used to add an object to the output. The function takes posession of the object, so the user code must not delete an object that was added to an event.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td>Pointer to the object to be added to the event </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key (branch name) to give the object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>basketSize</em>&nbsp;</td><td>Basket size for the branch created from the object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>splitLevel</em>&nbsp;</td><td>The split level of the branch to create </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>kTRUE</code> if the operation was successful, <code>kFALSE</code> if it wasn't </dd></dl>

</div>
</div>
<a class="anchor" id="af23ea51439ea4c963a5d0ba8e4e9a2e8"></a><!-- doxytag: member="xAOD::TEvent::recordMeta" ref="af23ea51439ea4c963a5d0ba8e4e9a2e8" args="(std::unique_ptr&lt; T &gt; obj, const std::string &amp;key,::Int_t basketSize=32000,::Int_t splitLevel=1)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a> xAOD::TEvent::recordMeta </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="../../d1/def/classT.html">T</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::Int_t&nbsp;</td>
          <td class="paramname"> <em>basketSize</em> = <code>32000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::Int_t&nbsp;</td>
          <td class="paramname"> <em>splitLevel</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add an object to the output file's metadata, explicitly taking ownership of it</p>
<p>This function can be used to add a metadata object to the output. As the interface clearly states, the function takes posession of the object given to it. So it's not even worth mentioning that the user must not delete the object after giving it to this function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td>Smart pointer to the object to be added to the output metadata </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key (branch name) to give the object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>basketSize</em>&nbsp;</td><td>Basket size for the branch created from the object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>splitLevel</em>&nbsp;</td><td>The split level of the branch to create </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>kTRUE</code> if the operation was successful, <code>kFALSE</code> if it wasn't </dd></dl>

</div>
</div>
<a class="anchor" id="a11dfdb955bd84935502353a0a7616b75"></a><!-- doxytag: member="xAOD::TEvent::recordMeta" ref="a11dfdb955bd84935502353a0a7616b75" args="(T *obj, const std::string &amp;key,::Int_t basketSize=32000,::Int_t splitLevel=1)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a> xAOD::TEvent::recordMeta </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/def/classT.html">T</a> *&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::Int_t&nbsp;</td>
          <td class="paramname"> <em>basketSize</em> = <code>32000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::Int_t&nbsp;</td>
          <td class="paramname"> <em>splitLevel</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add an object to the output file's metadata. </p>
<p>This function can be used to add a metadata object to the output. The function takes posession of the object, so the user code must not delete an object that was added to the output.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td>Pointer to the object to be added to the output metadata </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key (branch name) to give the object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>basketSize</em>&nbsp;</td><td>Basket size for the branch created from the object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>splitLevel</em>&nbsp;</td><td>The split level of the branch to create </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>kTRUE</code> if the operation was successful, <code>kFALSE</code> if it wasn't </dd></dl>

</div>
</div>
<a class="anchor" id="a7180825a285c43d7eefdf7f83f3b7854"></a><!-- doxytag: member="xAOD::TEvent::removeListener" ref="a7180825a285c43d7eefdf7f83f3b7854" args="(TVirtualIncidentListener *listener)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a> xAOD::TEvent::removeListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d1b/classxAOD_1_1TVirtualIncidentListener.html">TVirtualIncidentListener</a> *&nbsp;</td>
          <td class="paramname"> <em>listener</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove an incident listener object. </p>
<p>This function allows us to remove a listener when for instance a metadata tool is deleted during a job.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>listener</em>&nbsp;</td><td>Pointer to the listener that should be removed </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The usual <a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a> types </dd></dl>

</div>
</div>
<a class="anchor" id="aa602e807821e403a6443c11060174916"></a><!-- doxytag: member="xAOD::TEvent::retrieve" ref="aa602e807821e403a6443c11060174916" args="(T *&amp;obj, const std::string &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a> xAOD::TEvent::retrieve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/def/classT.html">T</a> *&amp;&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve an output object from the event. </p>
<p>This function can be used to retrieve an object from the output list. Since only output objects are considered, the function returns a non-const object, allowing downstream code to modify an object that was put into the event somewhere upstream.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td>The pointer that will be set to the object requested </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key (branch name) of the object </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>kTRUE</code> if the operation was successful, <code>kFALSE</code> if it wasn't </dd></dl>

</div>
</div>
<a class="anchor" id="a85e9bb280df774885102075cbf7b8e06"></a><!-- doxytag: member="xAOD::TEvent::retrieve" ref="a85e9bb280df774885102075cbf7b8e06" args="(const T *&amp;obj, const std::string &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a> xAOD::TEvent::retrieve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/def/classT.html">T</a> *&amp;&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve either an input or an output object from the event. </p>
<p>This function needs to be used when retrieving an object either from the input or the output object list. The returned object can not be modified.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td>The pointer that will be set to the object requested </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key (branch name) of the object </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>kTRUE</code> if the operation was successful, <code>kFALSE</code> if it wasn't </dd></dl>

</div>
</div>
<a class="anchor" id="a6eeaa9ae4eb9c2a91706f767de96ea45"></a><!-- doxytag: member="xAOD::TEvent::retrieveMetaInput" ref="a6eeaa9ae4eb9c2a91706f767de96ea45" args="(const T *&amp;obj, const std::string &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a> xAOD::TEvent::retrieveMetaInput </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/def/classT.html">T</a> *&amp;&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve an input metadata object. </p>
<p>This function can be used to retrieve an object from the input metadata list.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td>The pointer that will be set to the object requested </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key (branch name) of the object </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The usual <a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a> values </dd></dl>

</div>
</div>
<a class="anchor" id="a2c562dc4d26e317f0e32221e07c20cd7"></a><!-- doxytag: member="xAOD::TEvent::retrieveMetaOutput" ref="a2c562dc4d26e317f0e32221e07c20cd7" args="(T *&amp;obj, const std::string &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a> xAOD::TEvent::retrieveMetaOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/def/classT.html">T</a> *&amp;&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve an output metadata object. </p>
<p>This function can be used to retrieve an object from the output metadata list.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td>The pointer that will be set to the object requested </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key (branch name) of the object </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The usual <a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a> values </dd></dl>

</div>
</div>
<a class="anchor" id="aa10977469fe765f8d9fe5acd0b064b8d"></a><!-- doxytag: member="xAOD::TEvent::retrieveMetaOutput" ref="aa10977469fe765f8d9fe5acd0b064b8d" args="(const T *&amp;obj, const std::string &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a> xAOD::TEvent::retrieveMetaOutput </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/def/classT.html">T</a> *&amp;&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve an output metadata object. </p>
<p>This function can be used to retrieve an object from the output metadata list.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td>The pointer that will be set to the object requested </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key (branch name) of the object </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The usual <a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a> values </dd></dl>

</div>
</div>
<a class="anchor" id="a5423ace77c19aaf271c63334e32b2174"></a><!-- doxytag: member="xAOD::TEvent::setActive" ref="a5423ace77c19aaf271c63334e32b2174" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xAOD::TEvent::setActive </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set this event object as the currently active one. </p>
<p>Setting <a class="el" href="../../de/d95/classxAOD_1_1TEvent.html" title="Tool for accessing xAOD files outside of Athena.">TEvent</a> objects happens automatically when reading a file, but when writing a file from scratch, the code doesn't necessarily know which <a class="el" href="../../de/d95/classxAOD_1_1TEvent.html" title="Tool for accessing xAOD files outside of Athena.">TEvent</a> object a given smart pointer should "belong to". This function helps the user with setting this up. </p>

</div>
</div>
<a class="anchor" id="ab10bcece69a8bc7fb3f388f96feaacfd"></a><!-- doxytag: member="xAOD::TEvent::setAuxItemList" ref="ab10bcece69a8bc7fb3f388f96feaacfd" args="(const std::string &amp;containerKey, const std::string &amp;itemList)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xAOD::TEvent::setAuxItemList </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>containerKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>itemList</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Configure which dynamic variables to write out for a given store. </p>
<p>This function receives the rules for selecting which dynamic auxiliary branches should be written for a given container, in the exact same format in which we need to set it in the <a class="el" href="../../d5/dc5/namespaceAthena.html">Athena</a> output ItemList.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>containerKey</em>&nbsp;</td><td>The name of the auxiliary container in question </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>itemList</em>&nbsp;</td><td>The variable list according to the ... formatting rules </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa50ebfd4ab78b080eb845a20dc3bbb37"></a><!-- doxytag: member="xAOD::TEvent::setAuxStore" ref="aa50ebfd4ab78b080eb845a20dc3bbb37" args="(TObjectManager &amp;mgr,::Bool_t metadata=kFALSE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a> xAOD::TEvent::setAuxStore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d8e/classxAOD_1_1TObjectManager.html">TObjectManager</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::Bool_t&nbsp;</td>
          <td class="paramname"> <em>metadata</em> = <code>kFALSE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function connecting a <a class="el" href="../../d3/d78/structDV.html">DV</a> object to its auxiliary store. </p>
<p>Every time a <a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;.">DataVector</a> is read in from the input for a new TTree entry, one needs to re-connect it with its auxiliary store. This function takes care of this.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mgr</em>&nbsp;</td><td>The manager object of the <a class="el" href="../../d3/d78/structDV.html">DV</a> container </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>metadata</em>&nbsp;</td><td>Flag specifying whether we're dealing with a metadata or event data object </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>kTRUE</code> if the setup was successful, or <code>kFALSE</code> if it was not </dd></dl>

</div>
</div>
<a class="anchor" id="a86fb514054574fb9883bdd9b3ae761aa"></a><!-- doxytag: member="xAOD::TEvent::setUpDynamicStore" ref="a86fb514054574fb9883bdd9b3ae761aa" args="(TObjectManager &amp;mgr,::TTree *tree)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a> xAOD::TEvent::setUpDynamicStore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d8e/classxAOD_1_1TObjectManager.html">TObjectManager</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::TTree *&nbsp;</td>
          <td class="paramname"> <em>tree</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function adding dynamic variable reading capabilities to an auxiliary store object</p>
<p>This function is used by connectBranch(...) and connectMetaBranch(...) to set up auxiliary store type objects correctly for accessing dynamic variables from the input file.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mgr</em>&nbsp;</td><td>The object manager of the auxiliary store object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tree</em>&nbsp;</td><td>The tree to read dynamic variables from </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The usual <code><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a></code> types </dd></dl>

</div>
</div>
<a class="anchor" id="a1dbaade3e5b746d14c852a21bce9791e"></a><!-- doxytag: member="xAOD::TEvent::transientContains" ref="a1dbaade3e5b746d14c852a21bce9791e" args="(const std::string &amp;key, const std::type_info &amp;ti,::Bool_t metadata=kFALSE) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool_t xAOD::TEvent::transientContains </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::type_info &amp;&nbsp;</td>
          <td class="paramname"> <em>ti</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::Bool_t&nbsp;</td>
          <td class="paramname"> <em>metadata</em> = <code>kFALSE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal function checking if an object is already in memory. </p>
<p>Internal function checking if an object of a given type, with a given key is held in memory by the event object. It's this function doing the heavy lifting for the public template function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key/branch name of the object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ti</em>&nbsp;</td><td>The type description of the object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>metadata</em>&nbsp;</td><td>Flag deciding whether we are looking for a metadata object or not </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>kTRUE</code> if such a modifiable object is held by the event object at the moment, <code>kFALSE</code> otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="aca57bfb6ea9448c94cadcd2456f82609"></a><!-- doxytag: member="xAOD::TEvent::transientContains" ref="aca57bfb6ea9448c94cadcd2456f82609" args="(const std::string &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Bool_t xAOD::TEvent::transientContains </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function checking if an object is already in memory. </p>
<p>This function works pretty much like StoreGateSvc::transientContains. It doesn't try to do any I/O operations, it just checks if an object of a given type, with a given key, is already in memory.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key (branch name) of the object </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>kTRUE</code> if the object is already in memory, <code>kFALSE</code> otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ac9868d2dcd71329f9f11ac3725a2ad16"></a><!-- doxytag: member="xAOD::TEvent::transientContainsMeta" ref="ac9868d2dcd71329f9f11ac3725a2ad16" args="(const std::string &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Bool_t xAOD::TEvent::transientContainsMeta </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function checking if a meta-object is already in memory. </p>
<p>This function works pretty much like StoreGateSvc::transientContains for metadata objects. It doesn't try to do any I/O operations, it just checks if an object of a given type, with a given key, can be retrieved in non-const mode.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key (branch name) of the metadata object </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>kTRUE</code> if the object is available for modifications, <code>kFALSE</code> otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a692abe196e60b809f2c57e7930d9401e"></a><!-- doxytag: member="xAOD::TEvent::writeTo" ref="a692abe196e60b809f2c57e7930d9401e" args="(::TFile *file, Int_t autoFlush=200, const char *treeName=EVENT_TREE_NAME)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/da4/classxAOD_1_1TReturnCode.html">TReturnCode</a> xAOD::TEvent::writeTo </td>
          <td>(</td>
          <td class="paramtype">::TFile *&nbsp;</td>
          <td class="paramname"> <em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int_t&nbsp;</td>
          <td class="paramname"> <em>autoFlush</em> = <code>200</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>treeName</em> = <code><a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a3e39fc579b4d1f6c423334caf4fbdd90">EVENT_TREE_NAME</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Connect the object to an output file. </p>
<p>This function should be called on a file opened be the user, before any event processing would occur. It sets up the output event tree.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>file</em>&nbsp;</td><td>The file that the event data should be written to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>autoFlush</em>&nbsp;</td><td>The auto-flush setting to use on the output TTree </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>treeName</em>&nbsp;</td><td>Name of the output event tree </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>kTRUE</code> if successful, <code>kFALSE</code> otherwise </dd></dl>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a457ea1a0296188ab4c2683f413503e5b"></a><!-- doxytag: member="xAOD::TEvent::m_inTreeMissing" ref="a457ea1a0296188ab4c2683f413503e5b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">::Bool_t <a class="el" href="../../de/d95/classxAOD_1_1TEvent.html#a457ea1a0296188ab4c2683f413503e5b">xAOD::TEvent::m_inTreeMissing</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Internal status flag showing that an input file is open, but it doesn't contain an event tree </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.30/xAODRootAccess/xAODRootAccess/<a class="el" href="../../de/d44/TEvent_8h_source.html">TEvent.h</a></li>
<li>/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.30/xAODRootAccess/Root/TEvent.cxx</li>
<li>/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.30/xAODRootAccess/xAODRootAccess/TEvent.icc</li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 15 Apr 2017 for RootCore Packages by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
