<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>RootCore Packages: CxxUtils Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="../../index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="../../search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="../../namespaces.html"><span>Namespace&nbsp;List</span></a></li>
      <li><a href="../../namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>CxxUtils Namespace Reference</h1>
<p>Copy the elements of a sequence for which a predicate is true.  
<a href="#_details">More...</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d27/classCxxUtils_1_1ArrayIteratorChooser.html">ArrayIteratorChooser</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper for defining iterators over <code>Array's</code>.  <a href="../../d5/d27/classCxxUtils_1_1ArrayIteratorChooser.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d1b/classCxxUtils_1_1ArrayIteratorChooser_3_011_01_4.html">ArrayIteratorChooser&lt; 1 &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd9/classCxxUtils_1_1Array.html">Array</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read-only multidimensional array.  <a href="../../d5/dd9/classCxxUtils_1_1Array.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d88/classCxxUtils_1_1Array_3_010_01_4.html">Array&lt; 0 &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/classCxxUtils_1_1ArrayIterator.html">ArrayIterator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterator class for <code>Array&lt;N&gt;</code>.  <a href="../../d4/d75/classCxxUtils_1_1ArrayIterator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dcc/classCxxUtils_1_1WritableArray.html">WritableArray</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read-write multidimensional array.  <a href="../../dc/dcc/classCxxUtils_1_1WritableArray.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da2/classCxxUtils_1_1WritableArray_3_010_01_4.html">WritableArray&lt; 0 &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd4/classCxxUtils_1_1WritableArrayData.html">WritableArrayData</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dac/classCxxUtils_1_1ArrayScanner.html">ArrayScanner</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper class for converting strings to Array's.  <a href="../../df/dac/classCxxUtils_1_1ArrayScanner.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d3c/classCxxUtils_1_1BitPacker.html">BitPacker</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pack a set of values bitwise into a stream.  <a href="../../d5/d3c/classCxxUtils_1_1BitPacker.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dd9/classCxxUtils_1_1BitPacker8.html">BitPacker8</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pack a set of values bitwise into a stream.  <a href="../../d8/dd9/classCxxUtils_1_1BitPacker8.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d5c/classCxxUtils_1_1BitPacker16.html">BitPacker16</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pack a set of values bitwise into a stream.  <a href="../../d7/d5c/classCxxUtils_1_1BitPacker16.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d06/classCxxUtils_1_1BitUnpacker.html">BitUnpacker</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper to unpack a set of values bitwise from a stream.  <a href="../../d4/d06/classCxxUtils_1_1BitUnpacker.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dac/classCxxUtils_1_1BitUnpacker8.html">BitUnpacker8</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper to unpack a set of values bitwise from a stream.  <a href="../../d8/dac/classCxxUtils_1_1BitUnpacker8.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dbe/classCxxUtils_1_1BitUnpacker16.html">BitUnpacker16</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper to unpack a set of values bitwise from a stream.  <a href="../../d3/dbe/classCxxUtils_1_1BitUnpacker16.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/df5/classCxxUtils_1_1ClassName.html">ClassName</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Recursively separate out template arguments in a C++ class name.  <a href="../../d2/df5/classCxxUtils_1_1ClassName.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d8c/structCxxUtils_1_1enable__if.html">enable_if</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Define a member typedef <code>type</code> only if a boolean constant is true.  <a href="../../d9/d8c/structCxxUtils_1_1enable__if.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d83/structCxxUtils_1_1enable__if_3_01true_00_01__Tp_01_4.html">enable_if&lt; true, _Tp &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/df0/classCxxUtils_1_1FloatPacker.html">FloatPacker</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pack/unpack floating-point data from/to a given number of bits.  <a href="../../da/df0/classCxxUtils_1_1FloatPacker.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dad/classCxxUtils_1_1PackedArray.html">PackedArray</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An array of unsigned values of some bit size, packed tightly.  <a href="../../d2/dad/classCxxUtils_1_1PackedArray.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d6f/classCxxUtils_1_1pointer__list__base.html">pointer_list_base</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A fast way to store a variable-sized collection of pointers.  <a href="../../d1/d6f/classCxxUtils_1_1pointer__list__base.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d88/classCxxUtils_1_1pointer__list.html">pointer_list</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A fast way to store a variable-sized collection of pointers.  <a href="../../d1/d88/classCxxUtils_1_1pointer__list.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d12/structCxxUtils_1_1sincos.html">sincos</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper to simultaneously calculate sin and cos of the same angle.  <a href="../../d4/d12/structCxxUtils_1_1sincos.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d5e/structCxxUtils_1_1extrace__init.html">extrace_init</a></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <b>CacheLineSize</b> =  64
 }</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a426624a3ea2d412c113ce5217166d38d"></a><!-- doxytag: member="CxxUtils::copy_if" ref="a426624a3ea2d412c113ce5217166d38d" args="(InputIterator first, InputIterator last, OutputIterator result, Predicate pred)" -->
template&lt;typename InputIterator , typename OutputIterator , typename Predicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>copy_if</b> (InputIterator first, InputIterator last, OutputIterator result, Predicate pred)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="af16c85f6fe3658154a9b225609574726"></a><!-- doxytag: member="CxxUtils::copy_bounded1" ref="af16c85f6fe3658154a9b225609574726" args="(InputIterator begi, InputIterator endi, OutputIterator bego, OutputIterator endo, const InputTag &amp;, const OutputTag &amp;)" -->
template&lt;class InputIterator , class OutputIterator , class InputTag , class OutputTag &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d12/namespaceCxxUtils.html#af16c85f6fe3658154a9b225609574726">copy_bounded1</a> (InputIterator begi, InputIterator endi, OutputIterator bego, OutputIterator endo, const InputTag &amp;, const OutputTag &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy a range with bounds restriction; generic version. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a5ede98c8f13a1c221e932fe588f5d996"></a><!-- doxytag: member="CxxUtils::copy_bounded1" ref="a5ede98c8f13a1c221e932fe588f5d996" args="(InputIterator begi, InputIterator endi, OutputIterator bego, OutputIterator endo, const std::random_access_iterator_tag &amp;, const std::random_access_iterator_tag &amp;)" -->
template&lt;class InputIterator , class OutputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d12/namespaceCxxUtils.html#a5ede98c8f13a1c221e932fe588f5d996">copy_bounded1</a> (InputIterator begi, InputIterator endi, OutputIterator bego, OutputIterator endo, const std::random_access_iterator_tag &amp;, const std::random_access_iterator_tag &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy a range with bounds restriction; random_access_iterator version. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class OutputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d12/namespaceCxxUtils.html#a5049ecdf32f875ad81bca0377cd12bc3">copy_bounded</a> (InputIterator begi, InputIterator endi, OutputIterator bego, OutputIterator endo)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy a range with bounds restriction.  <a href="#a5049ecdf32f875ad81bca0377cd12bc3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class InputRange , class OutputRange &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">boost::range_iterator<br class="typebreak"/>
&lt; OutputRange &gt;::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d12/namespaceCxxUtils.html#a13bedce0dab0a2e825383e8f21ea37b2">copy_bounded</a> (const InputRange &amp;input, OutputRange &amp;output)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy a range with bounds restriction.  <a href="#a13bedce0dab0a2e825383e8f21ea37b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d12/namespaceCxxUtils.html#a1b199b3c90529fef9ea3d0b89d9eeca0">exctrace</a> (const std::exception &amp;e, <a class="el" href="../../d1/dc7/SealCommon_8h.html#a98d936fe848403f33ff9cebfc9a38597">IOFD</a> fd=IOFD_INVALID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print out information for the last exception.  <a href="#a1b199b3c90529fef9ea3d0b89d9eeca0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a8d7b43f454542ab8071fe88444f3cb2b"></a><!-- doxytag: member="CxxUtils::ones" ref="a8d7b43f454542ab8071fe88444f3cb2b" args="(unsigned int n)" -->
template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d1/def/classT.html">T</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d12/namespaceCxxUtils.html#a8d7b43f454542ab8071fe88444f3cb2b">ones</a> (unsigned int n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a bit mask with the lower <em>n</em> bits set. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d12/namespaceCxxUtils.html#abfc11f0c6320559e2a85f8dfabc4ab35">prefetchOne</a> (const void *address)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generic prefetch method.  <a href="#abfc11f0c6320559e2a85f8dfabc4ab35"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d12/namespaceCxxUtils.html#a678516f176527cc599c4f2d6955b04cb">prefetchN</a> (const void *ptr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prefetch an N-byte block of memory.  <a href="#a678516f176527cc599c4f2d6955b04cb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d12/namespaceCxxUtils.html#a01ccd92e2dd3def19d3a69cec058555d">prefetchObj</a> (const <a class="el" href="../../d1/def/classT.html">T</a> *ptr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generic prefetch of the object of specific types (sizes).  <a href="#a01ccd92e2dd3def19d3a69cec058555d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Iter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d12/namespaceCxxUtils.html#a026e0a124e8bb253ee77fe73f952d7e1">prefetchNext</a> (Iter iter, Iter endIter)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prefetch next object in sequence.  <a href="#a026e0a124e8bb253ee77fe73f952d7e1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Iter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d12/namespaceCxxUtils.html#ad61690c9769710cbcf846e498e0e762a">prefetchTwo</a> (Iter iter, Iter endIter)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prefetch two objects.  <a href="#ad61690c9769710cbcf846e498e0e762a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a20e9ea3bf1e4593c7e9e4fe952edc452"></a><!-- doxytag: member="CxxUtils::strformat" ref="a20e9ea3bf1e4593c7e9e4fe952edc452" args="(const char *fmt,...)" -->
std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d12/namespaceCxxUtils.html#a20e9ea3bf1e4593c7e9e4fe952edc452">strformat</a> (const char *fmt,...)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return a `stdstring` according to a format `fmt` and varargs <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Copy the elements of a sequence for which a predicate is true. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>An input iterator. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>last</em>&nbsp;</td><td>An input iterator. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>An output iterator. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pred</em>&nbsp;</td><td>A predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>Copies each element in the range <code></code>[first,last) for which <code>pred</code> returns true to the range beginning at <code>result</code>.</p>
<p>copy_if() is stable, so the relative order of elements that are copied is unchanged.</p>
<p><em>Example</em>: </p>
<div class="fragment"><pre class="fragment">  CxxUtils::copy_if( in.begin(), in.end(),
                     std::back_inserter(out), filter );
</pre></div><p> where in and out are STL-like containers and filter is a predicate </p>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a1495f9141a6860a45e9526a4eead7b07"></a><!-- doxytag: member="CxxUtils::@12" ref="a1495f9141a6860a45e9526a4eead7b07" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>While it is possible to determine cache line size at run time (e.g. using sysconf(_SC_LEVEL1_DCACHE_LINESIZE) on Linux or sysctlbyname("hw.cachelinesize", ...) on Apple systems) that approach creates more problems: the location that stores cache line size will probably be out of cache when one needs to know it. This is why we use a compile time constant for cache line size. Cache line size is 64 for the current generation of Intel/AMD CPUs.</p>
<p>If an object spans multiple cache lines then prefetching whole object should be done by prefetching at least one address from each of the cache lines that object occupies. How many lines are needed depends on three things: object size, cache line size, and object starting address. If CacheLineSize is lower than the actual line size then more prefetches than necessary will be generated (2, 4, or more per cache line if cache line size is power of 2). This may be somewhat wasteful so this number may need to be adjusted in the far future when _all_ CPUs have wider cache lines. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a13bedce0dab0a2e825383e8f21ea37b2"></a><!-- doxytag: member="CxxUtils::copy_bounded" ref="a13bedce0dab0a2e825383e8f21ea37b2" args="(const InputRange &amp;input, OutputRange &amp;output)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputRange , class OutputRange &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::range_iterator&lt;OutputRange&gt;::type CxxUtils::copy_bounded </td>
          <td>(</td>
          <td class="paramtype">const InputRange &amp;&nbsp;</td>
          <td class="paramname"> <em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputRange &amp;&nbsp;</td>
          <td class="paramname"> <em>output</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy a range with bounds restriction. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>input</em>&nbsp;</td><td>Input range </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>output</em>&nbsp;</td><td>Output range</td></tr>
  </table>
  </dd>
</dl>
<p>copy_bounded written in terms of iterator ranges. </p>

</div>
</div>
<a class="anchor" id="a5049ecdf32f875ad81bca0377cd12bc3"></a><!-- doxytag: member="CxxUtils::copy_bounded" ref="a5049ecdf32f875ad81bca0377cd12bc3" args="(InputIterator begi, InputIterator endi, OutputIterator bego, OutputIterator endo)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator CxxUtils::copy_bounded </td>
          <td>(</td>
          <td class="paramtype">InputIterator&nbsp;</td>
          <td class="paramname"> <em>begi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&nbsp;</td>
          <td class="paramname"> <em>endi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&nbsp;</td>
          <td class="paramname"> <em>bego</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&nbsp;</td>
          <td class="paramname"> <em>endo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy a range with bounds restriction. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>begi</em>&nbsp;</td><td>Start of input range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>endi</em>&nbsp;</td><td>End of input range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bego</em>&nbsp;</td><td>Start of output range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>endo</em>&nbsp;</td><td>End of output range.</td></tr>
  </table>
  </dd>
</dl>
<p>Like std::copy(begi, endi, bego), except that it will not copy more than std::distance(bego, endo) elements.</p>
<p>Copies exactly n = std::min (std::distance(begi,endi), std::distance(bego,endo)) elements. Returns bego + n. </p>

</div>
</div>
<a class="anchor" id="a1b199b3c90529fef9ea3d0b89d9eeca0"></a><!-- doxytag: member="CxxUtils::exctrace" ref="a1b199b3c90529fef9ea3d0b89d9eeca0" args="(const std::exception &amp;e, IOFD fd=IOFD_INVALID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CxxUtils::exctrace </td>
          <td>(</td>
          <td class="paramtype">const std::exception &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d1/dc7/SealCommon_8h.html#a98d936fe848403f33ff9cebfc9a38597">IOFD</a>&nbsp;</td>
          <td class="paramname"> <em>fd</em> = <code>IOFD_INVALID</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print out information for the last exception. </p>
<p>Prints the supplied exception, plus the backtrace from the last exception, if available.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>e</em>&nbsp;</td><td>The exception to print. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fd</em>&nbsp;</td><td>The file descriptor to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a678516f176527cc599c4f2d6955b04cb"></a><!-- doxytag: member="CxxUtils::prefetchN" ref="a678516f176527cc599c4f2d6955b04cb" args="(const void *ptr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CxxUtils::prefetchN </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prefetch an N-byte block of memory. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ptr</em>&nbsp;</td><td>Starting address of the block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a026e0a124e8bb253ee77fe73f952d7e1"></a><!-- doxytag: member="CxxUtils::prefetchNext" ref="a026e0a124e8bb253ee77fe73f952d7e1" args="(Iter iter, Iter endIter)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CxxUtils::prefetchNext </td>
          <td>(</td>
          <td class="paramtype">Iter&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&nbsp;</td>
          <td class="paramname"> <em>endIter</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prefetch next object in sequence. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>Current iteration position. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>endIter</em>&nbsp;</td><td>End of the sequence.</td></tr>
  </table>
  </dd>
</dl>
<p><code>Iter</code> is a <code>ForwardIterator</code> over pointers.</p>
<p>Prefetches next object in a collection of pointers. Accepts two iterators: the first iterator is the current iteration position, and the second iterator is the end iterator for the whole sequence. The first iterator must not be equal to the end iterator (this is not checked). This increments the iterator and, if not equal to the end, prefetches the complete object referenced by the pointer. </p>

</div>
</div>
<a class="anchor" id="a01ccd92e2dd3def19d3a69cec058555d"></a><!-- doxytag: member="CxxUtils::prefetchObj" ref="a01ccd92e2dd3def19d3a69cec058555d" args="(const T *ptr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CxxUtils::prefetchObj </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/def/classT.html">T</a> *&nbsp;</td>
          <td class="paramname"> <em>ptr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generic prefetch of the object of specific types (sizes). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>address</em>&nbsp;</td><td>memory location to prefetch</td></tr>
  </table>
  </dd>
</dl>
<p>This method will prefetch as many cache lines as needed to store the object of the specified type in memory. Type is specified as a template argument. </p>

</div>
</div>
<a class="anchor" id="abfc11f0c6320559e2a85f8dfabc4ab35"></a><!-- doxytag: member="CxxUtils::prefetchOne" ref="abfc11f0c6320559e2a85f8dfabc4ab35" args="(const void *address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CxxUtils::prefetchOne </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>address</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generic prefetch method. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>address</em>&nbsp;</td><td>memory location to prefetch</td></tr>
  </table>
  </dd>
</dl>
<p>This is generic method that does not have any extra behavior. It only prefetches the whole cache line which contains the specified memory location. It does not incur any additional overhead and may be the most efficient method for small objects which have a high chance of being on just a single cache line. </p>

</div>
</div>
<a class="anchor" id="ad61690c9769710cbcf846e498e0e762a"></a><!-- doxytag: member="CxxUtils::prefetchTwo" ref="ad61690c9769710cbcf846e498e0e762a" args="(Iter iter, Iter endIter)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CxxUtils::prefetchTwo </td>
          <td>(</td>
          <td class="paramtype">Iter&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&nbsp;</td>
          <td class="paramname"> <em>endIter</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prefetch two objects. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>Current iteration position. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>endIter</em>&nbsp;</td><td>End of the sequence.</td></tr>
  </table>
  </dd>
</dl>
<p><code>Iter</code> is a <code>ForwardIterator</code> over pointers.</p>
<p>Prefetches the current and next objects in a collection of pointers. Accepts two iterators: the first iterator is the current iteration position, and the second is the end iterator for the whole sequence. If the first iterator is not equal to end the iterator, the object to which it points is prefetched. Then the iterator is incremented and, if not equal to the end iterator, the next objects is also prefetched. </p>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 27 Apr 2017 for RootCore Packages by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
