<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>RootCore Packages: CxxUtils Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">RootCore Packages
   &#160;<span id="projectnumber">2.4.31</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="../../namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">CxxUtils Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Copy the elements of a sequence for which a predicate is true.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/classCxxUtils_1_1ArrayIterator.html">ArrayIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator class for <code><a class="el" href="../../d4/dd1/classArray_3_01N_01_4.html" title="A WriteableArray together with an Arrayrep. ">Array&lt;N&gt;</a></code>.  <a href="../../d4/d75/classCxxUtils_1_1ArrayIterator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d27/classCxxUtils_1_1ArrayIteratorChooser.html">ArrayIteratorChooser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for defining iterators over <code><a class="el" href="../../d5/dd9/classCxxUtils_1_1Array.html" title="Read-only multidimensional array. ">Array</a>'s</code>.  <a href="../../d5/d27/classCxxUtils_1_1ArrayIteratorChooser.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d1b/classCxxUtils_1_1ArrayIteratorChooser_3_011_01_4.html">ArrayIteratorChooser&lt; 1 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for defining iterators over <code><a class="el" href="../../d5/dd9/classCxxUtils_1_1Array.html" title="Read-only multidimensional array. ">Array</a>'s</code>, specialized for <code>N</code> == 1.  <a href="../../d4/d1b/classCxxUtils_1_1ArrayIteratorChooser_3_011_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd9/classCxxUtils_1_1Array.html">Array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-only multidimensional array.  <a href="../../d5/dd9/classCxxUtils_1_1Array.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d88/classCxxUtils_1_1Array_3_010_01_4.html">Array&lt; 0 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-only multidimensional array, specialized for <code>N=0</code>.  <a href="../../df/d88/classCxxUtils_1_1Array_3_010_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dcc/classCxxUtils_1_1WritableArray.html">WritableArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-write multidimensional array.  <a href="../../dc/dcc/classCxxUtils_1_1WritableArray.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da2/classCxxUtils_1_1WritableArray_3_010_01_4.html">WritableArray&lt; 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd4/classCxxUtils_1_1WritableArrayData.html">WritableArrayData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dac/classCxxUtils_1_1ArrayScanner.html">ArrayScanner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for converting strings to <a class="el" href="../../d5/dd9/classCxxUtils_1_1Array.html" title="Read-only multidimensional array. ">Array</a>'s.  <a href="../../df/dac/classCxxUtils_1_1ArrayScanner.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d3c/classCxxUtils_1_1BitPacker.html">BitPacker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack a set of values bitwise into a stream.  <a href="../../d5/d3c/classCxxUtils_1_1BitPacker.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dd9/classCxxUtils_1_1BitPacker8.html">BitPacker8</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack a set of values bitwise into a stream.  <a href="../../d8/dd9/classCxxUtils_1_1BitPacker8.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d5c/classCxxUtils_1_1BitPacker16.html">BitPacker16</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack a set of values bitwise into a stream.  <a href="../../d7/d5c/classCxxUtils_1_1BitPacker16.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d06/classCxxUtils_1_1BitUnpacker.html">BitUnpacker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to unpack a set of values bitwise from a stream.  <a href="../../d4/d06/classCxxUtils_1_1BitUnpacker.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dac/classCxxUtils_1_1BitUnpacker8.html">BitUnpacker8</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to unpack a set of values bitwise from a stream.  <a href="../../d8/dac/classCxxUtils_1_1BitUnpacker8.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dbe/classCxxUtils_1_1BitUnpacker16.html">BitUnpacker16</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to unpack a set of values bitwise from a stream.  <a href="../../d3/dbe/classCxxUtils_1_1BitUnpacker16.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/df5/classCxxUtils_1_1ClassName.html">ClassName</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively separate out template arguments in a C++ class name.  <a href="../../d2/df5/classCxxUtils_1_1ClassName.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d8c/structCxxUtils_1_1enable__if.html">enable_if</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a member typedef <code>type</code> only if a boolean constant is true.  <a href="../../d9/d8c/structCxxUtils_1_1enable__if.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d83/structCxxUtils_1_1enable__if_3_01true_00_01__Tp_01_4.html">enable_if&lt; true, _Tp &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/df0/classCxxUtils_1_1FloatPacker.html">FloatPacker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack/unpack floating-point data from/to a given number of bits.  <a href="../../da/df0/classCxxUtils_1_1FloatPacker.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dad/classCxxUtils_1_1PackedArray.html">PackedArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An array of unsigned values of some bit size, packed tightly.  <a href="../../d2/dad/classCxxUtils_1_1PackedArray.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d6f/classCxxUtils_1_1pointer__list__base.html">pointer_list_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fast way to store a variable-sized collection of pointers.  <a href="../../d1/d6f/classCxxUtils_1_1pointer__list__base.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d88/classCxxUtils_1_1pointer__list.html">pointer_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fast way to store a variable-sized collection of pointers.  <a href="../../d1/d88/classCxxUtils_1_1pointer__list.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d12/structCxxUtils_1_1sincos.html">sincos</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to simultaneously calculate sin and cos of the same angle.  <a href="../../d4/d12/structCxxUtils_1_1sincos.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d5e/structCxxUtils_1_1extrace__init.html">extrace_init</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a1495f9141a6860a45e9526a4eead7b07"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>CacheLineSize</b> = 64
 }</td></tr>
<tr class="separator:a1495f9141a6860a45e9526a4eead7b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4347a1b9c8e9aefad91888115f8c74a5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4347a1b9c8e9aefad91888115f8c74a5"></a>
template&lt;typename InputIterator , typename OutputIterator , typename Predicate &gt; </td></tr>
<tr class="memitem:a4347a1b9c8e9aefad91888115f8c74a5"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy_if</b> (InputIterator first, InputIterator last, OutputIterator result, Predicate pred)</td></tr>
<tr class="separator:a4347a1b9c8e9aefad91888115f8c74a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add65fdbdada73645899cd4201fbe77a3"><td class="memTemplParams" colspan="2"><a class="anchor" id="add65fdbdada73645899cd4201fbe77a3"></a>
template&lt;class InputIterator , class OutputIterator , class InputTag , class OutputTag &gt; </td></tr>
<tr class="memitem:add65fdbdada73645899cd4201fbe77a3"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d12/namespaceCxxUtils.html#add65fdbdada73645899cd4201fbe77a3">copy_bounded1</a> (InputIterator begi, InputIterator endi, OutputIterator bego, OutputIterator endo, const InputTag &amp;, const OutputTag &amp;)</td></tr>
<tr class="memdesc:add65fdbdada73645899cd4201fbe77a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a range with bounds restriction; generic version. <br/></td></tr>
<tr class="separator:add65fdbdada73645899cd4201fbe77a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea0213de4afc73ab40d841fd9d2534c3"><td class="memTemplParams" colspan="2"><a class="anchor" id="aea0213de4afc73ab40d841fd9d2534c3"></a>
template&lt;class InputIterator , class OutputIterator &gt; </td></tr>
<tr class="memitem:aea0213de4afc73ab40d841fd9d2534c3"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d12/namespaceCxxUtils.html#aea0213de4afc73ab40d841fd9d2534c3">copy_bounded1</a> (InputIterator begi, InputIterator endi, OutputIterator bego, OutputIterator endo, const std::random_access_iterator_tag &amp;, const std::random_access_iterator_tag &amp;)</td></tr>
<tr class="memdesc:aea0213de4afc73ab40d841fd9d2534c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a range with bounds restriction; random_access_iterator version. <br/></td></tr>
<tr class="separator:aea0213de4afc73ab40d841fd9d2534c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac91108ca126094dacf3d666952544c2b"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class OutputIterator &gt; </td></tr>
<tr class="memitem:ac91108ca126094dacf3d666952544c2b"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d12/namespaceCxxUtils.html#ac91108ca126094dacf3d666952544c2b">copy_bounded</a> (InputIterator begi, InputIterator endi, OutputIterator bego, OutputIterator endo)</td></tr>
<tr class="memdesc:ac91108ca126094dacf3d666952544c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a range with bounds restriction.  <a href="#ac91108ca126094dacf3d666952544c2b">More...</a><br/></td></tr>
<tr class="separator:ac91108ca126094dacf3d666952544c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae12800acaf11126ad57f91aef4a77c"><td class="memTemplParams" colspan="2">template&lt;class InputRange , class OutputRange &gt; </td></tr>
<tr class="memitem:aaae12800acaf11126ad57f91aef4a77c"><td class="memTemplItemLeft" align="right" valign="top">boost::range_iterator<br class="typebreak"/>
&lt; OutputRange &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d12/namespaceCxxUtils.html#aaae12800acaf11126ad57f91aef4a77c">copy_bounded</a> (const InputRange &amp;input, OutputRange &amp;output)</td></tr>
<tr class="memdesc:aaae12800acaf11126ad57f91aef4a77c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a range with bounds restriction.  <a href="#aaae12800acaf11126ad57f91aef4a77c">More...</a><br/></td></tr>
<tr class="separator:aaae12800acaf11126ad57f91aef4a77c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b199b3c90529fef9ea3d0b89d9eeca0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d12/namespaceCxxUtils.html#a1b199b3c90529fef9ea3d0b89d9eeca0">exctrace</a> (const std::exception &amp;e, <a class="el" href="../../d1/dc7/SealCommon_8h.html#a98d936fe848403f33ff9cebfc9a38597">IOFD</a> fd=<a class="el" href="../../d1/dc7/SealCommon_8h.html#a066e390969fb367df2540beba5bff9ca">IOFD_INVALID</a>)</td></tr>
<tr class="memdesc:a1b199b3c90529fef9ea3d0b89d9eeca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print out information for the last exception.  <a href="#a1b199b3c90529fef9ea3d0b89d9eeca0">More...</a><br/></td></tr>
<tr class="separator:a1b199b3c90529fef9ea3d0b89d9eeca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4844555208815b79fdbdc3ea86173ecf"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4844555208815b79fdbdc3ea86173ecf"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a4844555208815b79fdbdc3ea86173ecf"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d12/namespaceCxxUtils.html#a4844555208815b79fdbdc3ea86173ecf">ones</a> (unsigned int n)</td></tr>
<tr class="memdesc:a4844555208815b79fdbdc3ea86173ecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a bit mask with the lower <em>n</em> bits set. <br/></td></tr>
<tr class="separator:a4844555208815b79fdbdc3ea86173ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc11f0c6320559e2a85f8dfabc4ab35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d12/namespaceCxxUtils.html#abfc11f0c6320559e2a85f8dfabc4ab35">prefetchOne</a> (const void *address)</td></tr>
<tr class="memdesc:abfc11f0c6320559e2a85f8dfabc4ab35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic prefetch method.  <a href="#abfc11f0c6320559e2a85f8dfabc4ab35">More...</a><br/></td></tr>
<tr class="separator:abfc11f0c6320559e2a85f8dfabc4ab35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860e40c061a0db6dfaa1551e5b9f2187"><td class="memTemplParams" colspan="2">template&lt;size_t N&gt; </td></tr>
<tr class="memitem:a860e40c061a0db6dfaa1551e5b9f2187"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d12/namespaceCxxUtils.html#a860e40c061a0db6dfaa1551e5b9f2187">prefetchN</a> (const void *ptr)</td></tr>
<tr class="memdesc:a860e40c061a0db6dfaa1551e5b9f2187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefetch an N-byte block of memory.  <a href="#a860e40c061a0db6dfaa1551e5b9f2187">More...</a><br/></td></tr>
<tr class="separator:a860e40c061a0db6dfaa1551e5b9f2187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af718c90d783cc22477ffa47f40ec79dd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af718c90d783cc22477ffa47f40ec79dd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d12/namespaceCxxUtils.html#af718c90d783cc22477ffa47f40ec79dd">prefetchObj</a> (const T *ptr)</td></tr>
<tr class="memdesc:af718c90d783cc22477ffa47f40ec79dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic prefetch of the object of specific types (sizes).  <a href="#af718c90d783cc22477ffa47f40ec79dd">More...</a><br/></td></tr>
<tr class="separator:af718c90d783cc22477ffa47f40ec79dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3533852645f9b06ad5bb3ced347e617f"><td class="memTemplParams" colspan="2">template&lt;typename Iter &gt; </td></tr>
<tr class="memitem:a3533852645f9b06ad5bb3ced347e617f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d12/namespaceCxxUtils.html#a3533852645f9b06ad5bb3ced347e617f">prefetchNext</a> (Iter iter, Iter endIter)</td></tr>
<tr class="memdesc:a3533852645f9b06ad5bb3ced347e617f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefetch next object in sequence.  <a href="#a3533852645f9b06ad5bb3ced347e617f">More...</a><br/></td></tr>
<tr class="separator:a3533852645f9b06ad5bb3ced347e617f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a447b387e929ffab2f13937b42dd32"><td class="memTemplParams" colspan="2">template&lt;typename Iter &gt; </td></tr>
<tr class="memitem:ae7a447b387e929ffab2f13937b42dd32"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d12/namespaceCxxUtils.html#ae7a447b387e929ffab2f13937b42dd32">prefetchTwo</a> (Iter iter, Iter endIter)</td></tr>
<tr class="memdesc:ae7a447b387e929ffab2f13937b42dd32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefetch two objects.  <a href="#ae7a447b387e929ffab2f13937b42dd32">More...</a><br/></td></tr>
<tr class="separator:ae7a447b387e929ffab2f13937b42dd32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20e9ea3bf1e4593c7e9e4fe952edc452"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a20e9ea3bf1e4593c7e9e4fe952edc452"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d12/namespaceCxxUtils.html#a20e9ea3bf1e4593c7e9e4fe952edc452">strformat</a> (const char *fmt,...)</td></tr>
<tr class="memdesc:a20e9ea3bf1e4593c7e9e4fe952edc452"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a <code>std::string</code> according to a format <code>fmt</code> and varargs <br/></td></tr>
<tr class="separator:a20e9ea3bf1e4593c7e9e4fe952edc452"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Copy the elements of a sequence for which a predicate is true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">result</td><td>An output iterator. </td></tr>
    <tr><td class="paramname">pred</td><td>A predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>Copies each element in the range <code></code>[first,last) for which <code>pred</code> returns true to the range beginning at <code>result</code>.</p>
<p>copy_if() is stable, so the relative order of elements that are copied is unchanged.</p>
<p><em>Example</em>: </p>
<div class="fragment"><div class="line">*  CxxUtils::copy_if( in.begin(), in.end(),</div>
<div class="line">*                     std::back_inserter(out), filter );</div>
<div class="line">*  </div>
</div><!-- fragment --><p> where in and out are STL-like containers and filter is a predicate </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a1495f9141a6860a45e9526a4eead7b07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>While it is possible to determine cache line size at run time (e.g. using sysconf(_SC_LEVEL1_DCACHE_LINESIZE) on Linux or sysctlbyname("hw.cachelinesize", ...) on Apple systems) that approach creates more problems: the location that stores cache line size will probably be out of cache when one needs to know it. This is why we use a compile time constant for cache line size. Cache line size is 64 for the current generation of Intel/AMD CPUs.</p>
<p>If an object spans multiple cache lines then prefetching whole object should be done by prefetching at least one address from each of the cache lines that object occupies. How many lines are needed depends on three things: object size, cache line size, and object starting address. If CacheLineSize is lower than the actual line size then more prefetches than necessary will be generated (2, 4, or more per cache line if cache line size is power of 2). This may be somewhat wasteful so this number may need to be adjusted in the far future when <em>all</em> CPUs have wider cache lines. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ac91108ca126094dacf3d666952544c2b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator CxxUtils::copy_bounded </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>begi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>endi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>bego</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>endo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy a range with bounds restriction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begi</td><td>Start of input range. </td></tr>
    <tr><td class="paramname">endi</td><td>End of input range. </td></tr>
    <tr><td class="paramname">bego</td><td>Start of output range. </td></tr>
    <tr><td class="paramname">endo</td><td>End of output range.</td></tr>
  </table>
  </dd>
</dl>
<p>Like std::copy(begi, endi, bego), except that it will not copy more than std::distance(bego, endo) elements.</p>
<p>Copies exactly n = std::min (std::distance(begi,endi), std::distance(bego,endo)) elements. Returns bego + n. </p>

</div>
</div>
<a class="anchor" id="aaae12800acaf11126ad57f91aef4a77c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputRange , class OutputRange &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::range_iterator&lt;OutputRange&gt;::type CxxUtils::copy_bounded </td>
          <td>(</td>
          <td class="paramtype">const InputRange &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputRange &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy a range with bounds restriction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Input range </td></tr>
    <tr><td class="paramname">output</td><td>Output range</td></tr>
  </table>
  </dd>
</dl>
<p>copy_bounded written in terms of iterator ranges. </p>

</div>
</div>
<a class="anchor" id="a1b199b3c90529fef9ea3d0b89d9eeca0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CxxUtils::exctrace </td>
          <td>(</td>
          <td class="paramtype">const std::exception &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d1/dc7/SealCommon_8h.html#a98d936fe848403f33ff9cebfc9a38597">IOFD</a>&#160;</td>
          <td class="paramname"><em>fd</em> = <code><a class="el" href="../../d1/dc7/SealCommon_8h.html#a066e390969fb367df2540beba5bff9ca">IOFD_INVALID</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print out information for the last exception. </p>
<p>Prints the supplied exception, plus the backtrace from the last exception, if available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The exception to print. </td></tr>
    <tr><td class="paramname">fd</td><td>The file descriptor to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a860e40c061a0db6dfaa1551e5b9f2187"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CxxUtils::prefetchN </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prefetch an N-byte block of memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>Starting address of the block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3533852645f9b06ad5bb3ced347e617f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CxxUtils::prefetchNext </td>
          <td>(</td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>endIter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prefetch next object in sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>Current iteration position. </td></tr>
    <tr><td class="paramname">endIter</td><td>End of the sequence.</td></tr>
  </table>
  </dd>
</dl>
<p><code>Iter</code> is a <code>ForwardIterator</code> over pointers.</p>
<p>Prefetches next object in a collection of pointers. Accepts two iterators: the first iterator is the current iteration position, and the second iterator is the end iterator for the whole sequence. The first iterator must not be equal to the end iterator (this is not checked). This increments the iterator and, if not equal to the end, prefetches the complete object referenced by the pointer. </p>

</div>
</div>
<a class="anchor" id="af718c90d783cc22477ffa47f40ec79dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CxxUtils::prefetchObj </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic prefetch of the object of specific types (sizes). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>memory location to prefetch</td></tr>
  </table>
  </dd>
</dl>
<p>This method will prefetch as many cache lines as needed to store the object of the specified type in memory. Type is specified as a template argument. </p>

</div>
</div>
<a class="anchor" id="abfc11f0c6320559e2a85f8dfabc4ab35"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CxxUtils::prefetchOne </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic prefetch method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>memory location to prefetch</td></tr>
  </table>
  </dd>
</dl>
<p>This is generic method that does not have any extra behavior. It only prefetches the whole cache line which contains the specified memory location. It does not incur any additional overhead and may be the most efficient method for small objects which have a high chance of being on just a single cache line. </p>

</div>
</div>
<a class="anchor" id="ae7a447b387e929ffab2f13937b42dd32"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CxxUtils::prefetchTwo </td>
          <td>(</td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>endIter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prefetch two objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>Current iteration position. </td></tr>
    <tr><td class="paramname">endIter</td><td>End of the sequence.</td></tr>
  </table>
  </dd>
</dl>
<p><code>Iter</code> is a <code>ForwardIterator</code> over pointers.</p>
<p>Prefetches the current and next objects in a collection of pointers. Accepts two iterators: the first iterator is the current iteration position, and the second is the end iterator for the whole sequence. If the first iterator is not equal to end the iterator, the object to which it points is prefetched. Then the iterator is incremented and, if not equal to the end iterator, the next objects is also prefetched. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Dec 1 2017 11:08:52 for RootCore Packages by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
