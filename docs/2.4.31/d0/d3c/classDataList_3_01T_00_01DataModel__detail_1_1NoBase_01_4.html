<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>RootCore Packages: DataList&lt; T, DataModel_detail::NoBase &gt; Class Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">RootCore Packages
   &#160;<span id="projectnumber">2.4.31</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="../../classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="../../hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="../../functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="../../da/dd0/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DataList&lt; T, DataModel_detail::NoBase &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Base specialization for <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a>&lt;T&gt;</code>.  
 <a href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d1/d43/DataList_8h_source.html">DataList.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a4fb145fade4da0f72c0c518b4bb2b66f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4fb145fade4da0f72c0c518b4bb2b66f"></a>
typedef <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a>&#160;</td><td class="memItemRight" valign="bottom"><b>DataList_BASE</b></td></tr>
<tr class="separator:a4fb145fade4da0f72c0c518b4bb2b66f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da50ef8a9f78390888589f37b8baf83"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9da50ef8a9f78390888589f37b8baf83"></a>
typedef <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a>&#160;</td><td class="memItemRight" valign="bottom"><b>DVL_BASE</b></td></tr>
<tr class="separator:a9da50ef8a9f78390888589f37b8baf83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f7baf956209ef4cfcff4a68887a392"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac4f7baf956209ef4cfcff4a68887a392"></a>
typedef boost::true_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#ac4f7baf956209ef4cfcff4a68887a392">isSequence</a></td></tr>
<tr class="memdesc:ac4f7baf956209ef4cfcff4a68887a392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark as a sequence, for <a class="el" href="../../da/da2/classDataLink.html" title="DataLink implementation for ROOT usage. ">DataLink</a> / <a class="el" href="../../d6/d6e/classElementLink.html" title="ElementLink implementation for ROOT usage. ">ElementLink</a>. <br/></td></tr>
<tr class="separator:ac4f7baf956209ef4cfcff4a68887a392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd17c4641bc563342e90f0cacb64af97"><td class="memItemLeft" align="right" valign="top">typedef std::list&lt; T * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#abd17c4641bc563342e90f0cacb64af97">PtrList</a></td></tr>
<tr class="separator:abd17c4641bc563342e90f0cacb64af97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e706f302d8a41bce617916b547ea097"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e706f302d8a41bce617916b547ea097"></a>
typedef std::list&lt; T * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>BaseContainer</b></td></tr>
<tr class="separator:a5e706f302d8a41bce617916b547ea097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35cedee549ab02f8d911d53f558cefc7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35cedee549ab02f8d911d53f558cefc7"></a>
typedef T *&amp;&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b></td></tr>
<tr class="separator:a35cedee549ab02f8d911d53f558cefc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8fc5266f26e44d17d817367fa2ef29e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac8fc5266f26e44d17d817367fa2ef29e"></a>
typedef T *const &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b></td></tr>
<tr class="separator:ac8fc5266f26e44d17d817367fa2ef29e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5512d5dc3a73c22ec3beb3e35a0da4f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5512d5dc3a73c22ec3beb3e35a0da4f"></a>
typedef PtrList::size_type&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr class="separator:af5512d5dc3a73c22ec3beb3e35a0da4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a305f3ded130e83133289deea8c5cf144"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a305f3ded130e83133289deea8c5cf144"></a>
typedef PtrList::difference_type&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b></td></tr>
<tr class="separator:a305f3ded130e83133289deea8c5cf144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5944bbd9a25246126c4de4f2e22ac2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd5944bbd9a25246126c4de4f2e22ac2"></a>
typedef T *&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>
<tr class="separator:afd5944bbd9a25246126c4de4f2e22ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc453046748092e6fc4916a502294c17"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc453046748092e6fc4916a502294c17"></a>
typedef PtrList::allocator_type&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b></td></tr>
<tr class="separator:afc453046748092e6fc4916a502294c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcbacb6f844432bd4a56d2a0b368f18b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adcbacb6f844432bd4a56d2a0b368f18b"></a>
typedef T **&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b></td></tr>
<tr class="separator:adcbacb6f844432bd4a56d2a0b368f18b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8869b07738694f2afeffdfa6051efc65"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8869b07738694f2afeffdfa6051efc65"></a>
typedef T *const *&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b></td></tr>
<tr class="separator:a8869b07738694f2afeffdfa6051efc65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c7795fd259107d07d7efe6d53a038d3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c7795fd259107d07d7efe6d53a038d3"></a>
typedef const T *&#160;</td><td class="memItemRight" valign="bottom"><b>const_value_type</b></td></tr>
<tr class="separator:a4c7795fd259107d07d7efe6d53a038d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4d44e14e15d8c836d3af43e45cae85"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a2b4d44e14e15d8c836d3af43e45cae85">base_value_type</a></td></tr>
<tr class="separator:a2b4d44e14e15d8c836d3af43e45cae85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a43f3105d5ac0011046690b54cbefdf"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="../../d7/d05/classDataModel__detail_1_1ElementProxy.html">DataModel_detail::ElementProxy</a><br class="typebreak"/>
&lt; <a class="el" href="../../d9/dfb/classDataList.html">DataList</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a7a43f3105d5ac0011046690b54cbefdf">ElementProxy</a></td></tr>
<tr class="separator:a7a43f3105d5ac0011046690b54cbefdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b4ed8201c8530d85d7155410f5178e0"><td class="memItemLeft" align="right" valign="top">typedef PtrList::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a9b4ed8201c8530d85d7155410f5178e0">const_iterator</a></td></tr>
<tr class="separator:a9b4ed8201c8530d85d7155410f5178e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2005081b262f1e63a17d7ccc0615249d"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">DataModel_detail::iterator</a><br class="typebreak"/>
&lt; <a class="el" href="../../d9/dfb/classDataList.html">DataList</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a2005081b262f1e63a17d7ccc0615249d">iterator</a></td></tr>
<tr class="separator:a2005081b262f1e63a17d7ccc0615249d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a835adbeac6f6308e227b0ebbb601d40e"><td class="memItemLeft" align="right" valign="top">typedef std::reverse_iterator<br class="typebreak"/>
&lt; <a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a9b4ed8201c8530d85d7155410f5178e0">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a835adbeac6f6308e227b0ebbb601d40e">const_reverse_iterator</a></td></tr>
<tr class="separator:a835adbeac6f6308e227b0ebbb601d40e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add2a33702a069332966fb7369c33da52"><td class="memItemLeft" align="right" valign="top">typedef std::reverse_iterator<br class="typebreak"/>
&lt; <a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a2005081b262f1e63a17d7ccc0615249d">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#add2a33702a069332966fb7369c33da52">reverse_iterator</a></td></tr>
<tr class="separator:add2a33702a069332966fb7369c33da52"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors, destructors, assignment.</div></td></tr>
<tr class="memitem:a27604fb39d04f165c5ca6fdeae58b15f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a27604fb39d04f165c5ca6fdeae58b15f">DataList</a> (<a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">SG::OwnershipPolicy</a> <a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a835da5f372ef8a7d7054e8bea85c91b6">ownPolicy</a>=<a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8a1f65f0fb55784cfd27d9d4d6d7986d4d">SG::OWN_ELEMENTS</a>)</td></tr>
<tr class="memdesc:a27604fb39d04f165c5ca6fdeae58b15f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a27604fb39d04f165c5ca6fdeae58b15f">More...</a><br/></td></tr>
<tr class="separator:a27604fb39d04f165c5ca6fdeae58b15f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28dd8a67308d8cf2257eade0d1111e3b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a28dd8a67308d8cf2257eade0d1111e3b">DataList</a> (size_type n, <a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">SG::OwnershipPolicy</a> <a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a835da5f372ef8a7d7054e8bea85c91b6">ownPolicy</a>=<a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8a1f65f0fb55784cfd27d9d4d6d7986d4d">SG::OWN_ELEMENTS</a>)</td></tr>
<tr class="memdesc:a28dd8a67308d8cf2257eade0d1111e3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sized constructor.  <a href="#a28dd8a67308d8cf2257eade0d1111e3b">More...</a><br/></td></tr>
<tr class="separator:a28dd8a67308d8cf2257eade0d1111e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a897b471d93ba7a5d3863f028e65f5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#af0a897b471d93ba7a5d3863f028e65f5">DataList</a> (const <a class="el" href="../../d9/dfb/classDataList.html">DataList</a> &amp;rhs)</td></tr>
<tr class="memdesc:af0a897b471d93ba7a5d3863f028e65f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#af0a897b471d93ba7a5d3863f028e65f5">More...</a><br/></td></tr>
<tr class="separator:af0a897b471d93ba7a5d3863f028e65f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29b9fa5e2a9f1eae10654c17fe583a30"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:a29b9fa5e2a9f1eae10654c17fe583a30"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a29b9fa5e2a9f1eae10654c17fe583a30">DataList</a> (InputIterator first, InputIterator last, <a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">SG::OwnershipPolicy</a> <a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a835da5f372ef8a7d7054e8bea85c91b6">ownPolicy</a>=<a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8ad7d4cf2303700f0966e4140f236c4bf1">SG::VIEW_ELEMENTS</a>)</td></tr>
<tr class="memdesc:a29b9fa5e2a9f1eae10654c17fe583a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from iterators.  <a href="#a29b9fa5e2a9f1eae10654c17fe583a30">More...</a><br/></td></tr>
<tr class="separator:a29b9fa5e2a9f1eae10654c17fe583a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a098ae1daf011dd3037d2ac50bc618bfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dfb/classDataList.html">DataList</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a098ae1daf011dd3037d2ac50bc618bfc">operator=</a> (const <a class="el" href="../../d9/dfb/classDataList.html">DataList</a> &amp;rhs)</td></tr>
<tr class="memdesc:a098ae1daf011dd3037d2ac50bc618bfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="#a098ae1daf011dd3037d2ac50bc618bfc">More...</a><br/></td></tr>
<tr class="separator:a098ae1daf011dd3037d2ac50bc618bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbcddcf3f9486e277181db43c1cb1395"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:adbcddcf3f9486e277181db43c1cb1395"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#adbcddcf3f9486e277181db43c1cb1395">assign</a> (InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:adbcddcf3f9486e277181db43c1cb1395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign from iterators.  <a href="#adbcddcf3f9486e277181db43c1cb1395">More...</a><br/></td></tr>
<tr class="separator:adbcddcf3f9486e277181db43c1cb1395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9188108e3569f3e14b57134bdc011fc5"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a9188108e3569f3e14b57134bdc011fc5">~DataList</a> ()</td></tr>
<tr class="memdesc:a9188108e3569f3e14b57134bdc011fc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a9188108e3569f3e14b57134bdc011fc5">More...</a><br/></td></tr>
<tr class="separator:a9188108e3569f3e14b57134bdc011fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Size and capacity.</div></td></tr>
<tr class="memitem:a47eeeef94c243655cfa6995ad8f17d46"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47eeeef94c243655cfa6995ad8f17d46"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a47eeeef94c243655cfa6995ad8f17d46">size</a> () const </td></tr>
<tr class="memdesc:a47eeeef94c243655cfa6995ad8f17d46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the collection. <br/></td></tr>
<tr class="separator:a47eeeef94c243655cfa6995ad8f17d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7536225c8c9321ac4eec89bba451eef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7536225c8c9321ac4eec89bba451eef"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#ad7536225c8c9321ac4eec89bba451eef">max_size</a> () const </td></tr>
<tr class="memdesc:ad7536225c8c9321ac4eec89bba451eef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <code><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a47eeeef94c243655cfa6995ad8f17d46" title="Returns the number of elements in the collection. ">size()</a></code> of the largest possible collection. <br/></td></tr>
<tr class="separator:ad7536225c8c9321ac4eec89bba451eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49fdbcd60375b226b8272dca4d2fa43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#ab49fdbcd60375b226b8272dca4d2fa43">resize</a> (size_type sz)</td></tr>
<tr class="memdesc:ab49fdbcd60375b226b8272dca4d2fa43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the collection to the specified number of elements.  <a href="#ab49fdbcd60375b226b8272dca4d2fa43">More...</a><br/></td></tr>
<tr class="separator:ab49fdbcd60375b226b8272dca4d2fa43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db251354aa82da30e173170c4c9336d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0db251354aa82da30e173170c4c9336d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a0db251354aa82da30e173170c4c9336d">empty</a> () const </td></tr>
<tr class="memdesc:a0db251354aa82da30e173170c4c9336d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the collection is empty. <br/></td></tr>
<tr class="separator:a0db251354aa82da30e173170c4c9336d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Element access.</div></td></tr>
<tr class="memitem:a47921f2fe9b99ea2768c8353323dcb64"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a47921f2fe9b99ea2768c8353323dcb64">front</a> () const </td></tr>
<tr class="memdesc:a47921f2fe9b99ea2768c8353323dcb64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the first element in the collection as an rvalue.  <a href="#a47921f2fe9b99ea2768c8353323dcb64">More...</a><br/></td></tr>
<tr class="separator:a47921f2fe9b99ea2768c8353323dcb64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78fcb74e8810ee041560deb0fd0e5085"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a78fcb74e8810ee041560deb0fd0e5085">back</a> () const </td></tr>
<tr class="memdesc:a78fcb74e8810ee041560deb0fd0e5085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the last element in the collection as an rvalue.  <a href="#a78fcb74e8810ee041560deb0fd0e5085">More...</a><br/></td></tr>
<tr class="separator:a78fcb74e8810ee041560deb0fd0e5085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3933eb9f817615c290c4613218c776b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a7a43f3105d5ac0011046690b54cbefdf">ElementProxy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a3933eb9f817615c290c4613218c776b7">front</a> ()</td></tr>
<tr class="memdesc:a3933eb9f817615c290c4613218c776b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the first element in the collection as an lvalue.  <a href="#a3933eb9f817615c290c4613218c776b7">More...</a><br/></td></tr>
<tr class="separator:a3933eb9f817615c290c4613218c776b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac37d4ef9d3e17f774b15d65c80ef3956"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a7a43f3105d5ac0011046690b54cbefdf">ElementProxy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#ac37d4ef9d3e17f774b15d65c80ef3956">back</a> ()</td></tr>
<tr class="memdesc:ac37d4ef9d3e17f774b15d65c80ef3956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the last element in the collection as an lvalue.  <a href="#ac37d4ef9d3e17f774b15d65c80ef3956">More...</a><br/></td></tr>
<tr class="separator:ac37d4ef9d3e17f774b15d65c80ef3956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Iterator creation.</div></td></tr>
<tr class="memitem:a96cd0a1a4dfe935e939afc8a62394fe4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a9b4ed8201c8530d85d7155410f5178e0">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a96cd0a1a4dfe935e939afc8a62394fe4">begin</a> () const </td></tr>
<tr class="memdesc:a96cd0a1a4dfe935e939afc8a62394fe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <code>const_iterator</code> pointing at the beginning of the collection.  <a href="#a96cd0a1a4dfe935e939afc8a62394fe4">More...</a><br/></td></tr>
<tr class="separator:a96cd0a1a4dfe935e939afc8a62394fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ff31864f8bdda74e30255c6e578548"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a9b4ed8201c8530d85d7155410f5178e0">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a07ff31864f8bdda74e30255c6e578548">end</a> () const </td></tr>
<tr class="memdesc:a07ff31864f8bdda74e30255c6e578548"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <code>const_iterator</code> pointing past the end of the collection.  <a href="#a07ff31864f8bdda74e30255c6e578548">More...</a><br/></td></tr>
<tr class="separator:a07ff31864f8bdda74e30255c6e578548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f600a76301a2d3d14e482b9e2776cf2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a2005081b262f1e63a17d7ccc0615249d">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a1f600a76301a2d3d14e482b9e2776cf2">begin</a> ()</td></tr>
<tr class="memdesc:a1f600a76301a2d3d14e482b9e2776cf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an <code>iterator</code> pointing at the beginning of the collection.  <a href="#a1f600a76301a2d3d14e482b9e2776cf2">More...</a><br/></td></tr>
<tr class="separator:a1f600a76301a2d3d14e482b9e2776cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac68e2b55f65d97e88b866fb50218059d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a2005081b262f1e63a17d7ccc0615249d">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#ac68e2b55f65d97e88b866fb50218059d">end</a> ()</td></tr>
<tr class="memdesc:ac68e2b55f65d97e88b866fb50218059d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an <code>iterator</code> pointing past the end of the collection.  <a href="#ac68e2b55f65d97e88b866fb50218059d">More...</a><br/></td></tr>
<tr class="separator:ac68e2b55f65d97e88b866fb50218059d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00a3dad08bbd578054b202f4458a4c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a835adbeac6f6308e227b0ebbb601d40e">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#af00a3dad08bbd578054b202f4458a4c5">rbegin</a> () const </td></tr>
<tr class="memdesc:af00a3dad08bbd578054b202f4458a4c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <code>const_reverse_iterator</code> pointing past the end of the collection.  <a href="#af00a3dad08bbd578054b202f4458a4c5">More...</a><br/></td></tr>
<tr class="separator:af00a3dad08bbd578054b202f4458a4c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2912a56c75a78e3daba92d308c2bd09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a835adbeac6f6308e227b0ebbb601d40e">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#ae2912a56c75a78e3daba92d308c2bd09">rend</a> () const </td></tr>
<tr class="memdesc:ae2912a56c75a78e3daba92d308c2bd09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <code>const_reverse_iterator</code> pointing at the beginning of the collection.  <a href="#ae2912a56c75a78e3daba92d308c2bd09">More...</a><br/></td></tr>
<tr class="separator:ae2912a56c75a78e3daba92d308c2bd09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61dc30fc5a281edc891fc5646e8b39bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#add2a33702a069332966fb7369c33da52">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a61dc30fc5a281edc891fc5646e8b39bb">rbegin</a> ()</td></tr>
<tr class="memdesc:a61dc30fc5a281edc891fc5646e8b39bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <code>reverse_iterator</code> pointing past the end of the collection.  <a href="#a61dc30fc5a281edc891fc5646e8b39bb">More...</a><br/></td></tr>
<tr class="separator:a61dc30fc5a281edc891fc5646e8b39bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91706520fb2c75102299affef231541d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#add2a33702a069332966fb7369c33da52">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a91706520fb2c75102299affef231541d">rend</a> ()</td></tr>
<tr class="memdesc:a91706520fb2c75102299affef231541d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <code>reverse_iterator</code> pointing at the beginning of the collection.  <a href="#a91706520fb2c75102299affef231541d">More...</a><br/></td></tr>
<tr class="separator:a91706520fb2c75102299affef231541d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Insertion operations.</div></td></tr>
<tr class="memitem:ab09c229bdb18bf7c2e5385685ce15471"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#ab09c229bdb18bf7c2e5385685ce15471">push_front</a> (value_type pElem)</td></tr>
<tr class="memdesc:ab09c229bdb18bf7c2e5385685ce15471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an element at the beginning of the collection.  <a href="#ab09c229bdb18bf7c2e5385685ce15471">More...</a><br/></td></tr>
<tr class="separator:ab09c229bdb18bf7c2e5385685ce15471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeda608ccc6fac0ae29461df6cbf714a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#aeda608ccc6fac0ae29461df6cbf714a8">push_back</a> (value_type pElem)</td></tr>
<tr class="memdesc:aeda608ccc6fac0ae29461df6cbf714a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an element to the end of the collection.  <a href="#aeda608ccc6fac0ae29461df6cbf714a8">More...</a><br/></td></tr>
<tr class="separator:aeda608ccc6fac0ae29461df6cbf714a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02227e05459f68f7ae0ec287b7817729"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a2005081b262f1e63a17d7ccc0615249d">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a02227e05459f68f7ae0ec287b7817729">insert</a> (<a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a2005081b262f1e63a17d7ccc0615249d">iterator</a> position, value_type pElem)</td></tr>
<tr class="memdesc:a02227e05459f68f7ae0ec287b7817729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new element to the collection.  <a href="#a02227e05459f68f7ae0ec287b7817729">More...</a><br/></td></tr>
<tr class="separator:a02227e05459f68f7ae0ec287b7817729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4015fc80662b9271fba386779848ff0f"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:a4015fc80662b9271fba386779848ff0f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a4015fc80662b9271fba386779848ff0f">insert</a> (<a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a2005081b262f1e63a17d7ccc0615249d">iterator</a> position, InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:a4015fc80662b9271fba386779848ff0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a group of new elements to the collection.  <a href="#a4015fc80662b9271fba386779848ff0f">More...</a><br/></td></tr>
<tr class="separator:a4015fc80662b9271fba386779848ff0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Erasure operations.</div></td></tr>
<tr class="memitem:a0e87fb8184614c638940f4c2bc2ef823"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a2005081b262f1e63a17d7ccc0615249d">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a0e87fb8184614c638940f4c2bc2ef823">erase</a> (<a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a2005081b262f1e63a17d7ccc0615249d">iterator</a> position)</td></tr>
<tr class="memdesc:a0e87fb8184614c638940f4c2bc2ef823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove element at a given position.  <a href="#a0e87fb8184614c638940f4c2bc2ef823">More...</a><br/></td></tr>
<tr class="separator:a0e87fb8184614c638940f4c2bc2ef823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a210ba843db90aea8fd000b7fd0137d30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a2005081b262f1e63a17d7ccc0615249d">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a210ba843db90aea8fd000b7fd0137d30">erase</a> (<a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a2005081b262f1e63a17d7ccc0615249d">iterator</a> first, <a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a2005081b262f1e63a17d7ccc0615249d">iterator</a> last)</td></tr>
<tr class="memdesc:a210ba843db90aea8fd000b7fd0137d30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a range of elements.  <a href="#a210ba843db90aea8fd000b7fd0137d30">More...</a><br/></td></tr>
<tr class="separator:a210ba843db90aea8fd000b7fd0137d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63a46869c71bdec71e0294a6f72d8735"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a63a46869c71bdec71e0294a6f72d8735">pop_front</a> ()</td></tr>
<tr class="memdesc:a63a46869c71bdec71e0294a6f72d8735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the first element from the collection.  <a href="#a63a46869c71bdec71e0294a6f72d8735">More...</a><br/></td></tr>
<tr class="separator:a63a46869c71bdec71e0294a6f72d8735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa83393a907c793c2aa838fb6fa12aef3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#aa83393a907c793c2aa838fb6fa12aef3">pop_back</a> ()</td></tr>
<tr class="memdesc:aa83393a907c793c2aa838fb6fa12aef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the last element from the collection.  <a href="#aa83393a907c793c2aa838fb6fa12aef3">More...</a><br/></td></tr>
<tr class="separator:aa83393a907c793c2aa838fb6fa12aef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a651b5eb77fe0071bbe708dc18971c009"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a651b5eb77fe0071bbe708dc18971c009">clear</a> ()</td></tr>
<tr class="memdesc:a651b5eb77fe0071bbe708dc18971c009"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase all the elements in the collection.  <a href="#a651b5eb77fe0071bbe708dc18971c009">More...</a><br/></td></tr>
<tr class="separator:a651b5eb77fe0071bbe708dc18971c009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">List operations.</div></td></tr>
<tr class="memitem:a633c3ce289cbaf70eafcea4db83fcae3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a633c3ce289cbaf70eafcea4db83fcae3">splice</a> (<a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a2005081b262f1e63a17d7ccc0615249d">iterator</a> position, <a class="el" href="../../d9/dfb/classDataList.html">DataList</a> &amp;l)</td></tr>
<tr class="memdesc:a633c3ce289cbaf70eafcea4db83fcae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert contents of another list.  <a href="#a633c3ce289cbaf70eafcea4db83fcae3">More...</a><br/></td></tr>
<tr class="separator:a633c3ce289cbaf70eafcea4db83fcae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b434dbf244d93b44b46f6ff94a6d2f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a9b434dbf244d93b44b46f6ff94a6d2f2">splice</a> (<a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a2005081b262f1e63a17d7ccc0615249d">iterator</a> position, <a class="el" href="../../d9/dfb/classDataList.html">DataList</a> &amp;l, <a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a2005081b262f1e63a17d7ccc0615249d">iterator</a> i)</td></tr>
<tr class="memdesc:a9b434dbf244d93b44b46f6ff94a6d2f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert element from another list.  <a href="#a9b434dbf244d93b44b46f6ff94a6d2f2">More...</a><br/></td></tr>
<tr class="separator:a9b434dbf244d93b44b46f6ff94a6d2f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc339e17c39eb53440f0e8022b011db6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#abc339e17c39eb53440f0e8022b011db6">splice</a> (<a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a2005081b262f1e63a17d7ccc0615249d">iterator</a> position, <a class="el" href="../../d9/dfb/classDataList.html">DataList</a> &amp;l, <a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a2005081b262f1e63a17d7ccc0615249d">iterator</a> first, <a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a2005081b262f1e63a17d7ccc0615249d">iterator</a> last)</td></tr>
<tr class="memdesc:abc339e17c39eb53440f0e8022b011db6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert range from another list.  <a href="#abc339e17c39eb53440f0e8022b011db6">More...</a><br/></td></tr>
<tr class="separator:abc339e17c39eb53440f0e8022b011db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb755c1c808b9195aea714580a047f29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#adb755c1c808b9195aea714580a047f29">remove</a> (const value_type &amp;value)</td></tr>
<tr class="memdesc:adb755c1c808b9195aea714580a047f29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all elements equal to value.  <a href="#adb755c1c808b9195aea714580a047f29">More...</a><br/></td></tr>
<tr class="separator:adb755c1c808b9195aea714580a047f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c21080420c061eaeb098608ecaa10a0"><td class="memTemplParams" colspan="2">template&lt;typename PREDICATE &gt; </td></tr>
<tr class="memitem:a2c21080420c061eaeb098608ecaa10a0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a2c21080420c061eaeb098608ecaa10a0">remove_if</a> (PREDICATE p)</td></tr>
<tr class="memdesc:a2c21080420c061eaeb098608ecaa10a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all elements satisfying a predicate.  <a href="#a2c21080420c061eaeb098608ecaa10a0">More...</a><br/></td></tr>
<tr class="separator:a2c21080420c061eaeb098608ecaa10a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae940d6e63477383a918c1eaf834eb488"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#ae940d6e63477383a918c1eaf834eb488">unique</a> ()</td></tr>
<tr class="memdesc:ae940d6e63477383a918c1eaf834eb488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove consecutive duplicate elements.  <a href="#ae940d6e63477383a918c1eaf834eb488">More...</a><br/></td></tr>
<tr class="separator:ae940d6e63477383a918c1eaf834eb488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5bf6bc20d50017ebc802bd3b2ad524a"><td class="memTemplParams" colspan="2">template&lt;typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:af5bf6bc20d50017ebc802bd3b2ad524a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#af5bf6bc20d50017ebc802bd3b2ad524a">unique</a> (BinaryPredicate pred)</td></tr>
<tr class="memdesc:af5bf6bc20d50017ebc802bd3b2ad524a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove consecutive elements satisfying a predicate.  <a href="#af5bf6bc20d50017ebc802bd3b2ad524a">More...</a><br/></td></tr>
<tr class="separator:af5bf6bc20d50017ebc802bd3b2ad524a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381210b588a66c2161bef370b3106dc7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a381210b588a66c2161bef370b3106dc7">merge</a> (<a class="el" href="../../d9/dfb/classDataList.html">DataList</a> &amp;l)</td></tr>
<tr class="memdesc:a381210b588a66c2161bef370b3106dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge sorted lists.  <a href="#a381210b588a66c2161bef370b3106dc7">More...</a><br/></td></tr>
<tr class="separator:a381210b588a66c2161bef370b3106dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a337a97ee5630a21085eb434dea1a7035"><td class="memTemplParams" colspan="2">template&lt;typename COMPARE &gt; </td></tr>
<tr class="memitem:a337a97ee5630a21085eb434dea1a7035"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a337a97ee5630a21085eb434dea1a7035">merge</a> (<a class="el" href="../../d9/dfb/classDataList.html">DataList</a> &amp;l, COMPARE predicate)</td></tr>
<tr class="memdesc:a337a97ee5630a21085eb434dea1a7035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge sorted lists according to comparison function.  <a href="#a337a97ee5630a21085eb434dea1a7035">More...</a><br/></td></tr>
<tr class="separator:a337a97ee5630a21085eb434dea1a7035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a95df551a45b969628ca7cda2eda6d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a1a95df551a45b969628ca7cda2eda6d1">reverse</a> ()</td></tr>
<tr class="memdesc:a1a95df551a45b969628ca7cda2eda6d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse the elements in list.  <a href="#a1a95df551a45b969628ca7cda2eda6d1">More...</a><br/></td></tr>
<tr class="separator:a1a95df551a45b969628ca7cda2eda6d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a904290e6b3a3dc730b98b1866b160827"><td class="memItemLeft" align="right" valign="top">static const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a904290e6b3a3dc730b98b1866b160827">has_virtual</a> = false</td></tr>
<tr class="separator:a904290e6b3a3dc730b98b1866b160827"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Swap and sort.</h2></td></tr>
<tr class="memitem:a280aba4dcb670ce252bafb3b4902fba9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a280aba4dcb670ce252bafb3b4902fba9">swap</a> (<a class="el" href="../../d9/dfb/classDataList.html">DataList</a> &amp;rhs)</td></tr>
<tr class="memdesc:a280aba4dcb670ce252bafb3b4902fba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap this collection with another.  <a href="#a280aba4dcb670ce252bafb3b4902fba9">More...</a><br/></td></tr>
<tr class="separator:a280aba4dcb670ce252bafb3b4902fba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad707975872cf9e85f633a9829c916d15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#ad707975872cf9e85f633a9829c916d15">sort</a> ()</td></tr>
<tr class="memdesc:ad707975872cf9e85f633a9829c916d15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the container.  <a href="#ad707975872cf9e85f633a9829c916d15">More...</a><br/></td></tr>
<tr class="separator:ad707975872cf9e85f633a9829c916d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f85d62d62900304eb60d03550ae5d3"><td class="memTemplParams" colspan="2">template&lt;class COMPARE &gt; </td></tr>
<tr class="memitem:a95f85d62d62900304eb60d03550ae5d3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a95f85d62d62900304eb60d03550ae5d3">sort</a> (COMPARE comp)</td></tr>
<tr class="memdesc:a95f85d62d62900304eb60d03550ae5d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the container with a user-specified comparison operator.  <a href="#a95f85d62d62900304eb60d03550ae5d3">More...</a><br/></td></tr>
<tr class="separator:a95f85d62d62900304eb60d03550ae5d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad11d3b6dbf3f2dc4dddaa972377607ff"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#ad11d3b6dbf3f2dc4dddaa972377607ff">iter_swap</a> (<a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a2005081b262f1e63a17d7ccc0615249d">iterator</a> a, <a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a2005081b262f1e63a17d7ccc0615249d">iterator</a> b)</td></tr>
<tr class="memdesc:ad11d3b6dbf3f2dc4dddaa972377607ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the referents of two <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;. ">DataVector</a></code> iterators.  <a href="#ad11d3b6dbf3f2dc4dddaa972377607ff">More...</a><br/></td></tr>
<tr class="separator:ad11d3b6dbf3f2dc4dddaa972377607ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Non-standard operations.</h2></td></tr>
<tr class="memitem:ab7c31e2e55534c5724b20598db2324b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#ab7c31e2e55534c5724b20598db2324b8">swapElement</a> (<a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a2005081b262f1e63a17d7ccc0615249d">iterator</a> pos, value_type newElem, reference oldElem)</td></tr>
<tr class="memdesc:ab7c31e2e55534c5724b20598db2324b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap one element out of the container.  <a href="#ab7c31e2e55534c5724b20598db2324b8">More...</a><br/></td></tr>
<tr class="separator:ab7c31e2e55534c5724b20598db2324b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a637d00a090bf2fb52876227982ed2c3b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#abd17c4641bc563342e90f0cacb64af97">PtrList</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a637d00a090bf2fb52876227982ed2c3b">stdcont</a> () const </td></tr>
<tr class="memdesc:a637d00a090bf2fb52876227982ed2c3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the underlying <code>std::list</code> of the container.  <a href="#a637d00a090bf2fb52876227982ed2c3b">More...</a><br/></td></tr>
<tr class="separator:a637d00a090bf2fb52876227982ed2c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a835da5f372ef8a7d7054e8bea85c91b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a835da5f372ef8a7d7054e8bea85c91b6"></a>
<a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">SG::OwnershipPolicy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a835da5f372ef8a7d7054e8bea85c91b6">ownPolicy</a> () const </td></tr>
<tr class="memdesc:a835da5f372ef8a7d7054e8bea85c91b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the ownership policy setting for this container. <br/></td></tr>
<tr class="separator:a835da5f372ef8a7d7054e8bea85c91b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc7f61743b492152b434836640190583"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#afc7f61743b492152b434836640190583">clear</a> (<a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">SG::OwnershipPolicy</a> <a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a835da5f372ef8a7d7054e8bea85c91b6">ownPolicy</a>)</td></tr>
<tr class="memdesc:afc7f61743b492152b434836640190583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase all the elements in the collection, and reset the ownership mode.  <a href="#afc7f61743b492152b434836640190583">More...</a><br/></td></tr>
<tr class="separator:afc7f61743b492152b434836640190583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48e52dc31b3138ab558203889325917c"><td class="memItemLeft" align="right" valign="top">virtual const <br class="typebreak"/>
<a class="el" href="../../da/d8a/classDataModel__detail_1_1DVLInfoBase.html">DataModel_detail::DVLInfoBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a48e52dc31b3138ab558203889325917c">dvlinfo_v</a> () const </td></tr>
<tr class="memdesc:a48e52dc31b3138ab558203889325917c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the DV/DL info struct for this class.  <a href="#a48e52dc31b3138ab558203889325917c">More...</a><br/></td></tr>
<tr class="separator:a48e52dc31b3138ab558203889325917c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac854ab0e32699c904b79153ac25b3efa"><td class="memItemLeft" align="right" valign="top">static const <br class="typebreak"/>
<a class="el" href="../../da/d8a/classDataModel__detail_1_1DVLInfoBase.html">DataModel_detail::DVLInfoBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#ac854ab0e32699c904b79153ac25b3efa">dvlinfo</a> ()</td></tr>
<tr class="memdesc:ac854ab0e32699c904b79153ac25b3efa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the DV/DL info struct for this class.  <a href="#ac854ab0e32699c904b79153ac25b3efa">More...</a><br/></td></tr>
<tr class="separator:ac854ab0e32699c904b79153ac25b3efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Internal operations.</h2></td></tr>
<tr class="memitem:aa387b75132216aab1ab41e3ae44cc56f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa387b75132216aab1ab41e3ae44cc56f"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>DataModel_detail::ElementProxy&lt; DataList &gt;</b></td></tr>
<tr class="separator:aa387b75132216aab1ab41e3ae44cc56f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a803b456eae8c94a9cc000542421595b3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a803b456eae8c94a9cc000542421595b3"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>ConstDataList&lt; DataList &gt;</b></td></tr>
<tr class="separator:a803b456eae8c94a9cc000542421595b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1119a539ef95e66a83ed73e65ce4acb9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1119a539ef95e66a83ed73e65ce4acb9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>test2_assignelement1</b> ()</td></tr>
<tr class="separator:a1119a539ef95e66a83ed73e65ce4acb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58d4eab21e401f540614780a4bbe5c4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">SG::OwnershipPolicy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a58d4eab21e401f540614780a4bbe5c4f">m_ownPolicy</a></td></tr>
<tr class="separator:a58d4eab21e401f540614780a4bbe5c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adccdf67214a3ae7e0bf5c627f7773fb1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adccdf67214a3ae7e0bf5c627f7773fb1"></a>
<a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#abd17c4641bc563342e90f0cacb64af97">PtrList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#adccdf67214a3ae7e0bf5c627f7773fb1">m_pCont</a></td></tr>
<tr class="memdesc:adccdf67214a3ae7e0bf5c627f7773fb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This actually holds the elements. <br/></td></tr>
<tr class="separator:adccdf67214a3ae7e0bf5c627f7773fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9244ff2441f80e03469a43b412d9a69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#ac9244ff2441f80e03469a43b412d9a69">resortAux</a> (<a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a2005081b262f1e63a17d7ccc0615249d">iterator</a> beg, <a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a2005081b262f1e63a17d7ccc0615249d">iterator</a> <a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a07ff31864f8bdda74e30255c6e578548">end</a>)</td></tr>
<tr class="memdesc:ac9244ff2441f80e03469a43b412d9a69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset indices / reorder aux data after elements have been permuted.  <a href="#ac9244ff2441f80e03469a43b412d9a69">More...</a><br/></td></tr>
<tr class="separator:ac9244ff2441f80e03469a43b412d9a69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc13d32a48d8e181d1c4f444f9b63952"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#abc13d32a48d8e181d1c4f444f9b63952">testInsert</a> (const char *op)</td></tr>
<tr class="memdesc:abc13d32a48d8e181d1c4f444f9b63952"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if we can insert; raise an exception if not.  <a href="#abc13d32a48d8e181d1c4f444f9b63952">More...</a><br/></td></tr>
<tr class="separator:abc13d32a48d8e181d1c4f444f9b63952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e0b9dc2ba00a550bb6d228a454e4567"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a9e0b9dc2ba00a550bb6d228a454e4567">testInsertOol</a> (const char *op)</td></tr>
<tr class="memdesc:a9e0b9dc2ba00a550bb6d228a454e4567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if we can insert; raise an exception if not.  <a href="#a9e0b9dc2ba00a550bb6d228a454e4567">More...</a><br/></td></tr>
<tr class="separator:a9e0b9dc2ba00a550bb6d228a454e4567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a323a52a2cf1cf5531f1db34a01cea959"><td class="memItemLeft" align="right" valign="top">PtrList::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a323a52a2cf1cf5531f1db34a01cea959">erase_base</a> (typename PtrList::iterator position)</td></tr>
<tr class="memdesc:a323a52a2cf1cf5531f1db34a01cea959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for <code><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a0e87fb8184614c638940f4c2bc2ef823" title="Remove element at a given position. ">erase()</a></code>. Remove element at a given position.  <a href="#a323a52a2cf1cf5531f1db34a01cea959">More...</a><br/></td></tr>
<tr class="separator:a323a52a2cf1cf5531f1db34a01cea959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d3b26b1bfe8cd7fd5fbb6e539ca21d"><td class="memItemLeft" align="right" valign="top">PtrList::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#af6d3b26b1bfe8cd7fd5fbb6e539ca21d">erase_base</a> (typename PtrList::iterator first, typename PtrList::iterator last)</td></tr>
<tr class="memdesc:af6d3b26b1bfe8cd7fd5fbb6e539ca21d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for <code><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a0e87fb8184614c638940f4c2bc2ef823" title="Remove element at a given position. ">erase()</a></code>. Remove a range of elements.  <a href="#af6d3b26b1bfe8cd7fd5fbb6e539ca21d">More...</a><br/></td></tr>
<tr class="separator:af6d3b26b1bfe8cd7fd5fbb6e539ca21d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0868554e751e7a0601c5c66e40b2ed85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a0868554e751e7a0601c5c66e40b2ed85">clearMostDerived</a> ()</td></tr>
<tr class="memdesc:a0868554e751e7a0601c5c66e40b2ed85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear <code>m_isMostDerived</code> for this instance and for all bases.  <a href="#a0868554e751e7a0601c5c66e40b2ed85">More...</a><br/></td></tr>
<tr class="separator:a0868554e751e7a0601c5c66e40b2ed85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2abecca05cb11a4ddcc2bb2e1c5179ae"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a2abecca05cb11a4ddcc2bb2e1c5179ae">setMostDerived</a> ()</td></tr>
<tr class="memdesc:a2abecca05cb11a4ddcc2bb2e1c5179ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <code>m_isMostDerived</code> for this instance and clear it for all bases.  <a href="#a2abecca05cb11a4ddcc2bb2e1c5179ae">More...</a><br/></td></tr>
<tr class="separator:a2abecca05cb11a4ddcc2bb2e1c5179ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br/>
class DataList&lt; T, DataModel_detail::NoBase &gt;</h3>

<p>Base specialization for <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a>&lt;T&gt;</code>. </p>
<p>This is used for the case where <code>T</code> does not derive from other classes. This is the class which actually holds the list of pointers.</p>
<p>See the file comments for full details. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a2b4d44e14e15d8c836d3af43e45cae85"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::<a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a2b4d44e14e15d8c836d3af43e45cae85">base_value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <code>T</code> value used as the template parameter. Note that this is different from <code>value_type</code> (that's <code>T*</code>). </p>

</div>
</div>
<a class="anchor" id="a9b4ed8201c8530d85d7155410f5178e0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef PtrList::const_iterator <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::<a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a9b4ed8201c8530d85d7155410f5178e0">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Standard <code>const_iterator</code>. Here, we can just use the <code>std::list</code> iterator. </p>

</div>
</div>
<a class="anchor" id="a835adbeac6f6308e227b0ebbb601d40e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::reverse_iterator&lt;<a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a9b4ed8201c8530d85d7155410f5178e0">const_iterator</a>&gt; <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::<a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a835adbeac6f6308e227b0ebbb601d40e">const_reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Standard <code>const_reverse_iterator</code>. Note: we can't just use the underlying PtrList::const_reverse_iterator here; otherwise, const_reverse_iterator won't be convertable to reverse_iterator. </p>

</div>
</div>
<a class="anchor" id="a7a43f3105d5ac0011046690b54cbefdf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="../../d7/d05/classDataModel__detail_1_1ElementProxy.html">DataModel_detail::ElementProxy</a>&lt;<a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&gt; <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::<a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a7a43f3105d5ac0011046690b54cbefdf">ElementProxy</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This type is used to proxy lvalue accesses to <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code> elements, in order to handle ownership. </p>

</div>
</div>
<a class="anchor" id="a2005081b262f1e63a17d7ccc0615249d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">DataModel_detail::iterator</a>&lt;<a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&gt; <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::<a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a2005081b262f1e63a17d7ccc0615249d">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Standard <code>iterator</code>. Note that lvalue references here will yield an <code>ElementProxy</code>, not a <code>reference</code>. </p>

</div>
</div>
<a class="anchor" id="abd17c4641bc563342e90f0cacb64af97"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::list&lt;T*&gt; <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::<a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#abd17c4641bc563342e90f0cacb64af97">PtrList</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the type of the underlying <code>std::list</code> (what <code>stdcont</code> returns). </p>

</div>
</div>
<a class="anchor" id="add2a33702a069332966fb7369c33da52"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::reverse_iterator&lt;<a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a2005081b262f1e63a17d7ccc0615249d">iterator</a>&gt; <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::<a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#add2a33702a069332966fb7369c33da52">reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Standard <code>reverse_iterator</code>. Note that lvalue references here will yield an <code>ElementProxy</code>, not a <code>reference</code>. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a27604fb39d04f165c5ca6fdeae58b15f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::<a class="el" href="../../d9/dfb/classDataList.html">DataList</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">SG::OwnershipPolicy</a>&#160;</td>
          <td class="paramname"><em>ownPolicy</em> = <code><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8a1f65f0fb55784cfd27d9d4d6d7986d4d">SG::OWN_ELEMENTS</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ownPolicy</td><td>The ownership mode for the container.</td></tr>
  </table>
  </dd>
</dl>
<p>By default, a <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code> will own its elements. To avoid this, pass <code><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8ad7d4cf2303700f0966e4140f236c4bf1" title="this data object is a view, it does not own its elmts ">SG::VIEW_ELEMENTS</a></code> for <em>ownPolicy</em>. </p>

</div>
</div>
<a class="anchor" id="a28dd8a67308d8cf2257eade0d1111e3b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::<a class="el" href="../../d9/dfb/classDataList.html">DataList</a> </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">SG::OwnershipPolicy</a>&#160;</td>
          <td class="paramname"><em>ownPolicy</em> = <code><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8a1f65f0fb55784cfd27d9d4d6d7986d4d">SG::OWN_ELEMENTS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sized constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The size of the container. </td></tr>
    <tr><td class="paramname">ownPolicy</td><td>The ownership mode for the container.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that unlike the standard list constructor, you can't specify an initial value here. The container will be initialized with 0's.</p>
<p>By default, a <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code> will own its elements. To avoid this, pass <code><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8ad7d4cf2303700f0966e4140f236c4bf1" title="this data object is a view, it does not own its elmts ">SG::VIEW_ELEMENTS</a></code> for <em>ownPolicy</em>. </p>

</div>
</div>
<a class="anchor" id="af0a897b471d93ba7a5d3863f028e65f5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::<a class="el" href="../../d9/dfb/classDataList.html">DataList</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The container from which to copy.</td></tr>
  </table>
  </dd>
</dl>
<p>This is a `shallow' copy; the new container will not own its elements. </p>

</div>
</div>
<a class="anchor" id="a29b9fa5e2a9f1eae10654c17fe583a30"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::<a class="el" href="../../d9/dfb/classDataList.html">DataList</a> </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">SG::OwnershipPolicy</a>&#160;</td>
          <td class="paramname"><em>ownPolicy</em> = <code><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8ad7d4cf2303700f0966e4140f236c4bf1">SG::VIEW_ELEMENTS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor from iterators. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The start of the range to put in the new container. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the range to put in the new container. </td></tr>
    <tr><td class="paramname">ownPolicy</td><td>The ownership mode for the container.</td></tr>
  </table>
  </dd>
</dl>
<p>By default, a <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code> will own its elements (and take ownership of the pointers passed to this constructor). To avoid this, pass <code><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8ad7d4cf2303700f0966e4140f236c4bf1" title="this data object is a view, it does not own its elmts ">SG::VIEW_ELEMENTS</a></code> for <em>ownPolicy</em>. </p>

</div>
</div>
<a class="anchor" id="a9188108e3569f3e14b57134bdc011fc5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::~<a class="el" href="../../d9/dfb/classDataList.html">DataList</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>If this container owns its elements, the contained elements will be deleted as well. Before doing this, the destructor will scan for duplicate pointers (takes <img class="formulaInl" alt="$ n\log n $" src="../../form_0.png"/> time); duplicates are only destroyed once. Duplicates should, however, be considered an error; don't rely on this behavior. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="adbcddcf3f9486e277181db43c1cb1395"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign from iterators. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The start of the range to put in the container. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the range to put in the container.</td></tr>
  </table>
  </dd>
</dl>
<p>Any existing owned elements will be released. The <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code>'s ownership policy determines whether it will take ownership of the new elements. </p>

</div>
</div>
<a class="anchor" id="a78fcb74e8810ee041560deb0fd0e5085"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the last element in the collection as an rvalue. </p>
<dl class="section return"><dt>Returns</dt><dd>The last element in the collection.</dd></dl>
<p>No checking is done to ensure that the container is not empty. Note that we return a <code>const</code> <code>T*</code> rather than a reference. </p>

</div>
</div>
<a class="anchor" id="ac37d4ef9d3e17f774b15d65c80ef3956"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a7a43f3105d5ac0011046690b54cbefdf">ElementProxy</a> <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the last element in the collection as an lvalue. </p>
<dl class="section return"><dt>Returns</dt><dd>Proxy to the last element in the collection.</dd></dl>
<p>No checking is done to ensure that the container is not empty. Note that we return a proxy object rather than a reference; the proxy will handle deleting an owned element if it's assigned to. </p>

</div>
</div>
<a class="anchor" id="a96cd0a1a4dfe935e939afc8a62394fe4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a9b4ed8201c8530d85d7155410f5178e0">const_iterator</a> <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a <code>const_iterator</code> pointing at the beginning of the collection. </p>
<dl class="section return"><dt>Returns</dt><dd>A <code>const_iterator</code>.</dd></dl>
<p>Note that dereferencing the iterator will yield a <code>const</code> <code>T*</code> rather than a reference. </p>

</div>
</div>
<a class="anchor" id="a1f600a76301a2d3d14e482b9e2776cf2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a2005081b262f1e63a17d7ccc0615249d">iterator</a> <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an <code>iterator</code> pointing at the beginning of the collection. </p>
<dl class="section return"><dt>Returns</dt><dd>An <code>iterator</code>.</dd></dl>
<p>Note that dereferencing the iterator will yield a proxy rather than a reference; the proxy will handle deleting an owned element if it's assigned to. </p>

</div>
</div>
<a class="anchor" id="a651b5eb77fe0071bbe708dc18971c009"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase all the elements in the collection. </p>
<p>If the container owns its elements, then the removed elements will be deleted. Any duplicates will be removed in this process, but don't rely on this. </p>

</div>
</div>
<a class="anchor" id="afc7f61743b492152b434836640190583"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">SG::OwnershipPolicy</a>&#160;</td>
          <td class="paramname"><em>ownPolicy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase all the elements in the collection, and reset the ownership mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ownPolicy</td><td>The new ownership policy of the container.</td></tr>
  </table>
  </dd>
</dl>
<p>If the container owns its elements, then the removed elements will be deleted. Any duplicates will be removed in this process, but don't rely on this. </p>

</div>
</div>
<a class="anchor" id="a0868554e751e7a0601c5c66e40b2ed85"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::clearMostDerived </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear <code>m_isMostDerived</code> for this instance and for all bases. </p>
<p>Called from the constructor after setting <code>m_isMostDerived</code>. </p>

</div>
</div>
<a class="anchor" id="ac854ab0e32699c904b79153ac25b3efa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="../../da/d8a/classDataModel__detail_1_1DVLInfoBase.html">DataModel_detail::DVLInfoBase</a>&amp; <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::dvlinfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the DV/DL info struct for this class. </p>
<p>This can be used to make sure that it's instantiated. </p>

</div>
</div>
<a class="anchor" id="a48e52dc31b3138ab558203889325917c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="../../da/d8a/classDataModel__detail_1_1DVLInfoBase.html">DataModel_detail::DVLInfoBase</a>&amp; <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::dvlinfo_v </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the DV/DL info struct for this class. </p>
<p>This can be used to make sure that it's instantiated. </p>

</div>
</div>
<a class="anchor" id="a07ff31864f8bdda74e30255c6e578548"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a9b4ed8201c8530d85d7155410f5178e0">const_iterator</a> <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a <code>const_iterator</code> pointing past the end of the collection. </p>
<dl class="section return"><dt>Returns</dt><dd>A <code>const_iterator</code>.</dd></dl>
<p>Note that dereferencing the iterator will yield a <code>const</code> <code>T*</code> rather than a reference. </p>

</div>
</div>
<a class="anchor" id="ac68e2b55f65d97e88b866fb50218059d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a2005081b262f1e63a17d7ccc0615249d">iterator</a> <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an <code>iterator</code> pointing past the end of the collection. </p>
<dl class="section return"><dt>Returns</dt><dd>An <code>iterator</code>.</dd></dl>
<p>Note that dereferencing the iterator will yield a proxy rather than a reference; the proxy will handle deleting an owned element if it's assigned to. </p>

</div>
</div>
<a class="anchor" id="a0e87fb8184614c638940f4c2bc2ef823"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a2005081b262f1e63a17d7ccc0615249d">iterator</a> <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a2005081b262f1e63a17d7ccc0615249d">iterator</a>&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove element at a given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>Iterator pointing to the element to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the next element (or <code><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#ac68e2b55f65d97e88b866fb50218059d" title="Return an iterator pointing past the end of the collection. ">end()</a></code>).</dd></dl>
<p>If the container owns its elements, then the pointed-to element will be deleted. </p>

</div>
</div>
<a class="anchor" id="a210ba843db90aea8fd000b7fd0137d30"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a2005081b262f1e63a17d7ccc0615249d">iterator</a> <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a2005081b262f1e63a17d7ccc0615249d">iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a2005081b262f1e63a17d7ccc0615249d">iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a range of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator pointing to the first element to be removed. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator pointing one past the last element to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the element pointed to by <em>last</em> prior to erasing (or <code><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#ac68e2b55f65d97e88b866fb50218059d" title="Return an iterator pointing past the end of the collection. ">end()</a></code>).</dd></dl>
<p>If the container owns its elements, then the removed elements will be deleted. Any duplicates will be removed in this process, but don't rely on this. </p>

</div>
</div>
<a class="anchor" id="a323a52a2cf1cf5531f1db34a01cea959"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PtrList::iterator <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::erase_base </td>
          <td>(</td>
          <td class="paramtype">typename PtrList::iterator&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper for <code><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a0e87fb8184614c638940f4c2bc2ef823" title="Remove element at a given position. ">erase()</a></code>. Remove element at a given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>Iterator pointing to the element to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the next element (or <code><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#ac68e2b55f65d97e88b866fb50218059d" title="Return an iterator pointing past the end of the collection. ">end()</a></code>).</dd></dl>
<p>This function factors out common code between <code><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a0e87fb8184614c638940f4c2bc2ef823" title="Remove element at a given position. ">erase()</a></code> in the base and derived <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code> classes. It deals with the <code>std::list</code> iterators directly. </p>

</div>
</div>
<a class="anchor" id="af6d3b26b1bfe8cd7fd5fbb6e539ca21d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PtrList::iterator <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::erase_base </td>
          <td>(</td>
          <td class="paramtype">typename PtrList::iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename PtrList::iterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper for <code><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a0e87fb8184614c638940f4c2bc2ef823" title="Remove element at a given position. ">erase()</a></code>. Remove a range of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator pointing to the first element to be removed. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator pointing one past the last element to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the element pointed to by <em>last</em> prior to erasing (or <code> <a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#ac68e2b55f65d97e88b866fb50218059d" title="Return an iterator pointing past the end of the collection. ">end()</a></code>).</dd></dl>
<p>This function factors out common code between <code><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a0e87fb8184614c638940f4c2bc2ef823" title="Remove element at a given position. ">erase()</a></code> in the base and derived <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code> classes. It deals with the <code>std::list</code> iterators directly. </p>

</div>
</div>
<a class="anchor" id="a47921f2fe9b99ea2768c8353323dcb64"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the first element in the collection as an rvalue. </p>
<dl class="section return"><dt>Returns</dt><dd>The first element in the collection.</dd></dl>
<p>No checking is done to ensure that the container is not empty. Note that we return a <code>const</code> <code>T*</code> rather than a reference. </p>

</div>
</div>
<a class="anchor" id="a3933eb9f817615c290c4613218c776b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a7a43f3105d5ac0011046690b54cbefdf">ElementProxy</a> <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the first element in the collection as an lvalue. </p>
<dl class="section return"><dt>Returns</dt><dd>Proxy to the first element in the collection.</dd></dl>
<p>No checking is done to ensure that the container is not empty. Note that we return a proxy object rather than a reference; the proxy will handle deleting an owned element if it's assigned to. </p>

</div>
</div>
<a class="anchor" id="a02227e05459f68f7ae0ec287b7817729"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a2005081b262f1e63a17d7ccc0615249d">iterator</a> <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a2005081b262f1e63a17d7ccc0615249d">iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>pElem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new element to the collection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>Iterator before which the element will be added. </td></tr>
    <tr><td class="paramname">pElem</td><td>The element to add to the collection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the inserted data.</dd></dl>
<p>The container's ownership policy will determine if it takes ownership of the new element.</p>
<p>Note: this method may only be called using the most derived <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code> in the hierarchy. </p>

</div>
</div>
<a class="anchor" id="a4015fc80662b9271fba386779848ff0f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a2005081b262f1e63a17d7ccc0615249d">iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a group of new elements to the collection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>Iterator before which the element will be added. </td></tr>
    <tr><td class="paramname">first</td><td>The start of the range to put in the container. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the range to put in the container.</td></tr>
  </table>
  </dd>
</dl>
<p>The container's ownership policy will determine if it takes ownership of the new element.</p>
<p>Note: this method may only be called using the most derived <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code> in the hierarchy. </p>

</div>
</div>
<a class="anchor" id="ad11d3b6dbf3f2dc4dddaa972377607ff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::iter_swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a2005081b262f1e63a17d7ccc0615249d">iterator</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a2005081b262f1e63a17d7ccc0615249d">iterator</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap the referents of two <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;. ">DataVector</a></code> iterators. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first iterator for the swap. </td></tr>
    <tr><td class="paramname">b</td><td>The second iterator for the swap/ </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a381210b588a66c2161bef370b3106dc7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge sorted lists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>Sorted list to merge.</td></tr>
  </table>
  </dd>
</dl>
<p>Assumes that both <em>l</em> and this list are sorted according to <a class="el" href="../../d1/d43/DataList_8h.html#a6f545af795991d4ea90a9bc52e9863d8" title="List ordering relation. ">operator&lt;()</a>. Merges elements of <em>l</em> into this list in sorted order, leaving <em>l</em> empty when complete. Elements in this list precede elements in <em>l</em> that are equal. </p>

</div>
</div>
<a class="anchor" id="a337a97ee5630a21085eb434dea1a7035"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;typename COMPARE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">COMPARE&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge sorted lists according to comparison function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>Sorted list to merge. </td></tr>
    <tr><td class="paramname">predicate</td><td>Comparison function defining a sort order (which must be strictly weak ordering).</td></tr>
  </table>
  </dd>
</dl>
<p>Assumes that both <em>l</em> and this <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code> are sorted according to COMPARE predicate. Merges elements of <em>l</em> into this list in sorted order, leaving <em>l</em> empty when complete. Elements in this list precede elements in <em>x</em> that are equivalent according to StrictWeakOrdering(). </p>

</div>
</div>
<a class="anchor" id="a098ae1daf011dd3037d2ac50bc618bfc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&amp; <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code> from which to assign. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This object.</dd></dl>
<p>This is a `shallow' copy; after the completion of this, the <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code> will not own its elements. Any elements it owned prior to this call will be released.</p>
<p>Note: this method may only be called using the most derived <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code> in the hierarchy. </p>

</div>
</div>
<a class="anchor" id="aa83393a907c793c2aa838fb6fa12aef3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the last element from the collection. </p>
<p>If the container owns its elements, then the removed element will be deleted. </p>

</div>
</div>
<a class="anchor" id="a63a46869c71bdec71e0294a6f72d8735"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::pop_front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the first element from the collection. </p>
<p>If the container owns its elements, then the removed element will be deleted. </p>

</div>
</div>
<a class="anchor" id="aeda608ccc6fac0ae29461df6cbf714a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>pElem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an element to the end of the collection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pElem</td><td>The element to add to the collection.</td></tr>
  </table>
  </dd>
</dl>
<p>The container's ownership policy will determine if it takes ownership of the new element.</p>
<p>Note: this method may only be called using the most derived <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code> in the hierarchy. </p>

</div>
</div>
<a class="anchor" id="ab09c229bdb18bf7c2e5385685ce15471"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>pElem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an element at the beginning of the collection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pElem</td><td>The element to add to the collection.</td></tr>
  </table>
  </dd>
</dl>
<p>The container's ownership policy will determine if it takes ownership of the new element.</p>
<p>Note: this method may only be called using the most derived <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code> in the hierarchy. </p>

</div>
</div>
<a class="anchor" id="af00a3dad08bbd578054b202f4458a4c5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a835adbeac6f6308e227b0ebbb601d40e">const_reverse_iterator</a> <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a <code>const_reverse_iterator</code> pointing past the end of the collection. </p>
<dl class="section return"><dt>Returns</dt><dd>A <code>const_reverse_iterator</code>.</dd></dl>
<p>Note that dereferencing the iterator will yield a <code>const</code> <code>T*</code> rather than a reference. </p>

</div>
</div>
<a class="anchor" id="a61dc30fc5a281edc891fc5646e8b39bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#add2a33702a069332966fb7369c33da52">reverse_iterator</a> <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a <code>reverse_iterator</code> pointing past the end of the collection. </p>
<dl class="section return"><dt>Returns</dt><dd>A <code>reverse_iterator</code>.</dd></dl>
<p>Note that dereferencing the iterator will yield a proxy rather than a reference; the proxy will handle deleting an owned element if it's assigned to. </p>

</div>
</div>
<a class="anchor" id="adb755c1c808b9195aea714580a047f29"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all elements equal to value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to remove.</td></tr>
  </table>
  </dd>
</dl>
<p>Removes every element in the list equal to <em>value</em>. Remaining elements stay in list order. Note that this function only erases the elements, and that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. </p>

</div>
</div>
<a class="anchor" id="a2c21080420c061eaeb098608ecaa10a0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;typename PREDICATE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::remove_if </td>
          <td>(</td>
          <td class="paramtype">PREDICATE&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all elements satisfying a predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Unary predicate function or object.</td></tr>
  </table>
  </dd>
</dl>
<p>Removes every element in the list for which the predicate returns true. Remaining elements stay in list order. Note that this function only erases the elements, and that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. </p>

</div>
</div>
<a class="anchor" id="ae2912a56c75a78e3daba92d308c2bd09"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a835adbeac6f6308e227b0ebbb601d40e">const_reverse_iterator</a> <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a <code>const_reverse_iterator</code> pointing at the beginning of the collection. </p>
<dl class="section return"><dt>Returns</dt><dd>A <code>const_reverse_iterator</code>.</dd></dl>
<p>Note that dereferencing the iterator will yield a <code>const</code> <code>T*</code> rather than a reference. </p>

</div>
</div>
<a class="anchor" id="a91706520fb2c75102299affef231541d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#add2a33702a069332966fb7369c33da52">reverse_iterator</a> <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a <code>reverse_iterator</code> pointing at the beginning of the collection. </p>
<dl class="section return"><dt>Returns</dt><dd>A <code>reverse_iterator</code>.</dd></dl>
<p>Note that dereferencing the iterator will yield a proxy rather than a reference; the proxy will handle deleting an owned element if it's assigned to. </p>

</div>
</div>
<a class="anchor" id="ab49fdbcd60375b226b8272dca4d2fa43"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes the collection to the specified number of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sz</td><td>The new size of the collection.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that this function differs from the standard in that it does not allow specifying the value of any inserted elements. They will always be 0.</p>
<p>If the container is shrunk, elements will be deleted as with <code><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a0e87fb8184614c638940f4c2bc2ef823" title="Remove element at a given position. ">erase()</a></code>. </p>

</div>
</div>
<a class="anchor" id="ac9244ff2441f80e03469a43b412d9a69"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::resortAux </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a2005081b262f1e63a17d7ccc0615249d">iterator</a>&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a2005081b262f1e63a17d7ccc0615249d">iterator</a>&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset indices / reorder aux data after elements have been permuted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg</td><td>Start of the range of elements to process. </td></tr>
    <tr><td class="paramname">end</td><td>End of the range of elements to process.</td></tr>
  </table>
  </dd>
</dl>
<p>This is a no-op for <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code>. </p>

</div>
</div>
<a class="anchor" id="a1a95df551a45b969628ca7cda2eda6d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::reverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverse the elements in list. </p>
<p>Reverse the order of elements in the list in linear time. </p>

</div>
</div>
<a class="anchor" id="a2abecca05cb11a4ddcc2bb2e1c5179ae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::setMostDerived </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set <code>m_isMostDerived</code> for this instance and clear it for all bases. </p>
<p>Called from <code>testInsert</code> if the test fails. The flag may not have been set if this container was made via copy construction, so set it appropriately now so we can test again. </p>

</div>
</div>
<a class="anchor" id="ad707975872cf9e85f633a9829c916d15"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::sort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort the container. </p>
<p>This just sorts by pointer value, so it's probably not very useful. </p>

</div>
</div>
<a class="anchor" id="a95f85d62d62900304eb60d03550ae5d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;class COMPARE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::sort </td>
          <td>(</td>
          <td class="paramtype">COMPARE&#160;</td>
          <td class="paramname"><em>comp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort the container with a user-specified comparison operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>Functional to compare two values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a633c3ce289cbaf70eafcea4db83fcae3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::splice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a2005081b262f1e63a17d7ccc0615249d">iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert contents of another list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>Iterator referencing the element to insert before. </td></tr>
    <tr><td class="paramname">l</td><td>Source list.</td></tr>
  </table>
  </dd>
</dl>
<p>The elements of <em>l</em> are inserted in constant time in front of the element referenced by <em>position</em>. <em>l</em> becomes an empty list. </p>

</div>
</div>
<a class="anchor" id="a9b434dbf244d93b44b46f6ff94a6d2f2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::splice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a2005081b262f1e63a17d7ccc0615249d">iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a2005081b262f1e63a17d7ccc0615249d">iterator</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert element from another list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>Iterator referencing the element to insert before. </td></tr>
    <tr><td class="paramname">l</td><td>Source list. </td></tr>
    <tr><td class="paramname">i</td><td>Iterator referencing the element to move.</td></tr>
  </table>
  </dd>
</dl>
<p>Removes the element in list <em>l</em> referenced by <em>i</em> and inserts it into the current list before <em>position</em>. </p>

</div>
</div>
<a class="anchor" id="abc339e17c39eb53440f0e8022b011db6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::splice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a2005081b262f1e63a17d7ccc0615249d">iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a2005081b262f1e63a17d7ccc0615249d">iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a2005081b262f1e63a17d7ccc0615249d">iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert range from another list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>Iterator referencing the element to insert before. </td></tr>
    <tr><td class="paramname">l</td><td>Source list. </td></tr>
    <tr><td class="paramname">first</td><td>Iterator referencing the start of range in <em>l</em>. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator referencing the end of range in <em>l</em>.</td></tr>
  </table>
  </dd>
</dl>
<p>Removes elements in the range [<em>first</em>, <em>last</em> ) and inserts them before <em>position</em> in constant time.</p>
<p>Undefined if <em>position</em> is in [<em>first</em>, <em>last</em> ). </p>

</div>
</div>
<a class="anchor" id="a637d00a090bf2fb52876227982ed2c3b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#abd17c4641bc563342e90f0cacb64af97">PtrList</a>&amp; <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::stdcont </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the underlying <code>std::list</code> of the container. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the <code>std::list</code> actually holding the collection.</dd></dl>
<p>Note that <code><a class="el" href="../../d9/dfb/classDataList.html#a4f0cca5ce1808d7e1c95a9c00b694007" title="Return the underlying std::list of the container. ">DataList&lt;T&gt;::stdcont</a></code> does not necessarily return a <code>std::list&lt;T*&gt;</code> if <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code> inheritance is being used. </p>

</div>
</div>
<a class="anchor" id="a280aba4dcb670ce252bafb3b4902fba9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap this collection with another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The collection with which to swap.</td></tr>
  </table>
  </dd>
</dl>
<p>Ownership is swapped along with the collection content.</p>
<p>Note: this method may only be called using the most-derived <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code> in the hierarchy. The <em>rhs</em> must also be referenced using the most-derived <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code>. </p>

</div>
</div>
<a class="anchor" id="ab7c31e2e55534c5724b20598db2324b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::swapElement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a2005081b262f1e63a17d7ccc0615249d">iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>newElem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reference&#160;</td>
          <td class="paramname"><em>oldElem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap one element out of the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The element in the container to swap. </td></tr>
    <tr><td class="paramname">newElem</td><td>New element to put in the container. May be 0. </td></tr>
    <tr><td class="paramname">oldElem</td><td>Reference to receive the element removed from the container.</td></tr>
  </table>
  </dd>
</dl>
<p>Reference <em>oldElem</em> is initialized with element <em>pos</em> of the collection (no bounds checking). Then element <em>index</em> is set to <code>newElem</code>. If the collection owns its elements, then it will take ownership of <em>newElem</em> and release (without deleting) the element returned through <em>oldElem</em>.</p>
<p>Note: this method may only be called using the most derived <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code> in the hierarchy. </p>

</div>
</div>
<a class="anchor" id="abc13d32a48d8e181d1c4f444f9b63952"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::testInsert </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if we can insert; raise an exception if not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>Description of the attempted operation.</td></tr>
  </table>
  </dd>
</dl>
<p>In order to maintain type-safety, we can only allow insertions using the most-derived instance of <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code>. This checks this by testing the <code>m_isMostDerived</code>, which is set by the constructors to true only for the most-derived instance. If the test fails, we call to potentially out-of-line code to continue. </p>

</div>
</div>
<a class="anchor" id="a9e0b9dc2ba00a550bb6d228a454e4567"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::testInsertOol </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if we can insert; raise an exception if not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>Description of the attempted operation.</td></tr>
  </table>
  </dd>
</dl>
<p>This continues the test of <code>testInsert</code>. There is one case where <code>m_isMostDerived</code> may not be set correctly. If this container was made via copy construction, then all the <code>m_isMostDerived</code> flags will be false. So we call <code>setMostDerived</code> to set the flags correctly and test again. If the test fails again, then we raise an exception. </p>

</div>
</div>
<a class="anchor" id="ae940d6e63477383a918c1eaf834eb488"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::unique </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove consecutive duplicate elements. </p>
<p>For each consecutive set of elements with the same value, remove all but the first one. Remaining elements stay in list order. </p>

</div>
</div>
<a class="anchor" id="af5bf6bc20d50017ebc802bd3b2ad524a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;typename BinaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::unique </td>
          <td>(</td>
          <td class="paramtype">BinaryPredicate&#160;</td>
          <td class="paramname"><em>pred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove consecutive elements satisfying a predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pred</td><td>Binary predicate function or object.</td></tr>
  </table>
  </dd>
</dl>
<p>For each consecutive set of elements [first,last) that satisfy predicate(first,i) where i is an iterator in [first,last), remove all but the first one. Remaining elements stay in list order. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a904290e6b3a3dc730b98b1866b160827"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::has_virtual = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is true for any <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code> class if we need to use virtual derivation to get to the base <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code> class. Since this <em>is</em> the base <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code> class, set this unconditionally to <code>false</code>. </p>

</div>
</div>
<a class="anchor" id="a58d4eab21e401f540614780a4bbe5c4f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">SG::OwnershipPolicy</a> <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::m_ownPolicy</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The ownership policy of this container &mdash; either SG::OWNS_ELEMENTS or <a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8ad7d4cf2303700f0966e4140f236c4bf1" title="this data object is a view, it does not own its elmts ">SG::VIEW_ELEMENTS</a>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.31/AthContainers/AthContainers/<a class="el" href="../../d1/d43/DataList_8h_source.html">DataList.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Dec 1 2017 11:08:39 for RootCore Packages by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
