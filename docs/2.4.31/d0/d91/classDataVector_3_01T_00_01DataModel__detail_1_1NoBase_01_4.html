<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>RootCore Packages: DataVector&lt; T, DataModel_detail::NoBase &gt; Class Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">RootCore Packages
   &#160;<span id="projectnumber">2.4.31</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="../../classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="../../hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="../../functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="../../d1/db6/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DataVector&lt; T, DataModel_detail::NoBase &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Base specialization for <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;. ">DataVector</a>&lt;T&gt;</code>.  
 <a href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d7/dd6/DataVector_8h_source.html">DataVector.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for DataVector&lt; T, DataModel_detail::NoBase &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.png" usemap="#DataVector&lt; T, DataModel_detail::NoBase &gt;_map" alt=""/>
  <map id="DataVector&lt; T, DataModel_detail::NoBase &gt;_map" name="DataVector&lt; T, DataModel_detail::NoBase &gt;_map">
<area href="../../dd/da5/classSG_1_1AuxVectorBase.html" title="Manage index tracking and synchronization of auxiliary data. " alt="SG::AuxVectorBase" shape="rect" coords="0,112,264,136"/>
<area href="../../db/dd6/classSG_1_1AuxVectorData.html" title="Manage lookup of vectors of auxiliary data. " alt="SG::AuxVectorData" shape="rect" coords="0,56,264,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac35f5551429d21ca6cbcca041a2d9abf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac35f5551429d21ca6cbcca041a2d9abf"></a>
typedef <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a>&#160;</td><td class="memItemRight" valign="bottom"><b>DataVector_BASE</b></td></tr>
<tr class="separator:ac35f5551429d21ca6cbcca041a2d9abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af58267834003be5047f5c22527b414c8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af58267834003be5047f5c22527b414c8"></a>
typedef <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a>&#160;</td><td class="memItemRight" valign="bottom"><b>DVL_BASE</b></td></tr>
<tr class="separator:af58267834003be5047f5c22527b414c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d22da7eb5426078d4caa20180a8b42f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d22da7eb5426078d4caa20180a8b42f"></a>
typedef boost::true_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a8d22da7eb5426078d4caa20180a8b42f">isSequence</a></td></tr>
<tr class="memdesc:a8d22da7eb5426078d4caa20180a8b42f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark as a sequence, for <a class="el" href="../../da/da2/classDataLink.html" title="DataLink implementation for ROOT usage. ">DataLink</a> / <a class="el" href="../../d6/d6e/classElementLink.html" title="ElementLink implementation for ROOT usage. ">ElementLink</a>. <br/></td></tr>
<tr class="separator:a8d22da7eb5426078d4caa20180a8b42f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9037cb597ab293dcf843bd9f5d88699f"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; T * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a9037cb597ab293dcf843bd9f5d88699f">PtrVector</a></td></tr>
<tr class="separator:a9037cb597ab293dcf843bd9f5d88699f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b59e0e4711d397158b222c7cb0968b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae7b59e0e4711d397158b222c7cb0968b"></a>
typedef std::vector&lt; T * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>BaseContainer</b></td></tr>
<tr class="separator:ae7b59e0e4711d397158b222c7cb0968b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a15ced3a471eba601bc466cceb1407"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a36a15ced3a471eba601bc466cceb1407"></a>
typedef T *&amp;&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b></td></tr>
<tr class="separator:a36a15ced3a471eba601bc466cceb1407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4fe89196f2c3310e1682d52eaa6bf1a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4fe89196f2c3310e1682d52eaa6bf1a"></a>
typedef T *const &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b></td></tr>
<tr class="separator:af4fe89196f2c3310e1682d52eaa6bf1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a426cf9faa6a9550c9400c68a49d278"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a426cf9faa6a9550c9400c68a49d278"></a>
typedef PtrVector::size_type&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr class="separator:a0a426cf9faa6a9550c9400c68a49d278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7424c314b1b4a04aeaf6a9a88fbcd27"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7424c314b1b4a04aeaf6a9a88fbcd27"></a>
typedef PtrVector::difference_type&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b></td></tr>
<tr class="separator:aa7424c314b1b4a04aeaf6a9a88fbcd27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e0714111ae690350811e21ba22110a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e0714111ae690350811e21ba22110a9"></a>
typedef T *&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>
<tr class="separator:a0e0714111ae690350811e21ba22110a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b690898dbe6d9cff5454000275d141a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b690898dbe6d9cff5454000275d141a"></a>
typedef PtrVector::allocator_type&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b></td></tr>
<tr class="separator:a2b690898dbe6d9cff5454000275d141a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeecc2f1041e730ee4161320f785ade2c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeecc2f1041e730ee4161320f785ade2c"></a>
typedef T **&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b></td></tr>
<tr class="separator:aeecc2f1041e730ee4161320f785ade2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf14ad6aec74539a12dd463ee2569bc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abcf14ad6aec74539a12dd463ee2569bc"></a>
typedef T *const *&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b></td></tr>
<tr class="separator:abcf14ad6aec74539a12dd463ee2569bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75acba4abcd3d7b9728b643379e080e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75acba4abcd3d7b9728b643379e080e3"></a>
typedef const T *&#160;</td><td class="memItemRight" valign="bottom"><b>const_value_type</b></td></tr>
<tr class="separator:a75acba4abcd3d7b9728b643379e080e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc2ad3e5de641d68b5490651f15d9448"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#adc2ad3e5de641d68b5490651f15d9448">base_value_type</a></td></tr>
<tr class="separator:adc2ad3e5de641d68b5490651f15d9448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ab9c1706c2cd3273ec27a4b218ccfa"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="../../d7/d05/classDataModel__detail_1_1ElementProxy.html">DataModel_detail::ElementProxy</a><br class="typebreak"/>
&lt; <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a99ab9c1706c2cd3273ec27a4b218ccfa">ElementProxy</a></td></tr>
<tr class="separator:a99ab9c1706c2cd3273ec27a4b218ccfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad14d8fa936e56241eea1626b464c3b8c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad14d8fa936e56241eea1626b464c3b8c"></a>
typedef PtrVector::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#ad14d8fa936e56241eea1626b464c3b8c">const_iterator</a></td></tr>
<tr class="memdesc:ad14d8fa936e56241eea1626b464c3b8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard <code>const_iterator</code>. <br/></td></tr>
<tr class="separator:ad14d8fa936e56241eea1626b464c3b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a24970f8d3743d873f69407fbf76872"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">DataModel_detail::iterator</a><br class="typebreak"/>
&lt; <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a0a24970f8d3743d873f69407fbf76872">iterator</a></td></tr>
<tr class="separator:a0a24970f8d3743d873f69407fbf76872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d77f0c504d473f85376ddce8bd2163"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a61d77f0c504d473f85376ddce8bd2163"></a>
typedef std::reverse_iterator<br class="typebreak"/>
&lt; <a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#ad14d8fa936e56241eea1626b464c3b8c">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a61d77f0c504d473f85376ddce8bd2163">const_reverse_iterator</a></td></tr>
<tr class="memdesc:a61d77f0c504d473f85376ddce8bd2163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard <code>const_reverse_iterator</code>. <br/></td></tr>
<tr class="separator:a61d77f0c504d473f85376ddce8bd2163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3551d2e1bdbe02ade11f731cfb976f4f"><td class="memItemLeft" align="right" valign="top">typedef std::reverse_iterator<br class="typebreak"/>
&lt; <a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a0a24970f8d3743d873f69407fbf76872">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a3551d2e1bdbe02ade11f731cfb976f4f">reverse_iterator</a></td></tr>
<tr class="separator:a3551d2e1bdbe02ade11f731cfb976f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors, destructors, assignment.</div></td></tr>
<tr class="memitem:a51d310761242622f1b5329a6fe398e51"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a51d310761242622f1b5329a6fe398e51">DataVector</a> (<a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">SG::OwnershipPolicy</a> <a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#af0f040ba00e37768ecf92319cf7edcf0">ownPolicy</a>=<a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8a1f65f0fb55784cfd27d9d4d6d7986d4d">SG::OWN_ELEMENTS</a>, <a class="el" href="../../dd/d59/namespaceSG.html#a9f3d699f65390b7f8baf54d9cd634573">SG::IndexTrackingPolicy</a> <a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html#ae905757bbac29e780e4010eaf52ea01e">trackIndices</a>=<a class="el" href="../../dd/d59/namespaceSG.html#a9f3d699f65390b7f8baf54d9cd634573ad08b3b1af2cb1dd45428b131f9f05ad7">SG::DEFAULT_TRACK_INDICES</a>)</td></tr>
<tr class="memdesc:a51d310761242622f1b5329a6fe398e51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a51d310761242622f1b5329a6fe398e51">More...</a><br/></td></tr>
<tr class="separator:a51d310761242622f1b5329a6fe398e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd6dcc16e6805765bd3b11f9124d4e76"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#acd6dcc16e6805765bd3b11f9124d4e76">DataVector</a> (size_type n, <a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">SG::OwnershipPolicy</a> <a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#af0f040ba00e37768ecf92319cf7edcf0">ownPolicy</a>=<a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8a1f65f0fb55784cfd27d9d4d6d7986d4d">SG::OWN_ELEMENTS</a>, <a class="el" href="../../dd/d59/namespaceSG.html#a9f3d699f65390b7f8baf54d9cd634573">SG::IndexTrackingPolicy</a> <a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html#ae905757bbac29e780e4010eaf52ea01e">trackIndices</a>=<a class="el" href="../../dd/d59/namespaceSG.html#a9f3d699f65390b7f8baf54d9cd634573ad08b3b1af2cb1dd45428b131f9f05ad7">SG::DEFAULT_TRACK_INDICES</a>)</td></tr>
<tr class="memdesc:acd6dcc16e6805765bd3b11f9124d4e76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sized constructor.  <a href="#acd6dcc16e6805765bd3b11f9124d4e76">More...</a><br/></td></tr>
<tr class="separator:acd6dcc16e6805765bd3b11f9124d4e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a507c03514b600a8808c0d50e5f2292ec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a507c03514b600a8808c0d50e5f2292ec">DataVector</a> (const <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a> &amp;rhs)</td></tr>
<tr class="memdesc:a507c03514b600a8808c0d50e5f2292ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a507c03514b600a8808c0d50e5f2292ec">More...</a><br/></td></tr>
<tr class="separator:a507c03514b600a8808c0d50e5f2292ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297de4aad003ac89136a56ba1c030e99"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:a297de4aad003ac89136a56ba1c030e99"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a297de4aad003ac89136a56ba1c030e99">DataVector</a> (InputIterator first, InputIterator last, <a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">SG::OwnershipPolicy</a> <a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#af0f040ba00e37768ecf92319cf7edcf0">ownPolicy</a>=<a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8ad7d4cf2303700f0966e4140f236c4bf1">SG::VIEW_ELEMENTS</a>, <a class="el" href="../../dd/d59/namespaceSG.html#a9f3d699f65390b7f8baf54d9cd634573">SG::IndexTrackingPolicy</a> <a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html#ae905757bbac29e780e4010eaf52ea01e">trackIndices</a>=<a class="el" href="../../dd/d59/namespaceSG.html#a9f3d699f65390b7f8baf54d9cd634573ad08b3b1af2cb1dd45428b131f9f05ad7">SG::DEFAULT_TRACK_INDICES</a>, <a class="el" href="../../dc/d05/classSG_1_1IAuxStore.html">SG::IAuxStore</a> *store=0)</td></tr>
<tr class="memdesc:a297de4aad003ac89136a56ba1c030e99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from iterators.  <a href="#a297de4aad003ac89136a56ba1c030e99">More...</a><br/></td></tr>
<tr class="separator:a297de4aad003ac89136a56ba1c030e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7e3dcf0a187de3ad9091d75e4e27d15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#ad7e3dcf0a187de3ad9091d75e4e27d15">operator=</a> (const <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a> &amp;rhs)</td></tr>
<tr class="memdesc:ad7e3dcf0a187de3ad9091d75e4e27d15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="#ad7e3dcf0a187de3ad9091d75e4e27d15">More...</a><br/></td></tr>
<tr class="separator:ad7e3dcf0a187de3ad9091d75e4e27d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a54fbd06bf7ba56bfdba9a8a5aedf4a"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:a8a54fbd06bf7ba56bfdba9a8a5aedf4a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a8a54fbd06bf7ba56bfdba9a8a5aedf4a">assign</a> (InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:a8a54fbd06bf7ba56bfdba9a8a5aedf4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign from iterators.  <a href="#a8a54fbd06bf7ba56bfdba9a8a5aedf4a">More...</a><br/></td></tr>
<tr class="separator:a8a54fbd06bf7ba56bfdba9a8a5aedf4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab824ffa2d0adf0efec55d86c236e069c"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#ab824ffa2d0adf0efec55d86c236e069c">~DataVector</a> ()</td></tr>
<tr class="memdesc:ab824ffa2d0adf0efec55d86c236e069c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#ab824ffa2d0adf0efec55d86c236e069c">More...</a><br/></td></tr>
<tr class="separator:ab824ffa2d0adf0efec55d86c236e069c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Size and capacity.</div></td></tr>
<tr class="memitem:aa373b4153b48277e38b13e3d1b12ca57"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa373b4153b48277e38b13e3d1b12ca57"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#aa373b4153b48277e38b13e3d1b12ca57">size</a> () const </td></tr>
<tr class="memdesc:aa373b4153b48277e38b13e3d1b12ca57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the collection. <br/></td></tr>
<tr class="separator:aa373b4153b48277e38b13e3d1b12ca57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a258f5c8833dc8e1d659960784c468f25"><td class="memItemLeft" align="right" valign="top">virtual size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a258f5c8833dc8e1d659960784c468f25">size_v</a> () const </td></tr>
<tr class="memdesc:a258f5c8833dc8e1d659960784c468f25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the collection.  <a href="#a258f5c8833dc8e1d659960784c468f25">More...</a><br/></td></tr>
<tr class="separator:a258f5c8833dc8e1d659960784c468f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af073ac3549c572ef07b6dea868683034"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af073ac3549c572ef07b6dea868683034"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#af073ac3549c572ef07b6dea868683034">max_size</a> () const </td></tr>
<tr class="memdesc:af073ac3549c572ef07b6dea868683034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <code><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#aa373b4153b48277e38b13e3d1b12ca57" title="Returns the number of elements in the collection. ">size()</a></code> of the largest possible collection. <br/></td></tr>
<tr class="separator:af073ac3549c572ef07b6dea868683034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43652bda389a83f437300f0f1de68e05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a43652bda389a83f437300f0f1de68e05">resize</a> (size_type sz)</td></tr>
<tr class="memdesc:a43652bda389a83f437300f0f1de68e05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the collection to the specified number of elements.  <a href="#a43652bda389a83f437300f0f1de68e05">More...</a><br/></td></tr>
<tr class="separator:a43652bda389a83f437300f0f1de68e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89410e14163ca5e0914e7fa596d41685"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a89410e14163ca5e0914e7fa596d41685"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a89410e14163ca5e0914e7fa596d41685">capacity</a> () const </td></tr>
<tr class="memdesc:a89410e14163ca5e0914e7fa596d41685"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of elements that the collection can hold before needing to allocate more memory. <br/></td></tr>
<tr class="separator:a89410e14163ca5e0914e7fa596d41685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a236a9f58b14de59ef54c5107dfcff5dc"><td class="memItemLeft" align="right" valign="top">virtual size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a236a9f58b14de59ef54c5107dfcff5dc">capacity_v</a> () const </td></tr>
<tr class="memdesc:a236a9f58b14de59ef54c5107dfcff5dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of elements that the collection can hold before needing to allocate more memory.  <a href="#a236a9f58b14de59ef54c5107dfcff5dc">More...</a><br/></td></tr>
<tr class="separator:a236a9f58b14de59ef54c5107dfcff5dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cba59c9dc31127ba7a3fd98e0b23282"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9cba59c9dc31127ba7a3fd98e0b23282"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a9cba59c9dc31127ba7a3fd98e0b23282">empty</a> () const </td></tr>
<tr class="memdesc:a9cba59c9dc31127ba7a3fd98e0b23282"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the collection is empty. <br/></td></tr>
<tr class="separator:a9cba59c9dc31127ba7a3fd98e0b23282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad057592307e2749e25a3970ed6426b17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#ad057592307e2749e25a3970ed6426b17">reserve</a> (size_type n)</td></tr>
<tr class="memdesc:ad057592307e2749e25a3970ed6426b17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to preallocate enough memory for a specified number of elements.  <a href="#ad057592307e2749e25a3970ed6426b17">More...</a><br/></td></tr>
<tr class="separator:ad057592307e2749e25a3970ed6426b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Element access.</div></td></tr>
<tr class="memitem:ad3eba15a4069718475af38248a3d0d2e"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#ad3eba15a4069718475af38248a3d0d2e">operator[]</a> (size_type n) const </td></tr>
<tr class="memdesc:ad3eba15a4069718475af38248a3d0d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access an element, as an rvalue.  <a href="#ad3eba15a4069718475af38248a3d0d2e">More...</a><br/></td></tr>
<tr class="separator:ad3eba15a4069718475af38248a3d0d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c53dc5625a660a87187d033194dad02"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a4c53dc5625a660a87187d033194dad02">get</a> (size_type n) const </td></tr>
<tr class="memdesc:a4c53dc5625a660a87187d033194dad02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access an element, as an rvalue.  <a href="#a4c53dc5625a660a87187d033194dad02">More...</a><br/></td></tr>
<tr class="separator:a4c53dc5625a660a87187d033194dad02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dfa8e78005f6ba076fa4fd8f89905cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a99ab9c1706c2cd3273ec27a4b218ccfa">ElementProxy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a9dfa8e78005f6ba076fa4fd8f89905cc">operator[]</a> (size_type n)</td></tr>
<tr class="memdesc:a9dfa8e78005f6ba076fa4fd8f89905cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access an element, as an lvalue.  <a href="#a9dfa8e78005f6ba076fa4fd8f89905cc">More...</a><br/></td></tr>
<tr class="separator:a9dfa8e78005f6ba076fa4fd8f89905cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ea77da44d88c17ebb3ab9c3f6d78e1"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#aa8ea77da44d88c17ebb3ab9c3f6d78e1">at</a> (size_type n) const </td></tr>
<tr class="memdesc:aa8ea77da44d88c17ebb3ab9c3f6d78e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access an element, as an rvalue.  <a href="#aa8ea77da44d88c17ebb3ab9c3f6d78e1">More...</a><br/></td></tr>
<tr class="separator:aa8ea77da44d88c17ebb3ab9c3f6d78e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3744541d5aee9f68ea81cbe58e474fec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a99ab9c1706c2cd3273ec27a4b218ccfa">ElementProxy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a3744541d5aee9f68ea81cbe58e474fec">at</a> (size_type n)</td></tr>
<tr class="memdesc:a3744541d5aee9f68ea81cbe58e474fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access an element, as an lvalue.  <a href="#a3744541d5aee9f68ea81cbe58e474fec">More...</a><br/></td></tr>
<tr class="separator:a3744541d5aee9f68ea81cbe58e474fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4e4253e25498a4aed16cf5fd19176b"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a8b4e4253e25498a4aed16cf5fd19176b">front</a> () const </td></tr>
<tr class="memdesc:a8b4e4253e25498a4aed16cf5fd19176b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the first element in the collection as an rvalue.  <a href="#a8b4e4253e25498a4aed16cf5fd19176b">More...</a><br/></td></tr>
<tr class="separator:a8b4e4253e25498a4aed16cf5fd19176b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94471e13ddf6ee1c7808d032b60d40a5"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a94471e13ddf6ee1c7808d032b60d40a5">back</a> () const </td></tr>
<tr class="memdesc:a94471e13ddf6ee1c7808d032b60d40a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the last element in the collection as an rvalue.  <a href="#a94471e13ddf6ee1c7808d032b60d40a5">More...</a><br/></td></tr>
<tr class="separator:a94471e13ddf6ee1c7808d032b60d40a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12489c7ded0c123b55d5b4d8ff5386ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a99ab9c1706c2cd3273ec27a4b218ccfa">ElementProxy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a12489c7ded0c123b55d5b4d8ff5386ae">front</a> ()</td></tr>
<tr class="memdesc:a12489c7ded0c123b55d5b4d8ff5386ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the first element in the collection as an lvalue.  <a href="#a12489c7ded0c123b55d5b4d8ff5386ae">More...</a><br/></td></tr>
<tr class="separator:a12489c7ded0c123b55d5b4d8ff5386ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ded16015ae169fe929ab34eda1c079a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a99ab9c1706c2cd3273ec27a4b218ccfa">ElementProxy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a0ded16015ae169fe929ab34eda1c079a">back</a> ()</td></tr>
<tr class="memdesc:a0ded16015ae169fe929ab34eda1c079a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the last element in the collection as an lvalue.  <a href="#a0ded16015ae169fe929ab34eda1c079a">More...</a><br/></td></tr>
<tr class="separator:a0ded16015ae169fe929ab34eda1c079a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Iterator creation.</div></td></tr>
<tr class="memitem:a31fc0611d6e14e7dc95a7444b5389786"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#ad14d8fa936e56241eea1626b464c3b8c">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a31fc0611d6e14e7dc95a7444b5389786">begin</a> () const </td></tr>
<tr class="memdesc:a31fc0611d6e14e7dc95a7444b5389786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <code>const_iterator</code> pointing at the beginning of the collection.  <a href="#a31fc0611d6e14e7dc95a7444b5389786">More...</a><br/></td></tr>
<tr class="separator:a31fc0611d6e14e7dc95a7444b5389786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c31b486a1b577d581bcded32f8c0d4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#ad14d8fa936e56241eea1626b464c3b8c">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a4c31b486a1b577d581bcded32f8c0d4a">end</a> () const </td></tr>
<tr class="memdesc:a4c31b486a1b577d581bcded32f8c0d4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <code>const_iterator</code> pointing past the end of the collection.  <a href="#a4c31b486a1b577d581bcded32f8c0d4a">More...</a><br/></td></tr>
<tr class="separator:a4c31b486a1b577d581bcded32f8c0d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a016e07a7a7a825f01214a03d136381cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a0a24970f8d3743d873f69407fbf76872">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a016e07a7a7a825f01214a03d136381cb">begin</a> ()</td></tr>
<tr class="memdesc:a016e07a7a7a825f01214a03d136381cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an <code>iterator</code> pointing at the beginning of the collection.  <a href="#a016e07a7a7a825f01214a03d136381cb">More...</a><br/></td></tr>
<tr class="separator:a016e07a7a7a825f01214a03d136381cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a084ec53b556ed4283f598bdd33398943"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a0a24970f8d3743d873f69407fbf76872">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a084ec53b556ed4283f598bdd33398943">end</a> ()</td></tr>
<tr class="memdesc:a084ec53b556ed4283f598bdd33398943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an <code>iterator</code> pointing past the end of the collection.  <a href="#a084ec53b556ed4283f598bdd33398943">More...</a><br/></td></tr>
<tr class="separator:a084ec53b556ed4283f598bdd33398943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6225bfe9a292ddead10cec769022a2ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a61d77f0c504d473f85376ddce8bd2163">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a6225bfe9a292ddead10cec769022a2ce">rbegin</a> () const </td></tr>
<tr class="memdesc:a6225bfe9a292ddead10cec769022a2ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <code>const_reverse_iterator</code> pointing past the end of the collection.  <a href="#a6225bfe9a292ddead10cec769022a2ce">More...</a><br/></td></tr>
<tr class="separator:a6225bfe9a292ddead10cec769022a2ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa741d2f764cf729035ce630c542d43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a61d77f0c504d473f85376ddce8bd2163">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#acfa741d2f764cf729035ce630c542d43">rend</a> () const </td></tr>
<tr class="memdesc:acfa741d2f764cf729035ce630c542d43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <code>const_reverse_iterator</code> pointing at the beginning of the collection.  <a href="#acfa741d2f764cf729035ce630c542d43">More...</a><br/></td></tr>
<tr class="separator:acfa741d2f764cf729035ce630c542d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b47037798be81db90016ad9584899e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a3551d2e1bdbe02ade11f731cfb976f4f">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a2b47037798be81db90016ad9584899e9">rbegin</a> ()</td></tr>
<tr class="memdesc:a2b47037798be81db90016ad9584899e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <code>reverse_iterator</code> pointing past the end of the collection.  <a href="#a2b47037798be81db90016ad9584899e9">More...</a><br/></td></tr>
<tr class="separator:a2b47037798be81db90016ad9584899e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3346ad4e2fe7f416b8c1b7f62a838076"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a3551d2e1bdbe02ade11f731cfb976f4f">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a3346ad4e2fe7f416b8c1b7f62a838076">rend</a> ()</td></tr>
<tr class="memdesc:a3346ad4e2fe7f416b8c1b7f62a838076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <code>reverse_iterator</code> pointing at the beginning of the collection.  <a href="#a3346ad4e2fe7f416b8c1b7f62a838076">More...</a><br/></td></tr>
<tr class="separator:a3346ad4e2fe7f416b8c1b7f62a838076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865ba4448ebb8fcb61ed2ebe69a900fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#ad14d8fa936e56241eea1626b464c3b8c">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a865ba4448ebb8fcb61ed2ebe69a900fc">cbegin</a> () const </td></tr>
<tr class="memdesc:a865ba4448ebb8fcb61ed2ebe69a900fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <code>const_iterator</code> pointing at the beginning of the collection.  <a href="#a865ba4448ebb8fcb61ed2ebe69a900fc">More...</a><br/></td></tr>
<tr class="separator:a865ba4448ebb8fcb61ed2ebe69a900fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f60ec41043c1ef5dfb5b50dd4b08d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#ad14d8fa936e56241eea1626b464c3b8c">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a87f60ec41043c1ef5dfb5b50dd4b08d8">cend</a> () const </td></tr>
<tr class="memdesc:a87f60ec41043c1ef5dfb5b50dd4b08d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <code>const_iterator</code> pointing past the end of the collection.  <a href="#a87f60ec41043c1ef5dfb5b50dd4b08d8">More...</a><br/></td></tr>
<tr class="separator:a87f60ec41043c1ef5dfb5b50dd4b08d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d1064401af7c90703d0a2f79136e0ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a61d77f0c504d473f85376ddce8bd2163">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a1d1064401af7c90703d0a2f79136e0ec">crbegin</a> () const </td></tr>
<tr class="memdesc:a1d1064401af7c90703d0a2f79136e0ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <code>const_reverse_iterator</code> pointing past the end of the collection.  <a href="#a1d1064401af7c90703d0a2f79136e0ec">More...</a><br/></td></tr>
<tr class="separator:a1d1064401af7c90703d0a2f79136e0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afed788d8db665532545478186925b3a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a61d77f0c504d473f85376ddce8bd2163">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#afed788d8db665532545478186925b3a6">crend</a> () const </td></tr>
<tr class="memdesc:afed788d8db665532545478186925b3a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <code>const_reverse_iterator</code> pointing at the beginning of the collection.  <a href="#afed788d8db665532545478186925b3a6">More...</a><br/></td></tr>
<tr class="separator:afed788d8db665532545478186925b3a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Insertion operations.</div></td></tr>
<tr class="memitem:aaa71855a58852e9c5ffa61a555ed581f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#aaa71855a58852e9c5ffa61a555ed581f">push_back</a> (value_type pElem)</td></tr>
<tr class="memdesc:aaa71855a58852e9c5ffa61a555ed581f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an element to the end of the collection.  <a href="#aaa71855a58852e9c5ffa61a555ed581f">More...</a><br/></td></tr>
<tr class="separator:aaa71855a58852e9c5ffa61a555ed581f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e962bbda1ab83d0b892a0be604c0e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a54e962bbda1ab83d0b892a0be604c0e9">emplace_back</a> (value_type pElem)</td></tr>
<tr class="memdesc:a54e962bbda1ab83d0b892a0be604c0e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an element to the end of the collection.  <a href="#a54e962bbda1ab83d0b892a0be604c0e9">More...</a><br/></td></tr>
<tr class="separator:a54e962bbda1ab83d0b892a0be604c0e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a250b3c680672ec28ec9938239bc9328a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a0a24970f8d3743d873f69407fbf76872">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a250b3c680672ec28ec9938239bc9328a">insert</a> (<a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a0a24970f8d3743d873f69407fbf76872">iterator</a> position, value_type pElem)</td></tr>
<tr class="memdesc:a250b3c680672ec28ec9938239bc9328a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new element to the collection.  <a href="#a250b3c680672ec28ec9938239bc9328a">More...</a><br/></td></tr>
<tr class="separator:a250b3c680672ec28ec9938239bc9328a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a728e46d92c5d2d0cdce9e2ce51bab6d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a0a24970f8d3743d873f69407fbf76872">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a728e46d92c5d2d0cdce9e2ce51bab6d1">emplace</a> (<a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a0a24970f8d3743d873f69407fbf76872">iterator</a> position, value_type pElem)</td></tr>
<tr class="memdesc:a728e46d92c5d2d0cdce9e2ce51bab6d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new element to the collection.  <a href="#a728e46d92c5d2d0cdce9e2ce51bab6d1">More...</a><br/></td></tr>
<tr class="separator:a728e46d92c5d2d0cdce9e2ce51bab6d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fd38680b0724949c3619736caa9fbbb"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:a3fd38680b0724949c3619736caa9fbbb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a3fd38680b0724949c3619736caa9fbbb">insert</a> (<a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a0a24970f8d3743d873f69407fbf76872">iterator</a> position, InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:a3fd38680b0724949c3619736caa9fbbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a group of new elements to the collection.  <a href="#a3fd38680b0724949c3619736caa9fbbb">More...</a><br/></td></tr>
<tr class="separator:a3fd38680b0724949c3619736caa9fbbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Erasure operations.</div></td></tr>
<tr class="memitem:a5e41132c55010e688115f1ed6cc0edab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a0a24970f8d3743d873f69407fbf76872">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a5e41132c55010e688115f1ed6cc0edab">erase</a> (<a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a0a24970f8d3743d873f69407fbf76872">iterator</a> position)</td></tr>
<tr class="memdesc:a5e41132c55010e688115f1ed6cc0edab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove element at a given position.  <a href="#a5e41132c55010e688115f1ed6cc0edab">More...</a><br/></td></tr>
<tr class="separator:a5e41132c55010e688115f1ed6cc0edab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16b6a23080b04529edbcaede4c3b121"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a0a24970f8d3743d873f69407fbf76872">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#ae16b6a23080b04529edbcaede4c3b121">erase</a> (<a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a0a24970f8d3743d873f69407fbf76872">iterator</a> first, <a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a0a24970f8d3743d873f69407fbf76872">iterator</a> last)</td></tr>
<tr class="memdesc:ae16b6a23080b04529edbcaede4c3b121"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a range of elements.  <a href="#ae16b6a23080b04529edbcaede4c3b121">More...</a><br/></td></tr>
<tr class="separator:ae16b6a23080b04529edbcaede4c3b121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5435f79346220ac80c41bdc3adf9803c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a5435f79346220ac80c41bdc3adf9803c">pop_back</a> ()</td></tr>
<tr class="memdesc:a5435f79346220ac80c41bdc3adf9803c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the last element from the collection.  <a href="#a5435f79346220ac80c41bdc3adf9803c">More...</a><br/></td></tr>
<tr class="separator:a5435f79346220ac80c41bdc3adf9803c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3292a55621ae0171766b2f8e9d067436"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a3292a55621ae0171766b2f8e9d067436">clear</a> ()</td></tr>
<tr class="memdesc:a3292a55621ae0171766b2f8e9d067436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase all the elements in the collection.  <a href="#a3292a55621ae0171766b2f8e9d067436">More...</a><br/></td></tr>
<tr class="separator:a3292a55621ae0171766b2f8e9d067436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSG_1_1AuxVectorBase"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSG_1_1AuxVectorBase')"><img src="../../closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html">SG::AuxVectorBase</a></td></tr>
<tr class="memitem:a0393c7e87efbe788419774c662cba5a2 inherit pub_methods_classSG_1_1AuxVectorBase"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html#a0393c7e87efbe788419774c662cba5a2">AuxVectorBase</a> ()</td></tr>
<tr class="memdesc:a0393c7e87efbe788419774c662cba5a2 inherit pub_methods_classSG_1_1AuxVectorBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a0393c7e87efbe788419774c662cba5a2">More...</a><br/></td></tr>
<tr class="separator:a0393c7e87efbe788419774c662cba5a2 inherit pub_methods_classSG_1_1AuxVectorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a863ff9b970004c403c1398d24b1f60e7 inherit pub_methods_classSG_1_1AuxVectorBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a863ff9b970004c403c1398d24b1f60e7"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html#a863ff9b970004c403c1398d24b1f60e7">~AuxVectorBase</a> ()</td></tr>
<tr class="memdesc:a863ff9b970004c403c1398d24b1f60e7 inherit pub_methods_classSG_1_1AuxVectorBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr class="separator:a863ff9b970004c403c1398d24b1f60e7 inherit pub_methods_classSG_1_1AuxVectorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae905757bbac29e780e4010eaf52ea01e inherit pub_methods_classSG_1_1AuxVectorBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae905757bbac29e780e4010eaf52ea01e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html#ae905757bbac29e780e4010eaf52ea01e">trackIndices</a> () const </td></tr>
<tr class="memdesc:ae905757bbac29e780e4010eaf52ea01e inherit pub_methods_classSG_1_1AuxVectorBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if index tracking is enabled for this container. <br/></td></tr>
<tr class="separator:ae905757bbac29e780e4010eaf52ea01e inherit pub_methods_classSG_1_1AuxVectorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa21603645adb97780ff75af26630bfad inherit pub_methods_classSG_1_1AuxVectorBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html#aa21603645adb97780ff75af26630bfad">setStore</a> (const <a class="el" href="../../d3/dd5/classSG_1_1IConstAuxStore.html">SG::IConstAuxStore</a> *store)</td></tr>
<tr class="memdesc:aa21603645adb97780ff75af26630bfad inherit pub_methods_classSG_1_1AuxVectorBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the store associated with this object.  <a href="#aa21603645adb97780ff75af26630bfad">More...</a><br/></td></tr>
<tr class="separator:aa21603645adb97780ff75af26630bfad inherit pub_methods_classSG_1_1AuxVectorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58659470f0f2e27560cbe691eefce9c3 inherit pub_methods_classSG_1_1AuxVectorBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html#a58659470f0f2e27560cbe691eefce9c3">setStore</a> (<a class="el" href="../../dc/d05/classSG_1_1IAuxStore.html">SG::IAuxStore</a> *store)</td></tr>
<tr class="memdesc:a58659470f0f2e27560cbe691eefce9c3 inherit pub_methods_classSG_1_1AuxVectorBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the store associated with this object.  <a href="#a58659470f0f2e27560cbe691eefce9c3">More...</a><br/></td></tr>
<tr class="separator:a58659470f0f2e27560cbe691eefce9c3 inherit pub_methods_classSG_1_1AuxVectorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2893a7ee3b1f5c7bc7d5cc5ce65d6e16 inherit pub_methods_classSG_1_1AuxVectorBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html#a2893a7ee3b1f5c7bc7d5cc5ce65d6e16">setStore</a> (const <a class="el" href="../../da/da2/classDataLink.html">DataLink</a>&lt; <a class="el" href="../../d3/dd5/classSG_1_1IConstAuxStore.html">SG::IConstAuxStore</a> &gt; &amp;store)</td></tr>
<tr class="memdesc:a2893a7ee3b1f5c7bc7d5cc5ce65d6e16 inherit pub_methods_classSG_1_1AuxVectorBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the store associated with this object.  <a href="#a2893a7ee3b1f5c7bc7d5cc5ce65d6e16">More...</a><br/></td></tr>
<tr class="separator:a2893a7ee3b1f5c7bc7d5cc5ce65d6e16 inherit pub_methods_classSG_1_1AuxVectorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8223a5c9a9af0a9dbb8fc268cd0ea832 inherit pub_methods_classSG_1_1AuxVectorBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html#a8223a5c9a9af0a9dbb8fc268cd0ea832">setConstStore</a> (const <a class="el" href="../../d3/dd5/classSG_1_1IConstAuxStore.html">SG::IConstAuxStore</a> *store)</td></tr>
<tr class="memdesc:a8223a5c9a9af0a9dbb8fc268cd0ea832 inherit pub_methods_classSG_1_1AuxVectorBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym for <code>setStore</code> with <code><a class="el" href="../../d3/dd5/classSG_1_1IConstAuxStore.html" title="Interface for const operations on an auxiliary store. ">IConstAuxStore</a></code>.  <a href="#a8223a5c9a9af0a9dbb8fc268cd0ea832">More...</a><br/></td></tr>
<tr class="separator:a8223a5c9a9af0a9dbb8fc268cd0ea832 inherit pub_methods_classSG_1_1AuxVectorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4786cd7b376a4a33d840715f44b3d01f inherit pub_methods_classSG_1_1AuxVectorBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html#a4786cd7b376a4a33d840715f44b3d01f">setNonConstStore</a> (<a class="el" href="../../dc/d05/classSG_1_1IAuxStore.html">SG::IAuxStore</a> *store)</td></tr>
<tr class="memdesc:a4786cd7b376a4a33d840715f44b3d01f inherit pub_methods_classSG_1_1AuxVectorBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym for <code>setStore</code> with <code><a class="el" href="../../dc/d05/classSG_1_1IAuxStore.html" title="Interface for non-const operations on an auxiliary store. ">IAuxStore</a></code>.  <a href="#a4786cd7b376a4a33d840715f44b3d01f">More...</a><br/></td></tr>
<tr class="separator:a4786cd7b376a4a33d840715f44b3d01f inherit pub_methods_classSG_1_1AuxVectorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSG_1_1AuxVectorData"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSG_1_1AuxVectorData')"><img src="../../closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html">SG::AuxVectorData</a></td></tr>
<tr class="memitem:ac03d380d92722ca597c92da17ed08972 inherit pub_methods_classSG_1_1AuxVectorData"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac03d380d92722ca597c92da17ed08972"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#ac03d380d92722ca597c92da17ed08972">AuxVectorData</a> ()</td></tr>
<tr class="memdesc:ac03d380d92722ca597c92da17ed08972 inherit pub_methods_classSG_1_1AuxVectorData"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br/></td></tr>
<tr class="separator:ac03d380d92722ca597c92da17ed08972 inherit pub_methods_classSG_1_1AuxVectorData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c4723c7dd4279ff096d77b4832eb99 inherit pub_methods_classSG_1_1AuxVectorData"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2c4723c7dd4279ff096d77b4832eb99"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#ad2c4723c7dd4279ff096d77b4832eb99">~AuxVectorData</a> ()</td></tr>
<tr class="memdesc:ad2c4723c7dd4279ff096d77b4832eb99 inherit pub_methods_classSG_1_1AuxVectorData"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr class="separator:ad2c4723c7dd4279ff096d77b4832eb99 inherit pub_methods_classSG_1_1AuxVectorData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea4d64e4a85beda13d1243ece5d210e2 inherit pub_methods_classSG_1_1AuxVectorData"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#aea4d64e4a85beda13d1243ece5d210e2">swap</a> (<a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html">AuxVectorData</a> &amp;other)</td></tr>
<tr class="memdesc:aea4d64e4a85beda13d1243ece5d210e2 inherit pub_methods_classSG_1_1AuxVectorData"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap this instance with another.  <a href="#aea4d64e4a85beda13d1243ece5d210e2">More...</a><br/></td></tr>
<tr class="separator:aea4d64e4a85beda13d1243ece5d210e2 inherit pub_methods_classSG_1_1AuxVectorData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d6d9eefd8811b373b3eeda823e5c0ad inherit pub_methods_classSG_1_1AuxVectorData"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#a5d6d9eefd8811b373b3eeda823e5c0ad">clearCache</a> ()</td></tr>
<tr class="memdesc:a5d6d9eefd8811b373b3eeda823e5c0ad inherit pub_methods_classSG_1_1AuxVectorData"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the cached aux data pointers.  <a href="#a5d6d9eefd8811b373b3eeda823e5c0ad">More...</a><br/></td></tr>
<tr class="separator:a5d6d9eefd8811b373b3eeda823e5c0ad inherit pub_methods_classSG_1_1AuxVectorData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4379058b2eb0522291c4c20076ef7967 inherit pub_methods_classSG_1_1AuxVectorData"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#a4379058b2eb0522291c4c20076ef7967">lock</a> () ATH_OVERRIDE</td></tr>
<tr class="memdesc:a4379058b2eb0522291c4c20076ef7967 inherit pub_methods_classSG_1_1AuxVectorData"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the container.  <a href="#a4379058b2eb0522291c4c20076ef7967">More...</a><br/></td></tr>
<tr class="separator:a4379058b2eb0522291c4c20076ef7967 inherit pub_methods_classSG_1_1AuxVectorData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c86d28fd74648ddae868dc5fa005d2 inherit pub_methods_classSG_1_1AuxVectorData"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#a35c86d28fd74648ddae868dc5fa005d2">clearDecorations</a> () const </td></tr>
<tr class="memdesc:a35c86d28fd74648ddae868dc5fa005d2 inherit pub_methods_classSG_1_1AuxVectorData"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all decorations.  <a href="#a35c86d28fd74648ddae868dc5fa005d2">More...</a><br/></td></tr>
<tr class="separator:a35c86d28fd74648ddae868dc5fa005d2 inherit pub_methods_classSG_1_1AuxVectorData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe342233ecc5416805b44a47db63815a inherit pub_methods_classSG_1_1AuxVectorData"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d59/namespaceSG.html#a1a8bcc4ee42936e2b794bac38e0f6de0">SG::auxid_set_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#abe342233ecc5416805b44a47db63815a">getAuxIDs</a> () const </td></tr>
<tr class="memdesc:abe342233ecc5416805b44a47db63815a inherit pub_methods_classSG_1_1AuxVectorData"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a set of identifiers for existing data items in store associated with this object.  <a href="#abe342233ecc5416805b44a47db63815a">More...</a><br/></td></tr>
<tr class="separator:abe342233ecc5416805b44a47db63815a inherit pub_methods_classSG_1_1AuxVectorData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d2ca97c7546abb52972902ff47a275 inherit pub_methods_classSG_1_1AuxVectorData"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d59/namespaceSG.html#a1a8bcc4ee42936e2b794bac38e0f6de0">SG::auxid_set_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#a52d2ca97c7546abb52972902ff47a275">getWritableAuxIDs</a> () const </td></tr>
<tr class="memdesc:a52d2ca97c7546abb52972902ff47a275 inherit pub_methods_classSG_1_1AuxVectorData"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a set of identifiers for writable data items in this store.  <a href="#a52d2ca97c7546abb52972902ff47a275">More...</a><br/></td></tr>
<tr class="separator:a52d2ca97c7546abb52972902ff47a275 inherit pub_methods_classSG_1_1AuxVectorData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff7bce34ddc38433ed057fab2b0e9280 inherit pub_methods_classSG_1_1AuxVectorData"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#aff7bce34ddc38433ed057fab2b0e9280">isAvailable</a> (<a class="el" href="../../dd/d59/namespaceSG.html#affee481ab18822e03866e0a0d3ff011c">auxid_t</a> id) const </td></tr>
<tr class="memdesc:aff7bce34ddc38433ed057fab2b0e9280 inherit pub_methods_classSG_1_1AuxVectorData"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test to see if a variable exists in the store.  <a href="#aff7bce34ddc38433ed057fab2b0e9280">More...</a><br/></td></tr>
<tr class="separator:aff7bce34ddc38433ed057fab2b0e9280 inherit pub_methods_classSG_1_1AuxVectorData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a296b108b94c2b60cf894f05cbea26 inherit pub_methods_classSG_1_1AuxVectorData"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a08a296b108b94c2b60cf894f05cbea26 inherit pub_methods_classSG_1_1AuxVectorData"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#a08a296b108b94c2b60cf894f05cbea26">isAvailable</a> (const std::string &amp;name, const std::string &amp;clsname=&quot;&quot;) const </td></tr>
<tr class="memdesc:a08a296b108b94c2b60cf894f05cbea26 inherit pub_methods_classSG_1_1AuxVectorData"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test to see if a variable exists in the store.  <a href="#a08a296b108b94c2b60cf894f05cbea26">More...</a><br/></td></tr>
<tr class="separator:a08a296b108b94c2b60cf894f05cbea26 inherit pub_methods_classSG_1_1AuxVectorData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02bd683426600b15e16ae9d7ba88b589 inherit pub_methods_classSG_1_1AuxVectorData"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#a02bd683426600b15e16ae9d7ba88b589">isAvailableWritable</a> (<a class="el" href="../../dd/d59/namespaceSG.html#affee481ab18822e03866e0a0d3ff011c">auxid_t</a> id) const </td></tr>
<tr class="memdesc:a02bd683426600b15e16ae9d7ba88b589 inherit pub_methods_classSG_1_1AuxVectorData"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test to see if a variable is available for writing.  <a href="#a02bd683426600b15e16ae9d7ba88b589">More...</a><br/></td></tr>
<tr class="separator:a02bd683426600b15e16ae9d7ba88b589 inherit pub_methods_classSG_1_1AuxVectorData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab191e8b91f040d3f8bdb35ca97fef04c inherit pub_methods_classSG_1_1AuxVectorData"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab191e8b91f040d3f8bdb35ca97fef04c inherit pub_methods_classSG_1_1AuxVectorData"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#ab191e8b91f040d3f8bdb35ca97fef04c">isAvailableWritable</a> (const std::string &amp;name, const std::string &amp;clsname=&quot;&quot;) const </td></tr>
<tr class="memdesc:ab191e8b91f040d3f8bdb35ca97fef04c inherit pub_methods_classSG_1_1AuxVectorData"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test to see if a variable is available for writing.  <a href="#ab191e8b91f040d3f8bdb35ca97fef04c">More...</a><br/></td></tr>
<tr class="separator:ab191e8b91f040d3f8bdb35ca97fef04c inherit pub_methods_classSG_1_1AuxVectorData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f2136a2be890f5cf9e12b01342d50de inherit pub_methods_classSG_1_1AuxVectorData"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#a3f2136a2be890f5cf9e12b01342d50de">isAvailableWritableAsDecoration</a> (<a class="el" href="../../dd/d59/namespaceSG.html#affee481ab18822e03866e0a0d3ff011c">auxid_t</a> id) const </td></tr>
<tr class="memdesc:a3f2136a2be890f5cf9e12b01342d50de inherit pub_methods_classSG_1_1AuxVectorData"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test to see if a variable is available for writing as a decoration.  <a href="#a3f2136a2be890f5cf9e12b01342d50de">More...</a><br/></td></tr>
<tr class="separator:a3f2136a2be890f5cf9e12b01342d50de inherit pub_methods_classSG_1_1AuxVectorData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4848d1566f78ee97f73b33741e2035c inherit pub_methods_classSG_1_1AuxVectorData"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab4848d1566f78ee97f73b33741e2035c inherit pub_methods_classSG_1_1AuxVectorData"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#ab4848d1566f78ee97f73b33741e2035c">isAvailableWritableAsDecoration</a> (const std::string &amp;name, const std::string &amp;clsname=&quot;&quot;) const </td></tr>
<tr class="memdesc:ab4848d1566f78ee97f73b33741e2035c inherit pub_methods_classSG_1_1AuxVectorData"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test to see if a variable is available for writing as a decoration.  <a href="#ab4848d1566f78ee97f73b33741e2035c">More...</a><br/></td></tr>
<tr class="separator:ab4848d1566f78ee97f73b33741e2035c inherit pub_methods_classSG_1_1AuxVectorData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9234d6da5484f6699a4fe2a4873eb617 inherit pub_methods_classSG_1_1AuxVectorData"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a9234d6da5484f6699a4fe2a4873eb617 inherit pub_methods_classSG_1_1AuxVectorData"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d0/d6e/classSG_1_1AuxDataTraits.html">AuxDataTraits</a>&lt; T &gt;::reference_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#a9234d6da5484f6699a4fe2a4873eb617">getData</a> (<a class="el" href="../../dd/d59/namespaceSG.html#affee481ab18822e03866e0a0d3ff011c">SG::auxid_t</a> auxid, size_t ndx)</td></tr>
<tr class="memdesc:a9234d6da5484f6699a4fe2a4873eb617 inherit pub_methods_classSG_1_1AuxVectorData"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return reference to an aux data item.  <a href="#a9234d6da5484f6699a4fe2a4873eb617">More...</a><br/></td></tr>
<tr class="separator:a9234d6da5484f6699a4fe2a4873eb617 inherit pub_methods_classSG_1_1AuxVectorData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c5a911acaf8b8981bc81bed93184532 inherit pub_methods_classSG_1_1AuxVectorData"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a0c5a911acaf8b8981bc81bed93184532 inherit pub_methods_classSG_1_1AuxVectorData"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d0/d6e/classSG_1_1AuxDataTraits.html">AuxDataTraits</a>&lt; T &gt;<br class="typebreak"/>
::const_reference_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#a0c5a911acaf8b8981bc81bed93184532">getData</a> (<a class="el" href="../../dd/d59/namespaceSG.html#affee481ab18822e03866e0a0d3ff011c">SG::auxid_t</a> auxid, size_t ndx) const </td></tr>
<tr class="memdesc:a0c5a911acaf8b8981bc81bed93184532 inherit pub_methods_classSG_1_1AuxVectorData"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return const reference to an aux data item.  <a href="#a0c5a911acaf8b8981bc81bed93184532">More...</a><br/></td></tr>
<tr class="separator:a0c5a911acaf8b8981bc81bed93184532 inherit pub_methods_classSG_1_1AuxVectorData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae171198131dc47c28e9eb9074eb82421 inherit pub_methods_classSG_1_1AuxVectorData"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae171198131dc47c28e9eb9074eb82421 inherit pub_methods_classSG_1_1AuxVectorData"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d0/d6e/classSG_1_1AuxDataTraits.html">AuxDataTraits</a>&lt; T &gt;::reference_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#ae171198131dc47c28e9eb9074eb82421">getDecoration</a> (<a class="el" href="../../dd/d59/namespaceSG.html#affee481ab18822e03866e0a0d3ff011c">SG::auxid_t</a> auxid, size_t ndx) const </td></tr>
<tr class="memdesc:ae171198131dc47c28e9eb9074eb82421 inherit pub_methods_classSG_1_1AuxVectorData"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return reference to an aux decoration item.  <a href="#ae171198131dc47c28e9eb9074eb82421">More...</a><br/></td></tr>
<tr class="separator:ae171198131dc47c28e9eb9074eb82421 inherit pub_methods_classSG_1_1AuxVectorData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac60d418d024c0970f058e147b2e0ee6c inherit pub_methods_classSG_1_1AuxVectorData"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#ac60d418d024c0970f058e147b2e0ee6c">getDataArray</a> (<a class="el" href="../../dd/d59/namespaceSG.html#affee481ab18822e03866e0a0d3ff011c">SG::auxid_t</a> auxid) const </td></tr>
<tr class="memdesc:ac60d418d024c0970f058e147b2e0ee6c inherit pub_methods_classSG_1_1AuxVectorData"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const pointer to the start of an aux data vector.  <a href="#ac60d418d024c0970f058e147b2e0ee6c">More...</a><br/></td></tr>
<tr class="separator:ac60d418d024c0970f058e147b2e0ee6c inherit pub_methods_classSG_1_1AuxVectorData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ef17864033f73d8b7d4a516241a138 inherit pub_methods_classSG_1_1AuxVectorData"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#ae5ef17864033f73d8b7d4a516241a138">getDataArrayAllowMissing</a> (<a class="el" href="../../dd/d59/namespaceSG.html#affee481ab18822e03866e0a0d3ff011c">SG::auxid_t</a> auxid) const </td></tr>
<tr class="memdesc:ae5ef17864033f73d8b7d4a516241a138 inherit pub_methods_classSG_1_1AuxVectorData"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const pointer to the start of an aux data vector.  <a href="#ae5ef17864033f73d8b7d4a516241a138">More...</a><br/></td></tr>
<tr class="separator:ae5ef17864033f73d8b7d4a516241a138 inherit pub_methods_classSG_1_1AuxVectorData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a239b57ce5e7833bb83c8f0bf3b390814 inherit pub_methods_classSG_1_1AuxVectorData"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d3/dd5/classSG_1_1IConstAuxStore.html">SG::IConstAuxStore</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#a239b57ce5e7833bb83c8f0bf3b390814">getConstStore</a> () const </td></tr>
<tr class="memdesc:a239b57ce5e7833bb83c8f0bf3b390814 inherit pub_methods_classSG_1_1AuxVectorData"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current store, as a const interface.  <a href="#a239b57ce5e7833bb83c8f0bf3b390814">More...</a><br/></td></tr>
<tr class="separator:a239b57ce5e7833bb83c8f0bf3b390814 inherit pub_methods_classSG_1_1AuxVectorData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d8f5f0dd148fbf2041560f77ab0113 inherit pub_methods_classSG_1_1AuxVectorData"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/d05/classSG_1_1IAuxStore.html">SG::IAuxStore</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#af1d8f5f0dd148fbf2041560f77ab0113">getStore</a> () const </td></tr>
<tr class="memdesc:af1d8f5f0dd148fbf2041560f77ab0113 inherit pub_methods_classSG_1_1AuxVectorData"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current store, as a non-const interface.  <a href="#af1d8f5f0dd148fbf2041560f77ab0113">More...</a><br/></td></tr>
<tr class="separator:af1d8f5f0dd148fbf2041560f77ab0113 inherit pub_methods_classSG_1_1AuxVectorData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae11026ce063feb9b55456698ef2a4f inherit pub_methods_classSG_1_1AuxVectorData"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ae11026ce063feb9b55456698ef2a4f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#a7ae11026ce063feb9b55456698ef2a4f">hasStore</a> () const </td></tr>
<tr class="memdesc:a7ae11026ce063feb9b55456698ef2a4f inherit pub_methods_classSG_1_1AuxVectorData"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this object has an associated store. <br/></td></tr>
<tr class="separator:a7ae11026ce063feb9b55456698ef2a4f inherit pub_methods_classSG_1_1AuxVectorData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b5279b30e60d9b099cb6496404c1aa inherit pub_methods_classSG_1_1AuxVectorData"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97b5279b30e60d9b099cb6496404c1aa"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#a97b5279b30e60d9b099cb6496404c1aa">hasNonConstStore</a> () const </td></tr>
<tr class="memdesc:a97b5279b30e60d9b099cb6496404c1aa inherit pub_methods_classSG_1_1AuxVectorData"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this object has an associated non-const store. <br/></td></tr>
<tr class="separator:a97b5279b30e60d9b099cb6496404c1aa inherit pub_methods_classSG_1_1AuxVectorData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adad5487f0cdf6cd0d7de68dd84570324 inherit pub_methods_classSG_1_1AuxVectorData"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#adad5487f0cdf6cd0d7de68dd84570324">setOption</a> (<a class="el" href="../../dd/d59/namespaceSG.html#affee481ab18822e03866e0a0d3ff011c">auxid_t</a> id, const <a class="el" href="../../d7/d31/classSG_1_1AuxDataOption.html">AuxDataOption</a> &amp;option)</td></tr>
<tr class="memdesc:adad5487f0cdf6cd0d7de68dd84570324 inherit pub_methods_classSG_1_1AuxVectorData"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an option for an auxiliary data variable.  <a href="#adad5487f0cdf6cd0d7de68dd84570324">More...</a><br/></td></tr>
<tr class="separator:adad5487f0cdf6cd0d7de68dd84570324 inherit pub_methods_classSG_1_1AuxVectorData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f683bea801877c1001faa8116679ac4 inherit pub_methods_classSG_1_1AuxVectorData"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#a6f683bea801877c1001faa8116679ac4">setOption</a> (const std::string &amp;name, const <a class="el" href="../../d7/d31/classSG_1_1AuxDataOption.html">AuxDataOption</a> &amp;option)</td></tr>
<tr class="memdesc:a6f683bea801877c1001faa8116679ac4 inherit pub_methods_classSG_1_1AuxVectorData"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an option for an auxiliary data variable.  <a href="#a6f683bea801877c1001faa8116679ac4">More...</a><br/></td></tr>
<tr class="separator:a6f683bea801877c1001faa8116679ac4 inherit pub_methods_classSG_1_1AuxVectorData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49a59f74e1b4e28fc637d0fbfc8ec80 inherit pub_methods_classSG_1_1AuxVectorData"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#ab49a59f74e1b4e28fc637d0fbfc8ec80">setOption</a> (const std::string &amp;name, const std::string &amp;clsname, const <a class="el" href="../../d7/d31/classSG_1_1AuxDataOption.html">AuxDataOption</a> &amp;option)</td></tr>
<tr class="memdesc:ab49a59f74e1b4e28fc637d0fbfc8ec80 inherit pub_methods_classSG_1_1AuxVectorData"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an option for an auxiliary data variable.  <a href="#ab49a59f74e1b4e28fc637d0fbfc8ec80">More...</a><br/></td></tr>
<tr class="separator:ab49a59f74e1b4e28fc637d0fbfc8ec80 inherit pub_methods_classSG_1_1AuxVectorData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b3fbcb003e51c6f527aa309503a5cb inherit pub_methods_classSG_1_1AuxVectorData"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a36b3fbcb003e51c6f527aa309503a5cb inherit pub_methods_classSG_1_1AuxVectorData"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#a36b3fbcb003e51c6f527aa309503a5cb">setOption</a> (<a class="el" href="../../dd/d59/namespaceSG.html#affee481ab18822e03866e0a0d3ff011c">auxid_t</a> id, const std::string &amp;optname, T arg)</td></tr>
<tr class="memdesc:a36b3fbcb003e51c6f527aa309503a5cb inherit pub_methods_classSG_1_1AuxVectorData"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an option for an auxiliary data variable.  <a href="#a36b3fbcb003e51c6f527aa309503a5cb">More...</a><br/></td></tr>
<tr class="separator:a36b3fbcb003e51c6f527aa309503a5cb inherit pub_methods_classSG_1_1AuxVectorData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e648949c78a087367e8788dca149f2 inherit pub_methods_classSG_1_1AuxVectorData"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#a51e648949c78a087367e8788dca149f2">setOption</a> (const std::string &amp;name, const std::string &amp;optname, int arg)</td></tr>
<tr class="memdesc:a51e648949c78a087367e8788dca149f2 inherit pub_methods_classSG_1_1AuxVectorData"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an option for an auxiliary data variable.  <a href="#a51e648949c78a087367e8788dca149f2">More...</a><br/></td></tr>
<tr class="separator:a51e648949c78a087367e8788dca149f2 inherit pub_methods_classSG_1_1AuxVectorData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f4c954520372ce1381365cf0f8bee4 inherit pub_methods_classSG_1_1AuxVectorData"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae2f4c954520372ce1381365cf0f8bee4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>setOption</b> (const std::string &amp;name, const std::string &amp;optname, float arg)</td></tr>
<tr class="separator:ae2f4c954520372ce1381365cf0f8bee4 inherit pub_methods_classSG_1_1AuxVectorData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf14a816b4340b01e21b19fe76e8d4a inherit pub_methods_classSG_1_1AuxVectorData"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9bf14a816b4340b01e21b19fe76e8d4a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>setOption</b> (const std::string &amp;name, const std::string &amp;optname, double arg)</td></tr>
<tr class="separator:a9bf14a816b4340b01e21b19fe76e8d4a inherit pub_methods_classSG_1_1AuxVectorData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d807cdcacfd4bd97e565690495e8a4e inherit pub_methods_classSG_1_1AuxVectorData"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a4d807cdcacfd4bd97e565690495e8a4e inherit pub_methods_classSG_1_1AuxVectorData"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#a4d807cdcacfd4bd97e565690495e8a4e">setOption</a> (const std::string &amp;name, const std::string &amp;clsname, const std::string &amp;optname, T arg)</td></tr>
<tr class="memdesc:a4d807cdcacfd4bd97e565690495e8a4e inherit pub_methods_classSG_1_1AuxVectorData"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an option for an auxiliary data variable.  <a href="#a4d807cdcacfd4bd97e565690495e8a4e">More...</a><br/></td></tr>
<tr class="separator:a4d807cdcacfd4bd97e565690495e8a4e inherit pub_methods_classSG_1_1AuxVectorData"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:aa9b859c5e4d9bb75d44cba2e72690238"><td class="memItemLeft" align="right" valign="top">static const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#aa9b859c5e4d9bb75d44cba2e72690238">has_virtual</a> = false</td></tr>
<tr class="separator:aa9b859c5e4d9bb75d44cba2e72690238"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Swap and sort.</h2></td></tr>
<tr class="memitem:ace0665d0ab6fd551aeee44eca9a29a40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#ace0665d0ab6fd551aeee44eca9a29a40">swap</a> (<a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a> &amp;rhs)</td></tr>
<tr class="memdesc:ace0665d0ab6fd551aeee44eca9a29a40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap this collection with another.  <a href="#ace0665d0ab6fd551aeee44eca9a29a40">More...</a><br/></td></tr>
<tr class="separator:ace0665d0ab6fd551aeee44eca9a29a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b8b5064b52bcb7921b973abad09a8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#ab3b8b5064b52bcb7921b973abad09a8f">sort</a> ()</td></tr>
<tr class="memdesc:ab3b8b5064b52bcb7921b973abad09a8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the container.  <a href="#ab3b8b5064b52bcb7921b973abad09a8f">More...</a><br/></td></tr>
<tr class="separator:ab3b8b5064b52bcb7921b973abad09a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab188873786887e4909ac01239b08a8"><td class="memTemplParams" colspan="2">template&lt;class COMPARE &gt; </td></tr>
<tr class="memitem:acab188873786887e4909ac01239b08a8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#acab188873786887e4909ac01239b08a8">sort</a> (COMPARE comp)</td></tr>
<tr class="memdesc:acab188873786887e4909ac01239b08a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the container with a user-specified comparison operator.  <a href="#acab188873786887e4909ac01239b08a8">More...</a><br/></td></tr>
<tr class="separator:acab188873786887e4909ac01239b08a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a1ee3a77f7504b7a8f3d475f7cdd003"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a1a1ee3a77f7504b7a8f3d475f7cdd003">iter_swap</a> (<a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a0a24970f8d3743d873f69407fbf76872">iterator</a> a, <a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a0a24970f8d3743d873f69407fbf76872">iterator</a> b)</td></tr>
<tr class="memdesc:a1a1ee3a77f7504b7a8f3d475f7cdd003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the referents of two <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;. ">DataVector</a></code> iterators.  <a href="#a1a1ee3a77f7504b7a8f3d475f7cdd003">More...</a><br/></td></tr>
<tr class="separator:a1a1ee3a77f7504b7a8f3d475f7cdd003"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Non-standard operations.</h2></td></tr>
<tr class="memitem:abff69b3413c3e0a912f9d5589f4257e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#abff69b3413c3e0a912f9d5589f4257e9">swapElement</a> (size_type index, value_type newElem, reference oldElem)</td></tr>
<tr class="memdesc:abff69b3413c3e0a912f9d5589f4257e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap one element out of the container.  <a href="#abff69b3413c3e0a912f9d5589f4257e9">More...</a><br/></td></tr>
<tr class="separator:abff69b3413c3e0a912f9d5589f4257e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d41d8c4ab49f649b4fd20dbe648abd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a88d41d8c4ab49f649b4fd20dbe648abd">swapElement</a> (<a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a0a24970f8d3743d873f69407fbf76872">iterator</a> pos, value_type newElem, reference oldElem)</td></tr>
<tr class="memdesc:a88d41d8c4ab49f649b4fd20dbe648abd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap one element out of the container.  <a href="#a88d41d8c4ab49f649b4fd20dbe648abd">More...</a><br/></td></tr>
<tr class="separator:a88d41d8c4ab49f649b4fd20dbe648abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc7f275d2bc73e00c010828a4a5224f9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a9037cb597ab293dcf843bd9f5d88699f">PtrVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#adc7f275d2bc73e00c010828a4a5224f9">stdcont</a> () const </td></tr>
<tr class="memdesc:adc7f275d2bc73e00c010828a4a5224f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the underlying <code>std::vector</code> of the container.  <a href="#adc7f275d2bc73e00c010828a4a5224f9">More...</a><br/></td></tr>
<tr class="separator:adc7f275d2bc73e00c010828a4a5224f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0f040ba00e37768ecf92319cf7edcf0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0f040ba00e37768ecf92319cf7edcf0"></a>
<a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">SG::OwnershipPolicy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#af0f040ba00e37768ecf92319cf7edcf0">ownPolicy</a> () const </td></tr>
<tr class="memdesc:af0f040ba00e37768ecf92319cf7edcf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the ownership policy setting for this container. <br/></td></tr>
<tr class="separator:af0f040ba00e37768ecf92319cf7edcf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab8e11d10424034b008a627825e8093d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#aab8e11d10424034b008a627825e8093d">clear</a> (<a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">SG::OwnershipPolicy</a> <a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#af0f040ba00e37768ecf92319cf7edcf0">ownPolicy</a>)</td></tr>
<tr class="memdesc:aab8e11d10424034b008a627825e8093d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase all the elements in the collection, and reset the ownership mode.  <a href="#aab8e11d10424034b008a627825e8093d">More...</a><br/></td></tr>
<tr class="separator:aab8e11d10424034b008a627825e8093d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa047639d69932b1f94bf7016a6a2c4b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#aa047639d69932b1f94bf7016a6a2c4b7">clear</a> (<a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">SG::OwnershipPolicy</a> <a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#af0f040ba00e37768ecf92319cf7edcf0">ownPolicy</a>, <a class="el" href="../../dd/d59/namespaceSG.html#a9f3d699f65390b7f8baf54d9cd634573">SG::IndexTrackingPolicy</a> <a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html#ae905757bbac29e780e4010eaf52ea01e">trackIndices</a>)</td></tr>
<tr class="memdesc:aa047639d69932b1f94bf7016a6a2c4b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase all the elements in the collection, and reset the ownership mode.  <a href="#aa047639d69932b1f94bf7016a6a2c4b7">More...</a><br/></td></tr>
<tr class="separator:aa047639d69932b1f94bf7016a6a2c4b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd040d558ec4796705c57c66acfeacd3"><td class="memItemLeft" align="right" valign="top">virtual const <br class="typebreak"/>
<a class="el" href="../../da/d8a/classDataModel__detail_1_1DVLInfoBase.html">DataModel_detail::DVLInfoBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#abd040d558ec4796705c57c66acfeacd3">dvlinfo_v</a> () const </td></tr>
<tr class="memdesc:abd040d558ec4796705c57c66acfeacd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the DV/DL info struct for this class.  <a href="#abd040d558ec4796705c57c66acfeacd3">More...</a><br/></td></tr>
<tr class="separator:abd040d558ec4796705c57c66acfeacd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40b46f3b01ddc62478a0d98663325f0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html">SG::AuxVectorBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#ae40b46f3b01ddc62478a0d98663325f0">auxbase</a> () const </td></tr>
<tr class="memdesc:ae40b46f3b01ddc62478a0d98663325f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to <code>AuxVectorBase</code>.  <a href="#ae40b46f3b01ddc62478a0d98663325f0">More...</a><br/></td></tr>
<tr class="separator:ae40b46f3b01ddc62478a0d98663325f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01f7224a0d87d4c8d10678a80b39d27"><td class="memItemLeft" align="right" valign="top">static const <br class="typebreak"/>
<a class="el" href="../../da/d8a/classDataModel__detail_1_1DVLInfoBase.html">DataModel_detail::DVLInfoBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#af01f7224a0d87d4c8d10678a80b39d27">dvlinfo</a> ()</td></tr>
<tr class="memdesc:af01f7224a0d87d4c8d10678a80b39d27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the DV/DL info struct for this class.  <a href="#af01f7224a0d87d4c8d10678a80b39d27">More...</a><br/></td></tr>
<tr class="separator:af01f7224a0d87d4c8d10678a80b39d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54a54329e84fd2c5fcc780fc2a43ead6"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a54a54329e84fd2c5fcc780fc2a43ead6">baseOffset</a> (const std::type_info &amp;ti)</td></tr>
<tr class="memdesc:a54a54329e84fd2c5fcc780fc2a43ead6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the offset of a base <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;. ">DataVector</a></code> class.  <a href="#a54a54329e84fd2c5fcc780fc2a43ead6">More...</a><br/></td></tr>
<tr class="separator:a54a54329e84fd2c5fcc780fc2a43ead6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Internal operations.</h2></td></tr>
<tr class="memitem:a2cf6a773e2f312ccade13b686b8f01d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2cf6a773e2f312ccade13b686b8f01d6"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>DataModel_detail::ElementProxy&lt; DataVector &gt;</b></td></tr>
<tr class="separator:a2cf6a773e2f312ccade13b686b8f01d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a872beca4ae4bd23ae0ca85253466b96b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a872beca4ae4bd23ae0ca85253466b96b"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>ConstDataVector&lt; DataVector &gt;</b></td></tr>
<tr class="separator:a872beca4ae4bd23ae0ca85253466b96b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1119a539ef95e66a83ed73e65ce4acb9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1119a539ef95e66a83ed73e65ce4acb9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>test2_assignelement1</b> ()</td></tr>
<tr class="separator:a1119a539ef95e66a83ed73e65ce4acb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d549df8562ac32795e7bebf440b830d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d549df8562ac32795e7bebf440b830d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>test2_assignelement2</b> ()</td></tr>
<tr class="separator:a5d549df8562ac32795e7bebf440b830d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a205453f4c7420d058d1179766b292c87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">SG::OwnershipPolicy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a205453f4c7420d058d1179766b292c87">m_ownPolicy</a></td></tr>
<tr class="separator:a205453f4c7420d058d1179766b292c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f75d3161735bae23b4b0018f5dbef2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01f75d3161735bae23b4b0018f5dbef2"></a>
<a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a9037cb597ab293dcf843bd9f5d88699f">PtrVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a01f75d3161735bae23b4b0018f5dbef2">m_pCont</a></td></tr>
<tr class="memdesc:a01f75d3161735bae23b4b0018f5dbef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This actually holds the elements. <br/></td></tr>
<tr class="separator:a01f75d3161735bae23b4b0018f5dbef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4de50491cb3c3dc239fd4d52c7151d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#ab4de50491cb3c3dc239fd4d52c7151d7">resortAux</a> (<a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a0a24970f8d3743d873f69407fbf76872">iterator</a> beg, <a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a0a24970f8d3743d873f69407fbf76872">iterator</a> <a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a4c31b486a1b577d581bcded32f8c0d4a">end</a>)</td></tr>
<tr class="memdesc:ab4de50491cb3c3dc239fd4d52c7151d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset indices / reorder aux data after elements have been permuted.  <a href="#ab4de50491cb3c3dc239fd4d52c7151d7">More...</a><br/></td></tr>
<tr class="separator:ab4de50491cb3c3dc239fd4d52c7151d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191f1812d1e0bfab56d0ecb4e1902138"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a191f1812d1e0bfab56d0ecb4e1902138">testInsert</a> (const char *op)</td></tr>
<tr class="memdesc:a191f1812d1e0bfab56d0ecb4e1902138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if we can insert; raise an exception if not.  <a href="#a191f1812d1e0bfab56d0ecb4e1902138">More...</a><br/></td></tr>
<tr class="separator:a191f1812d1e0bfab56d0ecb4e1902138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c19881e3c41eb3a9ebbb24627ba7bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a64c19881e3c41eb3a9ebbb24627ba7bf">testInsertOol</a> (const char *op)</td></tr>
<tr class="memdesc:a64c19881e3c41eb3a9ebbb24627ba7bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if we can insert; raise an exception if not.  <a href="#a64c19881e3c41eb3a9ebbb24627ba7bf">More...</a><br/></td></tr>
<tr class="separator:a64c19881e3c41eb3a9ebbb24627ba7bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a162843eb42a30aa266bb3053af9e7abb"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a162843eb42a30aa266bb3053af9e7abb">baseOffset1</a> (const char *p, const <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a> &amp;dv, const std::type_info &amp;ti)</td></tr>
<tr class="memdesc:a162843eb42a30aa266bb3053af9e7abb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for <code>baseOffset</code>.  <a href="#a162843eb42a30aa266bb3053af9e7abb">More...</a><br/></td></tr>
<tr class="separator:a162843eb42a30aa266bb3053af9e7abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31431efcf2f87c3775b7c7c5e5e7081d"><td class="memItemLeft" align="right" valign="top">static const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a31431efcf2f87c3775b7c7c5e5e7081d">do_cast</a> (const typename PtrVector::value_type p)</td></tr>
<tr class="memdesc:a31431efcf2f87c3775b7c7c5e5e7081d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to shorten calls to <code><a class="el" href="../../de/d59/structDataModel__detail_1_1DVLCast.html" title="casting operations for DataVector/DataList. ">DataModel_detail::DVLCast</a></code>.  <a href="#a31431efcf2f87c3775b7c7c5e5e7081d">More...</a><br/></td></tr>
<tr class="separator:a31431efcf2f87c3775b7c7c5e5e7081d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0208dd537831fad033198a40aa0fcaf3"><td class="memItemLeft" align="right" valign="top">PtrVector::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a0208dd537831fad033198a40aa0fcaf3">erase_base</a> (typename PtrVector::iterator position)</td></tr>
<tr class="memdesc:a0208dd537831fad033198a40aa0fcaf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for <code><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a5e41132c55010e688115f1ed6cc0edab" title="Remove element at a given position. ">erase()</a></code>. Remove element at a given position.  <a href="#a0208dd537831fad033198a40aa0fcaf3">More...</a><br/></td></tr>
<tr class="separator:a0208dd537831fad033198a40aa0fcaf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b1da673ca3bba86c926acd40f986e6a"><td class="memItemLeft" align="right" valign="top">PtrVector::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a9b1da673ca3bba86c926acd40f986e6a">erase_base</a> (typename PtrVector::iterator first, typename PtrVector::iterator last)</td></tr>
<tr class="memdesc:a9b1da673ca3bba86c926acd40f986e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for <code><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a5e41132c55010e688115f1ed6cc0edab" title="Remove element at a given position. ">erase()</a></code>. Remove a range of elements.  <a href="#a9b1da673ca3bba86c926acd40f986e6a">More...</a><br/></td></tr>
<tr class="separator:a9b1da673ca3bba86c926acd40f986e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74c23e2aba33eb2ce6817c563b6c8917"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a74c23e2aba33eb2ce6817c563b6c8917">clearMostDerived</a> ()</td></tr>
<tr class="memdesc:a74c23e2aba33eb2ce6817c563b6c8917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear <code>m_isMostDerived</code> for this instance and for all bases.  <a href="#a74c23e2aba33eb2ce6817c563b6c8917">More...</a><br/></td></tr>
<tr class="separator:a74c23e2aba33eb2ce6817c563b6c8917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc9461741ecfa4b568e91b3e79abe1d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#abfc9461741ecfa4b568e91b3e79abe1d">setMostDerived</a> ()</td></tr>
<tr class="memdesc:abfc9461741ecfa4b568e91b3e79abe1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <code>m_isMostDerived</code> for this instance and clear it for all bases.  <a href="#abfc9461741ecfa4b568e91b3e79abe1d">More...</a><br/></td></tr>
<tr class="separator:abfc9461741ecfa4b568e91b3e79abe1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classSG_1_1AuxVectorBase"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classSG_1_1AuxVectorBase')"><img src="../../closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html">SG::AuxVectorBase</a></td></tr>
<tr class="memitem:afa59d7092a4f0e3f362056fa0de1eaf3 inherit pro_methods_classSG_1_1AuxVectorBase"><td class="memTemplParams" colspan="2">template&lt;class DVL &gt; </td></tr>
<tr class="memitem:afa59d7092a4f0e3f362056fa0de1eaf3 inherit pro_methods_classSG_1_1AuxVectorBase"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html#afa59d7092a4f0e3f362056fa0de1eaf3">initAuxVectorBase</a> (<a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">SG::OwnershipPolicy</a> ownPolicy, <a class="el" href="../../dd/d59/namespaceSG.html#a9f3d699f65390b7f8baf54d9cd634573">SG::IndexTrackingPolicy</a> indexTrackingPolicy)</td></tr>
<tr class="memdesc:afa59d7092a4f0e3f362056fa0de1eaf3 inherit pro_methods_classSG_1_1AuxVectorBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize index tracking mode.  <a href="#afa59d7092a4f0e3f362056fa0de1eaf3">More...</a><br/></td></tr>
<tr class="separator:afa59d7092a4f0e3f362056fa0de1eaf3 inherit pro_methods_classSG_1_1AuxVectorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1413cec813bba2f0cba00cd3136e7131 inherit pro_methods_classSG_1_1AuxVectorBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html#a1413cec813bba2f0cba00cd3136e7131">swap</a> (<a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html">AuxVectorBase</a> &amp;other)</td></tr>
<tr class="memdesc:a1413cec813bba2f0cba00cd3136e7131 inherit pro_methods_classSG_1_1AuxVectorBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap with another container.  <a href="#a1413cec813bba2f0cba00cd3136e7131">More...</a><br/></td></tr>
<tr class="separator:a1413cec813bba2f0cba00cd3136e7131 inherit pro_methods_classSG_1_1AuxVectorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af373d84b80c0a3c360c677fe69174016 inherit pro_methods_classSG_1_1AuxVectorBase"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:af373d84b80c0a3c360c677fe69174016 inherit pro_methods_classSG_1_1AuxVectorBase"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html#af373d84b80c0a3c360c677fe69174016">setIndices</a> (ForwardIterator beg, ForwardIterator end, size_t first=0)</td></tr>
<tr class="memdesc:af373d84b80c0a3c360c677fe69174016 inherit pro_methods_classSG_1_1AuxVectorBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set container/index for all elements within a range.  <a href="#af373d84b80c0a3c360c677fe69174016">More...</a><br/></td></tr>
<tr class="separator:af373d84b80c0a3c360c677fe69174016 inherit pro_methods_classSG_1_1AuxVectorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b8aed6fd2c9f1148350e2c30d7e1a0 inherit pro_methods_classSG_1_1AuxVectorBase"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:a20b8aed6fd2c9f1148350e2c30d7e1a0 inherit pro_methods_classSG_1_1AuxVectorBase"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html#a20b8aed6fd2c9f1148350e2c30d7e1a0">clearIndex</a> (ForwardIterator elt)</td></tr>
<tr class="memdesc:a20b8aed6fd2c9f1148350e2c30d7e1a0 inherit pro_methods_classSG_1_1AuxVectorBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the container / index for element <code>elt</code>.  <a href="#a20b8aed6fd2c9f1148350e2c30d7e1a0">More...</a><br/></td></tr>
<tr class="separator:a20b8aed6fd2c9f1148350e2c30d7e1a0 inherit pro_methods_classSG_1_1AuxVectorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad841e9fdd67d64cb7dc3aef1e99afdc5 inherit pro_methods_classSG_1_1AuxVectorBase"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:ad841e9fdd67d64cb7dc3aef1e99afdc5 inherit pro_methods_classSG_1_1AuxVectorBase"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html#ad841e9fdd67d64cb7dc3aef1e99afdc5">clearIndices</a> (ForwardIterator beg, ForwardIterator end)</td></tr>
<tr class="memdesc:ad841e9fdd67d64cb7dc3aef1e99afdc5 inherit pro_methods_classSG_1_1AuxVectorBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the container / index for a range of elements.  <a href="#ad841e9fdd67d64cb7dc3aef1e99afdc5">More...</a><br/></td></tr>
<tr class="separator:ad841e9fdd67d64cb7dc3aef1e99afdc5 inherit pro_methods_classSG_1_1AuxVectorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d8bbb097e83b09bf80b48281eb3dbb inherit pro_methods_classSG_1_1AuxVectorBase"><td class="memTemplParams" colspan="2">template&lt;class DVL &gt; </td></tr>
<tr class="memitem:a52d8bbb097e83b09bf80b48281eb3dbb inherit pro_methods_classSG_1_1AuxVectorBase"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html#a52d8bbb097e83b09bf80b48281eb3dbb">resize</a> (size_t size)</td></tr>
<tr class="memdesc:a52d8bbb097e83b09bf80b48281eb3dbb inherit pro_methods_classSG_1_1AuxVectorBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the aux data associated with this container.  <a href="#a52d8bbb097e83b09bf80b48281eb3dbb">More...</a><br/></td></tr>
<tr class="separator:a52d8bbb097e83b09bf80b48281eb3dbb inherit pro_methods_classSG_1_1AuxVectorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89fc1c2ef1e9adab376df9657011ac5a inherit pro_methods_classSG_1_1AuxVectorBase"><td class="memTemplParams" colspan="2">template&lt;class DVL &gt; </td></tr>
<tr class="memitem:a89fc1c2ef1e9adab376df9657011ac5a inherit pro_methods_classSG_1_1AuxVectorBase"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html#a89fc1c2ef1e9adab376df9657011ac5a">reserve</a> (size_t size)</td></tr>
<tr class="memdesc:a89fc1c2ef1e9adab376df9657011ac5a inherit pro_methods_classSG_1_1AuxVectorBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the capacity of the aux data associated with this container.  <a href="#a89fc1c2ef1e9adab376df9657011ac5a">More...</a><br/></td></tr>
<tr class="separator:a89fc1c2ef1e9adab376df9657011ac5a inherit pro_methods_classSG_1_1AuxVectorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd5c082d546fac4bca3d04f8c2b21fc inherit pro_methods_classSG_1_1AuxVectorBase"><td class="memTemplParams" colspan="2">template&lt;class DVL &gt; </td></tr>
<tr class="memitem:a8dd5c082d546fac4bca3d04f8c2b21fc inherit pro_methods_classSG_1_1AuxVectorBase"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html#a8dd5c082d546fac4bca3d04f8c2b21fc">shift</a> (DVL &amp;cont, size_t pos, ptrdiff_t offs)</td></tr>
<tr class="memdesc:a8dd5c082d546fac4bca3d04f8c2b21fc inherit pro_methods_classSG_1_1AuxVectorBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift the elements of the container.  <a href="#a8dd5c082d546fac4bca3d04f8c2b21fc">More...</a><br/></td></tr>
<tr class="separator:a8dd5c082d546fac4bca3d04f8c2b21fc inherit pro_methods_classSG_1_1AuxVectorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4be9ca08792014774acdd5218bd27a0 inherit pro_methods_classSG_1_1AuxVectorBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html#ad4be9ca08792014774acdd5218bd27a0">moveAux</a> (size_t index, <a class="el" href="../../dc/db0/classSG_1_1AuxElement.html">SG::AuxElement</a> *p, bool clear=false)</td></tr>
<tr class="memdesc:ad4be9ca08792014774acdd5218bd27a0 inherit pro_methods_classSG_1_1AuxVectorBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set index on an element and copy auxiliary data.  <a href="#ad4be9ca08792014774acdd5218bd27a0">More...</a><br/></td></tr>
<tr class="separator:ad4be9ca08792014774acdd5218bd27a0 inherit pro_methods_classSG_1_1AuxVectorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f4139a7242cdcce76a9cbff3bfd9ca2 inherit pro_methods_classSG_1_1AuxVectorBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html#a8f4139a7242cdcce76a9cbff3bfd9ca2">moveAux</a> (size_t index, const void *p, bool clear=false)</td></tr>
<tr class="memdesc:a8f4139a7242cdcce76a9cbff3bfd9ca2 inherit pro_methods_classSG_1_1AuxVectorBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set index on an element and copy auxiliary data.  <a href="#a8f4139a7242cdcce76a9cbff3bfd9ca2">More...</a><br/></td></tr>
<tr class="separator:a8f4139a7242cdcce76a9cbff3bfd9ca2 inherit pro_methods_classSG_1_1AuxVectorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe349e201c72dd81480c68bc9d775653 inherit pro_methods_classSG_1_1AuxVectorBase"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:afe349e201c72dd81480c68bc9d775653 inherit pro_methods_classSG_1_1AuxVectorBase"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html#afe349e201c72dd81480c68bc9d775653">moveAux</a> (size_t index, ForwardIterator beg, ForwardIterator end)</td></tr>
<tr class="memdesc:afe349e201c72dd81480c68bc9d775653 inherit pro_methods_classSG_1_1AuxVectorBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set index on a range of elements and copy auxiliary data.  <a href="#afe349e201c72dd81480c68bc9d775653">More...</a><br/></td></tr>
<tr class="separator:afe349e201c72dd81480c68bc9d775653 inherit pro_methods_classSG_1_1AuxVectorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3105544a00e10c72e45ca7367bb43e87 inherit pro_methods_classSG_1_1AuxVectorBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html#a3105544a00e10c72e45ca7367bb43e87">swapElementsAux</a> (size_t aindex, size_t bindex, <a class="el" href="../../dc/db0/classSG_1_1AuxElement.html">SG::AuxElement</a> *a, <a class="el" href="../../dc/db0/classSG_1_1AuxElement.html">SG::AuxElement</a> *b, <a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html">AuxVectorBase</a> *bcont)</td></tr>
<tr class="memdesc:a3105544a00e10c72e45ca7367bb43e87 inherit pro_methods_classSG_1_1AuxVectorBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap indices and auxiliary data between two elements.  <a href="#a3105544a00e10c72e45ca7367bb43e87">More...</a><br/></td></tr>
<tr class="separator:a3105544a00e10c72e45ca7367bb43e87 inherit pro_methods_classSG_1_1AuxVectorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e040f5014d7e5f77bfa8a1ae866dddc inherit pro_methods_classSG_1_1AuxVectorBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html#a3e040f5014d7e5f77bfa8a1ae866dddc">swapElementsAux</a> (size_t aindex, size_t bindex, const void *a, const void *b, <a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html">AuxVectorBase</a> *bcont)</td></tr>
<tr class="memdesc:a3e040f5014d7e5f77bfa8a1ae866dddc inherit pro_methods_classSG_1_1AuxVectorBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap indices and auxiliary data between two elements.  <a href="#a3e040f5014d7e5f77bfa8a1ae866dddc">More...</a><br/></td></tr>
<tr class="separator:a3e040f5014d7e5f77bfa8a1ae866dddc inherit pro_methods_classSG_1_1AuxVectorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1cf4f7e14c1fd9f28d9a6b92b1ad36b inherit pro_methods_classSG_1_1AuxVectorBase"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:af1cf4f7e14c1fd9f28d9a6b92b1ad36b inherit pro_methods_classSG_1_1AuxVectorBase"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html#af1cf4f7e14c1fd9f28d9a6b92b1ad36b">resortAux</a> (size_t index, ForwardIterator beg, ForwardIterator end)</td></tr>
<tr class="memdesc:af1cf4f7e14c1fd9f28d9a6b92b1ad36b inherit pro_methods_classSG_1_1AuxVectorBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset indices / reorder aux data after elements have been permuted.  <a href="#af1cf4f7e14c1fd9f28d9a6b92b1ad36b">More...</a><br/></td></tr>
<tr class="separator:af1cf4f7e14c1fd9f28d9a6b92b1ad36b inherit pro_methods_classSG_1_1AuxVectorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classSG_1_1AuxVectorData"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classSG_1_1AuxVectorData')"><img src="../../closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html">SG::AuxVectorData</a></td></tr>
<tr class="memitem:a9d9f283f683d509706b255b47f80719f inherit pro_methods_classSG_1_1AuxVectorData"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#a9d9f283f683d509706b255b47f80719f">getDataArray</a> (<a class="el" href="../../dd/d59/namespaceSG.html#affee481ab18822e03866e0a0d3ff011c">SG::auxid_t</a> auxid)</td></tr>
<tr class="memdesc:a9d9f283f683d509706b255b47f80719f inherit pro_methods_classSG_1_1AuxVectorData"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the start of an aux data vector.  <a href="#a9d9f283f683d509706b255b47f80719f">More...</a><br/></td></tr>
<tr class="separator:a9d9f283f683d509706b255b47f80719f inherit pro_methods_classSG_1_1AuxVectorData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42670ce61a36909d86c7cda581c38535 inherit pro_methods_classSG_1_1AuxVectorData"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#a42670ce61a36909d86c7cda581c38535">getDecorationArray</a> (<a class="el" href="../../dd/d59/namespaceSG.html#affee481ab18822e03866e0a0d3ff011c">SG::auxid_t</a> auxid) const </td></tr>
<tr class="memdesc:a42670ce61a36909d86c7cda581c38535 inherit pro_methods_classSG_1_1AuxVectorData"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the start of an aux data vector for a decoration.  <a href="#a42670ce61a36909d86c7cda581c38535">More...</a><br/></td></tr>
<tr class="separator:a42670ce61a36909d86c7cda581c38535 inherit pro_methods_classSG_1_1AuxVectorData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6e2da3c14ea74935120cd1b5a37f021 inherit pro_methods_classSG_1_1AuxVectorData"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#af6e2da3c14ea74935120cd1b5a37f021">setStore</a> (const <a class="el" href="../../d3/dd5/classSG_1_1IConstAuxStore.html">SG::IConstAuxStore</a> *store)</td></tr>
<tr class="memdesc:af6e2da3c14ea74935120cd1b5a37f021 inherit pro_methods_classSG_1_1AuxVectorData"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the store associated with this object.  <a href="#af6e2da3c14ea74935120cd1b5a37f021">More...</a><br/></td></tr>
<tr class="separator:af6e2da3c14ea74935120cd1b5a37f021 inherit pro_methods_classSG_1_1AuxVectorData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1980ceb02ed996944d1f2508d128d91c inherit pro_methods_classSG_1_1AuxVectorData"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#a1980ceb02ed996944d1f2508d128d91c">setStore</a> (<a class="el" href="../../dc/d05/classSG_1_1IAuxStore.html">SG::IAuxStore</a> *store)</td></tr>
<tr class="memdesc:a1980ceb02ed996944d1f2508d128d91c inherit pro_methods_classSG_1_1AuxVectorData"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the store associated with this object.  <a href="#a1980ceb02ed996944d1f2508d128d91c">More...</a><br/></td></tr>
<tr class="separator:a1980ceb02ed996944d1f2508d128d91c inherit pro_methods_classSG_1_1AuxVectorData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c013e89eb83e984483ee34fc91d68c inherit pro_methods_classSG_1_1AuxVectorData"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#a49c013e89eb83e984483ee34fc91d68c">setStore</a> (const <a class="el" href="../../da/da2/classDataLink.html">DataLink</a>&lt; <a class="el" href="../../d3/dd5/classSG_1_1IConstAuxStore.html">SG::IConstAuxStore</a> &gt; &amp;store)</td></tr>
<tr class="memdesc:a49c013e89eb83e984483ee34fc91d68c inherit pro_methods_classSG_1_1AuxVectorData"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the store associated with this object.  <a href="#a49c013e89eb83e984483ee34fc91d68c">More...</a><br/></td></tr>
<tr class="separator:a49c013e89eb83e984483ee34fc91d68c inherit pro_methods_classSG_1_1AuxVectorData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_attribs_classSG_1_1AuxVectorData"><td colspan="2" onclick="javascript:toggleInherit('pro_static_attribs_classSG_1_1AuxVectorData')"><img src="../../closed.png" alt="-"/>&#160;Static Protected Attributes inherited from <a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html">SG::AuxVectorData</a></td></tr>
<tr class="memitem:a95f42871b1d206674b8f49a8cd73ae55 inherit pro_static_attribs_classSG_1_1AuxVectorData"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#a95f42871b1d206674b8f49a8cd73ae55">s_minCacheLen</a> = 1024</td></tr>
<tr class="memdesc:a95f42871b1d206674b8f49a8cd73ae55 inherit pro_static_attribs_classSG_1_1AuxVectorData"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum length to use for the cache vector.  <a href="#a95f42871b1d206674b8f49a8cd73ae55">More...</a><br/></td></tr>
<tr class="separator:a95f42871b1d206674b8f49a8cd73ae55 inherit pro_static_attribs_classSG_1_1AuxVectorData"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br/>
class DataVector&lt; T, DataModel_detail::NoBase &gt;</h3>

<p>Base specialization for <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;. ">DataVector</a>&lt;T&gt;</code>. </p>
<p>This is used for the case where <code>T</code> does not derive from other classes. This is the class which actually holds the vector of pointers.</p>
<p>See the file comments for full details. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="adc2ad3e5de641d68b5490651f15d9448"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::<a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#adc2ad3e5de641d68b5490651f15d9448">base_value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <code>T</code> value used as the template parameter. Note that this is different from <code>value_type</code> (that's <code>T*</code>). </p>

</div>
</div>
<a class="anchor" id="a99ab9c1706c2cd3273ec27a4b218ccfa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="../../d7/d05/classDataModel__detail_1_1ElementProxy.html">DataModel_detail::ElementProxy</a>&lt;<a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&gt; <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::<a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a99ab9c1706c2cd3273ec27a4b218ccfa">ElementProxy</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This type is used to proxy lvalue accesses to <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;. ">DataVector</a></code> elements, in order to handle ownership. </p>

</div>
</div>
<a class="anchor" id="a0a24970f8d3743d873f69407fbf76872"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="../../d5/d70/classDataModel__detail_1_1iterator.html">DataModel_detail::iterator</a>&lt;<a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&gt; <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::<a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a0a24970f8d3743d873f69407fbf76872">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Standard <code>iterator</code>. Note that lvalue references here will yield an <code>ElementProxy</code>, not a <code>reference</code>. </p>

</div>
</div>
<a class="anchor" id="a9037cb597ab293dcf843bd9f5d88699f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;T*&gt; <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::<a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a9037cb597ab293dcf843bd9f5d88699f">PtrVector</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the type of the underlying <code>std::vector</code> (what <code>stdcont</code> returns). </p>

</div>
</div>
<a class="anchor" id="a3551d2e1bdbe02ade11f731cfb976f4f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::reverse_iterator&lt;<a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a0a24970f8d3743d873f69407fbf76872">iterator</a>&gt; <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::<a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a3551d2e1bdbe02ade11f731cfb976f4f">reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Standard <code>reverse_iterator</code>. Note that lvalue references here will yield an <code>ElementProxy</code>, not a <code>reference</code>. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a51d310761242622f1b5329a6fe398e51"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::<a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">SG::OwnershipPolicy</a>&#160;</td>
          <td class="paramname"><em>ownPolicy</em> = <code><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8a1f65f0fb55784cfd27d9d4d6d7986d4d">SG::OWN_ELEMENTS</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d59/namespaceSG.html#a9f3d699f65390b7f8baf54d9cd634573">SG::IndexTrackingPolicy</a>&#160;</td>
          <td class="paramname"><em>trackIndices</em> = <code><a class="el" href="../../dd/d59/namespaceSG.html#a9f3d699f65390b7f8baf54d9cd634573ad08b3b1af2cb1dd45428b131f9f05ad7">SG::DEFAULT_TRACK_INDICES</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ownPolicy</td><td>The ownership mode for the container. </td></tr>
    <tr><td class="paramname">trackIndices</td><td>The index tracking policy.</td></tr>
  </table>
  </dd>
</dl>
<p>By default, a <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;. ">DataVector</a></code> will own its elements. To avoid this, pass <code><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8ad7d4cf2303700f0966e4140f236c4bf1" title="this data object is a view, it does not own its elmts ">SG::VIEW_ELEMENTS</a></code> for <em>ownPolicy</em>. </p>

</div>
</div>
<a class="anchor" id="acd6dcc16e6805765bd3b11f9124d4e76"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::<a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a> </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">SG::OwnershipPolicy</a>&#160;</td>
          <td class="paramname"><em>ownPolicy</em> = <code><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8a1f65f0fb55784cfd27d9d4d6d7986d4d">SG::OWN_ELEMENTS</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d59/namespaceSG.html#a9f3d699f65390b7f8baf54d9cd634573">SG::IndexTrackingPolicy</a>&#160;</td>
          <td class="paramname"><em>trackIndices</em> = <code><a class="el" href="../../dd/d59/namespaceSG.html#a9f3d699f65390b7f8baf54d9cd634573ad08b3b1af2cb1dd45428b131f9f05ad7">SG::DEFAULT_TRACK_INDICES</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sized constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The size of the container. </td></tr>
    <tr><td class="paramname">ownPolicy</td><td>The ownership mode for the container. </td></tr>
    <tr><td class="paramname">trackIndices</td><td>The index tracking policy.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that unlike the standard vector constructor, you can't specify an initial value here. The container will be initialized with 0's.</p>
<p>By default, a <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;. ">DataVector</a></code> will own its elements. To avoid this, pass <code><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8ad7d4cf2303700f0966e4140f236c4bf1" title="this data object is a view, it does not own its elmts ">SG::VIEW_ELEMENTS</a></code> for <em>ownPolicy</em>. </p>

</div>
</div>
<a class="anchor" id="a507c03514b600a8808c0d50e5f2292ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::<a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The container from which to copy.</td></tr>
  </table>
  </dd>
</dl>
<p>This is a `shallow' copy; the new container will not own its elements. </p>

</div>
</div>
<a class="anchor" id="a297de4aad003ac89136a56ba1c030e99"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::<a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a> </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">SG::OwnershipPolicy</a>&#160;</td>
          <td class="paramname"><em>ownPolicy</em> = <code><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8ad7d4cf2303700f0966e4140f236c4bf1">SG::VIEW_ELEMENTS</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d59/namespaceSG.html#a9f3d699f65390b7f8baf54d9cd634573">SG::IndexTrackingPolicy</a>&#160;</td>
          <td class="paramname"><em>trackIndices</em> = <code><a class="el" href="../../dd/d59/namespaceSG.html#a9f3d699f65390b7f8baf54d9cd634573ad08b3b1af2cb1dd45428b131f9f05ad7">SG::DEFAULT_TRACK_INDICES</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d05/classSG_1_1IAuxStore.html">SG::IAuxStore</a> *&#160;</td>
          <td class="paramname"><em>store</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor from iterators. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The start of the range to put in the new container. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the range to put in the new container. </td></tr>
    <tr><td class="paramname">ownPolicy</td><td>The ownership mode for the container. </td></tr>
    <tr><td class="paramname">trackIndices</td><td>The index tracking policy. </td></tr>
    <tr><td class="paramname">store</td><td>An associated auxiliary data store.</td></tr>
  </table>
  </dd>
</dl>
<p>By default, a <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;. ">DataVector</a></code> will own its elements (and take ownership of the pointers passed to this constructor). To avoid this, pass <code><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8ad7d4cf2303700f0966e4140f236c4bf1" title="this data object is a view, it does not own its elmts ">SG::VIEW_ELEMENTS</a></code> for <em>ownPolicy</em>. </p>

</div>
</div>
<a class="anchor" id="ab824ffa2d0adf0efec55d86c236e069c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::~<a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>If this container owns its elements, the contained elements will be deleted as well. Before doing this, the destructor will scan for duplicate pointers (takes <img class="formulaInl" alt="$n \log n$" src="../../form_1.png"/> time); duplicates are only destroyed once. Duplicates should, however, be considered an error; don't rely on this behavior. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a8a54fbd06bf7ba56bfdba9a8a5aedf4a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign from iterators. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The start of the range to put in the container. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the range to put in the container.</td></tr>
  </table>
  </dd>
</dl>
<p>Any existing owned elements will be released. The <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;. ">DataVector</a>'s</code> ownership policy determines whether it will take ownership of the new elements. </p>

</div>
</div>
<a class="anchor" id="aa8ea77da44d88c17ebb3ab9c3f6d78e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access an element, as an rvalue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Array index to access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element at <em>n</em>.</dd></dl>
<p>Will raise <code>std::out_of_range</code> if the index is out-of-bounds. Note that we return a <code>const</code> <code>T*</code> rather than a reference. </p>

</div>
</div>
<a class="anchor" id="a3744541d5aee9f68ea81cbe58e474fec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a99ab9c1706c2cd3273ec27a4b218ccfa">ElementProxy</a> <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access an element, as an lvalue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Array index to access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Proxy to the element at <em>n</em>.</dd></dl>
<p>Will raise <code>std::out_of_range</code> if the index is out-of-bounds. Note that we return a proxy object rather than a reference; the proxy will handle deleting an owned element if it's assigned to. </p>

</div>
</div>
<a class="anchor" id="ae40b46f3b01ddc62478a0d98663325f0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dd/da5/classSG_1_1AuxVectorBase.html">SG::AuxVectorBase</a>&amp; <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::auxbase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to <code>AuxVectorBase</code>. </p>
<p>Needed to get  AuxVectorBase from a <code><a class="el" href="../../de/db1/classConstDataVector.html" title="DataVector adapter that acts like it holds const pointers. ">ConstDataVector</a></code>. Present in <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;. ">DataVector</a></code> as well for consistency. </p>

</div>
</div>
<a class="anchor" id="a94471e13ddf6ee1c7808d032b60d40a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the last element in the collection as an rvalue. </p>
<dl class="section return"><dt>Returns</dt><dd>The last element in the collection.</dd></dl>
<p>No checking is done to ensure that the container is not empty. Note that we return a <code>const</code> <code>T*</code> rather than a reference. </p>

</div>
</div>
<a class="anchor" id="a0ded16015ae169fe929ab34eda1c079a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a99ab9c1706c2cd3273ec27a4b218ccfa">ElementProxy</a> <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the last element in the collection as an lvalue. </p>
<dl class="section return"><dt>Returns</dt><dd>Proxy to the last element in the collection.</dd></dl>
<p>No checking is done to ensure that the container is not empty. Note that we return a proxy object rather than a reference; the proxy will handle deleting an owned element if it's assigned to. </p>

</div>
</div>
<a class="anchor" id="a54a54329e84fd2c5fcc780fc2a43ead6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::baseOffset </td>
          <td>(</td>
          <td class="paramtype">const std::type_info &amp;&#160;</td>
          <td class="paramname"><em>ti</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the offset of a base <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;. ">DataVector</a></code> class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ti</td><td><code>std::type_info</code> of the desired class.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>ti</code> represents a <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;. ">DataVector</a></code> base class of this one, then return the offset of that base class. Otherwise, return -1.</p>
<p>This function is here due to limitations of root 6, which can't calculate these offsets correctly from the dictionary if virtual derivation is used. </p>

</div>
</div>
<a class="anchor" id="a162843eb42a30aa266bb3053af9e7abb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::baseOffset1 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::type_info &amp;&#160;</td>
          <td class="paramname"><em>ti</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper for <code>baseOffset</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to the start of the top-level object. </td></tr>
    <tr><td class="paramname">dv</td><td>Reference to the <a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;. ">DataVector</a> object. </td></tr>
    <tr><td class="paramname">ti</td><td><code>std::type_info</code> of the desired class.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>ti</code> represents a <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;. ">DataVector</a></code> base class of this one, then return the offset of that base class. Otherwise, return -1. </p>

</div>
</div>
<a class="anchor" id="a31fc0611d6e14e7dc95a7444b5389786"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#ad14d8fa936e56241eea1626b464c3b8c">const_iterator</a> <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a <code>const_iterator</code> pointing at the beginning of the collection. </p>
<dl class="section return"><dt>Returns</dt><dd>A <code>const_iterator</code>.</dd></dl>
<p>Note that dereferencing the iterator will yield a <code>const</code> <code>T*</code> rather than a reference. </p>

</div>
</div>
<a class="anchor" id="a016e07a7a7a825f01214a03d136381cb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a0a24970f8d3743d873f69407fbf76872">iterator</a> <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an <code>iterator</code> pointing at the beginning of the collection. </p>
<dl class="section return"><dt>Returns</dt><dd>An <code>iterator</code>.</dd></dl>
<p>Note that dereferencing the iterator will yield a proxy rather than a reference; the proxy will handle deleting an owned element if it's assigned to. </p>

</div>
</div>
<a class="anchor" id="a236a9f58b14de59ef54c5107dfcff5dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_type <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::capacity_v </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of elements that the collection can hold before needing to allocate more memory. </p>
<p>This version is virtual, to be callable from the AuxData base class. </p>

<p>Implements <a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#aa05239b04a4e91b0bcc8da201f2cccaa">SG::AuxVectorData</a>.</p>

</div>
</div>
<a class="anchor" id="a865ba4448ebb8fcb61ed2ebe69a900fc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#ad14d8fa936e56241eea1626b464c3b8c">const_iterator</a> <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a <code>const_iterator</code> pointing at the beginning of the collection. </p>
<dl class="section return"><dt>Returns</dt><dd>A <code>const_iterator</code>.</dd></dl>
<p>Note that dereferencing the iterator will yield a <code>const</code> <code>T*</code> rather than a reference. </p>

</div>
</div>
<a class="anchor" id="a87f60ec41043c1ef5dfb5b50dd4b08d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#ad14d8fa936e56241eea1626b464c3b8c">const_iterator</a> <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a <code>const_iterator</code> pointing past the end of the collection. </p>
<dl class="section return"><dt>Returns</dt><dd>A <code>const_iterator</code>.</dd></dl>
<p>Note that dereferencing the iterator will yield a <code>const</code> <code>T*</code> rather than a reference. </p>

</div>
</div>
<a class="anchor" id="a3292a55621ae0171766b2f8e9d067436"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase all the elements in the collection. </p>
<p>If the container owns its elements, then the removed elements will be deleted. Any duplicates will be removed in this process, but don't rely on this. </p>

</div>
</div>
<a class="anchor" id="aab8e11d10424034b008a627825e8093d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">SG::OwnershipPolicy</a>&#160;</td>
          <td class="paramname"><em>ownPolicy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase all the elements in the collection, and reset the ownership mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ownPolicy</td><td>The new ownership policy of the container.</td></tr>
  </table>
  </dd>
</dl>
<p>If the container owns its elements, then the removed elements will be deleted. Any duplicates will be removed in this process, but don't rely on this. </p>

</div>
</div>
<a class="anchor" id="aa047639d69932b1f94bf7016a6a2c4b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">SG::OwnershipPolicy</a>&#160;</td>
          <td class="paramname"><em>ownPolicy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d59/namespaceSG.html#a9f3d699f65390b7f8baf54d9cd634573">SG::IndexTrackingPolicy</a>&#160;</td>
          <td class="paramname"><em>trackIndices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase all the elements in the collection, and reset the ownership mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ownPolicy</td><td>The new ownership policy of the container. </td></tr>
    <tr><td class="paramname">trackIndices</td><td>The index tracking policy.</td></tr>
  </table>
  </dd>
</dl>
<p>If the container owns its elements, then the removed elements will be deleted. Any duplicates will be removed in this process, but don't rely on this. </p>

</div>
</div>
<a class="anchor" id="a74c23e2aba33eb2ce6817c563b6c8917"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::clearMostDerived </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear <code>m_isMostDerived</code> for this instance and for all bases. </p>
<p>Called from the constructor after setting <code>m_isMostDerived</code>. </p>

</div>
</div>
<a class="anchor" id="a1d1064401af7c90703d0a2f79136e0ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a61d77f0c504d473f85376ddce8bd2163">const_reverse_iterator</a> <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a <code>const_reverse_iterator</code> pointing past the end of the collection. </p>
<dl class="section return"><dt>Returns</dt><dd>A <code>const_reverse_iterator</code>.</dd></dl>
<p>Note that dereferencing the iterator will yield a <code>const</code> <code>T*</code> rather than a reference. </p>

</div>
</div>
<a class="anchor" id="afed788d8db665532545478186925b3a6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a61d77f0c504d473f85376ddce8bd2163">const_reverse_iterator</a> <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a <code>const_reverse_iterator</code> pointing at the beginning of the collection. </p>
<dl class="section return"><dt>Returns</dt><dd>A <code>const_reverse_iterator</code>.</dd></dl>
<p>Note that dereferencing the iterator will yield a <code>const</code> <code>T*</code> rather than a reference. </p>

</div>
</div>
<a class="anchor" id="a31431efcf2f87c3775b7c7c5e5e7081d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const T* <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::do_cast </td>
          <td>(</td>
          <td class="paramtype">const typename PtrVector::value_type&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper to shorten calls to <code><a class="el" href="../../de/d59/structDataModel__detail_1_1DVLCast.html" title="casting operations for DataVector/DataList. ">DataModel_detail::DVLCast</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The value to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value as a <code>const</code> <code>T*</code>.</dd></dl>
<p>This is a no-op for the base class. </p>

</div>
</div>
<a class="anchor" id="af01f7224a0d87d4c8d10678a80b39d27"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="../../da/d8a/classDataModel__detail_1_1DVLInfoBase.html">DataModel_detail::DVLInfoBase</a>&amp; <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::dvlinfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the DV/DL info struct for this class. </p>
<p>This can be used to make sure that it's instantiated. </p>

</div>
</div>
<a class="anchor" id="abd040d558ec4796705c57c66acfeacd3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="../../da/d8a/classDataModel__detail_1_1DVLInfoBase.html">DataModel_detail::DVLInfoBase</a>&amp; <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::dvlinfo_v </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the DV/DL info struct for this class. </p>
<p>This can be used to make sure that it's instantiated. </p>

</div>
</div>
<a class="anchor" id="a728e46d92c5d2d0cdce9e2ce51bab6d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a0a24970f8d3743d873f69407fbf76872">iterator</a> <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a0a24970f8d3743d873f69407fbf76872">iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>pElem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new element to the collection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>Iterator before which the element will be added. </td></tr>
    <tr><td class="paramname">pElem</td><td>The element to add to the collection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the inserted data.</dd></dl>
<p>The container's ownership policy will determine if it takes ownership of the new element.</p>
<p>Note: this method may only be called using the most derived <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;. ">DataVector</a></code> in the hierarchy.</p>
<p>For <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;. ">DataVector</a></code>, this is just the same as <code>insert</code>. It's included just for interface compatibility with <code>std::vector</code>. </p>

</div>
</div>
<a class="anchor" id="a54e962bbda1ab83d0b892a0be604c0e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::emplace_back </td>
          <td>(</td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>pElem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an element to the end of the collection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pElem</td><td>The element to add to the collection.</td></tr>
  </table>
  </dd>
</dl>
<p>The container's ownership policy will determine if it takes ownership of the new element.</p>
<p>Note: this method may only be called using the most derived <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;. ">DataVector</a></code> in the hierarchy.</p>
<p>For <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;. ">DataVector</a></code>, this is just the same as <code>push_back</code>. It's included just for interface compatibility with <code>std::vector</code>. </p>

</div>
</div>
<a class="anchor" id="a4c31b486a1b577d581bcded32f8c0d4a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#ad14d8fa936e56241eea1626b464c3b8c">const_iterator</a> <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a <code>const_iterator</code> pointing past the end of the collection. </p>
<dl class="section return"><dt>Returns</dt><dd>A <code>const_iterator</code>.</dd></dl>
<p>Note that dereferencing the iterator will yield a <code>const</code> <code>T*</code> rather than a reference. </p>

</div>
</div>
<a class="anchor" id="a084ec53b556ed4283f598bdd33398943"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a0a24970f8d3743d873f69407fbf76872">iterator</a> <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an <code>iterator</code> pointing past the end of the collection. </p>
<dl class="section return"><dt>Returns</dt><dd>An <code>iterator</code>.</dd></dl>
<p>Note that dereferencing the iterator will yield a proxy rather than a reference; the proxy will handle deleting an owned element if it's assigned to. </p>

</div>
</div>
<a class="anchor" id="a5e41132c55010e688115f1ed6cc0edab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a0a24970f8d3743d873f69407fbf76872">iterator</a> <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a0a24970f8d3743d873f69407fbf76872">iterator</a>&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove element at a given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>Iterator pointing to the element to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the next element (or <code><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a084ec53b556ed4283f598bdd33398943" title="Return an iterator pointing past the end of the collection. ">end()</a></code>).</dd></dl>
<p>If the container owns its elements, then the pointed-to element will be deleted. </p>

</div>
</div>
<a class="anchor" id="ae16b6a23080b04529edbcaede4c3b121"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a0a24970f8d3743d873f69407fbf76872">iterator</a> <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a0a24970f8d3743d873f69407fbf76872">iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a0a24970f8d3743d873f69407fbf76872">iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a range of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator pointing to the first element to be removed. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator pointing one past the last element to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the element pointed to by <em>last</em> prior to erasing (or <code><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a084ec53b556ed4283f598bdd33398943" title="Return an iterator pointing past the end of the collection. ">end()</a></code>).</dd></dl>
<p>If the container owns its elements, then the removed elements will be deleted. Any duplicates will be removed in this process, but don't rely on this. </p>

</div>
</div>
<a class="anchor" id="a0208dd537831fad033198a40aa0fcaf3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PtrVector::iterator <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::erase_base </td>
          <td>(</td>
          <td class="paramtype">typename PtrVector::iterator&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper for <code><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a5e41132c55010e688115f1ed6cc0edab" title="Remove element at a given position. ">erase()</a></code>. Remove element at a given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>Iterator pointing to the element to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the next element (or <code><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a084ec53b556ed4283f598bdd33398943" title="Return an iterator pointing past the end of the collection. ">end()</a></code>).</dd></dl>
<p>This function factors out common code between <code><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a5e41132c55010e688115f1ed6cc0edab" title="Remove element at a given position. ">erase()</a></code> in the base and derived <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;. ">DataVector</a></code> classes. It deals with the <code>std::vector</code> iterators directly. </p>

</div>
</div>
<a class="anchor" id="a9b1da673ca3bba86c926acd40f986e6a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PtrVector::iterator <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::erase_base </td>
          <td>(</td>
          <td class="paramtype">typename PtrVector::iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename PtrVector::iterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper for <code><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a5e41132c55010e688115f1ed6cc0edab" title="Remove element at a given position. ">erase()</a></code>. Remove a range of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator pointing to the first element to be removed. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator pointing one past the last element to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the element pointed to by <em>last</em> prior to erasing (or <code><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a084ec53b556ed4283f598bdd33398943" title="Return an iterator pointing past the end of the collection. ">end()</a></code>).</dd></dl>
<p>This function factors out common code between <code><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a5e41132c55010e688115f1ed6cc0edab" title="Remove element at a given position. ">erase()</a></code> in the base and derived <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;. ">DataVector</a></code> classes. It deals with the <code>std::vector</code> iterators directly. </p>

</div>
</div>
<a class="anchor" id="a8b4e4253e25498a4aed16cf5fd19176b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the first element in the collection as an rvalue. </p>
<dl class="section return"><dt>Returns</dt><dd>The first element in the collection.</dd></dl>
<p>No checking is done to ensure that the container is not empty. Note that we return a <code>const</code> <code>T*</code> rather than a reference. </p>

</div>
</div>
<a class="anchor" id="a12489c7ded0c123b55d5b4d8ff5386ae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a99ab9c1706c2cd3273ec27a4b218ccfa">ElementProxy</a> <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the first element in the collection as an lvalue. </p>
<dl class="section return"><dt>Returns</dt><dd>Proxy to the first element in the collection.</dd></dl>
<p>No checking is done to ensure that the container is not empty. Note that we return a proxy object rather than a reference; the proxy will handle deleting an owned element if it's assigned to. </p>

</div>
</div>
<a class="anchor" id="a4c53dc5625a660a87187d033194dad02"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::get </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access an element, as an rvalue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Array index to access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element at <em>n</em>.</dd></dl>
<p>This is a synonym for operator[] const, to be used when calling from root (where we can't readily call just the const version of a method). </p>

</div>
</div>
<a class="anchor" id="a250b3c680672ec28ec9938239bc9328a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a0a24970f8d3743d873f69407fbf76872">iterator</a> <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a0a24970f8d3743d873f69407fbf76872">iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>pElem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new element to the collection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>Iterator before which the element will be added. </td></tr>
    <tr><td class="paramname">pElem</td><td>The element to add to the collection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the inserted data.</dd></dl>
<p>The container's ownership policy will determine if it takes ownership of the new element.</p>
<p>Note: this method may only be called using the most derived <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;. ">DataVector</a></code> in the hierarchy. </p>

</div>
</div>
<a class="anchor" id="a3fd38680b0724949c3619736caa9fbbb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a0a24970f8d3743d873f69407fbf76872">iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a group of new elements to the collection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>Iterator before which the element will be added. </td></tr>
    <tr><td class="paramname">first</td><td>The start of the range to put in the container. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the range to put in the container.</td></tr>
  </table>
  </dd>
</dl>
<p>The container's ownership policy will determine if it takes ownership of the new element.</p>
<p>Note: this method may only be called using the most derived <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;. ">DataVector</a></code> in the hierarchy. </p>

</div>
</div>
<a class="anchor" id="a1a1ee3a77f7504b7a8f3d475f7cdd003"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::iter_swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a0a24970f8d3743d873f69407fbf76872">iterator</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a0a24970f8d3743d873f69407fbf76872">iterator</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap the referents of two <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;. ">DataVector</a></code> iterators. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first iterator for the swap. </td></tr>
    <tr><td class="paramname">b</td><td>The second iterator for the swap/ </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad7e3dcf0a187de3ad9091d75e4e27d15"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&amp; <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The <a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;. ">DataVector</a> from which to assign. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This object.</dd></dl>
<p>This is a `shallow' copy; after the completion of this, the <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;. ">DataVector</a></code> will not own its elements. Any elements it owned prior to this call will be released.</p>
<p>Note: this method may only be called using the most derived <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;. ">DataVector</a></code> in the hierarchy. </p>

</div>
</div>
<a class="anchor" id="ad3eba15a4069718475af38248a3d0d2e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access an element, as an rvalue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Array index to access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element at <em>n</em>.</dd></dl>
<p>No bounds checking is done. Note that we return a <code>const</code> <code>T*</code> rather than a reference. </p>

</div>
</div>
<a class="anchor" id="a9dfa8e78005f6ba076fa4fd8f89905cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a99ab9c1706c2cd3273ec27a4b218ccfa">ElementProxy</a> <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access an element, as an lvalue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Array index to access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Proxy to the element at <em>n</em>.</dd></dl>
<p>No bounds checking is done. Note that we return a proxy object rather than a reference; the proxy will handle deleting an owned element if it's assigned to. </p>

</div>
</div>
<a class="anchor" id="a5435f79346220ac80c41bdc3adf9803c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the last element from the collection. </p>
<p>If the container owns its elements, then the removed element will be deleted. </p>

</div>
</div>
<a class="anchor" id="aaa71855a58852e9c5ffa61a555ed581f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>pElem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an element to the end of the collection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pElem</td><td>The element to add to the collection.</td></tr>
  </table>
  </dd>
</dl>
<p>The container's ownership policy will determine if it takes ownership of the new element.</p>
<p>Note: this method may only be called using the most derived <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;. ">DataVector</a></code> in the hierarchy. </p>

</div>
</div>
<a class="anchor" id="a6225bfe9a292ddead10cec769022a2ce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a61d77f0c504d473f85376ddce8bd2163">const_reverse_iterator</a> <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a <code>const_reverse_iterator</code> pointing past the end of the collection. </p>
<dl class="section return"><dt>Returns</dt><dd>A <code>const_reverse_iterator</code>.</dd></dl>
<p>Note that dereferencing the iterator will yield a <code>const</code> <code>T*</code> rather than a reference. </p>

</div>
</div>
<a class="anchor" id="a2b47037798be81db90016ad9584899e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a3551d2e1bdbe02ade11f731cfb976f4f">reverse_iterator</a> <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a <code>reverse_iterator</code> pointing past the end of the collection. </p>
<dl class="section return"><dt>Returns</dt><dd>A <code>reverse_iterator</code>.</dd></dl>
<p>Note that dereferencing the iterator will yield a proxy rather than a reference; the proxy will handle deleting an owned element if it's assigned to. </p>

</div>
</div>
<a class="anchor" id="acfa741d2f764cf729035ce630c542d43"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a61d77f0c504d473f85376ddce8bd2163">const_reverse_iterator</a> <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a <code>const_reverse_iterator</code> pointing at the beginning of the collection. </p>
<dl class="section return"><dt>Returns</dt><dd>A <code>const_reverse_iterator</code>.</dd></dl>
<p>Note that dereferencing the iterator will yield a <code>const</code> <code>T*</code> rather than a reference. </p>

</div>
</div>
<a class="anchor" id="a3346ad4e2fe7f416b8c1b7f62a838076"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a3551d2e1bdbe02ade11f731cfb976f4f">reverse_iterator</a> <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a <code>reverse_iterator</code> pointing at the beginning of the collection. </p>
<dl class="section return"><dt>Returns</dt><dd>A <code>reverse_iterator</code>.</dd></dl>
<p>Note that dereferencing the iterator will yield a proxy rather than a reference; the proxy will handle deleting an owned element if it's assigned to. </p>

</div>
</div>
<a class="anchor" id="ad057592307e2749e25a3970ed6426b17"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to preallocate enough memory for a specified number of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of elements required. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a43652bda389a83f437300f0f1de68e05"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes the collection to the specified number of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sz</td><td>The new size of the collection.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that this function differs from the standard in that it does not allow specifying the value of any inserted elements. They will always be 0.</p>
<p>If the container is shrunk, elements will be deleted as with <code><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a5e41132c55010e688115f1ed6cc0edab" title="Remove element at a given position. ">erase()</a></code>. </p>

</div>
</div>
<a class="anchor" id="ab4de50491cb3c3dc239fd4d52c7151d7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::resortAux </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a0a24970f8d3743d873f69407fbf76872">iterator</a>&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a0a24970f8d3743d873f69407fbf76872">iterator</a>&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset indices / reorder aux data after elements have been permuted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg</td><td>Start of the range of elements to process. </td></tr>
    <tr><td class="paramname">end</td><td>End of the range of elements to process.</td></tr>
  </table>
  </dd>
</dl>
<p>Call this after some operation that has permuted the elements in the container (such as sort). The index information in the elements will be used to permute all auxiliary data in the same way. Finally, all the indices will be reset in the correct order. </p>

</div>
</div>
<a class="anchor" id="abfc9461741ecfa4b568e91b3e79abe1d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::setMostDerived </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set <code>m_isMostDerived</code> for this instance and clear it for all bases. </p>
<p>Called from <code>testInsert</code> if the test fails. The flag may not have been set if this container was made via copy construction, so set it appropriately now so we can test again. </p>

</div>
</div>
<a class="anchor" id="a258f5c8833dc8e1d659960784c468f25"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_type <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::size_v </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the collection. </p>
<p>This version is virtual, to be callable from the AuxData base class. </p>

<p>Implements <a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#a72f56c76a3c92d48d8364723c0161af3">SG::AuxVectorData</a>.</p>

</div>
</div>
<a class="anchor" id="ab3b8b5064b52bcb7921b973abad09a8f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::sort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort the container. </p>
<p>This just sorts by pointer value, so it's probably not very useful. </p>

</div>
</div>
<a class="anchor" id="acab188873786887e4909ac01239b08a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;class COMPARE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::sort </td>
          <td>(</td>
          <td class="paramtype">COMPARE&#160;</td>
          <td class="paramname"><em>comp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort the container with a user-specified comparison operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>Functional to compare two values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adc7f275d2bc73e00c010828a4a5224f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a9037cb597ab293dcf843bd9f5d88699f">PtrVector</a>&amp; <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::stdcont </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the underlying <code>std::vector</code> of the container. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the <code>std::vector</code> actually holding the collection.</dd></dl>
<p>Note that <code><a class="el" href="../../d0/d4d/classDataVector.html#a0e2e64a35d842a206c96ccfec265df21" title="Return the underlying std::vector of the container. ">DataVector&lt;T&gt;::stdcont</a></code> does not necessarily return a <code>std::vector&lt;T*&gt;</code> if <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;. ">DataVector</a></code> inheritance is being used. </p>

</div>
</div>
<a class="anchor" id="ace0665d0ab6fd551aeee44eca9a29a40"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap this collection with another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The collection with which to swap.</td></tr>
  </table>
  </dd>
</dl>
<p>Ownership is swapped along with the collection content.</p>
<p>Note: this method may only be called using the most-derived <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;. ">DataVector</a></code> in the hierarchy. The <em>rhs</em> must also be referenced using the most-derived <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;. ">DataVector</a></code>. </p>

</div>
</div>
<a class="anchor" id="abff69b3413c3e0a912f9d5589f4257e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::swapElement </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>newElem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reference&#160;</td>
          <td class="paramname"><em>oldElem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap one element out of the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the element in the container to swap. </td></tr>
    <tr><td class="paramname">newElem</td><td>New element to put in the container. May be 0. </td></tr>
    <tr><td class="paramname">oldElem</td><td>Reference to receive the element removed from the container.</td></tr>
  </table>
  </dd>
</dl>
<p>Reference <em>oldElem</em> is initialized with element <em>index</em> of the collection (no bounds checking). Then element <em>index</em> is set to <code>newElem</code>. If the collection owns its elements, then it will take ownership of <em>newElem</em> and release (without deleting) the element returned through <em>oldElem</em>.</p>
<p>Note: this method may only be called using the most derived <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;. ">DataVector</a></code> in the hierarchy. </p>

</div>
</div>
<a class="anchor" id="a88d41d8c4ab49f649b4fd20dbe648abd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::swapElement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a0a24970f8d3743d873f69407fbf76872">iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>newElem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reference&#160;</td>
          <td class="paramname"><em>oldElem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap one element out of the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The element in the container to swap. </td></tr>
    <tr><td class="paramname">newElem</td><td>New element to put in the container. May be 0. </td></tr>
    <tr><td class="paramname">oldElem</td><td>Reference to receive the element removed from the container.</td></tr>
  </table>
  </dd>
</dl>
<p>Reference <em>oldElem</em> is initialized with element <em>pos</em> of the collection (no bounds checking). Then element <em>index</em> is set to <code>newElem</code>. If the collection owns its elements, then it will take ownership of <em>newElem</em> and release (without deleting) the element returned through <em>oldElem</em>.</p>
<p>Note: this method may only be called using the most derived <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;. ">DataVector</a></code> in the hierarchy. </p>

</div>
</div>
<a class="anchor" id="a191f1812d1e0bfab56d0ecb4e1902138"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::testInsert </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if we can insert; raise an exception if not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>Description of the attempted operation.</td></tr>
  </table>
  </dd>
</dl>
<p>In order to maintain type-safety, we can only allow insertions using the most-derived instance of <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;. ">DataVector</a></code>. This checks this by testing the <code>m_isMostDerived</code>, which is set by the constructors to true only for the most-derived instance. If the test fails, we call to potentially out-of-line code to continue. </p>

</div>
</div>
<a class="anchor" id="a64c19881e3c41eb3a9ebbb24627ba7bf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::testInsertOol </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if we can insert; raise an exception if not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>Description of the attempted operation.</td></tr>
  </table>
  </dd>
</dl>
<p>This continues the test of <code>testInsert</code>. There is one case where <code>m_isMostDerived</code> may not be set correctly. If this container was made via copy construction, then all the <code>m_isMostDerived</code> flags will be false. So we call <code>setMostDerived</code> to set the flags correctly and test again. If the test fails again, then we raise an exception. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="aa9b859c5e4d9bb75d44cba2e72690238"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::has_virtual = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is true for any <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;. ">DataVector</a></code> class if we need to use virtual derivation to get to the base <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;. ">DataVector</a></code> class. Since this <em>is</em> the base <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;. ">DataVector</a></code> class, set this unconditionally to <code>false</code>. </p>

</div>
</div>
<a class="anchor" id="a205453f4c7420d058d1179766b292c87"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8">SG::OwnershipPolicy</a> <a class="el" href="../../d0/d4d/classDataVector.html">DataVector</a>&lt; T, <a class="el" href="../../d4/d21/structDataModel__detail_1_1NoBase.html">DataModel_detail::NoBase</a> &gt;::m_ownPolicy</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The ownership policy of this container &mdash; either SG::OWNS_ELEMENTS or <a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8ad7d4cf2303700f0966e4140f236c4bf1" title="this data object is a view, it does not own its elmts ">SG::VIEW_ELEMENTS</a>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.31/AthContainers/AthContainers/<a class="el" href="../../d7/dd6/DataVector_8h_source.html">DataVector.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Dec 1 2017 11:08:39 for RootCore Packages by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
