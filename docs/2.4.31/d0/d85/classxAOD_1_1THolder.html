<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>RootCore Packages: xAOD::THolder Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">RootCore Packages
   &#160;<span id="projectnumber">2.4.31</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="../../classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="../../hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="../../functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../dd/d44/namespacexAOD.html">xAOD</a></li><li class="navelem"><a class="el" href="../../d0/d85/classxAOD_1_1THolder.html">THolder</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="../../db/dd7/classxAOD_1_1THolder-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">xAOD::THolder Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class takes care of holding EDM objects in memory.  
 <a href="../../d0/d85/classxAOD_1_1THolder.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d1/db1/THolder_8h_source.html">THolder.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for xAOD::THolder:</div>
<div class="dyncontent">
 <div class="center">
  <img src="../../d0/d85/classxAOD_1_1THolder.png" usemap="#xAOD::THolder_map" alt=""/>
  <map id="xAOD::THolder_map" name="xAOD::THolder_map">
<area href="../../d6/d4b/classxAOD_1_1TCDVHolderT.html" alt="xAOD::TCDVHolderT&lt; T &gt;" shape="rect" coords="0,56,162,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2020c29c9e01536adf5c06326089f43d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2020c29c9e01536adf5c06326089f43d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d85/classxAOD_1_1THolder.html#a2020c29c9e01536adf5c06326089f43d">THolder</a> ()</td></tr>
<tr class="memdesc:a2020c29c9e01536adf5c06326089f43d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br/></td></tr>
<tr class="separator:a2020c29c9e01536adf5c06326089f43d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b5e34c09af804f941e1e2f8dcb09c7b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b5e34c09af804f941e1e2f8dcb09c7b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d85/classxAOD_1_1THolder.html#a1b5e34c09af804f941e1e2f8dcb09c7b">THolder</a> (void *object,::TClass *type,::Bool_t owner=kTRUE)</td></tr>
<tr class="memdesc:a1b5e34c09af804f941e1e2f8dcb09c7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor pointing to an object in memory. <br/></td></tr>
<tr class="separator:a1b5e34c09af804f941e1e2f8dcb09c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b8de203830129be9a640ea3ec684f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a68b8de203830129be9a640ea3ec684f5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d85/classxAOD_1_1THolder.html#a68b8de203830129be9a640ea3ec684f5">THolder</a> (void *object, const std::type_info &amp;type,::Bool_t owner=kTRUE)</td></tr>
<tr class="memdesc:a68b8de203830129be9a640ea3ec684f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor pointing to an object in memory. <br/></td></tr>
<tr class="separator:a68b8de203830129be9a640ea3ec684f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6c7301dffdea2c5997662a3fc564575"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d85/classxAOD_1_1THolder.html#ae6c7301dffdea2c5997662a3fc564575">THolder</a> (const <a class="el" href="../../d0/d85/classxAOD_1_1THolder.html">THolder</a> &amp;parent)</td></tr>
<tr class="memdesc:ae6c7301dffdea2c5997662a3fc564575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#ae6c7301dffdea2c5997662a3fc564575">More...</a><br/></td></tr>
<tr class="separator:ae6c7301dffdea2c5997662a3fc564575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a348bab2d9c063bff0025efc1af0d7e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d85/classxAOD_1_1THolder.html#a0a348bab2d9c063bff0025efc1af0d7e">THolder</a> (<a class="el" href="../../d0/d85/classxAOD_1_1THolder.html">THolder</a> &amp;&amp;parent)</td></tr>
<tr class="memdesc:a0a348bab2d9c063bff0025efc1af0d7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="#a0a348bab2d9c063bff0025efc1af0d7e">More...</a><br/></td></tr>
<tr class="separator:a0a348bab2d9c063bff0025efc1af0d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0afb7d776dc3ef15ac169134593bf4e2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0afb7d776dc3ef15ac169134593bf4e2"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d85/classxAOD_1_1THolder.html#a0afb7d776dc3ef15ac169134593bf4e2">~THolder</a> ()</td></tr>
<tr class="memdesc:a0afb7d776dc3ef15ac169134593bf4e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The destructor cleans out the memory used by the managed object. <br/></td></tr>
<tr class="separator:a0afb7d776dc3ef15ac169134593bf4e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e0c9c44b282258a4d7ec144055f92e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d85/classxAOD_1_1THolder.html">THolder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d85/classxAOD_1_1THolder.html#a1e0c9c44b282258a4d7ec144055f92e6">operator=</a> (const <a class="el" href="../../d0/d85/classxAOD_1_1THolder.html">THolder</a> &amp;rhs)</td></tr>
<tr class="memdesc:a1e0c9c44b282258a4d7ec144055f92e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="#a1e0c9c44b282258a4d7ec144055f92e6">More...</a><br/></td></tr>
<tr class="separator:a1e0c9c44b282258a4d7ec144055f92e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac96544f53b648de77f2d444d11267f9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d85/classxAOD_1_1THolder.html">THolder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d85/classxAOD_1_1THolder.html#ac96544f53b648de77f2d444d11267f9a">operator=</a> (<a class="el" href="../../d0/d85/classxAOD_1_1THolder.html">THolder</a> &amp;&amp;rhs)</td></tr>
<tr class="memdesc:ac96544f53b648de77f2d444d11267f9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move operator.  <a href="#ac96544f53b648de77f2d444d11267f9a">More...</a><br/></td></tr>
<tr class="separator:ac96544f53b648de77f2d444d11267f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d832af0c8c55bbe0492d490342790a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6d832af0c8c55bbe0492d490342790a"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d85/classxAOD_1_1THolder.html#ad6d832af0c8c55bbe0492d490342790a">get</a> () const </td></tr>
<tr class="memdesc:ad6d832af0c8c55bbe0492d490342790a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a typeless pointer to the held object. <br/></td></tr>
<tr class="separator:ad6d832af0c8c55bbe0492d490342790a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83140cc8dbe76e4c9e8a485479f7613c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83140cc8dbe76e4c9e8a485479f7613c"></a>
void **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d85/classxAOD_1_1THolder.html#a83140cc8dbe76e4c9e8a485479f7613c">getPtr</a> ()</td></tr>
<tr class="memdesc:a83140cc8dbe76e4c9e8a485479f7613c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a typeless pointer to the held object's pointer. <br/></td></tr>
<tr class="separator:a83140cc8dbe76e4c9e8a485479f7613c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a60a21b41d3d4154ff5be66ac94fdaa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a60a21b41d3d4154ff5be66ac94fdaa"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d85/classxAOD_1_1THolder.html#a8a60a21b41d3d4154ff5be66ac94fdaa">set</a> (void *obj)</td></tr>
<tr class="memdesc:a8a60a21b41d3d4154ff5be66ac94fdaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the managed object. <br/></td></tr>
<tr class="separator:a8a60a21b41d3d4154ff5be66ac94fdaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d09bfde84e6a001fb44fb99fa4f030"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5d09bfde84e6a001fb44fb99fa4f030"></a>
::Bool_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d85/classxAOD_1_1THolder.html#ab5d09bfde84e6a001fb44fb99fa4f030">isOwner</a> () const </td></tr>
<tr class="memdesc:ab5d09bfde84e6a001fb44fb99fa4f030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the holder owns its object. <br/></td></tr>
<tr class="separator:ab5d09bfde84e6a001fb44fb99fa4f030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f15b2a9902d9750a3768e5700ae61a2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f15b2a9902d9750a3768e5700ae61a2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d85/classxAOD_1_1THolder.html#a4f15b2a9902d9750a3768e5700ae61a2">setOwner</a> (::Bool_t state=kTRUE)</td></tr>
<tr class="memdesc:a4f15b2a9902d9750a3768e5700ae61a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether the holder should own its object. <br/></td></tr>
<tr class="separator:a4f15b2a9902d9750a3768e5700ae61a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b96bbfa1fa22ed4db52e6b421546b8"><td class="memItemLeft" align="right" valign="top">virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d85/classxAOD_1_1THolder.html#ad4b96bbfa1fa22ed4db52e6b421546b8">getAs</a> (const std::type_info &amp;tid,::Bool_t silent=kFALSE) const </td></tr>
<tr class="memdesc:ad4b96bbfa1fa22ed4db52e6b421546b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the object as a specific pointer.  <a href="#ad4b96bbfa1fa22ed4db52e6b421546b8">More...</a><br/></td></tr>
<tr class="separator:ad4b96bbfa1fa22ed4db52e6b421546b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac20f281ae3e93761527d61575057961f"><td class="memItemLeft" align="right" valign="top">virtual const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d85/classxAOD_1_1THolder.html#ac20f281ae3e93761527d61575057961f">getAsConst</a> (const std::type_info &amp;tid,::Bool_t silent=kFALSE) const </td></tr>
<tr class="memdesc:ac20f281ae3e93761527d61575057961f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the object as a specific, constant pointer.  <a href="#ac20f281ae3e93761527d61575057961f">More...</a><br/></td></tr>
<tr class="separator:ac20f281ae3e93761527d61575057961f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb0cdae3b8f976c63d17572325746cc1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb0cdae3b8f976c63d17572325746cc1"></a>
::TClass *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d85/classxAOD_1_1THolder.html#acb0cdae3b8f976c63d17572325746cc1">getClass</a> () const </td></tr>
<tr class="memdesc:acb0cdae3b8f976c63d17572325746cc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the concrete type of the object. <br/></td></tr>
<tr class="separator:acb0cdae3b8f976c63d17572325746cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a217a1d18d4b3664e5756b34f85068fba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a217a1d18d4b3664e5756b34f85068fba"></a>
const std::type_info *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d85/classxAOD_1_1THolder.html#a217a1d18d4b3664e5756b34f85068fba">getTypeInfo</a> () const </td></tr>
<tr class="memdesc:a217a1d18d4b3664e5756b34f85068fba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the concrete type of the object. <br/></td></tr>
<tr class="separator:a217a1d18d4b3664e5756b34f85068fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa57902250e744edbf975fc4251c6643e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d85/classxAOD_1_1THolder.html#aa57902250e744edbf975fc4251c6643e">renew</a> ()</td></tr>
<tr class="memdesc:aa57902250e744edbf975fc4251c6643e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renew the object in memory.  <a href="#aa57902250e744edbf975fc4251c6643e">More...</a><br/></td></tr>
<tr class="separator:aa57902250e744edbf975fc4251c6643e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a30322b33558c6ab67a46e05648703ecc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30322b33558c6ab67a46e05648703ecc"></a>
typedef std::map&lt; const <br class="typebreak"/>
std::type_info *, TClass * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d85/classxAOD_1_1THolder.html#a30322b33558c6ab67a46e05648703ecc">TypeCache_t</a></td></tr>
<tr class="memdesc:a30322b33558c6ab67a46e05648703ecc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../dd/dc8/namespacexAOD_1_1Type.html">Type</a> for the internal cache. <br/></td></tr>
<tr class="separator:a30322b33558c6ab67a46e05648703ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3bbe8664d365f29c974b9635df39486"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab3bbe8664d365f29c974b9635df39486"></a>
typedef std::map&lt; void *, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d85/classxAOD_1_1THolder.html#ab3bbe8664d365f29c974b9635df39486">SharedCount_t</a></td></tr>
<tr class="memdesc:ab3bbe8664d365f29c974b9635df39486"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../dd/dc8/namespacexAOD_1_1Type.html">Type</a> implementing the instance counting. <br/></td></tr>
<tr class="separator:ab3bbe8664d365f29c974b9635df39486"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aa3fd2af8fe7606fe11418b17c2f2a601"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa3fd2af8fe7606fe11418b17c2f2a601"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d85/classxAOD_1_1THolder.html#aa3fd2af8fe7606fe11418b17c2f2a601">deleteObject</a> ()</td></tr>
<tr class="memdesc:aa3fd2af8fe7606fe11418b17c2f2a601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function used to delete the managed object from memory. <br/></td></tr>
<tr class="separator:aa3fd2af8fe7606fe11418b17c2f2a601"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a8c3554f272109bf5a2377ae24866893c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c3554f272109bf5a2377ae24866893c"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d85/classxAOD_1_1THolder.html#a8c3554f272109bf5a2377ae24866893c">m_object</a></td></tr>
<tr class="memdesc:a8c3554f272109bf5a2377ae24866893c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typeless pointer to the object in memory. <br/></td></tr>
<tr class="separator:a8c3554f272109bf5a2377ae24866893c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab330bab2ce644ac958127534aae1bbcd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab330bab2ce644ac958127534aae1bbcd"></a>
::TClass *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d85/classxAOD_1_1THolder.html#ab330bab2ce644ac958127534aae1bbcd">m_type</a></td></tr>
<tr class="memdesc:ab330bab2ce644ac958127534aae1bbcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete type of the object being held on to. <br/></td></tr>
<tr class="separator:ab330bab2ce644ac958127534aae1bbcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad144585893f0afc8d21d3607ea03dbeb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad144585893f0afc8d21d3607ea03dbeb"></a>
const std::type_info *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d85/classxAOD_1_1THolder.html#ad144585893f0afc8d21d3607ea03dbeb">m_typeInfo</a></td></tr>
<tr class="memdesc:ad144585893f0afc8d21d3607ea03dbeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete type of the object, if it doesn't have a dictionary. <br/></td></tr>
<tr class="separator:ad144585893f0afc8d21d3607ea03dbeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af29d34b8ea4e9945f92d775f7f4cf7c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af29d34b8ea4e9945f92d775f7f4cf7c3"></a>
::Bool_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d85/classxAOD_1_1THolder.html#af29d34b8ea4e9945f92d775f7f4cf7c3">m_owner</a></td></tr>
<tr class="memdesc:af29d34b8ea4e9945f92d775f7f4cf7c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A flag for whether the object owns what it points to. <br/></td></tr>
<tr class="separator:af29d34b8ea4e9945f92d775f7f4cf7c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:aae464a8842a668de6b3f6b60a1e63986"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae464a8842a668de6b3f6b60a1e63986"></a>
static <a class="el" href="../../d0/d85/classxAOD_1_1THolder.html#a30322b33558c6ab67a46e05648703ecc">TypeCache_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d85/classxAOD_1_1THolder.html#aae464a8842a668de6b3f6b60a1e63986">s_typeMap</a> = <a class="el" href="../../d0/d85/classxAOD_1_1THolder.html#a30322b33558c6ab67a46e05648703ecc">THolder::TypeCache_t</a>()</td></tr>
<tr class="memdesc:aae464a8842a668de6b3f6b60a1e63986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache for the requested class types. <br/></td></tr>
<tr class="separator:aae464a8842a668de6b3f6b60a1e63986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5f15c7a038163821af52bc9a0fa9769"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa5f15c7a038163821af52bc9a0fa9769"></a>
static <a class="el" href="../../d0/d85/classxAOD_1_1THolder.html#ab3bbe8664d365f29c974b9635df39486">SharedCount_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d85/classxAOD_1_1THolder.html#aa5f15c7a038163821af52bc9a0fa9769">s_sharedCount</a> = <a class="el" href="../../d0/d85/classxAOD_1_1THolder.html#ab3bbe8664d365f29c974b9635df39486">THolder::SharedCount_t</a>()</td></tr>
<tr class="memdesc:aa5f15c7a038163821af52bc9a0fa9769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable counting the different object instances. <br/></td></tr>
<tr class="separator:aa5f15c7a038163821af52bc9a0fa9769"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class takes care of holding EDM objects in memory. </p>
<p>In order to be able to access EDM objects easily as their concrete type, or as one of their base classes, a little trickery is needed.</p>
<p>We always access the branches of the input TTree as their concrete, transient types. It is then up to our own code to decide if the user is requesting the object as a type that it can be cast to, or not.</p>
<dl class="section author"><dt>Author</dt><dd>Attila Krasznahorkay <a href="#" onclick="location.href='mai'+'lto:'+'Att'+'il'+'a.K'+'ra'+'szn'+'ah'+'ork'+'ay'+'@ce'+'rn'+'.ch'; return false;">Attil<span style="display: none;">.nosp@m.</span>a.Kr<span style="display: none;">.nosp@m.</span>aszna<span style="display: none;">.nosp@m.</span>hork<span style="display: none;">.nosp@m.</span>ay@ce<span style="display: none;">.nosp@m.</span>rn.c<span style="display: none;">.nosp@m.</span>h</a></dd></dl>
<dl class="section rcs"><dt>Revision:</dt><dd>725531 </dd></dl>
<dl class="section rcs"><dt>Date:</dt><dd>2016-02-22 17:14:25 +0100 (Mon, 22 Feb 2016) </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae6c7301dffdea2c5997662a3fc564575"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xAOD::THolder::THolder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d85/classxAOD_1_1THolder.html">THolder</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>The copy constructor takes the pointer from the parent object, and based on whether the parent owned the object or not, increments the shared count.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>The parent object that should be copied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0a348bab2d9c063bff0025efc1af0d7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xAOD::THolder::THolder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d85/classxAOD_1_1THolder.html">THolder</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move constructor. </p>
<p>This is a tricky one. Since the object is being moved, meaning that the parent will be deleted right after this operation, instead of incrementing and then decrementing the shared count, we just tell the parent that it doesn't own its object anymore. In this case if it did own it, the shared count will remain valid. Since it's this object owning it now. If it didn't own the object in the first place, then no hard no foul.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>The parent object that should be moved </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad4b96bbfa1fa22ed4db52e6b421546b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * xAOD::THolder::getAs </td>
          <td>(</td>
          <td class="paramtype">const std::type_info &amp;&#160;</td>
          <td class="paramname"><em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::Bool_t&#160;</td>
          <td class="paramname"><em>silent</em> = <code>kFALSE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the object as a specific pointer. </p>
<p>This function is used for retrieving an object as one of its bases. It is used when the caller requires a non-const pointer to the managed object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tid</td><td>The type as which the object is to be retrieved </td></tr>
    <tr><td class="paramname">silent</td><td>When <code>kTRUE</code>, the call will fail silently when unsuccessful </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A non-const pointer that can be cast to the requested type </dd></dl>

</div>
</div>
<a class="anchor" id="ac20f281ae3e93761527d61575057961f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const void * xAOD::THolder::getAsConst </td>
          <td>(</td>
          <td class="paramtype">const std::type_info &amp;&#160;</td>
          <td class="paramname"><em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::Bool_t&#160;</td>
          <td class="paramname"><em>silent</em> = <code>kFALSE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the object as a specific, constant pointer. </p>
<p>This function is used for retrieving an object as one of its bases. It is used when the caller need a const pointer to the managed object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tid</td><td>The type as which the object is to be retrieved </td></tr>
    <tr><td class="paramname">silent</td><td>When <code>kTRUE</code>, the call will fail silently when unsuccessful </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A const pointer that can be cast to the requested type </dd></dl>

<p>Reimplemented in <a class="el" href="../../d6/d4b/classxAOD_1_1TCDVHolderT.html#a61e2667ff431cfc0c9d77f2cb49db757">xAOD::TCDVHolderT&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a1e0c9c44b282258a4d7ec144055f92e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d85/classxAOD_1_1THolder.html">THolder</a> &amp; xAOD::THolder::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d85/classxAOD_1_1THolder.html">THolder</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<p>The copy operator, just like the copy constructor makes the object aware that it doesn't own the object that it has the pointer to.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The object that has to be copied </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this same object </dd></dl>

</div>
</div>
<a class="anchor" id="ac96544f53b648de77f2d444d11267f9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d85/classxAOD_1_1THolder.html">THolder</a> &amp; xAOD::THolder::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d85/classxAOD_1_1THolder.html">THolder</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move operator. </p>
<p>This move operator is necessary to be able to use this type as a value type of STL containers.</p>
<p>See the comments given for the move constructor for an explanation of the behaviour of this operator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The object that has to be moved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this same object </dd></dl>

</div>
</div>
<a class="anchor" id="aa57902250e744edbf975fc4251c6643e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xAOD::THolder::renew </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renew the object in memory. </p>
<p>This function is mostly used in "Athena access mode", to delete the managed objects from memory between events, and recreate them from scratch. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.31/xAODRootAccess/xAODRootAccess/tools/<a class="el" href="../../d1/db1/THolder_8h_source.html">THolder.h</a></li>
<li>/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.31/xAODRootAccess/Root/THolder.cxx</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Dec 1 2017 11:09:14 for RootCore Packages by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
