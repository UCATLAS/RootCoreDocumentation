<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>RootCore Packages: SG::AuxVectorData Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">RootCore Packages
   &#160;<span id="projectnumber">2.4.31</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="../../classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="../../hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="../../functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../dd/d59/namespaceSG.html">SG</a></li><li class="navelem"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html">AuxVectorData</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="../../d8/daa/classSG_1_1AuxVectorData-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SG::AuxVectorData Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Manage lookup of vectors of auxiliary data.  
 <a href="../../db/dd6/classSG_1_1AuxVectorData.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d9/df2/AuxVectorData_8h_source.html">AuxVectorData.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SG::AuxVectorData:</div>
<div class="dyncontent">
 <div class="center">
  <img src="../../db/dd6/classSG_1_1AuxVectorData.png" usemap="#SG::AuxVectorData_map" alt=""/>
  <map id="SG::AuxVectorData_map" name="SG::AuxVectorData_map">
<area href="../../dc/dfb/classSG_1_1AuxElementData.html" title="Internal data container. " alt="SG::AuxElementData" shape="rect" coords="137,112,401,136"/>
<area href="../../dd/da5/classSG_1_1AuxVectorBase.html" title="Manage index tracking and synchronization of auxiliary data. " alt="SG::AuxVectorBase" shape="rect" coords="548,112,812,136"/>
<area href="../../da/d62/classSG_1_1AuxElementPrivateData.html" title="Internal data container for private store. " alt="SG::AuxElementPrivateData" shape="rect" coords="0,168,264,192"/>
<area href="../../d5/dde/classSG_1_1AuxElementStandaloneData.html" title="Internal data container for standalone store. " alt="SG::AuxElementStandaloneData" shape="rect" coords="274,168,538,192"/>
<area href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html" title="Base specialization for DataVector&lt;T&gt;. " alt="DataVector&lt; T, DataModel_detail::NoBase &gt;" shape="rect" coords="548,168,812,192"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac03d380d92722ca597c92da17ed08972"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac03d380d92722ca597c92da17ed08972"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#ac03d380d92722ca597c92da17ed08972">AuxVectorData</a> ()</td></tr>
<tr class="memdesc:ac03d380d92722ca597c92da17ed08972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br/></td></tr>
<tr class="separator:ac03d380d92722ca597c92da17ed08972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c4723c7dd4279ff096d77b4832eb99"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2c4723c7dd4279ff096d77b4832eb99"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#ad2c4723c7dd4279ff096d77b4832eb99">~AuxVectorData</a> ()</td></tr>
<tr class="memdesc:ad2c4723c7dd4279ff096d77b4832eb99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr class="separator:ad2c4723c7dd4279ff096d77b4832eb99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72f56c76a3c92d48d8364723c0161af3"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#a72f56c76a3c92d48d8364723c0161af3">size_v</a> () const =0</td></tr>
<tr class="memdesc:a72f56c76a3c92d48d8364723c0161af3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size of the container.  <a href="#a72f56c76a3c92d48d8364723c0161af3">More...</a><br/></td></tr>
<tr class="separator:a72f56c76a3c92d48d8364723c0161af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa05239b04a4e91b0bcc8da201f2cccaa"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#aa05239b04a4e91b0bcc8da201f2cccaa">capacity_v</a> () const =0</td></tr>
<tr class="memdesc:aa05239b04a4e91b0bcc8da201f2cccaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the capacity of the container.  <a href="#aa05239b04a4e91b0bcc8da201f2cccaa">More...</a><br/></td></tr>
<tr class="separator:aa05239b04a4e91b0bcc8da201f2cccaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Other operations.</div></td></tr>
<tr class="memitem:aea4d64e4a85beda13d1243ece5d210e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#aea4d64e4a85beda13d1243ece5d210e2">swap</a> (<a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html">AuxVectorData</a> &amp;other)</td></tr>
<tr class="memdesc:aea4d64e4a85beda13d1243ece5d210e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap this instance with another.  <a href="#aea4d64e4a85beda13d1243ece5d210e2">More...</a><br/></td></tr>
<tr class="separator:aea4d64e4a85beda13d1243ece5d210e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d6d9eefd8811b373b3eeda823e5c0ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#a5d6d9eefd8811b373b3eeda823e5c0ad">clearCache</a> ()</td></tr>
<tr class="memdesc:a5d6d9eefd8811b373b3eeda823e5c0ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the cached aux data pointers.  <a href="#a5d6d9eefd8811b373b3eeda823e5c0ad">More...</a><br/></td></tr>
<tr class="separator:a5d6d9eefd8811b373b3eeda823e5c0ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4379058b2eb0522291c4c20076ef7967"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#a4379058b2eb0522291c4c20076ef7967">lock</a> () ATH_OVERRIDE</td></tr>
<tr class="memdesc:a4379058b2eb0522291c4c20076ef7967"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the container.  <a href="#a4379058b2eb0522291c4c20076ef7967">More...</a><br/></td></tr>
<tr class="separator:a4379058b2eb0522291c4c20076ef7967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c86d28fd74648ddae868dc5fa005d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#a35c86d28fd74648ddae868dc5fa005d2">clearDecorations</a> () const </td></tr>
<tr class="memdesc:a35c86d28fd74648ddae868dc5fa005d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all decorations.  <a href="#a35c86d28fd74648ddae868dc5fa005d2">More...</a><br/></td></tr>
<tr class="separator:a35c86d28fd74648ddae868dc5fa005d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ac9d22b110b724211d946d911ecacdf64"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac9d22b110b724211d946d911ecacdf64"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Cache</b></td></tr>
<tr class="separator:ac9d22b110b724211d946d911ecacdf64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa54bfa91c82dd2b4071d28c52baf4b7c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa54bfa91c82dd2b4071d28c52baf4b7c"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SG::AuxElement</b></td></tr>
<tr class="separator:aa54bfa91c82dd2b4071d28c52baf4b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Aux store management.</h2></td></tr>
<tr class="memitem:a239b57ce5e7833bb83c8f0bf3b390814"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d3/dd5/classSG_1_1IConstAuxStore.html">SG::IConstAuxStore</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#a239b57ce5e7833bb83c8f0bf3b390814">getConstStore</a> () const </td></tr>
<tr class="memdesc:a239b57ce5e7833bb83c8f0bf3b390814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current store, as a const interface.  <a href="#a239b57ce5e7833bb83c8f0bf3b390814">More...</a><br/></td></tr>
<tr class="separator:a239b57ce5e7833bb83c8f0bf3b390814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d8f5f0dd148fbf2041560f77ab0113"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/d05/classSG_1_1IAuxStore.html">SG::IAuxStore</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#af1d8f5f0dd148fbf2041560f77ab0113">getStore</a> () const </td></tr>
<tr class="memdesc:af1d8f5f0dd148fbf2041560f77ab0113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current store, as a non-const interface.  <a href="#af1d8f5f0dd148fbf2041560f77ab0113">More...</a><br/></td></tr>
<tr class="separator:af1d8f5f0dd148fbf2041560f77ab0113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae11026ce063feb9b55456698ef2a4f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ae11026ce063feb9b55456698ef2a4f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#a7ae11026ce063feb9b55456698ef2a4f">hasStore</a> () const </td></tr>
<tr class="memdesc:a7ae11026ce063feb9b55456698ef2a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this object has an associated store. <br/></td></tr>
<tr class="separator:a7ae11026ce063feb9b55456698ef2a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b5279b30e60d9b099cb6496404c1aa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97b5279b30e60d9b099cb6496404c1aa"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#a97b5279b30e60d9b099cb6496404c1aa">hasNonConstStore</a> () const </td></tr>
<tr class="memdesc:a97b5279b30e60d9b099cb6496404c1aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this object has an associated non-const store. <br/></td></tr>
<tr class="separator:a97b5279b30e60d9b099cb6496404c1aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adad5487f0cdf6cd0d7de68dd84570324"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#adad5487f0cdf6cd0d7de68dd84570324">setOption</a> (<a class="el" href="../../dd/d59/namespaceSG.html#affee481ab18822e03866e0a0d3ff011c">auxid_t</a> id, const <a class="el" href="../../d7/d31/classSG_1_1AuxDataOption.html">AuxDataOption</a> &amp;option)</td></tr>
<tr class="memdesc:adad5487f0cdf6cd0d7de68dd84570324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an option for an auxiliary data variable.  <a href="#adad5487f0cdf6cd0d7de68dd84570324">More...</a><br/></td></tr>
<tr class="separator:adad5487f0cdf6cd0d7de68dd84570324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f683bea801877c1001faa8116679ac4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#a6f683bea801877c1001faa8116679ac4">setOption</a> (const std::string &amp;name, const <a class="el" href="../../d7/d31/classSG_1_1AuxDataOption.html">AuxDataOption</a> &amp;option)</td></tr>
<tr class="memdesc:a6f683bea801877c1001faa8116679ac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an option for an auxiliary data variable.  <a href="#a6f683bea801877c1001faa8116679ac4">More...</a><br/></td></tr>
<tr class="separator:a6f683bea801877c1001faa8116679ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49a59f74e1b4e28fc637d0fbfc8ec80"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#ab49a59f74e1b4e28fc637d0fbfc8ec80">setOption</a> (const std::string &amp;name, const std::string &amp;clsname, const <a class="el" href="../../d7/d31/classSG_1_1AuxDataOption.html">AuxDataOption</a> &amp;option)</td></tr>
<tr class="memdesc:ab49a59f74e1b4e28fc637d0fbfc8ec80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an option for an auxiliary data variable.  <a href="#ab49a59f74e1b4e28fc637d0fbfc8ec80">More...</a><br/></td></tr>
<tr class="separator:ab49a59f74e1b4e28fc637d0fbfc8ec80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b3fbcb003e51c6f527aa309503a5cb"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a36b3fbcb003e51c6f527aa309503a5cb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#a36b3fbcb003e51c6f527aa309503a5cb">setOption</a> (<a class="el" href="../../dd/d59/namespaceSG.html#affee481ab18822e03866e0a0d3ff011c">auxid_t</a> id, const std::string &amp;optname, T arg)</td></tr>
<tr class="memdesc:a36b3fbcb003e51c6f527aa309503a5cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an option for an auxiliary data variable.  <a href="#a36b3fbcb003e51c6f527aa309503a5cb">More...</a><br/></td></tr>
<tr class="separator:a36b3fbcb003e51c6f527aa309503a5cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e648949c78a087367e8788dca149f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#a51e648949c78a087367e8788dca149f2">setOption</a> (const std::string &amp;name, const std::string &amp;optname, int arg)</td></tr>
<tr class="memdesc:a51e648949c78a087367e8788dca149f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an option for an auxiliary data variable.  <a href="#a51e648949c78a087367e8788dca149f2">More...</a><br/></td></tr>
<tr class="separator:a51e648949c78a087367e8788dca149f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f4c954520372ce1381365cf0f8bee4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae2f4c954520372ce1381365cf0f8bee4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>setOption</b> (const std::string &amp;name, const std::string &amp;optname, float arg)</td></tr>
<tr class="separator:ae2f4c954520372ce1381365cf0f8bee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf14a816b4340b01e21b19fe76e8d4a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9bf14a816b4340b01e21b19fe76e8d4a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>setOption</b> (const std::string &amp;name, const std::string &amp;optname, double arg)</td></tr>
<tr class="separator:a9bf14a816b4340b01e21b19fe76e8d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d807cdcacfd4bd97e565690495e8a4e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a4d807cdcacfd4bd97e565690495e8a4e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#a4d807cdcacfd4bd97e565690495e8a4e">setOption</a> (const std::string &amp;name, const std::string &amp;clsname, const std::string &amp;optname, T arg)</td></tr>
<tr class="memdesc:a4d807cdcacfd4bd97e565690495e8a4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an option for an auxiliary data variable.  <a href="#a4d807cdcacfd4bd97e565690495e8a4e">More...</a><br/></td></tr>
<tr class="separator:a4d807cdcacfd4bd97e565690495e8a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6e2da3c14ea74935120cd1b5a37f021"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#af6e2da3c14ea74935120cd1b5a37f021">setStore</a> (const <a class="el" href="../../d3/dd5/classSG_1_1IConstAuxStore.html">SG::IConstAuxStore</a> *store)</td></tr>
<tr class="memdesc:af6e2da3c14ea74935120cd1b5a37f021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the store associated with this object.  <a href="#af6e2da3c14ea74935120cd1b5a37f021">More...</a><br/></td></tr>
<tr class="separator:af6e2da3c14ea74935120cd1b5a37f021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1980ceb02ed996944d1f2508d128d91c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#a1980ceb02ed996944d1f2508d128d91c">setStore</a> (<a class="el" href="../../dc/d05/classSG_1_1IAuxStore.html">SG::IAuxStore</a> *store)</td></tr>
<tr class="memdesc:a1980ceb02ed996944d1f2508d128d91c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the store associated with this object.  <a href="#a1980ceb02ed996944d1f2508d128d91c">More...</a><br/></td></tr>
<tr class="separator:a1980ceb02ed996944d1f2508d128d91c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c013e89eb83e984483ee34fc91d68c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#a49c013e89eb83e984483ee34fc91d68c">setStore</a> (const <a class="el" href="../../da/da2/classDataLink.html">DataLink</a>&lt; <a class="el" href="../../d3/dd5/classSG_1_1IConstAuxStore.html">SG::IConstAuxStore</a> &gt; &amp;store)</td></tr>
<tr class="memdesc:a49c013e89eb83e984483ee34fc91d68c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the store associated with this object.  <a href="#a49c013e89eb83e984483ee34fc91d68c">More...</a><br/></td></tr>
<tr class="separator:a49c013e89eb83e984483ee34fc91d68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Data access.</h2></td></tr>
<tr class="memitem:a95f42871b1d206674b8f49a8cd73ae55"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#a95f42871b1d206674b8f49a8cd73ae55">s_minCacheLen</a> = 1024</td></tr>
<tr class="memdesc:a95f42871b1d206674b8f49a8cd73ae55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum length to use for the cache vector.  <a href="#a95f42871b1d206674b8f49a8cd73ae55">More...</a><br/></td></tr>
<tr class="separator:a95f42871b1d206674b8f49a8cd73ae55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe342233ecc5416805b44a47db63815a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d59/namespaceSG.html#a1a8bcc4ee42936e2b794bac38e0f6de0">SG::auxid_set_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#abe342233ecc5416805b44a47db63815a">getAuxIDs</a> () const </td></tr>
<tr class="memdesc:abe342233ecc5416805b44a47db63815a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a set of identifiers for existing data items in store associated with this object.  <a href="#abe342233ecc5416805b44a47db63815a">More...</a><br/></td></tr>
<tr class="separator:abe342233ecc5416805b44a47db63815a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d2ca97c7546abb52972902ff47a275"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d59/namespaceSG.html#a1a8bcc4ee42936e2b794bac38e0f6de0">SG::auxid_set_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#a52d2ca97c7546abb52972902ff47a275">getWritableAuxIDs</a> () const </td></tr>
<tr class="memdesc:a52d2ca97c7546abb52972902ff47a275"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a set of identifiers for writable data items in this store.  <a href="#a52d2ca97c7546abb52972902ff47a275">More...</a><br/></td></tr>
<tr class="separator:a52d2ca97c7546abb52972902ff47a275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff7bce34ddc38433ed057fab2b0e9280"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#aff7bce34ddc38433ed057fab2b0e9280">isAvailable</a> (<a class="el" href="../../dd/d59/namespaceSG.html#affee481ab18822e03866e0a0d3ff011c">auxid_t</a> id) const </td></tr>
<tr class="memdesc:aff7bce34ddc38433ed057fab2b0e9280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test to see if a variable exists in the store.  <a href="#aff7bce34ddc38433ed057fab2b0e9280">More...</a><br/></td></tr>
<tr class="separator:aff7bce34ddc38433ed057fab2b0e9280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a296b108b94c2b60cf894f05cbea26"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a08a296b108b94c2b60cf894f05cbea26"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#a08a296b108b94c2b60cf894f05cbea26">isAvailable</a> (const std::string &amp;name, const std::string &amp;clsname=&quot;&quot;) const </td></tr>
<tr class="memdesc:a08a296b108b94c2b60cf894f05cbea26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test to see if a variable exists in the store.  <a href="#a08a296b108b94c2b60cf894f05cbea26">More...</a><br/></td></tr>
<tr class="separator:a08a296b108b94c2b60cf894f05cbea26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02bd683426600b15e16ae9d7ba88b589"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#a02bd683426600b15e16ae9d7ba88b589">isAvailableWritable</a> (<a class="el" href="../../dd/d59/namespaceSG.html#affee481ab18822e03866e0a0d3ff011c">auxid_t</a> id) const </td></tr>
<tr class="memdesc:a02bd683426600b15e16ae9d7ba88b589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test to see if a variable is available for writing.  <a href="#a02bd683426600b15e16ae9d7ba88b589">More...</a><br/></td></tr>
<tr class="separator:a02bd683426600b15e16ae9d7ba88b589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab191e8b91f040d3f8bdb35ca97fef04c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab191e8b91f040d3f8bdb35ca97fef04c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#ab191e8b91f040d3f8bdb35ca97fef04c">isAvailableWritable</a> (const std::string &amp;name, const std::string &amp;clsname=&quot;&quot;) const </td></tr>
<tr class="memdesc:ab191e8b91f040d3f8bdb35ca97fef04c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test to see if a variable is available for writing.  <a href="#ab191e8b91f040d3f8bdb35ca97fef04c">More...</a><br/></td></tr>
<tr class="separator:ab191e8b91f040d3f8bdb35ca97fef04c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f2136a2be890f5cf9e12b01342d50de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#a3f2136a2be890f5cf9e12b01342d50de">isAvailableWritableAsDecoration</a> (<a class="el" href="../../dd/d59/namespaceSG.html#affee481ab18822e03866e0a0d3ff011c">auxid_t</a> id) const </td></tr>
<tr class="memdesc:a3f2136a2be890f5cf9e12b01342d50de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test to see if a variable is available for writing as a decoration.  <a href="#a3f2136a2be890f5cf9e12b01342d50de">More...</a><br/></td></tr>
<tr class="separator:a3f2136a2be890f5cf9e12b01342d50de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4848d1566f78ee97f73b33741e2035c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab4848d1566f78ee97f73b33741e2035c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#ab4848d1566f78ee97f73b33741e2035c">isAvailableWritableAsDecoration</a> (const std::string &amp;name, const std::string &amp;clsname=&quot;&quot;) const </td></tr>
<tr class="memdesc:ab4848d1566f78ee97f73b33741e2035c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test to see if a variable is available for writing as a decoration.  <a href="#ab4848d1566f78ee97f73b33741e2035c">More...</a><br/></td></tr>
<tr class="separator:ab4848d1566f78ee97f73b33741e2035c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9234d6da5484f6699a4fe2a4873eb617"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a9234d6da5484f6699a4fe2a4873eb617"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d0/d6e/classSG_1_1AuxDataTraits.html">AuxDataTraits</a>&lt; T &gt;::reference_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#a9234d6da5484f6699a4fe2a4873eb617">getData</a> (<a class="el" href="../../dd/d59/namespaceSG.html#affee481ab18822e03866e0a0d3ff011c">SG::auxid_t</a> auxid, size_t ndx)</td></tr>
<tr class="memdesc:a9234d6da5484f6699a4fe2a4873eb617"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return reference to an aux data item.  <a href="#a9234d6da5484f6699a4fe2a4873eb617">More...</a><br/></td></tr>
<tr class="separator:a9234d6da5484f6699a4fe2a4873eb617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c5a911acaf8b8981bc81bed93184532"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a0c5a911acaf8b8981bc81bed93184532"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d0/d6e/classSG_1_1AuxDataTraits.html">AuxDataTraits</a>&lt; T &gt;<br class="typebreak"/>
::const_reference_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#a0c5a911acaf8b8981bc81bed93184532">getData</a> (<a class="el" href="../../dd/d59/namespaceSG.html#affee481ab18822e03866e0a0d3ff011c">SG::auxid_t</a> auxid, size_t ndx) const </td></tr>
<tr class="memdesc:a0c5a911acaf8b8981bc81bed93184532"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return const reference to an aux data item.  <a href="#a0c5a911acaf8b8981bc81bed93184532">More...</a><br/></td></tr>
<tr class="separator:a0c5a911acaf8b8981bc81bed93184532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae171198131dc47c28e9eb9074eb82421"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae171198131dc47c28e9eb9074eb82421"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d0/d6e/classSG_1_1AuxDataTraits.html">AuxDataTraits</a>&lt; T &gt;::reference_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#ae171198131dc47c28e9eb9074eb82421">getDecoration</a> (<a class="el" href="../../dd/d59/namespaceSG.html#affee481ab18822e03866e0a0d3ff011c">SG::auxid_t</a> auxid, size_t ndx) const </td></tr>
<tr class="memdesc:ae171198131dc47c28e9eb9074eb82421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return reference to an aux decoration item.  <a href="#ae171198131dc47c28e9eb9074eb82421">More...</a><br/></td></tr>
<tr class="separator:ae171198131dc47c28e9eb9074eb82421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac60d418d024c0970f058e147b2e0ee6c"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#ac60d418d024c0970f058e147b2e0ee6c">getDataArray</a> (<a class="el" href="../../dd/d59/namespaceSG.html#affee481ab18822e03866e0a0d3ff011c">SG::auxid_t</a> auxid) const </td></tr>
<tr class="memdesc:ac60d418d024c0970f058e147b2e0ee6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const pointer to the start of an aux data vector.  <a href="#ac60d418d024c0970f058e147b2e0ee6c">More...</a><br/></td></tr>
<tr class="separator:ac60d418d024c0970f058e147b2e0ee6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ef17864033f73d8b7d4a516241a138"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#ae5ef17864033f73d8b7d4a516241a138">getDataArrayAllowMissing</a> (<a class="el" href="../../dd/d59/namespaceSG.html#affee481ab18822e03866e0a0d3ff011c">SG::auxid_t</a> auxid) const </td></tr>
<tr class="memdesc:ae5ef17864033f73d8b7d4a516241a138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const pointer to the start of an aux data vector.  <a href="#ae5ef17864033f73d8b7d4a516241a138">More...</a><br/></td></tr>
<tr class="separator:ae5ef17864033f73d8b7d4a516241a138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d9f283f683d509706b255b47f80719f"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#a9d9f283f683d509706b255b47f80719f">getDataArray</a> (<a class="el" href="../../dd/d59/namespaceSG.html#affee481ab18822e03866e0a0d3ff011c">SG::auxid_t</a> auxid)</td></tr>
<tr class="memdesc:a9d9f283f683d509706b255b47f80719f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the start of an aux data vector.  <a href="#a9d9f283f683d509706b255b47f80719f">More...</a><br/></td></tr>
<tr class="separator:a9d9f283f683d509706b255b47f80719f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42670ce61a36909d86c7cda581c38535"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html#a42670ce61a36909d86c7cda581c38535">getDecorationArray</a> (<a class="el" href="../../dd/d59/namespaceSG.html#affee481ab18822e03866e0a0d3ff011c">SG::auxid_t</a> auxid) const </td></tr>
<tr class="memdesc:a42670ce61a36909d86c7cda581c38535"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the start of an aux data vector for a decoration.  <a href="#a42670ce61a36909d86c7cda581c38535">More...</a><br/></td></tr>
<tr class="separator:a42670ce61a36909d86c7cda581c38535"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Manage lookup of vectors of auxiliary data. </p>
<p>An object, usually a <code><a class="el" href="../../d0/d4d/classDataVector.html" title="Derived DataVector&lt;T&gt;. ">DataVector</a></code>, can have vectors of auxiliary data associated with it. This class manages this association.</p>
<p>An auxiliary data item is identified by an integer of type <code><a class="el" href="../../dd/d59/namespaceSG.html#affee481ab18822e03866e0a0d3ff011c" title="Identifier for a particular aux data item. ">SG::auxid_t</a></code>. The <code>getData</code> methods can be used to get a reference to one auxiliary data element given the <code>auxid</code> and the vector index. However, <code>getData</code> does not do type checking, so it should generally not be used. (Use instead the <code>Accessor</code> or <code>ConstAccessor</code> classes defined in <code><a class="el" href="../../dc/db0/classSG_1_1AuxElement.html" title="Base class for elements of a container that can have aux data. ">AuxElement</a></code>.)</p>
<p>The auxiliary data is not managed by this class, but rather by a separate `aux store' class, to which we hold a pointer. Actually, there can be two pointers. We define two interfaces for an aux store, <code><a class="el" href="../../d3/dd5/classSG_1_1IConstAuxStore.html" title="Interface for const operations on an auxiliary store. ">IConstAuxStore</a></code>, which defines operations for accessing data read-only, and <code><a class="el" href="../../dc/d05/classSG_1_1IAuxStore.html" title="Interface for non-const operations on an auxiliary store. ">IAuxStore</a></code>, which defines operations for modifying data. If we have a const store, only the pointer to the const interface is set; if we have non-const store, then both pointers are set (to the same object).</p>
<p>To speed up access to aux data, we cache pointers to the start of the data for each vector. There are separate caches for const and non-const pointers. If you make any changes to the aux store behind the back of this container object, you should call <code>clearCache</code>.</p>
<p>We also support adding `decorations' to a const container. These are new auxiliary data items that don't conflict with existing ones. See <a class="el" href="../../d3/dd5/classSG_1_1IConstAuxStore.html" title="Interface for const operations on an auxiliary store. ">IConstAuxStore</a> for more information.</p>
<p>Notes on thread safety:</p>
<p>It's a little tricky to make this class thread-safe without spoiling the optimizations in getDataArray. This section outlines some of the considerations that went into the chosen solution.</p>
<p>First, by `thread-safe', we mean that getDataArray can be called in different threads without problems. This is necessary to allow simultaneous reads of the container. We make no attempt to any synchronization on modifications to the container, such as adding elements. Such operations must be synchronized externally. This is the same sort of thread semantics that the STL containers supply. So our considerations of thread-safety involve only the management of the cache vector.</p>
<p>Second, reads (of the cache vector) are very common (and inlined), while modifications of it are uncommon (and handled by out-of-line code). Thus, we would like reading to be entirely lock-free. If we need to make modifications, though, we can do whatever locking we need. Making the reader lock-free, though, is complicated by the fact that the cache vector may relocate in memory if is expanded.</p>
<p>A way forward is suggested by read-copy-update (<a class="el" href="../../d9/d83/namespaceRCU.html">RCU</a>) synchronization. The idea there is that when you want to change some structure, you copy it and work on the copy. When the modifications are done, the new structure is copied to the old one in such a manner that at any instant in time, any reader will see a consistent version of the structure (even though it may not be the most recent one).</p>
<p>For this case, we can store the vector as a length and a pointer to the beginning. When we want to access AUXID, we first compare it to the length. If that's ok, then we test the pointer at index AUXID. If that's non-null, we go ahead and use it; if either test fails, we go to the out-of-line code.</p>
<p>The out-of-line code can then take out a lock and will in the new pointer in the vector. If it is necessary to expand the the vector, we allocate a new one and copy the old vector to the new one. Then we update the values: first, the pointer, then the length. This ensures that the inline code will always see something consistent. Then we must delay freeing the old vector until we're sure that no thread can possibly be using it anymore. For now, we just avoid deleting the old vectors until the container itself is deleted; the memory wasted by this should be negligible in the context of reconstruction.</p>
<p>This allows the inline part of the code to avoid locking. However, there is an additional critical detail. We have a test like this:</p>
<p>m_cache_length &lt;= auxid || !m_cache[auxid]</p>
<p>As long as the length is read before the cache pointer itself, everything's fine, even if those reads were some time in the past. But if the reads can be in the other order, we could face disaster. While the short-circuit operator should prevent the array indexing from happening before the length is read, there is nothing a priori to prevent a speculative read of m_cache before the length. For the cognoscenti, this is a `control dependency' (rather than a `data dependency'), which implies no ordering guarantees.</p>
<p>Now, we can deal with this by inserting a read barrier between the two loads. That should be correct in all cases. However, that tends to destroy the optimization below for repeated references to the same aux data item (see the use of <code>ATHCONTAINERS_ASSUME</code> in <code>getDataArray</code> in the icc file).</p>
<p>It turns out that on x86 machines, memory ordering guarantees are relatively strong. In particular, loads cannot be reordered with other loads, and stores from one CPU are seen in the same order by all other CPUs. So in this case, no barrier is actually needed &mdash; provided that the compiler emits the loads in the correct order. The supported way to do this with gcc is to use `asm volatile ("":::"memory")' &mdash; however, that explicitly clobbers member, which again spoils our optimization.</p>
<p>While it seems unlikely that the compiler would actually find it worthwhile to reorder the loads on an x86 machine, some extra safety would be nice. We try to prevent this reordering by adding an explicit data dependency. Instead of a single m_cache pointer, we have an array of two pointers (which will be identical) and use m_cache[m_cache_len&amp;1]. This provides an explicit data dependency which should prevent reading the pointer before the length; the cost is an added and operation and adding an index register to the dereference operation.</p>
<p>Actually, this is not completely watertight; the compiler could in principle decide to speculate the reads of both pointers, or speculate one and then throw it away if it guessed wrong. This seems sufficiently unlikely to be an issue that we'll live with it for now &mdash; though it might be worth having something to validate the generated code. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aa05239b04a4e91b0bcc8da201f2cccaa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t SG::AuxVectorData::capacity_v </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the capacity of the container. </p>
<p>This is used when we need to create a new aux data vector. </p>

<p>Implemented in <a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a236a9f58b14de59ef54c5107dfcff5dc">DataVector&lt; T, DataModel_detail::NoBase &gt;</a>, and <a class="el" href="../../dc/dfb/classSG_1_1AuxElementData.html#a299e4488cfcb6a08e7611fde899defbc">SG::AuxElementData</a>.</p>

</div>
</div>
<a class="anchor" id="a5d6d9eefd8811b373b3eeda823e5c0ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SG::AuxVectorData::clearCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the cached aux data pointers. </p>
<p>You should call this any time something changes in the aux store that could invalidate the vector pointers.</p>
<p>You should call this anytime something changes in the aux store that could invalidate the vector pointers. </p>

</div>
</div>
<a class="anchor" id="a35c86d28fd74648ddae868dc5fa005d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SG::AuxVectorData::clearDecorations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear all decorations. </p>
<p>Erase all decorations from the store, restoring the state to when <code>lock</code> was called. </p>

</div>
</div>
<a class="anchor" id="abe342233ecc5416805b44a47db63815a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dd/d59/namespaceSG.html#a1a8bcc4ee42936e2b794bac38e0f6de0">SG::auxid_set_t</a> &amp; SG::AuxVectorData::getAuxIDs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a set of identifiers for existing data items in store associated with this object. </p>
<p>This will include identifiers for all items, const and non-const. If no store is associated with this object, this will return an empty set. </p>

</div>
</div>
<a class="anchor" id="a239b57ce5e7833bb83c8f0bf3b390814"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d3/dd5/classSG_1_1IConstAuxStore.html">SG::IConstAuxStore</a> * SG::AuxVectorData::getConstStore </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the current store, as a const interface. </p>
<p>This will be non-zero if either a const or non-const store is associated with this object. </p>

</div>
</div>
<a class="anchor" id="a9234d6da5484f6699a4fe2a4873eb617"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d6e/classSG_1_1AuxDataTraits.html">AuxDataTraits</a>&lt; T &gt;::reference_type SG::AuxVectorData::getData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dd/d59/namespaceSG.html#affee481ab18822e03866e0a0d3ff011c">SG::auxid_t</a>&#160;</td>
          <td class="paramname"><em>auxid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ndx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return reference to an aux data item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">auxid</td><td>The desired aux data item. </td></tr>
    <tr><td class="paramname">ndx</td><td>Index of the element to return.</td></tr>
  </table>
  </dd>
</dl>
<p>This will return a reference to element <code>ndx</code> of aux data item <code>auxid</code>. If the aux data item does not exist, it will be created. Errors are signaled by raising an exception.</p>
<p>Warning: no type checking is done. You should usually access the data via <code><a class="el" href="../../d8/d31/classSG_1_1AuxElement_1_1Accessor.html" title="Helper class to provide type-safe access to aux data. ">AuxElement::Accessor</a></code> or <code><a class="el" href="../../dd/d86/classSG_1_1AuxElement_1_1ConstAccessor.html" title="Helper class to provide constant type-safe access to aux data. ">AuxElement::ConstAccessor</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">auxid</td><td>The desired aux data item. </td></tr>
    <tr><td class="paramname">ndx</td><td>Index of the element to return.</td></tr>
  </table>
  </dd>
</dl>
<p>This will return a reference to element <code>ndx</code> of aux data item <code>auxid</code>. If the aux data item does not exist, it will be created. Errors are signaled by raising an exception.</p>
<p>Warning: no type checking is done. You should usually access the data via <code><a class="el" href="../../d8/d31/classSG_1_1AuxElement_1_1Accessor.html" title="Helper class to provide type-safe access to aux data. ">AuxElement::Accessor</a></code>. </p>

</div>
</div>
<a class="anchor" id="a0c5a911acaf8b8981bc81bed93184532"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d6e/classSG_1_1AuxDataTraits.html">AuxDataTraits</a>&lt; T &gt;::const_reference_type SG::AuxVectorData::getData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dd/d59/namespaceSG.html#affee481ab18822e03866e0a0d3ff011c">SG::auxid_t</a>&#160;</td>
          <td class="paramname"><em>auxid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ndx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return const reference to an aux data item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">auxid</td><td>The desired aux data item. </td></tr>
    <tr><td class="paramname">ndx</td><td>Index of the element to return.</td></tr>
  </table>
  </dd>
</dl>
<p>This will return a reference to element <code>ndx</code> of aux data item <code>auxid</code>. Errors are signaled by raising an exception.</p>
<p>Warning: no type checking is done. You should usually access the data via <code><a class="el" href="../../d8/d31/classSG_1_1AuxElement_1_1Accessor.html" title="Helper class to provide type-safe access to aux data. ">AuxElement::Accessor</a></code> or <code><a class="el" href="../../dd/d86/classSG_1_1AuxElement_1_1ConstAccessor.html" title="Helper class to provide constant type-safe access to aux data. ">AuxElement::ConstAccessor</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">auxid</td><td>The desired aux data item. </td></tr>
    <tr><td class="paramname">ndx</td><td>Index of the element to return.</td></tr>
  </table>
  </dd>
</dl>
<p>This will return a reference to element <code>ndx</code> of aux data item <code>auxid</code>. If the aux data item does not exist, it will be created. Errors are signaled by raising an exception.</p>
<p>Warning: no type checking is done. You should usually access the data via <code><a class="el" href="../../d8/d31/classSG_1_1AuxElement_1_1Accessor.html" title="Helper class to provide type-safe access to aux data. ">AuxElement::Accessor</a></code>. </p>

</div>
</div>
<a class="anchor" id="ac60d418d024c0970f058e147b2e0ee6c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const void * SG::AuxVectorData::getDataArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dd/d59/namespaceSG.html#affee481ab18822e03866e0a0d3ff011c">SG::auxid_t</a>&#160;</td>
          <td class="paramname"><em>auxid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const pointer to the start of an aux data vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">auxid</td><td>The desired aux data item.</td></tr>
  </table>
  </dd>
</dl>
<p>This will return a pointer to the start of the data for aux data item <code>auxid</code>. Errors are signaled by raising an exception. </p>

</div>
</div>
<a class="anchor" id="a9d9f283f683d509706b255b47f80719f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * SG::AuxVectorData::getDataArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dd/d59/namespaceSG.html#affee481ab18822e03866e0a0d3ff011c">SG::auxid_t</a>&#160;</td>
          <td class="paramname"><em>auxid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer to the start of an aux data vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">auxid</td><td>The desired aux data item.</td></tr>
  </table>
  </dd>
</dl>
<p>This will return a pointer to the start of the data for aux data item <code>auxid</code>. If the item doesn't exist, it will be created. Errors are signaled by raising an exception. </p>

</div>
</div>
<a class="anchor" id="ae5ef17864033f73d8b7d4a516241a138"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const void * SG::AuxVectorData::getDataArrayAllowMissing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dd/d59/namespaceSG.html#affee481ab18822e03866e0a0d3ff011c">SG::auxid_t</a>&#160;</td>
          <td class="paramname"><em>auxid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const pointer to the start of an aux data vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">auxid</td><td>The desired aux data item.</td></tr>
  </table>
  </dd>
</dl>
<p>This will return a pointer to the start of the data for aux data item <code>auxid</code>. If the item does not exist, this will return nullptr rather than raising an exception. </p>

</div>
</div>
<a class="anchor" id="ae171198131dc47c28e9eb9074eb82421"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d6e/classSG_1_1AuxDataTraits.html">AuxDataTraits</a>&lt; T &gt;::reference_type SG::AuxVectorData::getDecoration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dd/d59/namespaceSG.html#affee481ab18822e03866e0a0d3ff011c">SG::auxid_t</a>&#160;</td>
          <td class="paramname"><em>auxid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ndx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return reference to an aux decoration item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">auxid</td><td>The desired aux decoration item. </td></tr>
    <tr><td class="paramname">ndx</td><td>Index of the element to return.</td></tr>
  </table>
  </dd>
</dl>
<p>This will return a reference to element <code>ndx</code> of aux decoration item <code>auxid</code>. If the aux data item does not exist, it will be created. Errors are signaled by raising an exception.</p>
<p>Warning: no type checking is done. You should usually access the data via <code><a class="el" href="../../d3/d59/classSG_1_1AuxElement_1_1Decorator.html" title="Helper class to provide type-safe access to aux data. ">AuxElement::Decorator</a></code>.</p>
<p>The difference between <code>getDecoration</code> and <code>getData</code> is that <code>getDecoration</code> takes a const container as input, but returns a non-const reference. This will only succeed if either the container is not locked or the item was first accessed as a decoration. </p>

</div>
</div>
<a class="anchor" id="a42670ce61a36909d86c7cda581c38535"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * SG::AuxVectorData::getDecorationArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dd/d59/namespaceSG.html#affee481ab18822e03866e0a0d3ff011c">SG::auxid_t</a>&#160;</td>
          <td class="paramname"><em>auxid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer to the start of an aux data vector for a decoration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">auxid</td><td>The desired aux data item.</td></tr>
  </table>
  </dd>
</dl>
<p>This will return a pointer to the start of the data for aux data item <code>auxid</code>. If the item doesn't exist, it will be created. Errors are signaled by raising an exception.</p>
<p>The difference between <code>getDecorationArray</code> and <code>getDataArray</code> is that <code>getDecorationArray</code> takes a const container as input, but returns a non-const pointer. This will only succeed if either the container is not locked or the item was first accessed as a decoration. </p>

</div>
</div>
<a class="anchor" id="af1d8f5f0dd148fbf2041560f77ab0113"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d05/classSG_1_1IAuxStore.html">SG::IAuxStore</a> * SG::AuxVectorData::getStore </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the current store, as a non-const interface. </p>
<p>This will be non-zero if a non-const store is associated with this object. </p>

</div>
</div>
<a class="anchor" id="a52d2ca97c7546abb52972902ff47a275"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dd/d59/namespaceSG.html#a1a8bcc4ee42936e2b794bac38e0f6de0">SG::auxid_set_t</a> &amp; SG::AuxVectorData::getWritableAuxIDs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a set of identifiers for writable data items in this store. </p>
<p>This will include only non-const identifiers. If no store is associated with this object, this will return an empty set. </p>

</div>
</div>
<a class="anchor" id="aff7bce34ddc38433ed057fab2b0e9280"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SG::AuxVectorData::isAvailable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dd/d59/namespaceSG.html#affee481ab18822e03866e0a0d3ff011c">auxid_t</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test to see if a variable exists in the store. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The variable to test. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a08a296b108b94c2b60cf894f05cbea26"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SG::AuxVectorData::isAvailable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>clsname</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test to see if a variable exists in the store. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the aux variable. </td></tr>
    <tr><td class="paramname">clsname</td><td>The name of the associated class. May be blank. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a02bd683426600b15e16ae9d7ba88b589"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SG::AuxVectorData::isAvailableWritable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dd/d59/namespaceSG.html#affee481ab18822e03866e0a0d3ff011c">auxid_t</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test to see if a variable is available for writing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The variable to test. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab191e8b91f040d3f8bdb35ca97fef04c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SG::AuxVectorData::isAvailableWritable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>clsname</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test to see if a variable is available for writing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the aux variable. </td></tr>
    <tr><td class="paramname">clsname</td><td>The name of the associated class. May be blank. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3f2136a2be890f5cf9e12b01342d50de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SG::AuxVectorData::isAvailableWritableAsDecoration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dd/d59/namespaceSG.html#affee481ab18822e03866e0a0d3ff011c">auxid_t</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test to see if a variable is available for writing as a decoration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The variable to test. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab4848d1566f78ee97f73b33741e2035c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SG::AuxVectorData::isAvailableWritableAsDecoration </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>clsname</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test to see if a variable is available for writing as a decoration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the aux variable. </td></tr>
    <tr><td class="paramname">clsname</td><td>The name of the associated class. May be blank. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4379058b2eb0522291c4c20076ef7967"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SG::AuxVectorData::lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lock the container. </p>
<p>After this, only decorations can be changed/modified. If the container is already locked, this is a no-op. </p>

</div>
</div>
<a class="anchor" id="adad5487f0cdf6cd0d7de68dd84570324"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SG::AuxVectorData::setOption </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dd/d59/namespaceSG.html#affee481ab18822e03866e0a0d3ff011c">auxid_t</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d31/classSG_1_1AuxDataOption.html">AuxDataOption</a> &amp;&#160;</td>
          <td class="paramname"><em>option</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an option for an auxiliary data variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The variable for which we want to set the option. </td></tr>
    <tr><td class="paramname">option</td><td>The option setting to make.</td></tr>
  </table>
  </dd>
</dl>
<p>The interpretation of <code>option</code> depends on the associated auxiliary store. See <a class="el" href="../../d4/d43/PackedParameters_8h.html" title="Describe how the contents of a PackedContainer are to be saved. ">PackedParameters.h</a> for option settings for writing packed data. Returns <code>true</code> on success, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a6f683bea801877c1001faa8116679ac4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SG::AuxVectorData::setOption </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d31/classSG_1_1AuxDataOption.html">AuxDataOption</a> &amp;&#160;</td>
          <td class="paramname"><em>option</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an option for an auxiliary data variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the variable. </td></tr>
    <tr><td class="paramname">option</td><td>The option setting to make.</td></tr>
  </table>
  </dd>
</dl>
<p>The interpretation of <code>option</code> depends on the associated auxiliary store. See <a class="el" href="../../d4/d43/PackedParameters_8h.html" title="Describe how the contents of a PackedContainer are to be saved. ">PackedParameters.h</a> for option settings for writing packed data. Returns <code>true</code> on success, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="ab49a59f74e1b4e28fc637d0fbfc8ec80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SG::AuxVectorData::setOption </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>clsname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d31/classSG_1_1AuxDataOption.html">AuxDataOption</a> &amp;&#160;</td>
          <td class="paramname"><em>option</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an option for an auxiliary data variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the variable. </td></tr>
    <tr><td class="paramname">clsname</td><td>The name of the associated class. May be blank. </td></tr>
    <tr><td class="paramname">option</td><td>The option setting to make.</td></tr>
  </table>
  </dd>
</dl>
<p>The interpretation of <code>option</code> depends on the associated auxiliary store. See <a class="el" href="../../d4/d43/PackedParameters_8h.html" title="Describe how the contents of a PackedContainer are to be saved. ">PackedParameters.h</a> for option settings for writing packed data. Returns <code>true</code> on success, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a36b3fbcb003e51c6f527aa309503a5cb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool SG::AuxVectorData::setOption </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dd/d59/namespaceSG.html#affee481ab18822e03866e0a0d3ff011c">auxid_t</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an option for an auxiliary data variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The variable for which we want to set the option. </td></tr>
    <tr><td class="paramname">optname</td><td>The name of the option to set. </td></tr>
    <tr><td class="paramname">arg</td><td>The option value to set.</td></tr>
  </table>
  </dd>
</dl>
<p>The interpretation of <code>option</code> depends on the associated auxiliary store. See <a class="el" href="../../d4/d43/PackedParameters_8h.html" title="Describe how the contents of a PackedContainer are to be saved. ">PackedParameters.h</a> for option settings for writing packed data. Returns <code>true</code> on success, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a51e648949c78a087367e8788dca149f2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SG::AuxVectorData::setOption </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set an option for an auxiliary data variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the variable. </td></tr>
    <tr><td class="paramname">optname</td><td>The name of the option to set. </td></tr>
    <tr><td class="paramname">arg</td><td>The option value to set.</td></tr>
  </table>
  </dd>
</dl>
<p>The interpretation of <code>option</code> depends on the associated auxiliary store. See <a class="el" href="../../d4/d43/PackedParameters_8h.html" title="Describe how the contents of a PackedContainer are to be saved. ">PackedParameters.h</a> for option settings for writing packed data. Returns <code>true</code> on success, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a4d807cdcacfd4bd97e565690495e8a4e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool SG::AuxVectorData::setOption </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>clsname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an option for an auxiliary data variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the variable. </td></tr>
    <tr><td class="paramname">clsname</td><td>The name of the associated class. May be blank. </td></tr>
    <tr><td class="paramname">optname</td><td>The name of the option to set. </td></tr>
    <tr><td class="paramname">arg</td><td>The option value to set.</td></tr>
  </table>
  </dd>
</dl>
<p>The interpretation of <code>option</code> depends on the associated auxiliary store. See <a class="el" href="../../d4/d43/PackedParameters_8h.html" title="Describe how the contents of a PackedContainer are to be saved. ">PackedParameters.h</a> for option settings for writing packed data. Returns <code>true</code> on success, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="af6e2da3c14ea74935120cd1b5a37f021"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SG::AuxVectorData::setStore </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/dd5/classSG_1_1IConstAuxStore.html">SG::IConstAuxStore</a> *&#160;</td>
          <td class="paramname"><em>store</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the store associated with this object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">store</td><td>The new store.</td></tr>
  </table>
  </dd>
</dl>
<p>This will clear the non-const store pointer, and also clear the cache.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">The</td><td>new store.</td></tr>
  </table>
  </dd>
</dl>
<p>This will clear the non-const store pointer, and also clear the cache. </p>

</div>
</div>
<a class="anchor" id="a1980ceb02ed996944d1f2508d128d91c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SG::AuxVectorData::setStore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d05/classSG_1_1IAuxStore.html">SG::IAuxStore</a> *&#160;</td>
          <td class="paramname"><em>store</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the store associated with this object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">store</td><td>The new store.</td></tr>
  </table>
  </dd>
</dl>
<p>This will set both the const and non-const store pointers, and also clear the cache.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">The</td><td>new store.</td></tr>
  </table>
  </dd>
</dl>
<p>This will set both the const and non-const store pointers, and also clear the cache. </p>

</div>
</div>
<a class="anchor" id="a49c013e89eb83e984483ee34fc91d68c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SG::AuxVectorData::setStore </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/da2/classDataLink.html">DataLink</a>&lt; <a class="el" href="../../d3/dd5/classSG_1_1IConstAuxStore.html">SG::IConstAuxStore</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>store</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the store associated with this object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">store</td><td>The new store.</td></tr>
  </table>
  </dd>
</dl>
<p>This will clear the non-const store pointer, and also clear the cache.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">The</td><td>new store.</td></tr>
  </table>
  </dd>
</dl>
<p>This will clear the non-const store pointer, and also clear the cache. </p>

</div>
</div>
<a class="anchor" id="a72f56c76a3c92d48d8364723c0161af3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t SG::AuxVectorData::size_v </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the size of the container. </p>
<p>This is used when we need to create a new aux data vector. </p>

<p>Implemented in <a class="el" href="../../d0/d91/classDataVector_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#a258f5c8833dc8e1d659960784c468f25">DataVector&lt; T, DataModel_detail::NoBase &gt;</a>, and <a class="el" href="../../dc/dfb/classSG_1_1AuxElementData.html#a5521e3f733358f3f5f97993d6d1766b1">SG::AuxElementData</a>.</p>

</div>
</div>
<a class="anchor" id="aea4d64e4a85beda13d1243ece5d210e2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SG::AuxVectorData::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/dd6/classSG_1_1AuxVectorData.html">AuxVectorData</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap this instance with another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other instance with which to swap. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a95f42871b1d206674b8f49a8cd73ae55"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SG::AuxVectorData::s_minCacheLen = 1024</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Minimum length to use for the cache vector. </p>
<p>Minimum length to use for the cache vector. This can be changed for regression tests. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.31/AthContainers/AthContainers/<a class="el" href="../../d9/df2/AuxVectorData_8h_source.html">AuxVectorData.h</a></li>
<li>/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.31/AthContainers/AthContainers/<a class="el" href="../../da/de7/AuxVectorData_8icc.html">AuxVectorData.icc</a></li>
<li>/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.31/AthContainers/Root/AuxVectorData.cxx</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Dec 1 2017 11:09:01 for RootCore Packages by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
