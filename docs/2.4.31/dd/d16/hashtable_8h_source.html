<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>RootCore Packages: /cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.31/CxxUtils/CxxUtils/hashtable.h Source File</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="../../index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="../../search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="../../files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="../../globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<h1>/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.31/CxxUtils/CxxUtils/hashtable.h</h1><a href="../../dd/d16/hashtable_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">// This file&apos;s extension implies that it&apos;s C, but it&apos;s really -*- C++ -*-.</span>
<a name="l00002"></a>00002 <span class="comment">// $Id: hashtable.h,v 1.4 2008-12-11 18:57:44 ssnyder Exp $</span>
<a name="l00015"></a>00015 <span class="comment"></span><span class="comment">// Internal header for TR1 unordered_set and unordered_map -*- C++ -*-</span>
<a name="l00016"></a>00016 <span class="comment">// Copyright (C) 2005, 2006 Free Software Foundation, Inc.</span>
<a name="l00017"></a>00017 <span class="comment">//</span>
<a name="l00018"></a>00018 <span class="comment">// This file is part of the GNU ISO C++ Library.  This library is free</span>
<a name="l00019"></a>00019 <span class="comment">// software; you can redistribute it and/or modify it under the</span>
<a name="l00020"></a>00020 <span class="comment">// terms of the GNU General Public License as published by the</span>
<a name="l00021"></a>00021 <span class="comment">// Free Software Foundation; either version 2, or (at your option)</span>
<a name="l00022"></a>00022 <span class="comment">// any later version.</span>
<a name="l00023"></a>00023 
<a name="l00024"></a>00024 <span class="comment">// This library is distributed in the hope that it will be useful,</span>
<a name="l00025"></a>00025 <span class="comment">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00026"></a>00026 <span class="comment">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00027"></a>00027 <span class="comment">// GNU General Public License for more details.</span>
<a name="l00028"></a>00028 
<a name="l00029"></a>00029 <span class="comment">// You should have received a copy of the GNU General Public License along</span>
<a name="l00030"></a>00030 <span class="comment">// with this library; see the file COPYING.  If not, write to the Free</span>
<a name="l00031"></a>00031 <span class="comment">// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,</span>
<a name="l00032"></a>00032 <span class="comment">// USA.</span>
<a name="l00033"></a>00033 
<a name="l00034"></a>00034 <span class="comment">// As a special exception, you may use this file as part of a free software</span>
<a name="l00035"></a>00035 <span class="comment">// library without restriction.  Specifically, if other files instantiate</span>
<a name="l00036"></a>00036 <span class="comment">// templates or use macros or inline functions from this file, or you compile</span>
<a name="l00037"></a>00037 <span class="comment">// this file and link it with other files to produce an executable, this</span>
<a name="l00038"></a>00038 <span class="comment">// file does not by itself cause the resulting executable to be covered by</span>
<a name="l00039"></a>00039 <span class="comment">// the GNU General Public License.  This exception does not however</span>
<a name="l00040"></a>00040 <span class="comment">// invalidate any other reasons why the executable file might be covered by</span>
<a name="l00041"></a>00041 <span class="comment">// the GNU General Public License.</span>
<a name="l00042"></a>00042 
<a name="l00043"></a>00043 <span class="comment">/*  @file  (sss --- hide from doxygen)</span>
<a name="l00044"></a>00044 <span class="comment"> *  This is a TR1 C++ Library header. </span>
<a name="l00045"></a>00045 <span class="comment"> */</span>
<a name="l00046"></a>00046 
<a name="l00047"></a>00047 <span class="comment">// This header file defines std::tr1::hashtable, which is used to</span>
<a name="l00048"></a>00048 <span class="comment">// implement std::tr1::unordered_set, std::tr1::unordered_map, </span>
<a name="l00049"></a>00049 <span class="comment">// std::tr1::unordered_multiset, and std::tr1::unordered_multimap.</span>
<a name="l00050"></a>00050 <span class="comment">// hashtable has many template parameters, partly to accommodate</span>
<a name="l00051"></a>00051 <span class="comment">// the differences between those four classes and partly to </span>
<a name="l00052"></a>00052 <span class="comment">// accommodate policy choices that go beyond what TR1 calls for.</span>
<a name="l00053"></a>00053 
<a name="l00054"></a>00054 <span class="comment">// ??? Arguably this should be Internal::hashtable, not std::tr1::hashtable.</span>
<a name="l00055"></a>00055 
<a name="l00056"></a>00056 <span class="comment">// Class template hashtable attempts to encapsulate all reasonable</span>
<a name="l00057"></a>00057 <span class="comment">// variation among hash tables that use chaining.  It does not handle</span>
<a name="l00058"></a>00058 <span class="comment">// open addressing.</span>
<a name="l00059"></a>00059 
<a name="l00060"></a>00060 <span class="comment">// References: </span>
<a name="l00061"></a>00061 <span class="comment">// M. Austern, &quot;A Proposal to Add Hash Tables to the Standard</span>
<a name="l00062"></a>00062 <span class="comment">//    Library (revision 4),&quot; WG21 Document N1456=03-0039, 2003.</span>
<a name="l00063"></a>00063 <span class="comment">// D. E. Knuth, The Art of Computer Programming, v. 3, Sorting and Searching.</span>
<a name="l00064"></a>00064 <span class="comment">// A. Tavori and V. Dreizin, &quot;Generic Associative Containers&quot;, 2004.</span>
<a name="l00065"></a>00065 <span class="comment">//    ??? Full citation?</span>
<a name="l00066"></a>00066 
<a name="l00067"></a>00067 <span class="preprocessor">#ifndef CXXUTILS_HASHTABLE_H // sss GNU_LIBSTDCXX_TR1_HASHTABLE_</span>
<a name="l00068"></a>00068 <span class="preprocessor"></span><span class="preprocessor">#define CXXUTILS_HASHTABLE_H // sss GNU_LIBSTDCXX_TR1_HASHTABLE_</span>
<a name="l00069"></a>00069 <span class="preprocessor"></span>
<a name="l00070"></a>00070 <span class="preprocessor">#include &lt;algorithm&gt;</span>
<a name="l00071"></a>00071 <span class="preprocessor">#include &lt;utility&gt;</span>      <span class="comment">// For std::pair</span>
<a name="l00072"></a>00072 <span class="preprocessor">#include &lt;iterator&gt;</span>
<a name="l00073"></a>00073 <span class="preprocessor">#include &lt;cstddef&gt;</span>
<a name="l00074"></a>00074 <span class="preprocessor">#include &lt;cstdlib&gt;</span>
<a name="l00075"></a>00075 <span class="preprocessor">#include &lt;cmath&gt;</span>
<a name="l00076"></a>00076 <span class="preprocessor">#include &lt;limits&gt;</span>
<a name="l00077"></a>00077 <span class="preprocessor">#include &lt;string&gt;</span>
<a name="l00078"></a>00078 <span class="preprocessor">#include &quot;boost/type_traits/remove_const.hpp&quot;</span> <span class="comment">// sss</span>
<a name="l00079"></a>00079 <span class="comment">//#include &lt;bits/functexcept.h&gt; sss</span>
<a name="l00080"></a>00080 <span class="comment">//#include &lt;tr1/type_traits&gt;    // For true_type and false_type sss</span>
<a name="l00081"></a>00081 
<a name="l00082"></a>00082 <span class="comment">//=====================================================================</span>
<a name="l00083"></a>00083 <span class="comment">// sss from TR1 type_traits</span>
<a name="l00084"></a>00084 <span class="keyword">namespace </span>CxxUtils_Internal {
<a name="l00085"></a>00085   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, _Tp __v&gt;
<a name="l00086"></a><a class="code" href="../../d1/dfc/structCxxUtils__Internal_1_1integral__constant.html">00086</a>     <span class="keyword">struct </span><a class="code" href="../../d1/dfc/structCxxUtils__Internal_1_1integral__constant.html">integral_constant</a>
<a name="l00087"></a>00087     {
<a name="l00088"></a>00088       <span class="keyword">static</span> <span class="keyword">const</span> _Tp                      value = __v;
<a name="l00089"></a>00089       <span class="keyword">typedef</span> _Tp                           value_type;
<a name="l00090"></a>00090       <span class="keyword">typedef</span> <a class="code" href="../../d1/dfc/structCxxUtils__Internal_1_1integral__constant.html">integral_constant&lt;_Tp, __v&gt;</a>   <a class="code" href="../../d1/dfc/structCxxUtils__Internal_1_1integral__constant.html">type</a>;
<a name="l00091"></a>00091     };
<a name="l00092"></a>00092   <span class="keyword">typedef</span> <a class="code" href="../../d1/dfc/structCxxUtils__Internal_1_1integral__constant.html">integral_constant&lt;bool, true&gt;</a>     <a class="code" href="../../d1/dfc/structCxxUtils__Internal_1_1integral__constant.html">true_type</a>;
<a name="l00093"></a>00093   <span class="keyword">typedef</span> <a class="code" href="../../d1/dfc/structCxxUtils__Internal_1_1integral__constant.html">integral_constant&lt;bool, false&gt;</a>    <a class="code" href="../../d1/dfc/structCxxUtils__Internal_1_1integral__constant.html">false_type</a>;
<a name="l00094"></a>00094 }
<a name="l00095"></a>00095 <span class="comment">// sss end from TR1 type_traits</span>
<a name="l00096"></a>00096 <span class="comment">//=====================================================================</span>
<a name="l00097"></a>00097 <span class="comment">//=====================================================================</span>
<a name="l00098"></a>00098 <span class="comment">// sss from TR1 functional</span>
<a name="l00099"></a>00099 <span class="keyword">namespace </span>SG {
<a name="l00100"></a>00100   <span class="comment">// Definition of default hash function std::tr1::hash&lt;&gt;.  The types for</span>
<a name="l00101"></a>00101   <span class="comment">// which std::tr1::hash&lt;T&gt; is defined is in clause 6.3.3. of the PDTR.</span>
<a name="l00102"></a>00102   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l00103"></a>00103     <span class="keyword">struct </span>hash;
<a name="l00104"></a>00104 
<a name="l00105"></a>00105 <span class="preprocessor">#define tr1_hashtable_define_trivial_hash(T)            \</span>
<a name="l00106"></a>00106 <span class="preprocessor">  template&lt;&gt;                                            \</span>
<a name="l00107"></a>00107 <span class="preprocessor">    struct hash&lt;T&gt;                                      \</span>
<a name="l00108"></a>00108 <span class="preprocessor">    : public std::unary_function&lt;T, std::size_t&gt;        \</span>
<a name="l00109"></a>00109 <span class="preprocessor">    {                                                   \</span>
<a name="l00110"></a>00110 <span class="preprocessor">      std::size_t                                       \</span>
<a name="l00111"></a>00111 <span class="preprocessor">      operator()(T val) const                           \</span>
<a name="l00112"></a>00112 <span class="preprocessor">      { return static_cast&lt;std::size_t&gt;(val); }         \</span>
<a name="l00113"></a>00113 <span class="preprocessor">    }                                                     </span>
<a name="l00114"></a>00114 <span class="preprocessor"></span>
<a name="l00115"></a>00115   tr1_hashtable_define_trivial_hash(<span class="keywordtype">bool</span>);
<a name="l00116"></a>00116   tr1_hashtable_define_trivial_hash(<span class="keywordtype">char</span>);
<a name="l00117"></a>00117   tr1_hashtable_define_trivial_hash(<span class="keywordtype">signed</span> <span class="keywordtype">char</span>);
<a name="l00118"></a>00118   tr1_hashtable_define_trivial_hash(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>);
<a name="l00119"></a>00119   tr1_hashtable_define_trivial_hash(<span class="keywordtype">wchar_t</span>);
<a name="l00120"></a>00120   tr1_hashtable_define_trivial_hash(<span class="keywordtype">short</span>);
<a name="l00121"></a>00121   tr1_hashtable_define_trivial_hash(<span class="keywordtype">int</span>);
<a name="l00122"></a>00122   tr1_hashtable_define_trivial_hash(<span class="keywordtype">long</span>);
<a name="l00123"></a>00123   tr1_hashtable_define_trivial_hash(<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>);
<a name="l00124"></a>00124   tr1_hashtable_define_trivial_hash(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>);
<a name="l00125"></a>00125   tr1_hashtable_define_trivial_hash(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>);
<a name="l00126"></a>00126 
<a name="l00127"></a>00127 <span class="preprocessor">#undef tr1_hashtable_define_trivial_hash</span>
<a name="l00128"></a>00128 <span class="preprocessor"></span>
<a name="l00129"></a>00129   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l00130"></a><a class="code" href="../../d8/d7d/structSG_1_1hash_3_01T_01_5_01_4.html">00130</a>     <span class="keyword">struct </span>hash&lt;<a class="code" href="../../d1/def/classT.html">T</a>*&gt;
<a name="l00131"></a>00131     : <span class="keyword">public</span> std::unary_function&lt;T*, std::size_t&gt;
<a name="l00132"></a>00132     {
<a name="l00133"></a>00133       std::size_t
<a name="l00134"></a>00134       operator()(<a class="code" href="../../d1/def/classT.html">T</a>* p)<span class="keyword"> const</span>
<a name="l00135"></a>00135 <span class="keyword">      </span>{ <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span>std::size_t<span class="keyword">&gt;</span>(p); }
<a name="l00136"></a>00136     };
<a name="l00137"></a>00137 
<a name="l00138"></a>00138   <span class="comment">// Fowler / Noll / Vo (FNV) Hash (type FNV-1a)</span>
<a name="l00139"></a>00139   <span class="comment">// (used by the next specializations of std::tr1::hash&lt;&gt;)</span>
<a name="l00140"></a>00140 
<a name="l00141"></a>00141   <span class="comment">// Dummy generic implementation (for sizeof(size_t) != 4, 8).</span>
<a name="l00142"></a>00142   <span class="keyword">template</span>&lt;std::<span class="keywordtype">size_t</span> = sizeof(std::<span class="keywordtype">size_t</span>)&gt;
<a name="l00143"></a><a class="code" href="../../dc/d91/structSG_1_1Fnv__hash.html">00143</a>     <span class="keyword">struct </span><a class="code" href="../../dc/d91/structSG_1_1Fnv__hash.html">Fnv_hash</a>
<a name="l00144"></a>00144     {
<a name="l00145"></a>00145       <span class="keyword">static</span> std::size_t
<a name="l00146"></a>00146       hash(<span class="keyword">const</span> <span class="keywordtype">char</span>* first, std::size_t length)
<a name="l00147"></a>00147       {
<a name="l00148"></a>00148     std::size_t result = 0;
<a name="l00149"></a>00149     <span class="keywordflow">for</span> (; length &gt; 0; --length)
<a name="l00150"></a>00150       result = (result * 131) + *first++;
<a name="l00151"></a>00151     <span class="keywordflow">return</span> result;
<a name="l00152"></a>00152       }
<a name="l00153"></a>00153     };
<a name="l00154"></a>00154 
<a name="l00155"></a>00155   <span class="keyword">template</span>&lt;&gt;
<a name="l00156"></a><a class="code" href="../../d4/d87/structSG_1_1Fnv__hash_3_014_01_4.html">00156</a>     <span class="keyword">struct </span><a class="code" href="../../dc/d91/structSG_1_1Fnv__hash.html">Fnv_hash</a>&lt;4&gt;
<a name="l00157"></a>00157     {
<a name="l00158"></a>00158       <span class="keyword">static</span> std::size_t
<a name="l00159"></a>00159       hash(<span class="keyword">const</span> <span class="keywordtype">char</span>* first, std::size_t length)
<a name="l00160"></a>00160       {
<a name="l00161"></a>00161     std::size_t result = <span class="keyword">static_cast&lt;</span>std::size_t<span class="keyword">&gt;</span>(2166136261UL);
<a name="l00162"></a>00162     <span class="keywordflow">for</span> (; length &gt; 0; --length)
<a name="l00163"></a>00163       {
<a name="l00164"></a>00164         result ^= (std::size_t)*first++;
<a name="l00165"></a>00165         result *= 16777619UL;
<a name="l00166"></a>00166       }
<a name="l00167"></a>00167     <span class="keywordflow">return</span> result;
<a name="l00168"></a>00168       }
<a name="l00169"></a>00169     };
<a name="l00170"></a>00170   
<a name="l00171"></a>00171   <span class="keyword">template</span>&lt;&gt;
<a name="l00172"></a><a class="code" href="../../d5/d49/structSG_1_1Fnv__hash_3_018_01_4.html">00172</a>     <span class="keyword">struct </span><a class="code" href="../../dc/d91/structSG_1_1Fnv__hash.html">Fnv_hash</a>&lt;8&gt;
<a name="l00173"></a>00173     {
<a name="l00174"></a>00174       <span class="keyword">static</span> std::size_t
<a name="l00175"></a>00175       hash(<span class="keyword">const</span> <span class="keywordtype">char</span>* first, std::size_t length)
<a name="l00176"></a>00176       {
<a name="l00177"></a>00177     std::size_t result = <span class="keyword">static_cast&lt;</span>std::size_t<span class="keyword">&gt;</span>(14695981039346656037ULL);
<a name="l00178"></a>00178     <span class="keywordflow">for</span> (; length &gt; 0; --length)
<a name="l00179"></a>00179       {
<a name="l00180"></a>00180         result ^= (std::size_t)*first++;
<a name="l00181"></a>00181         result *= <span class="keyword">static_cast&lt;</span>std::size_t<span class="keyword">&gt;</span>(1099511628211ULL); <span class="comment">// sss</span>
<a name="l00182"></a>00182       }
<a name="l00183"></a>00183     <span class="keywordflow">return</span> result;
<a name="l00184"></a>00184       }
<a name="l00185"></a>00185     };
<a name="l00186"></a>00186 
<a name="l00187"></a>00187   <span class="comment">// XXX String and floating point hashes probably shouldn&apos;t be inline</span>
<a name="l00188"></a>00188   <span class="comment">// member functions, since are nontrivial.  Once we have the framework</span>
<a name="l00189"></a>00189   <span class="comment">// for TR1 .cc files, these should go in one.</span>
<a name="l00190"></a>00190   <span class="keyword">template</span>&lt;&gt;
<a name="l00191"></a><a class="code" href="../../d4/dbc/structSG_1_1hash_3_01std_1_1string_01_4.html">00191</a>     <span class="keyword">struct </span>hash&lt;std::string&gt;
<a name="l00192"></a>00192     : <span class="keyword">public</span> std::unary_function&lt;std::string, std::size_t&gt;
<a name="l00193"></a>00193     {      
<a name="l00194"></a>00194       std::size_t
<a name="l00195"></a>00195       operator()(<span class="keyword">const</span> std::string&amp; s)<span class="keyword"> const</span>
<a name="l00196"></a>00196 <span class="keyword">      </span>{ <span class="keywordflow">return</span> <a class="code" href="../../dc/d91/structSG_1_1Fnv__hash.html">Fnv_hash&lt;&gt;::hash</a>(s.data(), s.length()); }
<a name="l00197"></a>00197     };
<a name="l00198"></a>00198 
<a name="l00199"></a>00199 <span class="preprocessor">#ifdef _GLIBCXX_USE_WCHAR_T</span>
<a name="l00200"></a>00200 <span class="preprocessor"></span>  <span class="keyword">template</span>&lt;&gt;
<a name="l00201"></a>00201     <span class="keyword">struct </span>hash&lt;std::wstring&gt;
<a name="l00202"></a>00202     : <span class="keyword">public</span> std::unary_function&lt;std::wstring, std::size_t&gt;
<a name="l00203"></a>00203     {
<a name="l00204"></a>00204       std::size_t
<a name="l00205"></a>00205       operator()(<span class="keyword">const</span> std::wstring&amp; s)<span class="keyword"> const</span>
<a name="l00206"></a>00206 <span class="keyword">      </span>{
<a name="l00207"></a>00207     <span class="keywordflow">return</span> <a class="code" href="../../dc/d91/structSG_1_1Fnv__hash.html">Fnv_hash&lt;&gt;::hash</a>(reinterpret_cast&lt;const char*&gt;(s.data()),
<a name="l00208"></a>00208                 s.length() * <span class="keyword">sizeof</span>(wchar_t));
<a name="l00209"></a>00209       }
<a name="l00210"></a>00210     };
<a name="l00211"></a>00211 <span class="preprocessor">#endif</span>
<a name="l00212"></a>00212 <span class="preprocessor"></span>
<a name="l00213"></a>00213   <span class="keyword">template</span>&lt;&gt;
<a name="l00214"></a><a class="code" href="../../df/d59/structSG_1_1hash_3_01float_01_4.html">00214</a>     <span class="keyword">struct </span>hash&lt;float&gt;
<a name="l00215"></a>00215     : <span class="keyword">public</span> std::unary_function&lt;float, std::size_t&gt;
<a name="l00216"></a>00216     {
<a name="l00217"></a>00217       std::size_t
<a name="l00218"></a>00218       operator()(<span class="keywordtype">float</span> fval)<span class="keyword"> const</span>
<a name="l00219"></a>00219 <span class="keyword">      </span>{
<a name="l00220"></a>00220     std::size_t result = 0;
<a name="l00221"></a>00221 
<a name="l00222"></a>00222     <span class="comment">// 0 and -0 both hash to zero.</span>
<a name="l00223"></a>00223     <span class="keywordflow">if</span> (fval != 0.0f)
<a name="l00224"></a>00224       result = <a class="code" href="../../dc/d91/structSG_1_1Fnv__hash.html">Fnv_hash&lt;&gt;::hash</a>(reinterpret_cast&lt;const char*&gt;(&amp;fval),
<a name="l00225"></a>00225                     <span class="keyword">sizeof</span>(fval));
<a name="l00226"></a>00226     <span class="keywordflow">return</span> result;
<a name="l00227"></a>00227       }
<a name="l00228"></a>00228     };
<a name="l00229"></a>00229 
<a name="l00230"></a>00230   <span class="keyword">template</span>&lt;&gt;
<a name="l00231"></a><a class="code" href="../../dd/d80/structSG_1_1hash_3_01double_01_4.html">00231</a>     <span class="keyword">struct </span>hash&lt;double&gt;
<a name="l00232"></a>00232     : <span class="keyword">public</span> std::unary_function&lt;double, std::size_t&gt;
<a name="l00233"></a>00233     {
<a name="l00234"></a>00234       std::size_t
<a name="l00235"></a>00235       operator()(<span class="keywordtype">double</span> dval)<span class="keyword"> const</span>
<a name="l00236"></a>00236 <span class="keyword">      </span>{
<a name="l00237"></a>00237     std::size_t result = 0;
<a name="l00238"></a>00238 
<a name="l00239"></a>00239     <span class="comment">// 0 and -0 both hash to zero.</span>
<a name="l00240"></a>00240     <span class="keywordflow">if</span> (dval != 0.0)
<a name="l00241"></a>00241       result = <a class="code" href="../../dc/d91/structSG_1_1Fnv__hash.html">Fnv_hash&lt;&gt;::hash</a>(reinterpret_cast&lt;const char*&gt;(&amp;dval),
<a name="l00242"></a>00242                     <span class="keyword">sizeof</span>(dval));
<a name="l00243"></a>00243     <span class="keywordflow">return</span> result;
<a name="l00244"></a>00244       }
<a name="l00245"></a>00245     };
<a name="l00246"></a>00246 
<a name="l00247"></a>00247   <span class="comment">// For long double, careful with random padding bits (e.g., on x86,</span>
<a name="l00248"></a>00248   <span class="comment">// 10 bytes -&gt; 12 bytes) and resort to frexp.</span>
<a name="l00249"></a>00249   <span class="keyword">template</span>&lt;&gt;
<a name="l00250"></a><a class="code" href="../../de/d76/structSG_1_1hash_3_01long_01double_01_4.html">00250</a>     <span class="keyword">struct </span>hash&lt;long double&gt;
<a name="l00251"></a>00251     : <span class="keyword">public</span> std::unary_function&lt;long double, std::size_t&gt;
<a name="l00252"></a>00252     {
<a name="l00253"></a>00253       std::size_t
<a name="l00254"></a>00254       operator()(<span class="keywordtype">long</span> <span class="keywordtype">double</span> ldval)<span class="keyword"> const</span>
<a name="l00255"></a>00255 <span class="keyword">      </span>{
<a name="l00256"></a>00256     std::size_t result = 0;
<a name="l00257"></a>00257 
<a name="l00258"></a>00258     <span class="keywordtype">int</span> exponent;
<a name="l00259"></a>00259     ldval = std::frexp(ldval, &amp;exponent);
<a name="l00260"></a>00260     ldval = ldval &lt; 0.0l ? -(ldval + 0.5l) : ldval;
<a name="l00261"></a>00261 
<a name="l00262"></a>00262     <span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">double</span> mult = std::numeric_limits&lt;std::size_t&gt;::max() + 1.0l;
<a name="l00263"></a>00263     ldval *= mult;
<a name="l00264"></a>00264 
<a name="l00265"></a>00265     <span class="comment">// Try to use all the bits of the mantissa (really necessary only</span>
<a name="l00266"></a>00266     <span class="comment">// on 32-bit targets, at least for 80-bit floating point formats).</span>
<a name="l00267"></a>00267     <span class="keyword">const</span> std::size_t hibits = (std::size_t)ldval;
<a name="l00268"></a>00268     ldval = (ldval - (<span class="keywordtype">long</span> double)hibits) * mult;
<a name="l00269"></a>00269 
<a name="l00270"></a>00270     <span class="keyword">const</span> std::size_t coeff =
<a name="l00271"></a>00271       (std::numeric_limits&lt;std::size_t&gt;::max()
<a name="l00272"></a>00272        / std::numeric_limits&lt;long double&gt;::max_exponent);
<a name="l00273"></a>00273 
<a name="l00274"></a>00274     result = hibits + (std::size_t)ldval + coeff * exponent;
<a name="l00275"></a>00275 
<a name="l00276"></a>00276     <span class="keywordflow">return</span> result;
<a name="l00277"></a>00277       }
<a name="l00278"></a>00278     };
<a name="l00279"></a>00279 }
<a name="l00280"></a>00280 <span class="comment">// sss end from TR1 functional</span>
<a name="l00281"></a>00281 <span class="comment">//=====================================================================</span>
<a name="l00282"></a>00282 
<a name="l00283"></a>00283 <span class="comment">//----------------------------------------------------------------------</span>
<a name="l00284"></a>00284 <span class="comment">// General utilities</span>
<a name="l00285"></a>00285 
<a name="l00286"></a>00286 <span class="keyword">namespace </span>CxxUtils_Internal <span class="comment">// sss Internal</span>
<a name="l00287"></a>00287 {
<a name="l00288"></a>00288   <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> Flag, <span class="keyword">typename</span> IfTrue, <span class="keyword">typename</span> IfFalse&gt;
<a name="l00289"></a>00289     <span class="keyword">struct </span>IF;
<a name="l00290"></a>00290 
<a name="l00291"></a>00291   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> IfTrue, <span class="keyword">typename</span> IfFalse&gt;
<a name="l00292"></a><a class="code" href="../../da/de1/structCxxUtils__Internal_1_1IF_3_01true_00_01IfTrue_00_01IfFalse_01_4.html">00292</a>     <span class="keyword">struct </span>IF&lt;true, IfTrue, IfFalse&gt;
<a name="l00293"></a>00293     { <span class="keyword">typedef</span> IfTrue type; };
<a name="l00294"></a>00294  
<a name="l00295"></a>00295   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> IfTrue, <span class="keyword">typename</span> IfFalse&gt;
<a name="l00296"></a><a class="code" href="../../de/d2a/structCxxUtils__Internal_1_1IF_3_01false_00_01IfTrue_00_01IfFalse_01_4.html">00296</a>     <span class="keyword">struct </span>IF&lt;false, IfTrue, IfFalse&gt;
<a name="l00297"></a>00297     { <span class="keyword">typedef</span> IfFalse type; };
<a name="l00298"></a>00298 
<a name="l00299"></a>00299   <span class="comment">// Helper function: return distance(first, last) for forward</span>
<a name="l00300"></a>00300   <span class="comment">// iterators, or 0 for input iterators.</span>
<a name="l00301"></a>00301   <span class="keyword">template</span>&lt;<span class="keyword">class</span> Iterator&gt;
<a name="l00302"></a>00302     <span class="keyword">inline</span> <span class="keyword">typename</span> std::iterator_traits&lt;Iterator&gt;::difference_type
<a name="l00303"></a>00303     distance_fw(Iterator <span class="comment">/*first*/</span>, Iterator <span class="comment">/*last*/</span>, std::input_iterator_tag)
<a name="l00304"></a>00304     { <span class="keywordflow">return</span> 0; }
<a name="l00305"></a>00305 
<a name="l00306"></a>00306   <span class="keyword">template</span>&lt;<span class="keyword">class</span> Iterator&gt;
<a name="l00307"></a>00307     <span class="keyword">inline</span> <span class="keyword">typename</span> std::iterator_traits&lt;Iterator&gt;::difference_type
<a name="l00308"></a>00308     distance_fw(Iterator first, Iterator last, std::forward_iterator_tag)
<a name="l00309"></a>00309     { <span class="keywordflow">return</span> std::distance(first, last); }
<a name="l00310"></a>00310 
<a name="l00311"></a>00311   <span class="keyword">template</span>&lt;<span class="keyword">class</span> Iterator&gt;
<a name="l00312"></a>00312     <span class="keyword">inline</span> <span class="keyword">typename</span> std::iterator_traits&lt;Iterator&gt;::difference_type
<a name="l00313"></a>00313     distance_fw(Iterator first, Iterator last)
<a name="l00314"></a>00314     {
<a name="l00315"></a>00315       <span class="keyword">typedef</span> <span class="keyword">typename</span> std::iterator_traits&lt;Iterator&gt;::iterator_category tag;
<a name="l00316"></a>00316       <span class="keywordflow">return</span> distance_fw(first, last, tag());
<a name="l00317"></a>00317     }
<a name="l00318"></a>00318   
<a name="l00319"></a>00319 } <span class="comment">// namespace CxxUtils_Internal sss</span>
<a name="l00320"></a>00320 
<a name="l00321"></a>00321 <span class="comment">//----------------------------------------------------------------------</span>
<a name="l00322"></a>00322 <span class="comment">// Auxiliary types used for all instantiations of hashtable: nodes</span>
<a name="l00323"></a>00323 <span class="comment">// and iterators.</span>
<a name="l00324"></a>00324 
<a name="l00325"></a>00325 <span class="comment">// Nodes, used to wrap elements stored in the hash table.  A policy</span>
<a name="l00326"></a>00326 <span class="comment">// template parameter of class template hashtable controls whether</span>
<a name="l00327"></a>00327 <span class="comment">// nodes also store a hash code. In some cases (e.g. strings) this may</span>
<a name="l00328"></a>00328 <span class="comment">// be a performance win.</span>
<a name="l00329"></a>00329 
<a name="l00330"></a>00330 <span class="keyword">namespace </span>CxxUtils_Internal <span class="comment">// sss Internal</span>
<a name="l00331"></a>00331 {
<a name="l00332"></a>00332   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Value, <span class="keywordtype">bool</span> cache_hash_code&gt;
<a name="l00333"></a>00333     <span class="keyword">struct </span>hash_node;
<a name="l00334"></a>00334 
<a name="l00335"></a>00335   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Value&gt;
<a name="l00336"></a><a class="code" href="../../dd/dfd/structCxxUtils__Internal_1_1hash__node_3_01Value_00_01true_01_4.html">00336</a>     <span class="keyword">struct </span>hash_node&lt;Value, true&gt;
<a name="l00337"></a>00337     {
<a name="l00338"></a>00338       Value m_v;
<a name="l00339"></a>00339       std::size_t hash_code;
<a name="l00340"></a>00340       hash_node* m_next;
<a name="l00341"></a>00341     };
<a name="l00342"></a>00342 
<a name="l00343"></a>00343   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Value&gt;
<a name="l00344"></a><a class="code" href="../../d4/d41/structCxxUtils__Internal_1_1hash__node_3_01Value_00_01false_01_4.html">00344</a>     <span class="keyword">struct </span>hash_node&lt;Value, false&gt;
<a name="l00345"></a>00345     {
<a name="l00346"></a>00346       Value m_v;
<a name="l00347"></a>00347       hash_node* m_next;
<a name="l00348"></a>00348     };
<a name="l00349"></a>00349 
<a name="l00350"></a>00350   <span class="comment">// Local iterators, used to iterate within a bucket but not between</span>
<a name="l00351"></a>00351   <span class="comment">// buckets.</span>
<a name="l00352"></a>00352 
<a name="l00353"></a>00353   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Value, <span class="keywordtype">bool</span> cache&gt;
<a name="l00354"></a><a class="code" href="../../d3/df9/structCxxUtils__Internal_1_1node__iterator__base.html">00354</a>     <span class="keyword">struct </span><a class="code" href="../../d3/df9/structCxxUtils__Internal_1_1node__iterator__base.html">node_iterator_base</a>
<a name="l00355"></a>00355     {
<a name="l00356"></a>00356       <a class="code" href="../../d3/df9/structCxxUtils__Internal_1_1node__iterator__base.html">node_iterator_base</a>(hash_node&lt;Value, cache&gt;* p)
<a name="l00357"></a>00357       : m_cur(p) { }
<a name="l00358"></a>00358       
<a name="l00359"></a>00359       <span class="keywordtype">void</span>
<a name="l00360"></a>00360       incr()
<a name="l00361"></a>00361       { m_cur = m_cur-&gt;m_next; }
<a name="l00362"></a>00362 
<a name="l00363"></a>00363       hash_node&lt;Value, cache&gt;* m_cur;
<a name="l00364"></a>00364     };
<a name="l00365"></a>00365 
<a name="l00366"></a>00366   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Value, <span class="keywordtype">bool</span> cache&gt;
<a name="l00367"></a>00367     <span class="keyword">inline</span> <span class="keywordtype">bool</span>
<a name="l00368"></a>00368     <a class="code" href="../../d1/d43/DataList_8h.html#a2f4af3db6bca5dc8d962d673635f0865" title="List equality comparison.">operator==</a>(<span class="keyword">const</span> <a class="code" href="../../d3/df9/structCxxUtils__Internal_1_1node__iterator__base.html">node_iterator_base&lt;Value, cache&gt;</a>&amp; x,
<a name="l00369"></a>00369            <span class="keyword">const</span> <a class="code" href="../../d3/df9/structCxxUtils__Internal_1_1node__iterator__base.html">node_iterator_base&lt;Value, cache&gt;</a>&amp; y)
<a name="l00370"></a>00370     { <span class="keywordflow">return</span> x.m_cur == y.m_cur; }
<a name="l00371"></a>00371 
<a name="l00372"></a>00372   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Value, <span class="keywordtype">bool</span> cache&gt;
<a name="l00373"></a>00373     <span class="keyword">inline</span> <span class="keywordtype">bool</span>
<a name="l00374"></a>00374     <a class="code" href="../../d1/d43/DataList_8h.html#aa7a25d1b36f44af915a534c124985c2b" title="Based on operator==.">operator!=</a>(<span class="keyword">const</span> node_iterator_base&lt;Value, cache&gt;&amp; x,
<a name="l00375"></a>00375            <span class="keyword">const</span> node_iterator_base&lt;Value, cache&gt;&amp; y)
<a name="l00376"></a>00376     { <span class="keywordflow">return</span> x.m_cur != y.m_cur; }
<a name="l00377"></a>00377 
<a name="l00378"></a>00378   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Value, <span class="keywordtype">bool</span> constant_iterators, <span class="keywordtype">bool</span> cache&gt;
<a name="l00379"></a><a class="code" href="../../d8/de8/structCxxUtils__Internal_1_1node__iterator.html">00379</a>     <span class="keyword">struct </span><a class="code" href="../../d8/de8/structCxxUtils__Internal_1_1node__iterator.html">node_iterator</a>
<a name="l00380"></a>00380     : <span class="keyword">public</span> <a class="code" href="../../d3/df9/structCxxUtils__Internal_1_1node__iterator__base.html">node_iterator_base</a>&lt;Value, cache&gt;
<a name="l00381"></a>00381     {
<a name="l00382"></a>00382       <span class="keyword">typedef</span> Value                                    value_type;
<a name="l00383"></a>00383       <span class="keyword">typedef</span> <span class="keyword">typename</span> IF&lt;constant_iterators, const Value*, Value*&gt;::type
<a name="l00384"></a>00384                                                        pointer;
<a name="l00385"></a>00385       <span class="keyword">typedef</span> <span class="keyword">typename</span> IF&lt;constant_iterators, const Value&amp;, Value&amp;&gt;::type
<a name="l00386"></a>00386                                                        reference;
<a name="l00387"></a>00387       <span class="keyword">typedef</span> std::ptrdiff_t                           difference_type;
<a name="l00388"></a>00388       <span class="keyword">typedef</span> std::forward_iterator_tag                iterator_category;
<a name="l00389"></a>00389 
<a name="l00390"></a>00390       <span class="keyword">explicit</span>
<a name="l00391"></a>00391       <a class="code" href="../../d8/de8/structCxxUtils__Internal_1_1node__iterator.html">node_iterator</a>(hash_node&lt;Value, cache&gt;* p = 0)
<a name="l00392"></a>00392       : <a class="code" href="../../d3/df9/structCxxUtils__Internal_1_1node__iterator__base.html">node_iterator_base&lt;Value, cache&gt;</a>(p) { }
<a name="l00393"></a>00393 
<a name="l00394"></a>00394       reference
<a name="l00395"></a>00395       operator*()<span class="keyword"> const</span>
<a name="l00396"></a>00396 <span class="keyword">      </span>{ <span class="keywordflow">return</span> this-&gt;m_cur-&gt;m_v; }
<a name="l00397"></a>00397   
<a name="l00398"></a>00398       pointer
<a name="l00399"></a>00399       operator-&gt;()<span class="keyword"> const</span>
<a name="l00400"></a>00400 <span class="keyword">      </span>{ <span class="keywordflow">return</span> &amp;this-&gt;m_cur-&gt;m_v; }
<a name="l00401"></a>00401 
<a name="l00402"></a>00402       <a class="code" href="../../d8/de8/structCxxUtils__Internal_1_1node__iterator.html">node_iterator</a>&amp;
<a name="l00403"></a>00403       operator++()
<a name="l00404"></a>00404       { 
<a name="l00405"></a>00405     this-&gt;incr(); 
<a name="l00406"></a>00406     <span class="keywordflow">return</span> *<span class="keyword">this</span>; 
<a name="l00407"></a>00407       }
<a name="l00408"></a>00408   
<a name="l00409"></a>00409       <a class="code" href="../../d8/de8/structCxxUtils__Internal_1_1node__iterator.html">node_iterator</a>
<a name="l00410"></a>00410       operator++(<span class="keywordtype">int</span>)
<a name="l00411"></a>00411       { 
<a name="l00412"></a>00412     <a class="code" href="../../d8/de8/structCxxUtils__Internal_1_1node__iterator.html">node_iterator</a> tmp(*<span class="keyword">this</span>);
<a name="l00413"></a>00413     this-&gt;incr();
<a name="l00414"></a>00414     <span class="keywordflow">return</span> tmp;
<a name="l00415"></a>00415       }
<a name="l00416"></a>00416     };
<a name="l00417"></a>00417 
<a name="l00418"></a>00418   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Value, <span class="keywordtype">bool</span> constant_iterators, <span class="keywordtype">bool</span> cache&gt;
<a name="l00419"></a><a class="code" href="../../dd/d7e/structCxxUtils__Internal_1_1node__const__iterator.html">00419</a>     <span class="keyword">struct </span><a class="code" href="../../dd/d7e/structCxxUtils__Internal_1_1node__const__iterator.html">node_const_iterator</a>
<a name="l00420"></a>00420     : <span class="keyword">public</span> <a class="code" href="../../d3/df9/structCxxUtils__Internal_1_1node__iterator__base.html">node_iterator_base</a>&lt;Value, cache&gt;
<a name="l00421"></a>00421     {
<a name="l00422"></a>00422       <span class="keyword">typedef</span> Value                                    value_type;
<a name="l00423"></a>00423       <span class="keyword">typedef</span> <span class="keyword">const</span> Value*                             pointer;
<a name="l00424"></a>00424       <span class="keyword">typedef</span> <span class="keyword">const</span> Value&amp;                             reference;
<a name="l00425"></a>00425       <span class="keyword">typedef</span> std::ptrdiff_t                           difference_type;
<a name="l00426"></a>00426       <span class="keyword">typedef</span> std::forward_iterator_tag                iterator_category;
<a name="l00427"></a>00427 
<a name="l00428"></a>00428       <span class="keyword">explicit</span>
<a name="l00429"></a>00429       <a class="code" href="../../dd/d7e/structCxxUtils__Internal_1_1node__const__iterator.html">node_const_iterator</a>(hash_node&lt;Value, cache&gt;* p = 0)
<a name="l00430"></a>00430       : <a class="code" href="../../d3/df9/structCxxUtils__Internal_1_1node__iterator__base.html">node_iterator_base&lt;Value, cache&gt;</a>(p) { }
<a name="l00431"></a>00431 
<a name="l00432"></a>00432       <a class="code" href="../../dd/d7e/structCxxUtils__Internal_1_1node__const__iterator.html">node_const_iterator</a>(<span class="keyword">const</span> <a class="code" href="../../d8/de8/structCxxUtils__Internal_1_1node__iterator.html">node_iterator</a>&lt;Value, constant_iterators,
<a name="l00433"></a>00433               cache&gt;&amp; x)
<a name="l00434"></a>00434       : <a class="code" href="../../d3/df9/structCxxUtils__Internal_1_1node__iterator__base.html">node_iterator_base&lt;Value, cache&gt;</a>(x.m_cur) { }
<a name="l00435"></a>00435 
<a name="l00436"></a>00436       reference
<a name="l00437"></a>00437       operator*()<span class="keyword"> const</span>
<a name="l00438"></a>00438 <span class="keyword">      </span>{ <span class="keywordflow">return</span> this-&gt;m_cur-&gt;m_v; }
<a name="l00439"></a>00439   
<a name="l00440"></a>00440       pointer
<a name="l00441"></a>00441       operator-&gt;()<span class="keyword"> const</span>
<a name="l00442"></a>00442 <span class="keyword">      </span>{ <span class="keywordflow">return</span> &amp;this-&gt;m_cur-&gt;m_v; }
<a name="l00443"></a>00443 
<a name="l00444"></a>00444       <a class="code" href="../../dd/d7e/structCxxUtils__Internal_1_1node__const__iterator.html">node_const_iterator</a>&amp;
<a name="l00445"></a>00445       operator++()
<a name="l00446"></a>00446       { 
<a name="l00447"></a>00447     this-&gt;incr(); 
<a name="l00448"></a>00448     <span class="keywordflow">return</span> *<span class="keyword">this</span>; 
<a name="l00449"></a>00449       }
<a name="l00450"></a>00450   
<a name="l00451"></a>00451       <a class="code" href="../../dd/d7e/structCxxUtils__Internal_1_1node__const__iterator.html">node_const_iterator</a>
<a name="l00452"></a>00452       operator++(<span class="keywordtype">int</span>)
<a name="l00453"></a>00453       { 
<a name="l00454"></a>00454     <a class="code" href="../../dd/d7e/structCxxUtils__Internal_1_1node__const__iterator.html">node_const_iterator</a> tmp(*<span class="keyword">this</span>);
<a name="l00455"></a>00455     this-&gt;incr();
<a name="l00456"></a>00456     <span class="keywordflow">return</span> tmp;
<a name="l00457"></a>00457       }
<a name="l00458"></a>00458     };
<a name="l00459"></a>00459 
<a name="l00460"></a>00460   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Value, <span class="keywordtype">bool</span> cache&gt;
<a name="l00461"></a><a class="code" href="../../d5/d44/structCxxUtils__Internal_1_1hashtable__iterator__base.html">00461</a>     <span class="keyword">struct </span><a class="code" href="../../d5/d44/structCxxUtils__Internal_1_1hashtable__iterator__base.html">hashtable_iterator_base</a>
<a name="l00462"></a>00462     {
<a name="l00463"></a>00463       <a class="code" href="../../d5/d44/structCxxUtils__Internal_1_1hashtable__iterator__base.html">hashtable_iterator_base</a>(hash_node&lt;Value, cache&gt;* node,
<a name="l00464"></a>00464                   hash_node&lt;Value, cache&gt;** bucket)
<a name="l00465"></a>00465       : m_cur_node(node), m_cur_bucket(bucket)
<a name="l00466"></a>00466       { }
<a name="l00467"></a>00467 
<a name="l00468"></a>00468       <span class="keywordtype">void</span>
<a name="l00469"></a>00469       incr()
<a name="l00470"></a>00470       {
<a name="l00471"></a>00471     m_cur_node = m_cur_node-&gt;m_next;
<a name="l00472"></a>00472     <span class="keywordflow">if</span> (!m_cur_node)
<a name="l00473"></a>00473       m_incr_bucket();
<a name="l00474"></a>00474       }
<a name="l00475"></a>00475 
<a name="l00476"></a>00476       <span class="keywordtype">void</span>
<a name="l00477"></a>00477       m_incr_bucket();
<a name="l00478"></a>00478 
<a name="l00479"></a>00479       <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00480"></a>00480       <span class="keywordtype">void</span> erase_node (<a class="code" href="../../d1/def/classT.html">T</a>&amp; t) { t.erase_node (m_cur_node, m_cur_bucket); } <span class="comment">// sss</span>
<a name="l00481"></a>00481 
<a name="l00482"></a>00482       hash_node&lt;Value, cache&gt;* m_cur_node;
<a name="l00483"></a>00483 
<a name="l00484"></a>00484     <span class="keyword">protected</span>: <span class="comment">// sss</span>
<a name="l00485"></a>00485       hash_node&lt;Value, cache&gt;** m_cur_bucket;
<a name="l00486"></a>00486     };
<a name="l00487"></a>00487 
<a name="l00488"></a>00488   <span class="comment">// Global iterators, used for arbitrary iteration within a hash</span>
<a name="l00489"></a>00489   <span class="comment">// table.  Larger and more expensive than local iterators.</span>
<a name="l00490"></a>00490   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Value, <span class="keywordtype">bool</span> cache&gt;
<a name="l00491"></a>00491     <span class="keywordtype">void</span>
<a name="l00492"></a>00492     <a class="code" href="../../d5/d44/structCxxUtils__Internal_1_1hashtable__iterator__base.html">hashtable_iterator_base&lt;Value, cache&gt;::</a>
<a name="l00493"></a>00493 <a class="code" href="../../d5/d44/structCxxUtils__Internal_1_1hashtable__iterator__base.html">    m_incr_bucket</a>()
<a name="l00494"></a>00494     {
<a name="l00495"></a>00495       ++m_cur_bucket;
<a name="l00496"></a>00496 
<a name="l00497"></a>00497       <span class="comment">// This loop requires the bucket array to have a non-null sentinel.</span>
<a name="l00498"></a>00498       <span class="keywordflow">while</span> (!*m_cur_bucket)
<a name="l00499"></a>00499     ++m_cur_bucket;
<a name="l00500"></a>00500       m_cur_node = *m_cur_bucket;
<a name="l00501"></a>00501     }
<a name="l00502"></a>00502 
<a name="l00503"></a>00503   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Value, <span class="keywordtype">bool</span> cache&gt;
<a name="l00504"></a>00504     <span class="keyword">inline</span> <span class="keywordtype">bool</span>
<a name="l00505"></a>00505     <a class="code" href="../../d1/d43/DataList_8h.html#a2f4af3db6bca5dc8d962d673635f0865" title="List equality comparison.">operator==</a>(<span class="keyword">const</span> hashtable_iterator_base&lt;Value, cache&gt;&amp; x,
<a name="l00506"></a>00506            <span class="keyword">const</span> hashtable_iterator_base&lt;Value, cache&gt;&amp; y)
<a name="l00507"></a>00507     { <span class="keywordflow">return</span> x.m_cur_node == y.m_cur_node; }
<a name="l00508"></a>00508 
<a name="l00509"></a>00509   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Value, <span class="keywordtype">bool</span> cache&gt;
<a name="l00510"></a>00510     <span class="keyword">inline</span> <span class="keywordtype">bool</span>
<a name="l00511"></a>00511     <a class="code" href="../../d1/d43/DataList_8h.html#aa7a25d1b36f44af915a534c124985c2b" title="Based on operator==.">operator!=</a>(<span class="keyword">const</span> hashtable_iterator_base&lt;Value, cache&gt;&amp; x,
<a name="l00512"></a>00512            <span class="keyword">const</span> hashtable_iterator_base&lt;Value, cache&gt;&amp; y)
<a name="l00513"></a>00513     { <span class="keywordflow">return</span> x.m_cur_node != y.m_cur_node; }
<a name="l00514"></a>00514 
<a name="l00515"></a>00515   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Value, <span class="keywordtype">bool</span> constant_iterators, <span class="keywordtype">bool</span> cache&gt;
<a name="l00516"></a><a class="code" href="../../d6/de1/structCxxUtils__Internal_1_1hashtable__iterator.html">00516</a>     <span class="keyword">struct </span><a class="code" href="../../d6/de1/structCxxUtils__Internal_1_1hashtable__iterator.html">hashtable_iterator</a>
<a name="l00517"></a>00517     : <span class="keyword">public</span> <a class="code" href="../../d5/d44/structCxxUtils__Internal_1_1hashtable__iterator__base.html">hashtable_iterator_base</a>&lt;Value, cache&gt;
<a name="l00518"></a>00518     {
<a name="l00519"></a>00519       <span class="keyword">typedef</span> Value                                    value_type;
<a name="l00520"></a>00520       <span class="keyword">typedef</span> <span class="keyword">typename</span> IF&lt;constant_iterators, const Value*, Value*&gt;::type
<a name="l00521"></a>00521                                                        pointer;
<a name="l00522"></a>00522       <span class="keyword">typedef</span> <span class="keyword">typename</span> IF&lt;constant_iterators, const Value&amp;, Value&amp;&gt;::type
<a name="l00523"></a>00523                                                        reference;
<a name="l00524"></a>00524       <span class="keyword">typedef</span> std::ptrdiff_t                           difference_type;
<a name="l00525"></a>00525       <span class="keyword">typedef</span> std::forward_iterator_tag                iterator_category;
<a name="l00526"></a>00526 
<a name="l00527"></a>00527       <span class="comment">// sss -- added default ctor.</span>
<a name="l00528"></a>00528       <span class="comment">// Needed to fulfill ForwardIterator requirements.</span>
<a name="l00529"></a>00529       <a class="code" href="../../d6/de1/structCxxUtils__Internal_1_1hashtable__iterator.html">hashtable_iterator</a>()
<a name="l00530"></a>00530       : <a class="code" href="../../d5/d44/structCxxUtils__Internal_1_1hashtable__iterator__base.html">hashtable_iterator_base&lt;Value, cache&gt;</a>(0, 0) { }
<a name="l00531"></a>00531 
<a name="l00532"></a>00532       <a class="code" href="../../d6/de1/structCxxUtils__Internal_1_1hashtable__iterator.html">hashtable_iterator</a>(hash_node&lt;Value, cache&gt;* p,
<a name="l00533"></a>00533              hash_node&lt;Value, cache&gt;** b)
<a name="l00534"></a>00534       : <a class="code" href="../../d5/d44/structCxxUtils__Internal_1_1hashtable__iterator__base.html">hashtable_iterator_base&lt;Value, cache&gt;</a>(p, b) { }
<a name="l00535"></a>00535 
<a name="l00536"></a>00536       <span class="keyword">explicit</span>
<a name="l00537"></a>00537       <a class="code" href="../../d6/de1/structCxxUtils__Internal_1_1hashtable__iterator.html">hashtable_iterator</a>(hash_node&lt;Value, cache&gt;** b)
<a name="l00538"></a>00538       : <a class="code" href="../../d5/d44/structCxxUtils__Internal_1_1hashtable__iterator__base.html">hashtable_iterator_base&lt;Value, cache&gt;</a>(*b, b) { }
<a name="l00539"></a>00539   
<a name="l00540"></a>00540       reference
<a name="l00541"></a>00541       operator*()<span class="keyword"> const</span>
<a name="l00542"></a>00542 <span class="keyword">      </span>{ <span class="keywordflow">return</span> this-&gt;m_cur_node-&gt;m_v; }
<a name="l00543"></a>00543   
<a name="l00544"></a>00544       pointer
<a name="l00545"></a>00545       operator-&gt;()<span class="keyword"> const</span>
<a name="l00546"></a>00546 <span class="keyword">      </span>{ <span class="keywordflow">return</span> &amp;this-&gt;m_cur_node-&gt;m_v; }
<a name="l00547"></a>00547 
<a name="l00548"></a>00548       <a class="code" href="../../d6/de1/structCxxUtils__Internal_1_1hashtable__iterator.html">hashtable_iterator</a>&amp;
<a name="l00549"></a>00549       operator++()
<a name="l00550"></a>00550       { 
<a name="l00551"></a>00551     this-&gt;incr();
<a name="l00552"></a>00552     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00553"></a>00553       }
<a name="l00554"></a>00554   
<a name="l00555"></a>00555       <a class="code" href="../../d6/de1/structCxxUtils__Internal_1_1hashtable__iterator.html">hashtable_iterator</a>
<a name="l00556"></a>00556       operator++(<span class="keywordtype">int</span>)
<a name="l00557"></a>00557       { 
<a name="l00558"></a>00558     <a class="code" href="../../d6/de1/structCxxUtils__Internal_1_1hashtable__iterator.html">hashtable_iterator</a> tmp(*<span class="keyword">this</span>);
<a name="l00559"></a>00559     this-&gt;incr();
<a name="l00560"></a>00560     <span class="keywordflow">return</span> tmp;
<a name="l00561"></a>00561       }
<a name="l00562"></a>00562     };
<a name="l00563"></a>00563 
<a name="l00564"></a>00564   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Value, <span class="keywordtype">bool</span> constant_iterators, <span class="keywordtype">bool</span> cache&gt;
<a name="l00565"></a><a class="code" href="../../d2/d21/structCxxUtils__Internal_1_1hashtable__const__iterator.html">00565</a>     <span class="keyword">struct </span><a class="code" href="../../d2/d21/structCxxUtils__Internal_1_1hashtable__const__iterator.html">hashtable_const_iterator</a>
<a name="l00566"></a>00566     : <span class="keyword">public</span> <a class="code" href="../../d5/d44/structCxxUtils__Internal_1_1hashtable__iterator__base.html">hashtable_iterator_base</a>&lt;Value, cache&gt;
<a name="l00567"></a>00567     {
<a name="l00568"></a>00568       <span class="keyword">typedef</span> Value                                    value_type;
<a name="l00569"></a>00569       <span class="keyword">typedef</span> <span class="keyword">const</span> Value*                             pointer;
<a name="l00570"></a>00570       <span class="keyword">typedef</span> <span class="keyword">const</span> Value&amp;                             reference;
<a name="l00571"></a>00571       <span class="keyword">typedef</span> std::ptrdiff_t                           difference_type;
<a name="l00572"></a>00572       <span class="keyword">typedef</span> std::forward_iterator_tag                iterator_category;
<a name="l00573"></a>00573 
<a name="l00574"></a>00574       <span class="comment">// sss -- added default ctor.</span>
<a name="l00575"></a>00575       <span class="comment">// Needed to fulfill ForwardIterator requirements.</span>
<a name="l00576"></a>00576       <a class="code" href="../../d2/d21/structCxxUtils__Internal_1_1hashtable__const__iterator.html">hashtable_const_iterator</a>()
<a name="l00577"></a>00577       : <a class="code" href="../../d5/d44/structCxxUtils__Internal_1_1hashtable__iterator__base.html">hashtable_iterator_base&lt;Value, cache&gt;</a>(0, 0) { }
<a name="l00578"></a>00578 
<a name="l00579"></a>00579       <a class="code" href="../../d2/d21/structCxxUtils__Internal_1_1hashtable__const__iterator.html">hashtable_const_iterator</a>(hash_node&lt;Value, cache&gt;* p,
<a name="l00580"></a>00580                    hash_node&lt;Value, cache&gt;** b)
<a name="l00581"></a>00581       : <a class="code" href="../../d5/d44/structCxxUtils__Internal_1_1hashtable__iterator__base.html">hashtable_iterator_base&lt;Value, cache&gt;</a>(p, b) { }
<a name="l00582"></a>00582 
<a name="l00583"></a>00583       <span class="keyword">explicit</span>
<a name="l00584"></a>00584       <a class="code" href="../../d2/d21/structCxxUtils__Internal_1_1hashtable__const__iterator.html">hashtable_const_iterator</a>(hash_node&lt;Value, cache&gt;** b)
<a name="l00585"></a>00585       : <a class="code" href="../../d5/d44/structCxxUtils__Internal_1_1hashtable__iterator__base.html">hashtable_iterator_base&lt;Value, cache&gt;</a>(*b, b) { }
<a name="l00586"></a>00586   
<a name="l00587"></a>00587       <a class="code" href="../../d2/d21/structCxxUtils__Internal_1_1hashtable__const__iterator.html">hashtable_const_iterator</a>(<span class="keyword">const</span> <a class="code" href="../../d6/de1/structCxxUtils__Internal_1_1hashtable__iterator.html">hashtable_iterator</a>&lt;Value,
<a name="l00588"></a>00588                    constant_iterators, cache&gt;&amp; x)
<a name="l00589"></a>00589         : <a class="code" href="../../d5/d44/structCxxUtils__Internal_1_1hashtable__iterator__base.html">hashtable_iterator_base&lt;Value, cache&gt;</a>(x<span class="comment">/*x.m_cur_node, x.m_cur_bucket*/</span>) { } <span class="comment">// sss</span>
<a name="l00590"></a>00590 
<a name="l00591"></a>00591       reference
<a name="l00592"></a>00592       operator*()<span class="keyword"> const</span>
<a name="l00593"></a>00593 <span class="keyword">      </span>{ <span class="keywordflow">return</span> this-&gt;m_cur_node-&gt;m_v; }
<a name="l00594"></a>00594   
<a name="l00595"></a>00595       pointer
<a name="l00596"></a>00596       operator-&gt;()<span class="keyword"> const</span>
<a name="l00597"></a>00597 <span class="keyword">      </span>{ <span class="keywordflow">return</span> &amp;this-&gt;m_cur_node-&gt;m_v; }
<a name="l00598"></a>00598 
<a name="l00599"></a>00599       <a class="code" href="../../d2/d21/structCxxUtils__Internal_1_1hashtable__const__iterator.html">hashtable_const_iterator</a>&amp;
<a name="l00600"></a>00600       operator++()
<a name="l00601"></a>00601       { 
<a name="l00602"></a>00602     this-&gt;incr();
<a name="l00603"></a>00603     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00604"></a>00604       }
<a name="l00605"></a>00605   
<a name="l00606"></a>00606       <a class="code" href="../../d2/d21/structCxxUtils__Internal_1_1hashtable__const__iterator.html">hashtable_const_iterator</a>
<a name="l00607"></a>00607       operator++(<span class="keywordtype">int</span>)
<a name="l00608"></a>00608       { 
<a name="l00609"></a>00609     <a class="code" href="../../d2/d21/structCxxUtils__Internal_1_1hashtable__const__iterator.html">hashtable_const_iterator</a> tmp(*<span class="keyword">this</span>);
<a name="l00610"></a>00610     this-&gt;incr();
<a name="l00611"></a>00611     <span class="keywordflow">return</span> tmp;
<a name="l00612"></a>00612       }
<a name="l00613"></a>00613     };
<a name="l00614"></a>00614 } <span class="comment">// namespace CxxUtils_Internal sss</span>
<a name="l00615"></a>00615 
<a name="l00616"></a>00616 <span class="comment">// ----------------------------------------------------------------------</span>
<a name="l00617"></a>00617 <span class="comment">// Many of class template hashtable&apos;s template parameters are policy</span>
<a name="l00618"></a>00618 <span class="comment">// classes.  These are defaults for the policies.</span>
<a name="l00619"></a>00619 
<a name="l00620"></a>00620 <span class="keyword">namespace </span>CxxUtils_Internal <span class="comment">// sss Internal</span>
<a name="l00621"></a>00621 {
<a name="l00622"></a>00622   <span class="comment">// The two key extraction policies used by the *set and *map variants.</span>
<a name="l00623"></a>00623   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l00624"></a><a class="code" href="../../d1/d0a/structCxxUtils__Internal_1_1identity.html">00624</a>     <span class="keyword">struct </span><a class="code" href="../../d1/d0a/structCxxUtils__Internal_1_1identity.html">identity</a>
<a name="l00625"></a>00625     {
<a name="l00626"></a>00626       <a class="code" href="../../d1/def/classT.html">T</a>
<a name="l00627"></a>00627       operator()(<span class="keyword">const</span> <a class="code" href="../../d1/def/classT.html">T</a>&amp; t)<span class="keyword"> const</span>
<a name="l00628"></a>00628 <span class="keyword">      </span>{ <span class="keywordflow">return</span> t; }
<a name="l00629"></a>00629     };
<a name="l00630"></a>00630 
<a name="l00631"></a>00631   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Pair&gt;
<a name="l00632"></a><a class="code" href="../../dc/dbe/structCxxUtils__Internal_1_1extract1st.html">00632</a>     <span class="keyword">struct </span><a class="code" href="../../dc/dbe/structCxxUtils__Internal_1_1extract1st.html">extract1st</a>
<a name="l00633"></a>00633     {
<a name="l00634"></a>00634       <span class="comment">// sss remove const to prevent warnings with gcc 4.3</span>
<a name="l00635"></a>00635       <span class="keyword">typename</span>
<a name="l00636"></a>00636         boost::remove_const&lt;typename Pair::first_type&gt;::type
<a name="l00637"></a>00637       operator()(<span class="keyword">const</span> Pair&amp; p)<span class="keyword"> const</span>
<a name="l00638"></a>00638 <span class="keyword">      </span>{ <span class="keywordflow">return</span> p.first; }
<a name="l00639"></a>00639     };
<a name="l00640"></a>00640 
<a name="l00641"></a>00641   <span class="comment">// Default range hashing function: use division to fold a large number</span>
<a name="l00642"></a>00642   <span class="comment">// into the range [0, N).</span>
<a name="l00643"></a><a class="code" href="../../d3/dfb/structCxxUtils__Internal_1_1mod__range__hashing.html">00643</a>   <span class="keyword">struct </span><a class="code" href="../../d3/dfb/structCxxUtils__Internal_1_1mod__range__hashing.html">mod_range_hashing</a>
<a name="l00644"></a>00644   {
<a name="l00645"></a>00645     <span class="keyword">typedef</span> std::size_t first_argument_type;
<a name="l00646"></a>00646     <span class="keyword">typedef</span> std::size_t second_argument_type;
<a name="l00647"></a>00647     <span class="keyword">typedef</span> std::size_t result_type;
<a name="l00648"></a>00648 
<a name="l00649"></a>00649     result_type
<a name="l00650"></a>00650     operator() (first_argument_type r, second_argument_type N)<span class="keyword"> const</span>
<a name="l00651"></a>00651 <span class="keyword">    </span>{ <span class="keywordflow">return</span> r % N; }
<a name="l00652"></a>00652   };
<a name="l00653"></a>00653 
<a name="l00654"></a>00654   <span class="comment">// Default ranged hash function H.  In principle it should be a</span>
<a name="l00655"></a>00655   <span class="comment">// function object composed from objects of type H1 and H2 such that</span>
<a name="l00656"></a>00656   <span class="comment">// h(k, N) = h2(h1(k), N), but that would mean making extra copies of</span>
<a name="l00657"></a>00657   <span class="comment">// h1 and h2.  So instead we&apos;ll just use a tag to tell class template</span>
<a name="l00658"></a>00658   <span class="comment">// hashtable to do that composition.</span>
<a name="l00659"></a><a class="code" href="../../dc/d78/structCxxUtils__Internal_1_1default__ranged__hash.html">00659</a>   <span class="keyword">struct </span><a class="code" href="../../dc/d78/structCxxUtils__Internal_1_1default__ranged__hash.html">default_ranged_hash</a> { };
<a name="l00660"></a>00660 
<a name="l00661"></a>00661   <span class="comment">// Default value for rehash policy.  Bucket size is (usually) the</span>
<a name="l00662"></a>00662   <span class="comment">// smallest prime that keeps the load factor small enough.</span>
<a name="l00663"></a><a class="code" href="../../df/dfa/structCxxUtils__Internal_1_1prime__rehash__policy.html">00663</a>   <span class="keyword">struct </span><a class="code" href="../../df/dfa/structCxxUtils__Internal_1_1prime__rehash__policy.html">prime_rehash_policy</a>
<a name="l00664"></a>00664   {
<a name="l00665"></a>00665     <a class="code" href="../../df/dfa/structCxxUtils__Internal_1_1prime__rehash__policy.html">prime_rehash_policy</a>(<span class="keywordtype">float</span> z = 1.0);
<a name="l00666"></a>00666     
<a name="l00667"></a>00667     <span class="keywordtype">float</span>
<a name="l00668"></a>00668     max_load_factor() <span class="keyword">const</span>;
<a name="l00669"></a>00669 
<a name="l00670"></a>00670     <span class="comment">// Return a bucket size no smaller than n.</span>
<a name="l00671"></a>00671     std::size_t
<a name="l00672"></a>00672     next_bkt(std::size_t n) <span class="keyword">const</span>;
<a name="l00673"></a>00673     
<a name="l00674"></a>00674     <span class="comment">// Return a bucket count appropriate for n elements</span>
<a name="l00675"></a>00675     std::size_t
<a name="l00676"></a>00676     bkt_for_elements(std::size_t n) <span class="keyword">const</span>;
<a name="l00677"></a>00677     
<a name="l00678"></a>00678     <span class="comment">// n_bkt is current bucket count, n_elt is current element count,</span>
<a name="l00679"></a>00679     <span class="comment">// and n_ins is number of elements to be inserted.  Do we need to</span>
<a name="l00680"></a>00680     <span class="comment">// increase bucket count?  If so, return make_pair(true, n), where n</span>
<a name="l00681"></a>00681     <span class="comment">// is the new bucket count.  If not, return make_pair(false, 0).</span>
<a name="l00682"></a>00682     std::pair&lt;bool, std::size_t&gt;
<a name="l00683"></a>00683     need_rehash(std::size_t n_bkt, std::size_t n_elt, std::size_t n_ins) <span class="keyword">const</span>;
<a name="l00684"></a>00684     
<a name="l00685"></a>00685     <span class="keywordtype">float</span> m_max_load_factor;
<a name="l00686"></a>00686     <span class="keywordtype">float</span> m_growth_factor;
<a name="l00687"></a>00687     <span class="keyword">mutable</span> std::size_t m_next_resize;
<a name="l00688"></a>00688   };
<a name="l00689"></a>00689 
<a name="l00690"></a>00690   <span class="comment">// XXX This is a hack.  prime_rehash_policy&apos;s member functions, and</span>
<a name="l00691"></a>00691   <span class="comment">// certainly the list of primes, should be defined in a .cc file.</span>
<a name="l00692"></a>00692   <span class="comment">// We&apos;re temporarily putting them in a header because we don&apos;t have a</span>
<a name="l00693"></a>00693   <span class="comment">// place to put TR1 .cc files yet.  There&apos;s no good reason for any of</span>
<a name="l00694"></a>00694   <span class="comment">// prime_rehash_policy&apos;s member functions to be inline, and there&apos;s</span>
<a name="l00695"></a>00695   <span class="comment">// certainly no good reason for X&lt;&gt; to exist at all.</span>
<a name="l00696"></a>00696   <span class="comment">// sss: Moved the prime table to hashtable.cxx.  </span>
<a name="l00697"></a>00697   <span class="comment">//      gcc 3.2.3 chokes on the original code.</span>
<a name="l00698"></a>00698   
<a name="l00699"></a><a class="code" href="../../d2/d86/structCxxUtils__Internal_1_1lt.html">00699</a>   <span class="keyword">struct </span><a class="code" href="../../d2/d86/structCxxUtils__Internal_1_1lt.html">lt</a>
<a name="l00700"></a>00700   {
<a name="l00701"></a>00701     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> X, <span class="keyword">typename</span> Y&gt;
<a name="l00702"></a>00702       <span class="keywordtype">bool</span>
<a name="l00703"></a>00703       operator()(<a class="code" href="../../d9/d9e/structCxxUtils__Internal_1_1X.html">X</a> x, Y y)
<a name="l00704"></a>00704       { <span class="keywordflow">return</span> x &lt; y; }
<a name="l00705"></a>00705   };
<a name="l00706"></a>00706 
<a name="l00707"></a>00707   <span class="comment">//template&lt;int dummy&gt; // sss</span>
<a name="l00708"></a><a class="code" href="../../d9/d9e/structCxxUtils__Internal_1_1X.html">00708</a>     <span class="keyword">struct </span><a class="code" href="../../d9/d9e/structCxxUtils__Internal_1_1X.html">X</a>
<a name="l00709"></a>00709     {
<a name="l00710"></a>00710       <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> n_primes = 256;
<a name="l00711"></a>00711       <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> primes[n_primes + 1];
<a name="l00712"></a>00712     };
<a name="l00713"></a>00713 
<a name="l00714"></a>00714 <span class="preprocessor">#if 0 // sss</span>
<a name="l00715"></a>00715 <span class="preprocessor"></span>  <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dummy&gt;
<a name="l00716"></a>00716     <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="../../d9/d9e/structCxxUtils__Internal_1_1X.html">X&lt;dummy&gt;::n_primes</a>;
<a name="l00717"></a>00717 
<a name="l00718"></a>00718   <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dummy&gt;
<a name="l00719"></a>00719     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="../../d9/d9e/structCxxUtils__Internal_1_1X.html">X&lt;dummy&gt;::primes</a>[n_primes + 1] =
<a name="l00720"></a>00720     {
<a name="l00721"></a>00721       2ul, 3ul, 5ul, 7ul, 11ul, 13ul, 17ul, 19ul, 23ul, 29ul, 31ul,
<a name="l00722"></a>00722       37ul, 41ul, 43ul, 47ul, 53ul, 59ul, 61ul, 67ul, 71ul, 73ul, 79ul,
<a name="l00723"></a>00723       83ul, 89ul, 97ul, 103ul, 109ul, 113ul, 127ul, 137ul, 139ul, 149ul,
<a name="l00724"></a>00724       157ul, 167ul, 179ul, 193ul, 199ul, 211ul, 227ul, 241ul, 257ul,
<a name="l00725"></a>00725       277ul, 293ul, 313ul, 337ul, 359ul, 383ul, 409ul, 439ul, 467ul,
<a name="l00726"></a>00726       503ul, 541ul, 577ul, 619ul, 661ul, 709ul, 761ul, 823ul, 887ul,
<a name="l00727"></a>00727       953ul, 1031ul, 1109ul, 1193ul, 1289ul, 1381ul, 1493ul, 1613ul,
<a name="l00728"></a>00728       1741ul, 1879ul, 2029ul, 2179ul, 2357ul, 2549ul, 2753ul, 2971ul,
<a name="l00729"></a>00729       3209ul, 3469ul, 3739ul, 4027ul, 4349ul, 4703ul, 5087ul, 5503ul,
<a name="l00730"></a>00730       5953ul, 6427ul, 6949ul, 7517ul, 8123ul, 8783ul, 9497ul, 10273ul,
<a name="l00731"></a>00731       11113ul, 12011ul, 12983ul, 14033ul, 15173ul, 16411ul, 17749ul,
<a name="l00732"></a>00732       19183ul, 20753ul, 22447ul, 24281ul, 26267ul, 28411ul, 30727ul,
<a name="l00733"></a>00733       33223ul, 35933ul, 38873ul, 42043ul, 45481ul, 49201ul, 53201ul,
<a name="l00734"></a>00734       57557ul, 62233ul, 67307ul, 72817ul, 78779ul, 85229ul, 92203ul,
<a name="l00735"></a>00735       99733ul, 107897ul, 116731ul, 126271ul, 136607ul, 147793ul,
<a name="l00736"></a>00736       159871ul, 172933ul, 187091ul, 202409ul, 218971ul, 236897ul,
<a name="l00737"></a>00737       256279ul, 277261ul, 299951ul, 324503ul, 351061ul, 379787ul,
<a name="l00738"></a>00738       410857ul, 444487ul, 480881ul, 520241ul, 562841ul, 608903ul,
<a name="l00739"></a>00739       658753ul, 712697ul, 771049ul, 834181ul, 902483ul, 976369ul,
<a name="l00740"></a>00740       1056323ul, 1142821ul, 1236397ul, 1337629ul, 1447153ul, 1565659ul,
<a name="l00741"></a>00741       1693859ul, 1832561ul, 1982627ul, 2144977ul, 2320627ul, 2510653ul,
<a name="l00742"></a>00742       2716249ul, 2938679ul, 3179303ul, 3439651ul, 3721303ul, 4026031ul,
<a name="l00743"></a>00743       4355707ul, 4712381ul, 5098259ul, 5515729ul, 5967347ul, 6456007ul,
<a name="l00744"></a>00744       6984629ul, 7556579ul, 8175383ul, 8844859ul, 9569143ul, 10352717ul,
<a name="l00745"></a>00745       11200489ul, 12117689ul, 13109983ul, 14183539ul, 15345007ul,
<a name="l00746"></a>00746       16601593ul, 17961079ul, 19431899ul, 21023161ul, 22744717ul,
<a name="l00747"></a>00747       24607243ul, 26622317ul, 28802401ul, 31160981ul, 33712729ul,
<a name="l00748"></a>00748       36473443ul, 39460231ul, 42691603ul, 46187573ul, 49969847ul,
<a name="l00749"></a>00749       54061849ul, 58488943ul, 63278561ul, 68460391ul, 74066549ul,
<a name="l00750"></a>00750       80131819ul, 86693767ul, 93793069ul, 101473717ul, 109783337ul,
<a name="l00751"></a>00751       118773397ul, 128499677ul, 139022417ul, 150406843ul, 162723577ul,
<a name="l00752"></a>00752       176048909ul, 190465427ul, 206062531ul, 222936881ul, 241193053ul,
<a name="l00753"></a>00753       260944219ul, 282312799ul, 305431229ul, 330442829ul, 357502601ul,
<a name="l00754"></a>00754       386778277ul, 418451333ul, 452718089ul, 489790921ul, 529899637ul,
<a name="l00755"></a>00755       573292817ul, 620239453ul, 671030513ul, 725980837ul, 785430967ul,
<a name="l00756"></a>00756       849749479ul, 919334987ul, 994618837ul, 1076067617ul, 1164186217ul,
<a name="l00757"></a>00757       1259520799ul, 1362662261ul, 1474249943ul, 1594975441ul,
<a name="l00758"></a>00758       1725587117ul, 1866894511ul, 2019773507ul, 2185171673ul,
<a name="l00759"></a>00759       2364114217ul, 2557710269ul, 2767159799ul, 2993761039ul,
<a name="l00760"></a>00760       3238918481ul, 3504151727ul, 3791104843ul, 4101556399ul,
<a name="l00761"></a>00761       4294967291ul,
<a name="l00762"></a>00762       4294967291ul <span class="comment">// sentinel so we don&apos;t have to test result of lower_bound</span>
<a name="l00763"></a>00763     };
<a name="l00764"></a>00764 <span class="preprocessor">#endif // sss</span>
<a name="l00765"></a>00765 <span class="preprocessor"></span>
<a name="l00766"></a>00766   <span class="keyword">inline</span>
<a name="l00767"></a>00767   prime_rehash_policy::
<a name="l00768"></a>00768   prime_rehash_policy(<span class="keywordtype">float</span> z)
<a name="l00769"></a>00769   : m_max_load_factor(z), m_growth_factor(2.f), m_next_resize(0)
<a name="l00770"></a>00770   { }
<a name="l00771"></a>00771 
<a name="l00772"></a>00772   <span class="keyword">inline</span> <span class="keywordtype">float</span>
<a name="l00773"></a>00773   prime_rehash_policy::
<a name="l00774"></a>00774   max_load_factor()<span class="keyword"> const</span>
<a name="l00775"></a>00775 <span class="keyword">  </span>{ <span class="keywordflow">return</span> m_max_load_factor; }
<a name="l00776"></a>00776 
<a name="l00777"></a>00777   <span class="comment">// Return a prime no smaller than n.</span>
<a name="l00778"></a>00778   <span class="keyword">inline</span> std::size_t
<a name="l00779"></a>00779   prime_rehash_policy::
<a name="l00780"></a>00780   next_bkt(std::size_t n)<span class="keyword"> const</span>
<a name="l00781"></a>00781 <span class="keyword">  </span>{
<a name="l00782"></a>00782     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>* <span class="keyword">const</span> last = X<span class="comment">/*&lt;0&gt;*/</span>::primes + X<span class="comment">/*&lt;0&gt;*/</span>::n_primes; <span class="comment">// sss</span>
<a name="l00783"></a>00783     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>* p = std::lower_bound (X<span class="comment">/*&lt;0&gt;*/</span>::primes, last, n); <span class="comment">// sss</span>
<a name="l00784"></a>00784     m_next_resize = <span class="keyword">static_cast&lt;</span>std::size_t<span class="keyword">&gt;</span>(std::ceil(static_cast&lt;float&gt;(*p) * m_max_load_factor)); <span class="comment">// sss</span>
<a name="l00785"></a>00785     <span class="keywordflow">return</span> *p;
<a name="l00786"></a>00786   }
<a name="l00787"></a>00787 
<a name="l00788"></a>00788   <span class="comment">// Return the smallest prime p such that alpha p &gt;= n, where alpha</span>
<a name="l00789"></a>00789   <span class="comment">// is the load factor.</span>
<a name="l00790"></a>00790   <span class="keyword">inline</span> std::size_t
<a name="l00791"></a>00791   prime_rehash_policy::
<a name="l00792"></a>00792   bkt_for_elements(std::size_t n)<span class="keyword"> const</span>
<a name="l00793"></a>00793 <span class="keyword">  </span>{
<a name="l00794"></a>00794     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>* <span class="keyword">const</span> last = X<span class="comment">/*&lt;0&gt;*/</span>::primes + X<span class="comment">/*&lt;0&gt;*/</span>::n_primes; <span class="comment">// sss</span>
<a name="l00795"></a>00795     <span class="keyword">const</span> <span class="keywordtype">float</span> min_bkts = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(n) / m_max_load_factor; <span class="comment">// sss</span>
<a name="l00796"></a>00796     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>* p = std::lower_bound (X<span class="comment">/*&lt;0&gt;*/</span>::primes, last, <span class="comment">// sss</span>
<a name="l00797"></a>00797                            min_bkts, lt());
<a name="l00798"></a>00798     m_next_resize = <span class="keyword">static_cast&lt;</span>std::size_t<span class="keyword">&gt;</span>(std::ceil(static_cast&lt;float&gt;(*p) * m_max_load_factor)); <span class="comment">// sss</span>
<a name="l00799"></a>00799     <span class="keywordflow">return</span> *p;
<a name="l00800"></a>00800   }
<a name="l00801"></a>00801 
<a name="l00802"></a>00802   <span class="comment">// Finds the smallest prime p such that alpha p &gt; n_elt + n_ins.</span>
<a name="l00803"></a>00803   <span class="comment">// If p &gt; n_bkt, return make_pair(true, p); otherwise return</span>
<a name="l00804"></a>00804   <span class="comment">// make_pair(false, 0).  In principle this isn&apos;t very different from </span>
<a name="l00805"></a>00805   <span class="comment">// bkt_for_elements.</span>
<a name="l00806"></a>00806   
<a name="l00807"></a>00807   <span class="comment">// The only tricky part is that we&apos;re caching the element count at</span>
<a name="l00808"></a>00808   <span class="comment">// which we need to rehash, so we don&apos;t have to do a floating-point</span>
<a name="l00809"></a>00809   <span class="comment">// multiply for every insertion.</span>
<a name="l00810"></a>00810   
<a name="l00811"></a>00811   <span class="keyword">inline</span> std::pair&lt;bool, std::size_t&gt;
<a name="l00812"></a>00812   prime_rehash_policy::
<a name="l00813"></a>00813   need_rehash(std::size_t n_bkt, std::size_t n_elt, std::size_t n_ins)<span class="keyword"> const</span>
<a name="l00814"></a>00814 <span class="keyword">  </span>{
<a name="l00815"></a>00815     <span class="keywordflow">if</span> (n_elt + n_ins &gt; m_next_resize)
<a name="l00816"></a>00816       {
<a name="l00817"></a>00817     <span class="keywordtype">float</span> min_bkts = (float(n_ins) + float(n_elt)) / m_max_load_factor;
<a name="l00818"></a>00818     <span class="keywordflow">if</span> (min_bkts &gt; n_bkt)
<a name="l00819"></a>00819       {
<a name="l00820"></a>00820         min_bkts = std::max (min_bkts, m_growth_factor * static_cast&lt;float&gt;(n_bkt)); <span class="comment">// sss</span>
<a name="l00821"></a>00821         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>* <span class="keyword">const</span> last = X<span class="comment">/*&lt;0&gt;*/</span>::primes + X<span class="comment">/*&lt;0&gt;*/</span>::n_primes; <span class="comment">// sss</span>
<a name="l00822"></a>00822         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>* p = std::lower_bound (X<span class="comment">/*&lt;0&gt;*/</span>::primes, last, <span class="comment">// sss</span>
<a name="l00823"></a>00823                                min_bkts, lt());
<a name="l00824"></a>00824         m_next_resize = 
<a name="l00825"></a>00825           <span class="keyword">static_cast&lt;</span>std::size_t<span class="keyword">&gt;</span>(std::ceil(static_cast&lt;float&gt;(*p) * m_max_load_factor)); <span class="comment">// sss</span>
<a name="l00826"></a>00826         <span class="keywordflow">return</span> std::make_pair(<span class="keyword">true</span>, *p);
<a name="l00827"></a>00827       }
<a name="l00828"></a>00828     <span class="keywordflow">else</span> 
<a name="l00829"></a>00829       {
<a name="l00830"></a>00830         m_next_resize = 
<a name="l00831"></a>00831           <span class="keyword">static_cast&lt;</span>std::size_t<span class="keyword">&gt;</span>(std::ceil(static_cast&lt;float&gt;(n_bkt) * m_max_load_factor));  <span class="comment">// sss</span>
<a name="l00832"></a>00832         <span class="keywordflow">return</span> std::make_pair(<span class="keyword">false</span>, 0);
<a name="l00833"></a>00833       }
<a name="l00834"></a>00834       }
<a name="l00835"></a>00835     <span class="keywordflow">else</span>
<a name="l00836"></a>00836       <span class="keywordflow">return</span> std::make_pair(<span class="keyword">false</span>, 0);
<a name="l00837"></a>00837   }
<a name="l00838"></a>00838 
<a name="l00839"></a>00839 } <span class="comment">// namespace CxxUtils_Internal sss</span>
<a name="l00840"></a>00840 
<a name="l00841"></a>00841 <span class="comment">//----------------------------------------------------------------------</span>
<a name="l00842"></a>00842 <span class="comment">// Base classes for std::tr1::hashtable.  We define these base classes</span>
<a name="l00843"></a>00843 <span class="comment">// because in some cases we want to do different things depending on</span>
<a name="l00844"></a>00844 <span class="comment">// the value of a policy class.  In some cases the policy class affects</span>
<a name="l00845"></a>00845 <span class="comment">// which member functions and nested typedefs are defined; we handle that</span>
<a name="l00846"></a>00846 <span class="comment">// by specializing base class templates.  Several of the base class templates</span>
<a name="l00847"></a>00847 <span class="comment">// need to access other members of class template hashtable, so we use</span>
<a name="l00848"></a>00848 <span class="comment">// the &quot;curiously recurring template pattern&quot; for them.</span>
<a name="l00849"></a>00849 
<a name="l00850"></a>00850 <span class="keyword">namespace </span>CxxUtils_Internal <span class="comment">// sss Internal</span>
<a name="l00851"></a>00851 {
<a name="l00852"></a>00852   <span class="comment">// class template map_base.  If the hashtable has a value type of the</span>
<a name="l00853"></a>00853   <span class="comment">// form pair&lt;T1, T2&gt; and a key extraction policy that returns the</span>
<a name="l00854"></a>00854   <span class="comment">// first part of the pair, the hashtable gets a mapped_type typedef.</span>
<a name="l00855"></a>00855   <span class="comment">// If it satisfies those criteria and also has unique keys, then it</span>
<a name="l00856"></a>00856   <span class="comment">// also gets an operator[].</span>
<a name="l00857"></a>00857   
<a name="l00858"></a>00858   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V, <span class="keyword">typename</span> Ex, <span class="keywordtype">bool</span> unique, <span class="keyword">typename</span> Hashtable&gt;
<a name="l00859"></a><a class="code" href="../../d6/daa/structCxxUtils__Internal_1_1map__base.html">00859</a>     <span class="keyword">struct </span><a class="code" href="../../d6/daa/structCxxUtils__Internal_1_1map__base.html">map_base</a> { };
<a name="l00860"></a>00860       
<a name="l00861"></a>00861   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> Pair, <span class="keyword">typename</span> Hashtable&gt;
<a name="l00862"></a><a class="code" href="../../d8/d09/structCxxUtils__Internal_1_1map__base_3_01K_00_01Pair_00_01extract1st_3_01Pair_01_4_00_01false_00_01Hashtable_01_4.html">00862</a>     <span class="keyword">struct </span><a class="code" href="../../d6/daa/structCxxUtils__Internal_1_1map__base.html">map_base</a>&lt;K, Pair, <a class="code" href="../../dc/dbe/structCxxUtils__Internal_1_1extract1st.html">extract1st</a>&lt;Pair&gt;, false, Hashtable&gt;
<a name="l00863"></a>00863     {
<a name="l00864"></a>00864       <span class="keyword">typedef</span> <span class="keyword">typename</span> Pair::second_type mapped_type;
<a name="l00865"></a>00865     };
<a name="l00866"></a>00866 
<a name="l00867"></a>00867   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> Pair, <span class="keyword">typename</span> Hashtable&gt;
<a name="l00868"></a><a class="code" href="../../d8/dea/structCxxUtils__Internal_1_1map__base_3_01K_00_01Pair_00_01extract1st_3_01Pair_01_4_00_01true_00_01Hashtable_01_4.html">00868</a>     <span class="keyword">struct </span><a class="code" href="../../d6/daa/structCxxUtils__Internal_1_1map__base.html">map_base</a>&lt;K, Pair, <a class="code" href="../../dc/dbe/structCxxUtils__Internal_1_1extract1st.html">extract1st</a>&lt;Pair&gt;, true, Hashtable&gt;
<a name="l00869"></a>00869     {
<a name="l00870"></a>00870       <span class="keyword">typedef</span> <span class="keyword">typename</span> Pair::second_type mapped_type;
<a name="l00871"></a>00871       
<a name="l00872"></a>00872       mapped_type&amp;
<a name="l00873"></a>00873       operator[](<span class="keyword">const</span> K&amp; k)
<a name="l00874"></a>00874       {
<a name="l00875"></a>00875     Hashtable* h = <span class="keyword">static_cast&lt;</span>Hashtable*<span class="keyword">&gt;</span>(<span class="keyword">this</span>);
<a name="l00876"></a>00876     <span class="keyword">typename</span> Hashtable::iterator it = 
<a name="l00877"></a>00877       h-&gt;insert(std::make_pair(k, mapped_type())).first;
<a name="l00878"></a>00878     <span class="keywordflow">return</span> it-&gt;second;
<a name="l00879"></a>00879       }
<a name="l00880"></a>00880     };
<a name="l00881"></a>00881 
<a name="l00882"></a>00882   <span class="comment">// class template rehash_base.  Give hashtable the max_load_factor</span>
<a name="l00883"></a>00883   <span class="comment">// functions iff the rehash policy is prime_rehash_policy.</span>
<a name="l00884"></a>00884   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> RehashPolicy, <span class="keyword">typename</span> Hashtable&gt;
<a name="l00885"></a><a class="code" href="../../df/d53/structCxxUtils__Internal_1_1rehash__base.html">00885</a>     <span class="keyword">struct </span><a class="code" href="../../df/d53/structCxxUtils__Internal_1_1rehash__base.html">rehash_base</a> { };
<a name="l00886"></a>00886 
<a name="l00887"></a>00887   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Hashtable&gt;
<a name="l00888"></a><a class="code" href="../../db/d6a/structCxxUtils__Internal_1_1rehash__base_3_01prime__rehash__policy_00_01Hashtable_01_4.html">00888</a>     <span class="keyword">struct </span><a class="code" href="../../df/d53/structCxxUtils__Internal_1_1rehash__base.html">rehash_base</a>&lt;<a class="code" href="../../df/dfa/structCxxUtils__Internal_1_1prime__rehash__policy.html">prime_rehash_policy</a>, Hashtable&gt;
<a name="l00889"></a>00889     {
<a name="l00890"></a>00890       <span class="keywordtype">float</span>
<a name="l00891"></a>00891       max_load_factor()<span class="keyword"> const</span>
<a name="l00892"></a>00892 <span class="keyword">      </span>{
<a name="l00893"></a>00893     <span class="keyword">const</span> Hashtable* This = <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>Hashtable*<span class="keyword">&gt;</span>(<span class="keyword">this</span>);
<a name="l00894"></a>00894     <span class="keywordflow">return</span> This-&gt;rehash_policy().max_load_factor();
<a name="l00895"></a>00895       }
<a name="l00896"></a>00896 
<a name="l00897"></a>00897       <span class="keywordtype">void</span>
<a name="l00898"></a>00898       max_load_factor(<span class="keywordtype">float</span> z)
<a name="l00899"></a>00899       {
<a name="l00900"></a>00900     Hashtable* This = <span class="keyword">static_cast&lt;</span>Hashtable*<span class="keyword">&gt;</span>(<span class="keyword">this</span>);
<a name="l00901"></a>00901     This-&gt;rehash_policy(<a class="code" href="../../df/dfa/structCxxUtils__Internal_1_1prime__rehash__policy.html">prime_rehash_policy</a>(z));    
<a name="l00902"></a>00902       }
<a name="l00903"></a>00903     };
<a name="l00904"></a>00904 
<a name="l00905"></a>00905   <span class="comment">// Class template hash_code_base.  Encapsulates two policy issues that</span>
<a name="l00906"></a>00906   <span class="comment">// aren&apos;t quite orthogonal.</span>
<a name="l00907"></a>00907   <span class="comment">//   (1) the difference between using a ranged hash function and using</span>
<a name="l00908"></a>00908   <span class="comment">//       the combination of a hash function and a range-hashing function.</span>
<a name="l00909"></a>00909   <span class="comment">//       In the former case we don&apos;t have such things as hash codes, so</span>
<a name="l00910"></a>00910   <span class="comment">//       we have a dummy type as placeholder.</span>
<a name="l00911"></a>00911   <span class="comment">//   (2) Whether or not we cache hash codes.  Caching hash codes is</span>
<a name="l00912"></a>00912   <span class="comment">//       meaningless if we have a ranged hash function.</span>
<a name="l00913"></a>00913   <span class="comment">// We also put the key extraction and equality comparison function </span>
<a name="l00914"></a>00914   <span class="comment">// objects here, for convenience.</span>
<a name="l00915"></a>00915   
<a name="l00916"></a>00916   <span class="comment">// Primary template: unused except as a hook for specializations.</span>
<a name="l00917"></a>00917   
<a name="l00918"></a>00918   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value,
<a name="l00919"></a>00919        <span class="keyword">typename</span> ExtractKey, <span class="keyword">typename</span> Equal,
<a name="l00920"></a>00920        <span class="keyword">typename</span> H1, <span class="keyword">typename</span> H2, <span class="keyword">typename</span> H,
<a name="l00921"></a>00921        <span class="keywordtype">bool</span> cache_hash_code&gt;
<a name="l00922"></a>00922     <span class="keyword">struct </span><a class="code" href="../../d0/d2e/classInternal_1_1hash__code__base.html">hash_code_base</a>;
<a name="l00923"></a>00923 
<a name="l00924"></a>00924   <span class="comment">// Specialization: ranged hash function, no caching hash codes.  H1</span>
<a name="l00925"></a>00925   <span class="comment">// and H2 are provided but ignored.  We define a dummy hash code type.</span>
<a name="l00926"></a>00926   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value,
<a name="l00927"></a>00927        <span class="keyword">typename</span> ExtractKey, <span class="keyword">typename</span> Equal,
<a name="l00928"></a>00928        <span class="keyword">typename</span> H1, <span class="keyword">typename</span> H2, <span class="keyword">typename</span> H&gt;
<a name="l00929"></a><a class="code" href="../../d4/dcb/structCxxUtils__Internal_1_1hash__code__base_3_01Key_00_01Value_00_01ExtractKey_00_01Equal_00_01a1d090efd1d13aa3ac9dd6f06b86ea82.html">00929</a>     <span class="keyword">struct </span><a class="code" href="../../d0/d2e/classInternal_1_1hash__code__base.html">hash_code_base</a>&lt;Key, Value, ExtractKey, Equal, H1, H2, H, false&gt;
<a name="l00930"></a>00930     {
<a name="l00931"></a>00931     <span class="keyword">protected</span>:
<a name="l00932"></a>00932       <a class="code" href="../../d0/d2e/classInternal_1_1hash__code__base.html">hash_code_base</a>(<span class="keyword">const</span> ExtractKey&amp; ex, <span class="keyword">const</span> Equal&amp; eq,
<a name="l00933"></a>00933              <span class="keyword">const</span> H1&amp;, <span class="keyword">const</span> H2&amp;, <span class="keyword">const</span> H&amp; h)
<a name="l00934"></a>00934       : m_extract(ex), m_eq(eq), m_ranged_hash(h) { }
<a name="l00935"></a>00935 
<a name="l00936"></a>00936       <span class="keyword">typedef</span> <span class="keywordtype">void</span>* hash_code_t;
<a name="l00937"></a>00937   
<a name="l00938"></a>00938       hash_code_t
<a name="l00939"></a>00939       m_hash_code(<span class="keyword">const</span> Key&amp; <span class="comment">/*k*/</span>)<span class="keyword"> const</span>
<a name="l00940"></a>00940 <span class="keyword">      </span>{ <span class="keywordflow">return</span> 0; }
<a name="l00941"></a>00941   
<a name="l00942"></a>00942       std::size_t
<a name="l00943"></a>00943       bucket_index(<span class="keyword">const</span> Key&amp; k, hash_code_t, std::size_t N)<span class="keyword"> const</span>
<a name="l00944"></a>00944 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_ranged_hash (k, N); }
<a name="l00945"></a>00945 
<a name="l00946"></a>00946       std::size_t
<a name="l00947"></a>00947       bucket_index(<span class="keyword">const</span> <a class="code" href="../../d4/d41/structCxxUtils__Internal_1_1hash__node_3_01Value_00_01false_01_4.html">hash_node&lt;Value, false&gt;</a>* p, std::size_t N)<span class="keyword"> const</span>
<a name="l00948"></a>00948 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_ranged_hash (m_extract (p-&gt;m_v), N); }
<a name="l00949"></a>00949   
<a name="l00950"></a>00950       <span class="keywordtype">bool</span>
<a name="l00951"></a>00951       compare(<span class="keyword">const</span> Key&amp; k, hash_code_t, <a class="code" href="../../d4/d41/structCxxUtils__Internal_1_1hash__node_3_01Value_00_01false_01_4.html">hash_node&lt;Value, false&gt;</a>* n)<span class="keyword"> const</span>
<a name="l00952"></a>00952 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_eq (k, m_extract(n-&gt;m_v)); }
<a name="l00953"></a>00953 
<a name="l00954"></a>00954       <span class="keywordtype">void</span>
<a name="l00955"></a>00955       store_code(<a class="code" href="../../d4/d41/structCxxUtils__Internal_1_1hash__node_3_01Value_00_01false_01_4.html">hash_node&lt;Value, false&gt;</a>*, hash_code_t)<span class="keyword"> const</span>
<a name="l00956"></a>00956 <span class="keyword">      </span>{ }
<a name="l00957"></a>00957 
<a name="l00958"></a>00958       <span class="keywordtype">void</span>
<a name="l00959"></a>00959       copy_code(<a class="code" href="../../d4/d41/structCxxUtils__Internal_1_1hash__node_3_01Value_00_01false_01_4.html">hash_node&lt;Value, false&gt;</a>*, <span class="keyword">const</span> <a class="code" href="../../d4/d41/structCxxUtils__Internal_1_1hash__node_3_01Value_00_01false_01_4.html">hash_node&lt;Value, false&gt;</a>*)<span class="keyword"> const</span>
<a name="l00960"></a>00960 <span class="keyword">      </span>{ }
<a name="l00961"></a>00961       
<a name="l00962"></a>00962       <span class="keywordtype">void</span>
<a name="l00963"></a>00963       m_swap(<a class="code" href="../../d0/d2e/classInternal_1_1hash__code__base.html">hash_code_base</a>&amp; x)
<a name="l00964"></a>00964       {
<a name="l00965"></a>00965     <a class="code" href="../../db/ded/ConstDataList_8h.html#a67766f262856f1e197e15fec33b60bac" title="See DataList&amp;lt;T, BASE&amp;gt;::swap().">std::swap</a>(m_extract, x.m_extract);
<a name="l00966"></a>00966     <a class="code" href="../../db/ded/ConstDataList_8h.html#a67766f262856f1e197e15fec33b60bac" title="See DataList&amp;lt;T, BASE&amp;gt;::swap().">std::swap</a>(m_eq, x.m_eq);
<a name="l00967"></a>00967     <a class="code" href="../../db/ded/ConstDataList_8h.html#a67766f262856f1e197e15fec33b60bac" title="See DataList&amp;lt;T, BASE&amp;gt;::swap().">std::swap</a>(m_ranged_hash, x.m_ranged_hash);
<a name="l00968"></a>00968       }
<a name="l00969"></a>00969 
<a name="l00970"></a>00970     <span class="keyword">protected</span>:
<a name="l00971"></a>00971       ExtractKey m_extract;
<a name="l00972"></a>00972       Equal m_eq;
<a name="l00973"></a>00973       H m_ranged_hash;
<a name="l00974"></a>00974     };
<a name="l00975"></a>00975 
<a name="l00976"></a>00976 
<a name="l00977"></a>00977   <span class="comment">// No specialization for ranged hash function while caching hash codes.</span>
<a name="l00978"></a>00978   <span class="comment">// That combination is meaningless, and trying to do it is an error.</span>
<a name="l00979"></a>00979   
<a name="l00980"></a>00980   
<a name="l00981"></a>00981   <span class="comment">// Specialization: ranged hash function, cache hash codes.  This</span>
<a name="l00982"></a>00982   <span class="comment">// combination is meaningless, so we provide only a declaration</span>
<a name="l00983"></a>00983   <span class="comment">// and no definition.</span>
<a name="l00984"></a>00984   
<a name="l00985"></a>00985   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value,
<a name="l00986"></a>00986         <span class="keyword">typename</span> ExtractKey, <span class="keyword">typename</span> Equal,
<a name="l00987"></a>00987         <span class="keyword">typename</span> H1, <span class="keyword">typename</span> H2, <span class="keyword">typename</span> H&gt;
<a name="l00988"></a>00988     <span class="keyword">struct </span><a class="code" href="../../d0/d2e/classInternal_1_1hash__code__base.html">hash_code_base</a>&lt;Key, Value, ExtractKey, Equal, H1, H2, H, true&gt;;
<a name="l00989"></a>00989 
<a name="l00990"></a>00990 
<a name="l00991"></a>00991   <span class="comment">// Specialization: hash function and range-hashing function, no</span>
<a name="l00992"></a>00992   <span class="comment">// caching of hash codes.  H is provided but ignored.  Provides</span>
<a name="l00993"></a>00993   <span class="comment">// typedef and accessor required by TR1.</span>
<a name="l00994"></a>00994   
<a name="l00995"></a>00995   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value,
<a name="l00996"></a>00996        <span class="keyword">typename</span> ExtractKey, <span class="keyword">typename</span> Equal,
<a name="l00997"></a>00997        <span class="keyword">typename</span> H1, <span class="keyword">typename</span> H2&gt;
<a name="l00998"></a><a class="code" href="../../d6/d0d/structCxxUtils__Internal_1_1hash__code__base_3_01Key_00_01Value_00_01ExtractKey_00_01Equal_00_01f3965ec272c126c75c8e16106d9bbf3a.html">00998</a>     <span class="keyword">struct </span><a class="code" href="../../d0/d2e/classInternal_1_1hash__code__base.html">hash_code_base</a>&lt;Key, Value, ExtractKey, Equal, H1, H2,
<a name="l00999"></a>00999               <a class="code" href="../../dc/d78/structCxxUtils__Internal_1_1default__ranged__hash.html">default_ranged_hash</a>, false&gt;
<a name="l01000"></a>01000     {
<a name="l01001"></a>01001       <span class="keyword">typedef</span> H1 hasher;
<a name="l01002"></a>01002       
<a name="l01003"></a>01003       hasher
<a name="l01004"></a>01004       hash_function()<span class="keyword"> const</span>
<a name="l01005"></a>01005 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_h1; }
<a name="l01006"></a>01006 
<a name="l01007"></a>01007     <span class="keyword">protected</span>:
<a name="l01008"></a>01008       <a class="code" href="../../d0/d2e/classInternal_1_1hash__code__base.html">hash_code_base</a>(<span class="keyword">const</span> ExtractKey&amp; ex, <span class="keyword">const</span> Equal&amp; eq,
<a name="l01009"></a>01009              <span class="keyword">const</span> H1&amp; h1, <span class="keyword">const</span> H2&amp; h2, <span class="keyword">const</span> <a class="code" href="../../dc/d78/structCxxUtils__Internal_1_1default__ranged__hash.html">default_ranged_hash</a>&amp;)
<a name="l01010"></a>01010       : m_extract(ex), m_eq(eq), m_h1(h1), m_h2(h2) { }
<a name="l01011"></a>01011 
<a name="l01012"></a>01012       <span class="keyword">typedef</span> std::size_t hash_code_t;
<a name="l01013"></a>01013       
<a name="l01014"></a>01014       hash_code_t
<a name="l01015"></a>01015       m_hash_code(<span class="keyword">const</span> Key&amp; k)<span class="keyword"> const</span>
<a name="l01016"></a>01016 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_h1(k); }
<a name="l01017"></a>01017       
<a name="l01018"></a>01018       std::size_t
<a name="l01019"></a>01019       bucket_index(<span class="keyword">const</span> Key&amp;, hash_code_t c, std::size_t N)<span class="keyword"> const</span>
<a name="l01020"></a>01020 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_h2 (c, N); }
<a name="l01021"></a>01021 
<a name="l01022"></a>01022       std::size_t
<a name="l01023"></a>01023       bucket_index(<span class="keyword">const</span> <a class="code" href="../../d4/d41/structCxxUtils__Internal_1_1hash__node_3_01Value_00_01false_01_4.html">hash_node&lt;Value, false&gt;</a>* p, std::size_t N)<span class="keyword"> const</span>
<a name="l01024"></a>01024 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_h2 (m_h1 (m_extract (p-&gt;m_v)), N); }
<a name="l01025"></a>01025 
<a name="l01026"></a>01026       <span class="keywordtype">bool</span>
<a name="l01027"></a>01027       compare(<span class="keyword">const</span> Key&amp; k, hash_code_t, <a class="code" href="../../d4/d41/structCxxUtils__Internal_1_1hash__node_3_01Value_00_01false_01_4.html">hash_node&lt;Value, false&gt;</a>* n)<span class="keyword"> const</span>
<a name="l01028"></a>01028 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_eq (k, m_extract(n-&gt;m_v)); }
<a name="l01029"></a>01029 
<a name="l01030"></a>01030       <span class="keywordtype">void</span>
<a name="l01031"></a>01031       store_code(<a class="code" href="../../d4/d41/structCxxUtils__Internal_1_1hash__node_3_01Value_00_01false_01_4.html">hash_node&lt;Value, false&gt;</a>*, hash_code_t)<span class="keyword"> const</span>
<a name="l01032"></a>01032 <span class="keyword">      </span>{ }
<a name="l01033"></a>01033 
<a name="l01034"></a>01034       <span class="keywordtype">void</span>
<a name="l01035"></a>01035       copy_code(<a class="code" href="../../d4/d41/structCxxUtils__Internal_1_1hash__node_3_01Value_00_01false_01_4.html">hash_node&lt;Value, false&gt;</a>*, <span class="keyword">const</span> <a class="code" href="../../d4/d41/structCxxUtils__Internal_1_1hash__node_3_01Value_00_01false_01_4.html">hash_node&lt;Value, false&gt;</a>*)<span class="keyword"> const</span>
<a name="l01036"></a>01036 <span class="keyword">      </span>{ }
<a name="l01037"></a>01037 
<a name="l01038"></a>01038       <span class="keywordtype">void</span>
<a name="l01039"></a>01039       m_swap(<a class="code" href="../../d0/d2e/classInternal_1_1hash__code__base.html">hash_code_base</a>&amp; x)
<a name="l01040"></a>01040       {
<a name="l01041"></a>01041     <a class="code" href="../../db/ded/ConstDataList_8h.html#a67766f262856f1e197e15fec33b60bac" title="See DataList&amp;lt;T, BASE&amp;gt;::swap().">std::swap</a>(m_extract, x.m_extract);
<a name="l01042"></a>01042     <a class="code" href="../../db/ded/ConstDataList_8h.html#a67766f262856f1e197e15fec33b60bac" title="See DataList&amp;lt;T, BASE&amp;gt;::swap().">std::swap</a>(m_eq, x.m_eq);
<a name="l01043"></a>01043     <a class="code" href="../../db/ded/ConstDataList_8h.html#a67766f262856f1e197e15fec33b60bac" title="See DataList&amp;lt;T, BASE&amp;gt;::swap().">std::swap</a>(m_h1, x.m_h1);
<a name="l01044"></a>01044     <a class="code" href="../../db/ded/ConstDataList_8h.html#a67766f262856f1e197e15fec33b60bac" title="See DataList&amp;lt;T, BASE&amp;gt;::swap().">std::swap</a>(m_h2, x.m_h2);
<a name="l01045"></a>01045       }
<a name="l01046"></a>01046 
<a name="l01047"></a>01047     <span class="keyword">protected</span>:
<a name="l01048"></a>01048       ExtractKey m_extract;
<a name="l01049"></a>01049       Equal m_eq;
<a name="l01050"></a>01050       H1 m_h1;
<a name="l01051"></a>01051       H2 m_h2;
<a name="l01052"></a>01052     };
<a name="l01053"></a>01053 
<a name="l01054"></a>01054   <span class="comment">// Specialization: hash function and range-hashing function, </span>
<a name="l01055"></a>01055   <span class="comment">// caching hash codes.  H is provided but ignored.  Provides</span>
<a name="l01056"></a>01056   <span class="comment">// typedef and accessor required by TR1.</span>
<a name="l01057"></a>01057   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value,
<a name="l01058"></a>01058        <span class="keyword">typename</span> ExtractKey, <span class="keyword">typename</span> Equal,
<a name="l01059"></a>01059        <span class="keyword">typename</span> H1, <span class="keyword">typename</span> H2&gt;
<a name="l01060"></a><a class="code" href="../../d7/d30/structCxxUtils__Internal_1_1hash__code__base_3_01Key_00_01Value_00_01ExtractKey_00_01Equal_00_01066dedd3c6153db03b49152de0b7a67f.html">01060</a>     <span class="keyword">struct </span><a class="code" href="../../d0/d2e/classInternal_1_1hash__code__base.html">hash_code_base</a>&lt;Key, Value, ExtractKey, Equal, H1, H2,
<a name="l01061"></a>01061               <a class="code" href="../../dc/d78/structCxxUtils__Internal_1_1default__ranged__hash.html">default_ranged_hash</a>, true&gt;
<a name="l01062"></a>01062     {
<a name="l01063"></a>01063       <span class="keyword">typedef</span> H1 hasher;
<a name="l01064"></a>01064       
<a name="l01065"></a>01065       hasher
<a name="l01066"></a>01066       hash_function()<span class="keyword"> const</span>
<a name="l01067"></a>01067 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_h1; }
<a name="l01068"></a>01068 
<a name="l01069"></a>01069     <span class="keyword">protected</span>:
<a name="l01070"></a>01070       <a class="code" href="../../d0/d2e/classInternal_1_1hash__code__base.html">hash_code_base</a>(<span class="keyword">const</span> ExtractKey&amp; ex, <span class="keyword">const</span> Equal&amp; eq,
<a name="l01071"></a>01071              <span class="keyword">const</span> H1&amp; h1, <span class="keyword">const</span> H2&amp; h2, <span class="keyword">const</span> <a class="code" href="../../dc/d78/structCxxUtils__Internal_1_1default__ranged__hash.html">default_ranged_hash</a>&amp;)
<a name="l01072"></a>01072       : m_extract(ex), m_eq(eq), m_h1(h1), m_h2(h2) { }
<a name="l01073"></a>01073 
<a name="l01074"></a>01074       <span class="keyword">typedef</span> std::size_t hash_code_t;
<a name="l01075"></a>01075   
<a name="l01076"></a>01076       hash_code_t
<a name="l01077"></a>01077       m_hash_code(<span class="keyword">const</span> Key&amp; k)<span class="keyword"> const</span>
<a name="l01078"></a>01078 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_h1(k); }
<a name="l01079"></a>01079   
<a name="l01080"></a>01080       std::size_t
<a name="l01081"></a>01081       bucket_index(<span class="keyword">const</span> Key&amp;, hash_code_t c, std::size_t N)<span class="keyword"> const</span>
<a name="l01082"></a>01082 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_h2 (c, N); }
<a name="l01083"></a>01083 
<a name="l01084"></a>01084       std::size_t
<a name="l01085"></a>01085       bucket_index(<span class="keyword">const</span> <a class="code" href="../../dd/dfd/structCxxUtils__Internal_1_1hash__node_3_01Value_00_01true_01_4.html">hash_node&lt;Value, true&gt;</a>* p, std::size_t N)<span class="keyword"> const</span>
<a name="l01086"></a>01086 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_h2 (p-&gt;hash_code, N); }
<a name="l01087"></a>01087 
<a name="l01088"></a>01088       <span class="keywordtype">bool</span>
<a name="l01089"></a>01089       compare(<span class="keyword">const</span> Key&amp; k, hash_code_t c, <a class="code" href="../../dd/dfd/structCxxUtils__Internal_1_1hash__node_3_01Value_00_01true_01_4.html">hash_node&lt;Value, true&gt;</a>* n)<span class="keyword"> const</span>
<a name="l01090"></a>01090 <span class="keyword">      </span>{ <span class="keywordflow">return</span> c == n-&gt;hash_code &amp;&amp; m_eq(k, m_extract(n-&gt;m_v)); }
<a name="l01091"></a>01091 
<a name="l01092"></a>01092       <span class="keywordtype">void</span>
<a name="l01093"></a>01093       store_code(<a class="code" href="../../dd/dfd/structCxxUtils__Internal_1_1hash__node_3_01Value_00_01true_01_4.html">hash_node&lt;Value, true&gt;</a>* n, hash_code_t c)<span class="keyword"> const</span>
<a name="l01094"></a>01094 <span class="keyword">      </span>{ n-&gt;hash_code = c; }
<a name="l01095"></a>01095 
<a name="l01096"></a>01096       <span class="keywordtype">void</span>
<a name="l01097"></a>01097       copy_code(<a class="code" href="../../dd/dfd/structCxxUtils__Internal_1_1hash__node_3_01Value_00_01true_01_4.html">hash_node&lt;Value, true&gt;</a>* to,
<a name="l01098"></a>01098         <span class="keyword">const</span> <a class="code" href="../../dd/dfd/structCxxUtils__Internal_1_1hash__node_3_01Value_00_01true_01_4.html">hash_node&lt;Value, true&gt;</a>* from)<span class="keyword"> const</span>
<a name="l01099"></a>01099 <span class="keyword">      </span>{ to-&gt;hash_code = from-&gt;hash_code; }
<a name="l01100"></a>01100 
<a name="l01101"></a>01101       <span class="keywordtype">void</span>
<a name="l01102"></a>01102       m_swap(<a class="code" href="../../d0/d2e/classInternal_1_1hash__code__base.html">hash_code_base</a>&amp; x)
<a name="l01103"></a>01103       {
<a name="l01104"></a>01104     <a class="code" href="../../db/ded/ConstDataList_8h.html#a67766f262856f1e197e15fec33b60bac" title="See DataList&amp;lt;T, BASE&amp;gt;::swap().">std::swap</a>(m_extract, x.m_extract);
<a name="l01105"></a>01105     <a class="code" href="../../db/ded/ConstDataList_8h.html#a67766f262856f1e197e15fec33b60bac" title="See DataList&amp;lt;T, BASE&amp;gt;::swap().">std::swap</a>(m_eq, x.m_eq);
<a name="l01106"></a>01106     <a class="code" href="../../db/ded/ConstDataList_8h.html#a67766f262856f1e197e15fec33b60bac" title="See DataList&amp;lt;T, BASE&amp;gt;::swap().">std::swap</a>(m_h1, x.m_h1);
<a name="l01107"></a>01107     <a class="code" href="../../db/ded/ConstDataList_8h.html#a67766f262856f1e197e15fec33b60bac" title="See DataList&amp;lt;T, BASE&amp;gt;::swap().">std::swap</a>(m_h2, x.m_h2);
<a name="l01108"></a>01108       }
<a name="l01109"></a>01109       
<a name="l01110"></a>01110     <span class="keyword">protected</span>:
<a name="l01111"></a>01111       ExtractKey m_extract;
<a name="l01112"></a>01112       Equal m_eq;
<a name="l01113"></a>01113       H1 m_h1;
<a name="l01114"></a>01114       H2 m_h2;
<a name="l01115"></a>01115     };
<a name="l01116"></a>01116 
<a name="l01117"></a>01117 } <span class="comment">// namespace CxxUtils_Internal sss</span>
<a name="l01118"></a>01118 
<a name="l01119"></a>01119 <span class="comment">//namespace std      sss</span>
<a name="l01120"></a>01120 <span class="comment">//{                  sss</span>
<a name="l01121"></a>01121 <span class="keyword">namespace </span>SG <span class="comment">// tr1  sss</span>
<a name="l01122"></a>01122 {
<a name="l01123"></a>01123 <span class="preprocessor">#define Internal CxxUtils_Internal // sss</span>
<a name="l01124"></a>01124 <span class="preprocessor"></span>  <span class="comment">//----------------------------------------------------------------------</span>
<a name="l01125"></a>01125   <span class="comment">// Class template hashtable, class definition.</span>
<a name="l01126"></a>01126   
<a name="l01127"></a>01127   <span class="comment">// Meaning of class template hashtable&apos;s template parameters</span>
<a name="l01128"></a>01128   
<a name="l01129"></a>01129   <span class="comment">// Key and Value: arbitrary CopyConstructible types.</span>
<a name="l01130"></a>01130   
<a name="l01131"></a>01131   <span class="comment">// Allocator: an allocator type ([lib.allocator.requirements]) whose</span>
<a name="l01132"></a>01132   <span class="comment">// value type is Value.</span>
<a name="l01133"></a>01133   
<a name="l01134"></a>01134   <span class="comment">// ExtractKey: function object that takes a object of type Value</span>
<a name="l01135"></a>01135   <span class="comment">// and returns a value of type Key.</span>
<a name="l01136"></a>01136   
<a name="l01137"></a>01137   <span class="comment">// Equal: function object that takes two objects of type k and returns</span>
<a name="l01138"></a>01138   <span class="comment">// a bool-like value that is true if the two objects are considered equal.</span>
<a name="l01139"></a>01139   
<a name="l01140"></a>01140   <span class="comment">// H1: the hash function.  A unary function object with argument type</span>
<a name="l01141"></a>01141   <span class="comment">// Key and result type size_t.  Return values should be distributed</span>
<a name="l01142"></a>01142   <span class="comment">// over the entire range [0, numeric_limits&lt;size_t&gt;:::max()].</span>
<a name="l01143"></a>01143   
<a name="l01144"></a>01144   <span class="comment">// H2: the range-hashing function (in the terminology of Tavori and</span>
<a name="l01145"></a>01145   <span class="comment">// Dreizin).  A binary function object whose argument types and result</span>
<a name="l01146"></a>01146   <span class="comment">// type are all size_t.  Given arguments r and N, the return value is</span>
<a name="l01147"></a>01147   <span class="comment">// in the range [0, N).</span>
<a name="l01148"></a>01148   
<a name="l01149"></a>01149   <span class="comment">// H: the ranged hash function (Tavori and Dreizin). A binary function</span>
<a name="l01150"></a>01150   <span class="comment">// whose argument types are Key and size_t and whose result type is</span>
<a name="l01151"></a>01151   <span class="comment">// size_t.  Given arguments k and N, the return value is in the range</span>
<a name="l01152"></a>01152   <span class="comment">// [0, N).  Default: h(k, N) = h2(h1(k), N).  If H is anything other</span>
<a name="l01153"></a>01153   <span class="comment">// than the default, H1 and H2 are ignored.</span>
<a name="l01154"></a>01154   
<a name="l01155"></a>01155   <span class="comment">// RehashPolicy: Policy class with three members, all of which govern</span>
<a name="l01156"></a>01156   <span class="comment">// the bucket count. n_bkt(n) returns a bucket count no smaller</span>
<a name="l01157"></a>01157   <span class="comment">// than n.  bkt_for_elements(n) returns a bucket count appropriate</span>
<a name="l01158"></a>01158   <span class="comment">// for an element count of n.  need_rehash(n_bkt, n_elt, n_ins)</span>
<a name="l01159"></a>01159   <span class="comment">// determines whether, if the current bucket count is n_bkt and the</span>
<a name="l01160"></a>01160   <span class="comment">// current element count is n_elt, we need to increase the bucket</span>
<a name="l01161"></a>01161   <span class="comment">// count.  If so, returns make_pair(true, n), where n is the new</span>
<a name="l01162"></a>01162   <span class="comment">// bucket count.  If not, returns make_pair(false, &lt;anything&gt;).</span>
<a name="l01163"></a>01163   
<a name="l01164"></a>01164   <span class="comment">// ??? Right now it is hard-wired that the number of buckets never</span>
<a name="l01165"></a>01165   <span class="comment">// shrinks.  Should we allow RehashPolicy to change that?</span>
<a name="l01166"></a>01166   
<a name="l01167"></a>01167   <span class="comment">// cache_hash_code: bool.  true if we store the value of the hash</span>
<a name="l01168"></a>01168   <span class="comment">// function along with the value.  This is a time-space tradeoff.</span>
<a name="l01169"></a>01169   <span class="comment">// Storing it may improve lookup speed by reducing the number of times</span>
<a name="l01170"></a>01170   <span class="comment">// we need to call the Equal function.</span>
<a name="l01171"></a>01171   
<a name="l01172"></a>01172   <span class="comment">// constant_iterators: bool.  true if iterator and const_iterator are</span>
<a name="l01173"></a>01173   <span class="comment">// both constant iterator types.  This is true for unordered_set and</span>
<a name="l01174"></a>01174   <span class="comment">// unordered_multiset, false for unordered_map and unordered_multimap.</span>
<a name="l01175"></a>01175   
<a name="l01176"></a>01176   <span class="comment">// unique_keys: bool.  true if the return value of hashtable::count(k)</span>
<a name="l01177"></a>01177   <span class="comment">// is always at most one, false if it may be an arbitrary number.  This</span>
<a name="l01178"></a>01178   <span class="comment">// true for unordered_set and unordered_map, false for unordered_multiset</span>
<a name="l01179"></a>01179   <span class="comment">// and unordered_multimap.</span>
<a name="l01180"></a>01180   
<a name="l01181"></a>01181   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, 
<a name="l01182"></a>01182        <span class="keyword">typename</span> Allocator,
<a name="l01183"></a>01183        <span class="keyword">typename</span> ExtractKey, <span class="keyword">typename</span> Equal,
<a name="l01184"></a>01184        <span class="keyword">typename</span> H1, <span class="keyword">typename</span> H2,
<a name="l01185"></a>01185        <span class="keyword">typename</span> H, <span class="keyword">typename</span> RehashPolicy,
<a name="l01186"></a>01186        <span class="keywordtype">bool</span> cache_hash_code,
<a name="l01187"></a>01187        <span class="keywordtype">bool</span> constant_iterators,
<a name="l01188"></a>01188        <span class="keywordtype">bool</span> unique_keys&gt;
<a name="l01189"></a><a class="code" href="../../de/d63/classSG_1_1hashtable.html">01189</a>     <span class="keyword">class </span><a class="code" href="../../de/d63/classSG_1_1hashtable.html">hashtable</a>
<a name="l01190"></a>01190     : <span class="keyword">public</span> Internal::<a class="code" href="../../db/d2b/classInternal_1_1rehash__base.html">rehash_base</a>&lt;RehashPolicy,
<a name="l01191"></a>01191                    hashtable&lt;Key, Value, Allocator, ExtractKey,
<a name="l01192"></a>01192                          Equal, H1, H2, H, RehashPolicy,
<a name="l01193"></a>01193                          cache_hash_code, constant_iterators,
<a name="l01194"></a>01194                          unique_keys&gt; &gt;,
<a name="l01195"></a>01195       <span class="keyword">public</span> Internal::<a class="code" href="../../d0/d2e/classInternal_1_1hash__code__base.html">hash_code_base</a>&lt;Key, Value, ExtractKey, Equal, H1, H2, H,
<a name="l01196"></a>01196                       cache_hash_code&gt;,
<a name="l01197"></a>01197       <span class="keyword">public</span> Internal::<a class="code" href="../../d1/d54/classInternal_1_1map__base.html">map_base</a>&lt;Key, Value, ExtractKey, unique_keys,
<a name="l01198"></a>01198                 hashtable&lt;Key, Value, Allocator, ExtractKey,
<a name="l01199"></a>01199                       Equal, H1, H2, H, RehashPolicy,
<a name="l01200"></a>01200                       cache_hash_code, constant_iterators,
<a name="l01201"></a>01201                       unique_keys&gt; &gt;
<a name="l01202"></a>01202     {
<a name="l01203"></a>01203     <span class="keyword">public</span>:
<a name="l01204"></a>01204       <span class="keyword">typedef</span> Allocator                                      allocator_type;
<a name="l01205"></a>01205       <span class="keyword">typedef</span> Value                                          value_type;
<a name="l01206"></a>01206       <span class="keyword">typedef</span> Key                                            key_type;
<a name="l01207"></a>01207       <span class="keyword">typedef</span> Equal                                          key_equal;
<a name="l01208"></a>01208       <span class="comment">// mapped_type, if present, comes from map_base.</span>
<a name="l01209"></a>01209       <span class="comment">// hasher, if present, comes from hash_code_base.</span>
<a name="l01210"></a>01210       <span class="keyword">typedef</span> <span class="keyword">typename</span> Allocator::difference_type            difference_type;
<a name="l01211"></a>01211       <span class="keyword">typedef</span> <span class="keyword">typename</span> Allocator::size_type                  size_type;
<a name="l01212"></a>01212       <span class="keyword">typedef</span> <span class="keyword">typename</span> Allocator::reference                  reference;
<a name="l01213"></a>01213       <span class="keyword">typedef</span> <span class="keyword">typename</span> Allocator::const_reference            const_reference;
<a name="l01214"></a>01214       
<a name="l01215"></a>01215       <span class="keyword">typedef</span> Internal::node_iterator&lt;value_type, constant_iterators,
<a name="l01216"></a>01216                       cache_hash_code&gt;
<a name="l01217"></a>01217         local_iterator;
<a name="l01218"></a>01218       <span class="keyword">typedef</span> Internal::node_const_iterator&lt;value_type, constant_iterators,
<a name="l01219"></a>01219                         cache_hash_code&gt;
<a name="l01220"></a>01220         const_local_iterator;
<a name="l01221"></a>01221 
<a name="l01222"></a>01222       <span class="keyword">typedef</span> Internal::hashtable_iterator&lt;value_type, constant_iterators,
<a name="l01223"></a>01223                        cache_hash_code&gt;
<a name="l01224"></a>01224         iterator;
<a name="l01225"></a>01225       <span class="keyword">typedef</span> Internal::hashtable_const_iterator&lt;value_type, constant_iterators,
<a name="l01226"></a>01226                          cache_hash_code&gt;
<a name="l01227"></a>01227         const_iterator;
<a name="l01228"></a>01228 
<a name="l01229"></a>01229     <span class="keyword">private</span>:
<a name="l01230"></a>01230       <span class="keyword">typedef</span> Internal::hash_node&lt;Value, cache_hash_code&gt;    node;
<a name="l01231"></a>01231       <span class="keyword">typedef</span> <span class="keyword">typename</span> Allocator::template rebind&lt;node&gt;::other
<a name="l01232"></a>01232         node_allocator_t;
<a name="l01233"></a>01233       <span class="keyword">typedef</span> <span class="keyword">typename</span> Allocator::template rebind&lt;node*&gt;::other
<a name="l01234"></a>01234         bucket_allocator_t;
<a name="l01235"></a>01235 
<a name="l01236"></a>01236     <span class="keyword">private</span>:
<a name="l01237"></a>01237       node_allocator_t m_node_allocator;
<a name="l01238"></a>01238       <span class="comment">// sss -- Some of our allocators have non-trivial state, and</span>
<a name="l01239"></a>01239       <span class="comment">// thus a non-trivial copy ctor.  However, m_allocate_node</span>
<a name="l01240"></a>01240       <span class="comment">// will do a copy conversion of node_allocator_t to allocator_type</span>
<a name="l01241"></a>01241       <span class="comment">// for each node allocated.  Instead, do the conversion once</span>
<a name="l01242"></a>01242       <span class="comment">// and cache it.  Note: in newer gcc versions, extensions to the</span>
<a name="l01243"></a>01243       <span class="comment">// allocator model allow dispensing with the conversions.  So once</span>
<a name="l01244"></a>01244       <span class="comment">// we go to c++0x, this shouldn&apos;t be an issue.</span>
<a name="l01245"></a>01245       allocator_type m_payload_allocator;
<a name="l01246"></a>01246       node** m_buckets;
<a name="l01247"></a>01247       size_type m_bucket_count;
<a name="l01248"></a>01248       size_type m_element_count;
<a name="l01249"></a>01249       RehashPolicy m_rehash_policy;
<a name="l01250"></a>01250       
<a name="l01251"></a>01251       node*
<a name="l01252"></a>01252       m_allocate_node(<span class="keyword">const</span> value_type&amp; v);
<a name="l01253"></a>01253   
<a name="l01254"></a>01254       <span class="keywordtype">void</span>
<a name="l01255"></a>01255       m_deallocate_node(node* n);
<a name="l01256"></a>01256   
<a name="l01257"></a>01257       <span class="keywordtype">void</span>
<a name="l01258"></a>01258       m_deallocate_nodes(node**, size_type);
<a name="l01259"></a>01259 
<a name="l01260"></a>01260       node**
<a name="l01261"></a>01261       m_allocate_buckets(size_type n);
<a name="l01262"></a>01262   
<a name="l01263"></a>01263       <span class="keywordtype">void</span>
<a name="l01264"></a>01264       m_deallocate_buckets(node**, size_type n);
<a name="l01265"></a>01265 
<a name="l01266"></a>01266     <span class="keyword">public</span>:             <span class="comment">// Constructor, destructor, assignment, swap</span>
<a name="l01267"></a>01267       <a class="code" href="../../de/d63/classSG_1_1hashtable.html">hashtable</a>(size_type bucket_hint,
<a name="l01268"></a>01268         <span class="keyword">const</span> H1&amp;, <span class="keyword">const</span> H2&amp;, <span class="keyword">const</span> H&amp;,
<a name="l01269"></a>01269         <span class="keyword">const</span> Equal&amp;, <span class="keyword">const</span> ExtractKey&amp;,
<a name="l01270"></a>01270         <span class="keyword">const</span> allocator_type&amp;);
<a name="l01271"></a>01271   
<a name="l01272"></a>01272       <span class="keyword">template</span>&lt;<span class="keyword">typename</span> InIter&gt;
<a name="l01273"></a>01273         <a class="code" href="../../de/d63/classSG_1_1hashtable.html">hashtable</a>(InIter first, InIter last,
<a name="l01274"></a>01274           size_type bucket_hint,
<a name="l01275"></a>01275           <span class="keyword">const</span> H1&amp;, <span class="keyword">const</span> H2&amp;, <span class="keyword">const</span> H&amp;,
<a name="l01276"></a>01276           <span class="keyword">const</span> Equal&amp;, <span class="keyword">const</span> ExtractKey&amp;,
<a name="l01277"></a>01277           <span class="keyword">const</span> allocator_type&amp;);
<a name="l01278"></a>01278   
<a name="l01279"></a>01279       <a class="code" href="../../de/d63/classSG_1_1hashtable.html">hashtable</a>(<span class="keyword">const</span> <a class="code" href="../../de/d63/classSG_1_1hashtable.html">hashtable</a>&amp;);
<a name="l01280"></a>01280       
<a name="l01281"></a>01281       <a class="code" href="../../de/d63/classSG_1_1hashtable.html">hashtable</a>&amp;
<a name="l01282"></a>01282       operator=(<span class="keyword">const</span> <a class="code" href="../../de/d63/classSG_1_1hashtable.html">hashtable</a>&amp;);
<a name="l01283"></a>01283   
<a name="l01284"></a>01284       ~<a class="code" href="../../de/d63/classSG_1_1hashtable.html">hashtable</a>();
<a name="l01285"></a>01285 
<a name="l01286"></a>01286       <span class="keywordtype">void</span> swap(<a class="code" href="../../de/d63/classSG_1_1hashtable.html">hashtable</a>&amp;);
<a name="l01287"></a>01287 
<a name="l01288"></a>01288     <span class="keyword">public</span>:             <span class="comment">// Basic container operations</span>
<a name="l01289"></a>01289       iterator
<a name="l01290"></a>01290       begin()
<a name="l01291"></a>01291       {
<a name="l01292"></a>01292     iterator i(m_buckets);
<a name="l01293"></a>01293     <span class="keywordflow">if</span> (!i.m_cur_node)
<a name="l01294"></a>01294       i.m_incr_bucket();
<a name="l01295"></a>01295     <span class="keywordflow">return</span> i;
<a name="l01296"></a>01296       }
<a name="l01297"></a>01297 
<a name="l01298"></a>01298       const_iterator
<a name="l01299"></a>01299       begin()<span class="keyword"> const</span>
<a name="l01300"></a>01300 <span class="keyword">      </span>{
<a name="l01301"></a>01301     const_iterator i(m_buckets);
<a name="l01302"></a>01302     <span class="keywordflow">if</span> (!i.m_cur_node)
<a name="l01303"></a>01303       i.m_incr_bucket();
<a name="l01304"></a>01304     <span class="keywordflow">return</span> i;
<a name="l01305"></a>01305       }
<a name="l01306"></a>01306 
<a name="l01307"></a>01307       iterator
<a name="l01308"></a>01308       end()
<a name="l01309"></a>01309       { <span class="keywordflow">return</span> iterator(m_buckets + m_bucket_count); }
<a name="l01310"></a>01310 
<a name="l01311"></a>01311       const_iterator
<a name="l01312"></a>01312       end()<span class="keyword"> const</span>
<a name="l01313"></a>01313 <span class="keyword">      </span>{ <span class="keywordflow">return</span> const_iterator(m_buckets + m_bucket_count); }
<a name="l01314"></a>01314 
<a name="l01315"></a>01315       size_type
<a name="l01316"></a>01316       size()<span class="keyword"> const</span>
<a name="l01317"></a>01317 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_element_count; }
<a name="l01318"></a>01318   
<a name="l01319"></a>01319       <span class="keywordtype">bool</span>
<a name="l01320"></a>01320       empty()<span class="keyword"> const</span>
<a name="l01321"></a>01321 <span class="keyword">      </span>{ <span class="keywordflow">return</span> size() == 0; }
<a name="l01322"></a>01322 
<a name="l01323"></a>01323       allocator_type
<a name="l01324"></a>01324       get_allocator()<span class="keyword"> const</span>
<a name="l01325"></a>01325 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_node_allocator; }
<a name="l01326"></a>01326   
<a name="l01327"></a>01327       size_type
<a name="l01328"></a>01328       max_size()<span class="keyword"> const</span>
<a name="l01329"></a>01329 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_node_allocator.max_size(); }
<a name="l01330"></a>01330 
<a name="l01331"></a>01331     <span class="keyword">public</span>:                             <span class="comment">// Observers</span>
<a name="l01332"></a>01332       key_equal
<a name="l01333"></a>01333       key_eq()<span class="keyword"> const</span>
<a name="l01334"></a>01334 <span class="keyword">      </span>{ <span class="keywordflow">return</span> this-&gt;m_eq; }
<a name="l01335"></a>01335 
<a name="l01336"></a>01336       <span class="comment">// hash_function, if present, comes from hash_code_base.</span>
<a name="l01337"></a>01337 
<a name="l01338"></a>01338     <span class="keyword">public</span>:             <span class="comment">// Bucket operations</span>
<a name="l01339"></a>01339       size_type
<a name="l01340"></a>01340       bucket_count()<span class="keyword"> const</span>
<a name="l01341"></a>01341 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_bucket_count; }
<a name="l01342"></a>01342   
<a name="l01343"></a>01343       size_type
<a name="l01344"></a>01344       max_bucket_count()<span class="keyword"> const</span>
<a name="l01345"></a>01345 <span class="keyword">      </span>{ <span class="keywordflow">return</span> max_size(); }
<a name="l01346"></a>01346   
<a name="l01347"></a>01347       size_type
<a name="l01348"></a>01348       bucket_size(size_type n)<span class="keyword"> const</span>
<a name="l01349"></a>01349 <span class="keyword">      </span>{ <span class="keywordflow">return</span> std::distance(begin(n), end(n)); }
<a name="l01350"></a>01350   
<a name="l01351"></a>01351       size_type
<a name="l01352"></a>01352       bucket(<span class="keyword">const</span> key_type&amp; k)<span class="keyword"> const</span>
<a name="l01353"></a>01353 <span class="keyword">      </span>{ 
<a name="l01354"></a>01354     <span class="keywordflow">return</span> this-&gt;bucket_index(k, this-&gt;m_hash_code(k),
<a name="l01355"></a>01355                   this-&gt;m_bucket_count);
<a name="l01356"></a>01356       }
<a name="l01357"></a>01357 
<a name="l01358"></a>01358       local_iterator
<a name="l01359"></a>01359       begin(size_type n)
<a name="l01360"></a>01360       { <span class="keywordflow">return</span> local_iterator(m_buckets[n]); }
<a name="l01361"></a>01361   
<a name="l01362"></a>01362       local_iterator
<a name="l01363"></a>01363       end(size_type)
<a name="l01364"></a>01364       { <span class="keywordflow">return</span> local_iterator(0); }
<a name="l01365"></a>01365   
<a name="l01366"></a>01366       const_local_iterator
<a name="l01367"></a>01367       begin(size_type n)<span class="keyword"> const</span>
<a name="l01368"></a>01368 <span class="keyword">      </span>{ <span class="keywordflow">return</span> const_local_iterator(m_buckets[n]); }
<a name="l01369"></a>01369   
<a name="l01370"></a>01370       const_local_iterator
<a name="l01371"></a>01371       end(size_type)<span class="keyword"> const</span>
<a name="l01372"></a>01372 <span class="keyword">      </span>{ <span class="keywordflow">return</span> const_local_iterator(0); }
<a name="l01373"></a>01373 
<a name="l01374"></a>01374       <span class="keywordtype">float</span>
<a name="l01375"></a>01375       load_factor()<span class="keyword"> const</span>
<a name="l01376"></a>01376 <span class="keyword">      </span>{ 
<a name="l01377"></a>01377     <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(size()) / static_cast&lt;float&gt;(bucket_count());
<a name="l01378"></a>01378       }
<a name="l01379"></a>01379       <span class="comment">// max_load_factor, if present, comes from rehash_base.</span>
<a name="l01380"></a>01380 
<a name="l01381"></a>01381       <span class="comment">// Generalization of max_load_factor.  Extension, not found in TR1.  Only</span>
<a name="l01382"></a>01382       <span class="comment">// useful if RehashPolicy is something other than the default.</span>
<a name="l01383"></a>01383       <span class="keyword">const</span> RehashPolicy&amp;
<a name="l01384"></a>01384       rehash_policy()<span class="keyword"> const</span>
<a name="l01385"></a>01385 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_rehash_policy; }
<a name="l01386"></a>01386       
<a name="l01387"></a>01387       <span class="keywordtype">void</span> 
<a name="l01388"></a>01388       rehash_policy(<span class="keyword">const</span> RehashPolicy&amp;);
<a name="l01389"></a>01389 
<a name="l01390"></a>01390     <span class="keyword">public</span>:             <span class="comment">// lookup</span>
<a name="l01391"></a>01391       iterator
<a name="l01392"></a>01392       find(<span class="keyword">const</span> key_type&amp;);
<a name="l01393"></a>01393 
<a name="l01394"></a>01394       const_iterator
<a name="l01395"></a>01395       find(<span class="keyword">const</span> key_type&amp; k) <span class="keyword">const</span>;
<a name="l01396"></a>01396 
<a name="l01397"></a>01397       size_type
<a name="l01398"></a>01398       count(<span class="keyword">const</span> key_type&amp; k) <span class="keyword">const</span>;
<a name="l01399"></a>01399 
<a name="l01400"></a>01400       std::pair&lt;iterator, iterator&gt;
<a name="l01401"></a>01401       equal_range(<span class="keyword">const</span> key_type&amp; k);
<a name="l01402"></a>01402 
<a name="l01403"></a>01403       std::pair&lt;const_iterator, const_iterator&gt;
<a name="l01404"></a>01404       equal_range(<span class="keyword">const</span> key_type&amp; k) <span class="keyword">const</span>;
<a name="l01405"></a>01405 
<a name="l01406"></a>01406     <span class="keyword">private</span>:            <span class="comment">// Insert and erase helper functions</span>
<a name="l01407"></a>01407       <span class="comment">// ??? This dispatching is a workaround for the fact that we don&apos;t</span>
<a name="l01408"></a>01408       <span class="comment">// have partial specialization of member templates; it would be</span>
<a name="l01409"></a>01409       <span class="comment">// better to just specialize insert on unique_keys.  There may be a</span>
<a name="l01410"></a>01410       <span class="comment">// cleaner workaround.</span>
<a name="l01411"></a>01411       <span class="keyword">typedef</span> <span class="keyword">typename</span> Internal::IF&lt;unique_keys,
<a name="l01412"></a>01412                     std::pair&lt;iterator, bool&gt;, iterator&gt;::type
<a name="l01413"></a>01413         Insert_Return_Type;
<a name="l01414"></a>01414 
<a name="l01415"></a>01415       <span class="keyword">typedef</span> <span class="keyword">typename</span> Internal::IF&lt;unique_keys,
<a name="l01416"></a>01416                     Internal::extract1st&lt;Insert_Return_Type&gt;,
<a name="l01417"></a>01417                     Internal::identity&lt;Insert_Return_Type&gt;
<a name="l01418"></a>01418                                    &gt;::type
<a name="l01419"></a>01419         Insert_Conv_Type;
<a name="l01420"></a>01420 
<a name="l01421"></a>01421       node*
<a name="l01422"></a>01422       find_node(node* p, <span class="keyword">const</span> key_type&amp; k,
<a name="l01423"></a>01423         <span class="keyword">typename</span> hashtable::hash_code_t c) <span class="keyword">const</span>;
<a name="l01424"></a>01424 
<a name="l01425"></a>01425       std::pair&lt;iterator, bool&gt;
<a name="l01426"></a>01426       insert(<span class="keyword">const</span> value_type&amp;, CxxUtils_Internal<span class="comment">/*std::tr1*/</span>::true_type); <span class="comment">// sss</span>
<a name="l01427"></a>01427   
<a name="l01428"></a>01428       iterator
<a name="l01429"></a>01429       insert(<span class="keyword">const</span> value_type&amp;, CxxUtils_Internal<span class="comment">/*std::tr1*/</span>::false_type); <span class="comment">// sss</span>
<a name="l01430"></a>01430 
<a name="l01431"></a>01431       <span class="keyword">friend</span> <span class="keyword">struct </span><a class="code" href="../../d5/d44/structCxxUtils__Internal_1_1hashtable__iterator__base.html">CxxUtils_Internal::hashtable_iterator_base</a>&lt;Value, cache_hash_code&gt;; <span class="comment">// sss</span>
<a name="l01432"></a>01432       <span class="keywordtype">void</span>
<a name="l01433"></a>01433       erase_node(node*, node**);
<a name="l01434"></a>01434 
<a name="l01435"></a>01435     <span class="keyword">public</span>:             <span class="comment">// Insert and erase</span>
<a name="l01436"></a>01436       Insert_Return_Type
<a name="l01437"></a>01437       insert(<span class="keyword">const</span> value_type&amp; v) 
<a name="l01438"></a>01438       { 
<a name="l01439"></a>01439     <span class="keywordflow">return</span> this-&gt;insert(v, CxxUtils_Internal<span class="comment">/*std::tr1*/</span>::integral_constant&lt;<span class="keywordtype">bool</span>,<span class="comment">//sss</span>
<a name="l01440"></a>01440                 unique_keys&gt;());
<a name="l01441"></a>01441       }
<a name="l01442"></a>01442 
<a name="l01443"></a>01443       iterator
<a name="l01444"></a>01444       insert(iterator, <span class="keyword">const</span> value_type&amp; v)
<a name="l01445"></a>01445       { <span class="keywordflow">return</span> iterator(Insert_Conv_Type()(this-&gt;insert(v))); }
<a name="l01446"></a>01446       
<a name="l01447"></a>01447       const_iterator
<a name="l01448"></a>01448       insert(const_iterator, <span class="keyword">const</span> value_type&amp; v)
<a name="l01449"></a>01449       { <span class="keywordflow">return</span> const_iterator(Insert_Conv_Type()(this-&gt;insert(v))); }
<a name="l01450"></a>01450 
<a name="l01451"></a>01451       <span class="keyword">template</span>&lt;<span class="keyword">typename</span> InIter&gt;
<a name="l01452"></a>01452         <span class="keywordtype">void</span>
<a name="l01453"></a>01453         insert(InIter first, InIter last);
<a name="l01454"></a>01454 
<a name="l01455"></a>01455       iterator
<a name="l01456"></a>01456       erase(iterator);
<a name="l01457"></a>01457 
<a name="l01458"></a>01458       const_iterator
<a name="l01459"></a>01459       erase(const_iterator);
<a name="l01460"></a>01460 
<a name="l01461"></a>01461       size_type
<a name="l01462"></a>01462       erase(<span class="keyword">const</span> key_type&amp;);
<a name="l01463"></a>01463 
<a name="l01464"></a>01464       iterator
<a name="l01465"></a>01465       erase(iterator, iterator);
<a name="l01466"></a>01466 
<a name="l01467"></a>01467       const_iterator
<a name="l01468"></a>01468       erase(const_iterator, const_iterator);
<a name="l01469"></a>01469 
<a name="l01470"></a>01470       <span class="keywordtype">void</span>
<a name="l01471"></a>01471       clear();
<a name="l01472"></a>01472 
<a name="l01473"></a>01473     <span class="keyword">public</span>:
<a name="l01474"></a>01474       <span class="comment">// Set number of buckets to be appropriate for container of n element.</span>
<a name="l01475"></a>01475       <span class="keywordtype">void</span> rehash(size_type n);
<a name="l01476"></a>01476       
<a name="l01477"></a>01477     <span class="keyword">private</span>:
<a name="l01478"></a>01478       <span class="comment">// Unconditionally change size of bucket array to n.</span>
<a name="l01479"></a>01479       <span class="keywordtype">void</span> m_rehash(size_type n);
<a name="l01480"></a>01480     };
<a name="l01481"></a>01481 
<a name="l01482"></a>01482   <span class="comment">//----------------------------------------------------------------------</span>
<a name="l01483"></a>01483   <span class="comment">// Definitions of class template hashtable&apos;s out-of-line member functions.</span>
<a name="l01484"></a>01484   
<a name="l01485"></a>01485   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V, 
<a name="l01486"></a>01486        <span class="keyword">typename</span> A, <span class="keyword">typename</span> Ex, <span class="keyword">typename</span> Eq,
<a name="l01487"></a>01487        <span class="keyword">typename</span> H1, <span class="keyword">typename</span> H2, <span class="keyword">typename</span> H, <span class="keyword">typename</span> RP,
<a name="l01488"></a>01488        <span class="keywordtype">bool</span> c, <span class="keywordtype">bool</span> ci, <span class="keywordtype">bool</span> u&gt;
<a name="l01489"></a>01489     <span class="keyword">typename</span> <a class="code" href="../../de/d63/classSG_1_1hashtable.html">hashtable&lt;K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u&gt;::node</a>*
<a name="l01490"></a>01490     <a class="code" href="../../de/d63/classSG_1_1hashtable.html">hashtable&lt;K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u&gt;::</a>
<a name="l01491"></a>01491 <a class="code" href="../../de/d63/classSG_1_1hashtable.html">    m_allocate_node</a>(<span class="keyword">const</span> value_type&amp; v)
<a name="l01492"></a>01492     {
<a name="l01493"></a>01493       node* n = m_node_allocator.allocate(1);
<a name="l01494"></a>01494       <span class="keywordflow">try</span>
<a name="l01495"></a>01495       {
<a name="l01496"></a>01496           m_payload_allocator.construct(&amp;n-&gt;m_v, v);
<a name="l01497"></a>01497       n-&gt;m_next = 0;
<a name="l01498"></a>01498       <span class="keywordflow">return</span> n;
<a name="l01499"></a>01499     }
<a name="l01500"></a>01500       <span class="keywordflow">catch</span>(...)
<a name="l01501"></a>01501     {
<a name="l01502"></a>01502       m_node_allocator.deallocate(n, 1);
<a name="l01503"></a>01503       <span class="keywordflow">throw</span>;
<a name="l01504"></a>01504     }
<a name="l01505"></a>01505     }
<a name="l01506"></a>01506 
<a name="l01507"></a>01507   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V, 
<a name="l01508"></a>01508        <span class="keyword">typename</span> A, <span class="keyword">typename</span> Ex, <span class="keyword">typename</span> Eq,
<a name="l01509"></a>01509        <span class="keyword">typename</span> H1, <span class="keyword">typename</span> H2, <span class="keyword">typename</span> H, <span class="keyword">typename</span> RP,
<a name="l01510"></a>01510        <span class="keywordtype">bool</span> c, <span class="keywordtype">bool</span> ci, <span class="keywordtype">bool</span> u&gt;
<a name="l01511"></a>01511     <span class="keywordtype">void</span>
<a name="l01512"></a>01512     hashtable&lt;K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u&gt;::
<a name="l01513"></a>01513     m_deallocate_node(node* n)
<a name="l01514"></a>01514     {
<a name="l01515"></a>01515       m_payload_allocator.destroy(&amp;n-&gt;m_v);
<a name="l01516"></a>01516       m_node_allocator.deallocate(n, 1);
<a name="l01517"></a>01517     }
<a name="l01518"></a>01518 
<a name="l01519"></a>01519   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V, 
<a name="l01520"></a>01520        <span class="keyword">typename</span> A, <span class="keyword">typename</span> Ex, <span class="keyword">typename</span> Eq,
<a name="l01521"></a>01521        <span class="keyword">typename</span> H1, <span class="keyword">typename</span> H2, <span class="keyword">typename</span> H, <span class="keyword">typename</span> RP,
<a name="l01522"></a>01522        <span class="keywordtype">bool</span> c, <span class="keywordtype">bool</span> ci, <span class="keywordtype">bool</span> u&gt;
<a name="l01523"></a>01523     <span class="keywordtype">void</span>
<a name="l01524"></a>01524     hashtable&lt;K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u&gt;::
<a name="l01525"></a>01525     m_deallocate_nodes(node** array, size_type n)
<a name="l01526"></a>01526     {
<a name="l01527"></a>01527       <span class="keywordflow">for</span> (size_type i = 0; i &lt; n; ++i)
<a name="l01528"></a>01528     {
<a name="l01529"></a>01529       node* p = array[i];
<a name="l01530"></a>01530       <span class="keywordflow">while</span> (p)
<a name="l01531"></a>01531         {
<a name="l01532"></a>01532           node* tmp = p;
<a name="l01533"></a>01533           p = p-&gt;m_next;
<a name="l01534"></a>01534           m_deallocate_node (tmp);
<a name="l01535"></a>01535         }
<a name="l01536"></a>01536       array[i] = 0;
<a name="l01537"></a>01537     }
<a name="l01538"></a>01538     }
<a name="l01539"></a>01539 
<a name="l01540"></a>01540   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V, 
<a name="l01541"></a>01541        <span class="keyword">typename</span> A, <span class="keyword">typename</span> Ex, <span class="keyword">typename</span> Eq,
<a name="l01542"></a>01542        <span class="keyword">typename</span> H1, <span class="keyword">typename</span> H2, <span class="keyword">typename</span> H, <span class="keyword">typename</span> RP,
<a name="l01543"></a>01543        <span class="keywordtype">bool</span> c, <span class="keywordtype">bool</span> ci, <span class="keywordtype">bool</span> u&gt;
<a name="l01544"></a>01544     <span class="keyword">typename</span> hashtable&lt;K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u&gt;::node**
<a name="l01545"></a>01545     hashtable&lt;K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u&gt;::
<a name="l01546"></a>01546     m_allocate_buckets(size_type n)
<a name="l01547"></a>01547     {
<a name="l01548"></a>01548       bucket_allocator_t alloc(m_node_allocator);
<a name="l01549"></a>01549 
<a name="l01550"></a>01550       <span class="comment">// We allocate one extra bucket to hold a sentinel, an arbitrary</span>
<a name="l01551"></a>01551       <span class="comment">// non-null pointer.  Iterator increment relies on this.</span>
<a name="l01552"></a>01552       node** p = alloc.allocate(n+1);
<a name="l01553"></a>01553       std::fill(p, p+n, (node*) 0);
<a name="l01554"></a>01554       p[n] = <span class="keyword">reinterpret_cast&lt;</span>node*<span class="keyword">&gt;</span>(0x1000);
<a name="l01555"></a>01555       <span class="keywordflow">return</span> p;
<a name="l01556"></a>01556     }
<a name="l01557"></a>01557 
<a name="l01558"></a>01558   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V, 
<a name="l01559"></a>01559        <span class="keyword">typename</span> A, <span class="keyword">typename</span> Ex, <span class="keyword">typename</span> Eq,
<a name="l01560"></a>01560        <span class="keyword">typename</span> H1, <span class="keyword">typename</span> H2, <span class="keyword">typename</span> H, <span class="keyword">typename</span> RP,
<a name="l01561"></a>01561        <span class="keywordtype">bool</span> c, <span class="keywordtype">bool</span> ci, <span class="keywordtype">bool</span> u&gt;
<a name="l01562"></a>01562     <span class="keywordtype">void</span>
<a name="l01563"></a>01563     hashtable&lt;K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u&gt;::
<a name="l01564"></a>01564     m_deallocate_buckets(node** p, size_type n)
<a name="l01565"></a>01565     {
<a name="l01566"></a>01566       bucket_allocator_t alloc(m_node_allocator);
<a name="l01567"></a>01567       alloc.deallocate(p, n+1);
<a name="l01568"></a>01568     }
<a name="l01569"></a>01569 
<a name="l01570"></a>01570   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V, 
<a name="l01571"></a>01571        <span class="keyword">typename</span> A, <span class="keyword">typename</span> Ex, <span class="keyword">typename</span> Eq,
<a name="l01572"></a>01572        <span class="keyword">typename</span> H1, <span class="keyword">typename</span> H2, <span class="keyword">typename</span> H, <span class="keyword">typename</span> RP,
<a name="l01573"></a>01573        <span class="keywordtype">bool</span> c, <span class="keywordtype">bool</span> ci, <span class="keywordtype">bool</span> u&gt;
<a name="l01574"></a>01574     hashtable&lt;K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u&gt;::
<a name="l01575"></a>01575     hashtable(size_type bucket_hint,
<a name="l01576"></a>01576           <span class="keyword">const</span> H1&amp; h1, <span class="keyword">const</span> H2&amp; h2, <span class="keyword">const</span> H&amp; h,
<a name="l01577"></a>01577           <span class="keyword">const</span> Eq&amp; eq, <span class="keyword">const</span> Ex&amp; exk,
<a name="l01578"></a>01578           <span class="keyword">const</span> allocator_type&amp; a)
<a name="l01579"></a>01579     : Internal::<a class="code" href="../../db/d2b/classInternal_1_1rehash__base.html">rehash_base</a>&lt;RP,hashtable&gt;(),
<a name="l01580"></a>01580       Internal::<a class="code" href="../../d0/d2e/classInternal_1_1hash__code__base.html">hash_code_base</a>&lt;K, V, Ex, Eq, H1, H2, H, c&gt;(exk, eq, h1, h2, h),
<a name="l01581"></a>01581       Internal::<a class="code" href="../../d1/d54/classInternal_1_1map__base.html">map_base</a>&lt;K, V, Ex, u, hashtable&gt;(),
<a name="l01582"></a>01582       m_node_allocator(a),
<a name="l01583"></a>01583       m_payload_allocator(a),
<a name="l01584"></a>01584       m_bucket_count(0),
<a name="l01585"></a>01585       m_element_count(0),
<a name="l01586"></a>01586       m_rehash_policy()
<a name="l01587"></a>01587     {
<a name="l01588"></a>01588       m_bucket_count = m_rehash_policy.next_bkt(bucket_hint);
<a name="l01589"></a>01589       m_buckets = m_allocate_buckets(m_bucket_count);
<a name="l01590"></a>01590     }
<a name="l01591"></a>01591 
<a name="l01592"></a>01592   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V, 
<a name="l01593"></a>01593        <span class="keyword">typename</span> A, <span class="keyword">typename</span> Ex, <span class="keyword">typename</span> Eq,
<a name="l01594"></a>01594        <span class="keyword">typename</span> H1, <span class="keyword">typename</span> H2, <span class="keyword">typename</span> H, <span class="keyword">typename</span> RP,
<a name="l01595"></a>01595        <span class="keywordtype">bool</span> c, <span class="keywordtype">bool</span> ci, <span class="keywordtype">bool</span> u&gt;
<a name="l01596"></a>01596     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> InIter&gt;
<a name="l01597"></a>01597       hashtable&lt;K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u&gt;::
<a name="l01598"></a>01598       hashtable(InIter f, InIter l,
<a name="l01599"></a>01599         size_type bucket_hint,
<a name="l01600"></a>01600         <span class="keyword">const</span> H1&amp; h1, <span class="keyword">const</span> H2&amp; h2, <span class="keyword">const</span> H&amp; h,
<a name="l01601"></a>01601         <span class="keyword">const</span> Eq&amp; eq, <span class="keyword">const</span> Ex&amp; exk,
<a name="l01602"></a>01602         <span class="keyword">const</span> allocator_type&amp; a)
<a name="l01603"></a>01603       : Internal::<a class="code" href="../../db/d2b/classInternal_1_1rehash__base.html">rehash_base</a>&lt;RP,hashtable&gt;(),
<a name="l01604"></a>01604     Internal::<a class="code" href="../../d0/d2e/classInternal_1_1hash__code__base.html">hash_code_base</a>&lt;K, V, Ex, Eq, H1, H2, H, c&gt; (exk, eq,
<a name="l01605"></a>01605                                   h1, h2, h),
<a name="l01606"></a>01606     Internal::<a class="code" href="../../d1/d54/classInternal_1_1map__base.html">map_base</a>&lt;K,V,Ex,u,hashtable&gt;(),
<a name="l01607"></a>01607     m_node_allocator(a),
<a name="l01608"></a>01608     m_bucket_count (0),
<a name="l01609"></a>01609     m_element_count(0),
<a name="l01610"></a>01610     m_rehash_policy()
<a name="l01611"></a>01611       {
<a name="l01612"></a>01612     m_bucket_count = std::max(m_rehash_policy.next_bkt(bucket_hint),
<a name="l01613"></a>01613                   m_rehash_policy.
<a name="l01614"></a>01614                   bkt_for_elements(Internal::
<a name="l01615"></a>01615                            distance_fw(f, l)));
<a name="l01616"></a>01616     m_buckets = m_allocate_buckets(m_bucket_count);
<a name="l01617"></a>01617     <span class="keywordflow">try</span>
<a name="l01618"></a>01618       {
<a name="l01619"></a>01619         <span class="keywordflow">for</span> (; f != l; ++f)
<a name="l01620"></a>01620           this-&gt;insert(*f);
<a name="l01621"></a>01621       }
<a name="l01622"></a>01622     <span class="keywordflow">catch</span>(...)
<a name="l01623"></a>01623       {
<a name="l01624"></a>01624         clear();
<a name="l01625"></a>01625         m_deallocate_buckets(m_buckets, m_bucket_count);
<a name="l01626"></a>01626         <span class="keywordflow">throw</span>;
<a name="l01627"></a>01627       }
<a name="l01628"></a>01628       }
<a name="l01629"></a>01629   
<a name="l01630"></a>01630   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V, 
<a name="l01631"></a>01631        <span class="keyword">typename</span> A, <span class="keyword">typename</span> Ex, <span class="keyword">typename</span> Eq,
<a name="l01632"></a>01632        <span class="keyword">typename</span> H1, <span class="keyword">typename</span> H2, <span class="keyword">typename</span> H, <span class="keyword">typename</span> RP,
<a name="l01633"></a>01633        <span class="keywordtype">bool</span> c, <span class="keywordtype">bool</span> ci, <span class="keywordtype">bool</span> u&gt;
<a name="l01634"></a>01634     hashtable&lt;K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u&gt;::
<a name="l01635"></a>01635     hashtable(<span class="keyword">const</span> hashtable&amp; ht)
<a name="l01636"></a>01636     : Internal::<a class="code" href="../../db/d2b/classInternal_1_1rehash__base.html">rehash_base</a>&lt;RP, hashtable&gt;(ht),
<a name="l01637"></a>01637       Internal::<a class="code" href="../../d0/d2e/classInternal_1_1hash__code__base.html">hash_code_base</a>&lt;K, V, Ex, Eq, H1, H2, H, c&gt;(ht),
<a name="l01638"></a>01638       Internal::<a class="code" href="../../d1/d54/classInternal_1_1map__base.html">map_base</a>&lt;K, V, Ex, u, hashtable&gt;(ht),
<a name="l01639"></a>01639       m_node_allocator(ht.get_allocator()),
<a name="l01640"></a>01640       m_payload_allocator(ht.get_allocator()),
<a name="l01641"></a>01641       m_bucket_count(ht.m_bucket_count),
<a name="l01642"></a>01642       m_element_count(ht.m_element_count),
<a name="l01643"></a>01643       m_rehash_policy(ht.m_rehash_policy)
<a name="l01644"></a>01644     {
<a name="l01645"></a>01645       m_buckets = m_allocate_buckets (m_bucket_count);
<a name="l01646"></a>01646       <span class="keywordflow">try</span>
<a name="l01647"></a>01647     {
<a name="l01648"></a>01648       <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; ht.m_bucket_count; ++i)
<a name="l01649"></a>01649         {
<a name="l01650"></a>01650           node* n = ht.m_buckets[i];
<a name="l01651"></a>01651           node** tail = m_buckets + i;
<a name="l01652"></a>01652           <span class="keywordflow">while</span> (n)
<a name="l01653"></a>01653         {
<a name="l01654"></a>01654           *tail = m_allocate_node(n-&gt;m_v);
<a name="l01655"></a>01655           this-&gt;copy_code(*tail, n);
<a name="l01656"></a>01656           tail = &amp;((*tail)-&gt;m_next);
<a name="l01657"></a>01657           n = n-&gt;m_next;
<a name="l01658"></a>01658         }
<a name="l01659"></a>01659         }
<a name="l01660"></a>01660     }
<a name="l01661"></a>01661       <span class="keywordflow">catch</span> (...)
<a name="l01662"></a>01662     {
<a name="l01663"></a>01663       clear();
<a name="l01664"></a>01664       m_deallocate_buckets (m_buckets, m_bucket_count);
<a name="l01665"></a>01665       <span class="keywordflow">throw</span>;
<a name="l01666"></a>01666     }
<a name="l01667"></a>01667     }
<a name="l01668"></a>01668 
<a name="l01669"></a>01669   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V, 
<a name="l01670"></a>01670        <span class="keyword">typename</span> A, <span class="keyword">typename</span> Ex, <span class="keyword">typename</span> Eq,
<a name="l01671"></a>01671        <span class="keyword">typename</span> H1, <span class="keyword">typename</span> H2, <span class="keyword">typename</span> H, <span class="keyword">typename</span> RP,
<a name="l01672"></a>01672        <span class="keywordtype">bool</span> c, <span class="keywordtype">bool</span> ci, <span class="keywordtype">bool</span> u&gt;
<a name="l01673"></a>01673     hashtable&lt;K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u&gt;&amp;
<a name="l01674"></a>01674     hashtable&lt;K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u&gt;::
<a name="l01675"></a>01675     operator=(<span class="keyword">const</span> hashtable&amp; ht)
<a name="l01676"></a>01676     {
<a name="l01677"></a>01677       hashtable tmp(ht);
<a name="l01678"></a>01678       this-&gt;<a class="code" href="../../db/ded/ConstDataList_8h.html#a67766f262856f1e197e15fec33b60bac" title="See DataList&amp;lt;T, BASE&amp;gt;::swap().">swap</a>(tmp);
<a name="l01679"></a>01679       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01680"></a>01680     }
<a name="l01681"></a>01681 
<a name="l01682"></a>01682   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V, 
<a name="l01683"></a>01683        <span class="keyword">typename</span> A, <span class="keyword">typename</span> Ex, <span class="keyword">typename</span> Eq,
<a name="l01684"></a>01684        <span class="keyword">typename</span> H1, <span class="keyword">typename</span> H2, <span class="keyword">typename</span> H, <span class="keyword">typename</span> RP,
<a name="l01685"></a>01685        <span class="keywordtype">bool</span> c, <span class="keywordtype">bool</span> ci, <span class="keywordtype">bool</span> u&gt;
<a name="l01686"></a>01686     hashtable&lt;K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u&gt;::
<a name="l01687"></a>01687     ~hashtable()
<a name="l01688"></a>01688     {
<a name="l01689"></a>01689       clear();
<a name="l01690"></a>01690       m_deallocate_buckets(m_buckets, m_bucket_count);
<a name="l01691"></a>01691     }
<a name="l01692"></a>01692 
<a name="l01693"></a>01693   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V, 
<a name="l01694"></a>01694        <span class="keyword">typename</span> A, <span class="keyword">typename</span> Ex, <span class="keyword">typename</span> Eq,
<a name="l01695"></a>01695        <span class="keyword">typename</span> H1, <span class="keyword">typename</span> H2, <span class="keyword">typename</span> H, <span class="keyword">typename</span> RP,
<a name="l01696"></a>01696        <span class="keywordtype">bool</span> c, <span class="keywordtype">bool</span> ci, <span class="keywordtype">bool</span> u&gt;
<a name="l01697"></a>01697     <span class="keywordtype">void</span>
<a name="l01698"></a>01698     <a class="code" href="../../db/ded/ConstDataList_8h.html#a67766f262856f1e197e15fec33b60bac" title="See DataList&amp;lt;T, BASE&amp;gt;::swap().">hashtable&lt;K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u&gt;::</a>
<a name="l01699"></a>01699 <a class="code" href="../../db/ded/ConstDataList_8h.html#a67766f262856f1e197e15fec33b60bac" title="See DataList&amp;lt;T, BASE&amp;gt;::swap().">    swap</a>(hashtable&amp; x)
<a name="l01700"></a>01700     {
<a name="l01701"></a>01701       <span class="comment">// The only base class with member variables is hash_code_base.  We</span>
<a name="l01702"></a>01702       <span class="comment">// define hash_code_base::m_swap because different specializations</span>
<a name="l01703"></a>01703       <span class="comment">// have different members.</span>
<a name="l01704"></a>01704       Internal::hash_code_base&lt;K, V, Ex, Eq, H1, H2, H, c&gt;::m_swap(x);
<a name="l01705"></a>01705 
<a name="l01706"></a>01706       <span class="comment">// open LWG issue 431</span>
<a name="l01707"></a>01707       <span class="comment">// std::swap(m_node_allocator, x.m_node_allocator);</span>
<a name="l01708"></a>01708       <a class="code" href="../../db/ded/ConstDataList_8h.html#a67766f262856f1e197e15fec33b60bac" title="See DataList&amp;lt;T, BASE&amp;gt;::swap().">std::swap</a>(m_rehash_policy, x.m_rehash_policy);
<a name="l01709"></a>01709       <a class="code" href="../../db/ded/ConstDataList_8h.html#a67766f262856f1e197e15fec33b60bac" title="See DataList&amp;lt;T, BASE&amp;gt;::swap().">std::swap</a>(m_buckets, x.m_buckets);
<a name="l01710"></a>01710       <a class="code" href="../../db/ded/ConstDataList_8h.html#a67766f262856f1e197e15fec33b60bac" title="See DataList&amp;lt;T, BASE&amp;gt;::swap().">std::swap</a>(m_bucket_count, x.m_bucket_count);
<a name="l01711"></a>01711       <a class="code" href="../../db/ded/ConstDataList_8h.html#a67766f262856f1e197e15fec33b60bac" title="See DataList&amp;lt;T, BASE&amp;gt;::swap().">std::swap</a>(m_element_count, x.m_element_count);
<a name="l01712"></a>01712     }
<a name="l01713"></a>01713 
<a name="l01714"></a>01714   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V, 
<a name="l01715"></a>01715        <span class="keyword">typename</span> A, <span class="keyword">typename</span> Ex, <span class="keyword">typename</span> Eq,
<a name="l01716"></a>01716        <span class="keyword">typename</span> H1, <span class="keyword">typename</span> H2, <span class="keyword">typename</span> H, <span class="keyword">typename</span> RP,
<a name="l01717"></a>01717        <span class="keywordtype">bool</span> c, <span class="keywordtype">bool</span> ci, <span class="keywordtype">bool</span> u&gt;
<a name="l01718"></a>01718     <span class="keywordtype">void</span>
<a name="l01719"></a>01719     hashtable&lt;K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u&gt;::
<a name="l01720"></a>01720     rehash_policy(<span class="keyword">const</span> RP&amp; pol)
<a name="l01721"></a>01721     {
<a name="l01722"></a>01722       m_rehash_policy = pol;
<a name="l01723"></a>01723       size_type n_bkt = pol.bkt_for_elements(m_element_count);
<a name="l01724"></a>01724       <span class="keywordflow">if</span> (n_bkt &gt; m_bucket_count)
<a name="l01725"></a>01725     m_rehash (n_bkt);
<a name="l01726"></a>01726     }
<a name="l01727"></a>01727 
<a name="l01728"></a>01728   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V, 
<a name="l01729"></a>01729        <span class="keyword">typename</span> A, <span class="keyword">typename</span> Ex, <span class="keyword">typename</span> Eq,
<a name="l01730"></a>01730        <span class="keyword">typename</span> H1, <span class="keyword">typename</span> H2, <span class="keyword">typename</span> H, <span class="keyword">typename</span> RP,
<a name="l01731"></a>01731        <span class="keywordtype">bool</span> c, <span class="keywordtype">bool</span> ci, <span class="keywordtype">bool</span> u&gt;
<a name="l01732"></a>01732     <span class="keyword">typename</span> hashtable&lt;K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u&gt;::iterator
<a name="l01733"></a>01733     hashtable&lt;K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u&gt;::
<a name="l01734"></a>01734     find(<span class="keyword">const</span> key_type&amp; k)
<a name="l01735"></a>01735     {
<a name="l01736"></a>01736       <span class="keyword">typename</span> hashtable::hash_code_t code = this-&gt;m_hash_code(k);
<a name="l01737"></a>01737       std::size_t n = this-&gt;bucket_index(k, code, this-&gt;bucket_count());
<a name="l01738"></a>01738       node* p = find_node(m_buckets[n], k, code);
<a name="l01739"></a>01739       <span class="keywordflow">return</span> p ? iterator(p, m_buckets + n) : this-&gt;end();
<a name="l01740"></a>01740     }
<a name="l01741"></a>01741   
<a name="l01742"></a>01742   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V, 
<a name="l01743"></a>01743        <span class="keyword">typename</span> A, <span class="keyword">typename</span> Ex, <span class="keyword">typename</span> Eq,
<a name="l01744"></a>01744        <span class="keyword">typename</span> H1, <span class="keyword">typename</span> H2, <span class="keyword">typename</span> H, <span class="keyword">typename</span> RP,
<a name="l01745"></a>01745        <span class="keywordtype">bool</span> c, <span class="keywordtype">bool</span> ci, <span class="keywordtype">bool</span> u&gt;
<a name="l01746"></a>01746     <span class="keyword">typename</span> hashtable&lt;K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u&gt;::const_iterator
<a name="l01747"></a>01747     hashtable&lt;K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u&gt;::
<a name="l01748"></a>01748     find(<span class="keyword">const</span> key_type&amp; k)<span class="keyword"> const</span>
<a name="l01749"></a>01749 <span class="keyword">    </span>{
<a name="l01750"></a>01750       <span class="keyword">typename</span> hashtable::hash_code_t code = this-&gt;m_hash_code(k);
<a name="l01751"></a>01751       std::size_t n = this-&gt;bucket_index(k, code, this-&gt;bucket_count());
<a name="l01752"></a>01752       node* p = find_node(m_buckets[n], k, code);
<a name="l01753"></a>01753       <span class="keywordflow">return</span> p ? const_iterator(p, m_buckets + n) : this-&gt;end();
<a name="l01754"></a>01754     }
<a name="l01755"></a>01755   
<a name="l01756"></a>01756   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V, 
<a name="l01757"></a>01757        <span class="keyword">typename</span> A, <span class="keyword">typename</span> Ex, <span class="keyword">typename</span> Eq,
<a name="l01758"></a>01758        <span class="keyword">typename</span> H1, <span class="keyword">typename</span> H2, <span class="keyword">typename</span> H, <span class="keyword">typename</span> RP,
<a name="l01759"></a>01759        <span class="keywordtype">bool</span> c, <span class="keywordtype">bool</span> ci, <span class="keywordtype">bool</span> u&gt;
<a name="l01760"></a>01760     <span class="keyword">typename</span> hashtable&lt;K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u&gt;::size_type
<a name="l01761"></a>01761     hashtable&lt;K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u&gt;::
<a name="l01762"></a>01762     count(<span class="keyword">const</span> key_type&amp; k)<span class="keyword"> const</span>
<a name="l01763"></a>01763 <span class="keyword">    </span>{
<a name="l01764"></a>01764       <span class="keyword">typename</span> hashtable::hash_code_t code = this-&gt;m_hash_code(k);
<a name="l01765"></a>01765       std::size_t n = this-&gt;bucket_index(k, code, this-&gt;bucket_count());
<a name="l01766"></a>01766       <span class="keywordtype">size_t</span> result = 0;
<a name="l01767"></a>01767       <span class="keywordflow">for</span> (node* p = m_buckets[n]; p ; p = p-&gt;m_next)
<a name="l01768"></a>01768     <span class="keywordflow">if</span> (this-&gt;<a class="code" href="../../da/d8a/namespaceAmg.html#ab845c2de1ce866d4b91a11fc7c1a9ca8">compare</a>(k, code, p))
<a name="l01769"></a>01769       ++result;
<a name="l01770"></a>01770       <span class="keywordflow">return</span> result;
<a name="l01771"></a>01771     }
<a name="l01772"></a>01772 
<a name="l01773"></a>01773   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V, 
<a name="l01774"></a>01774        <span class="keyword">typename</span> A, <span class="keyword">typename</span> Ex, <span class="keyword">typename</span> Eq,
<a name="l01775"></a>01775        <span class="keyword">typename</span> H1, <span class="keyword">typename</span> H2, <span class="keyword">typename</span> H, <span class="keyword">typename</span> RP,
<a name="l01776"></a>01776        <span class="keywordtype">bool</span> c, <span class="keywordtype">bool</span> ci, <span class="keywordtype">bool</span> u&gt;
<a name="l01777"></a>01777     std::pair&lt;<span class="keyword">typename</span> hashtable&lt;K, V, A, Ex, Eq, H1,
<a name="l01778"></a>01778                  H2, H, RP, c, ci, u&gt;::iterator,
<a name="l01779"></a>01779           <span class="keyword">typename</span> hashtable&lt;K, V, A, Ex, Eq, H1,
<a name="l01780"></a>01780                  H2, H, RP, c, ci, u&gt;::iterator&gt;
<a name="l01781"></a>01781     hashtable&lt;K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u&gt;::
<a name="l01782"></a>01782     equal_range(<span class="keyword">const</span> key_type&amp; k)
<a name="l01783"></a>01783     {
<a name="l01784"></a>01784       <span class="keyword">typename</span> hashtable::hash_code_t code = this-&gt;m_hash_code(k);
<a name="l01785"></a>01785       std::size_t n = this-&gt;bucket_index(k, code, this-&gt;bucket_count());
<a name="l01786"></a>01786       node** head = m_buckets + n;
<a name="l01787"></a>01787       node* p = find_node (*head, k, code);
<a name="l01788"></a>01788       
<a name="l01789"></a>01789       <span class="keywordflow">if</span> (p)
<a name="l01790"></a>01790     {
<a name="l01791"></a>01791       node* p1 = p-&gt;m_next;
<a name="l01792"></a>01792       <span class="keywordflow">for</span> (; p1 ; p1 = p1-&gt;m_next)
<a name="l01793"></a>01793         <span class="keywordflow">if</span> (!this-&gt;compare (k, code, p1))
<a name="l01794"></a>01794           <span class="keywordflow">break</span>;
<a name="l01795"></a>01795 
<a name="l01796"></a>01796       iterator first(p, head);
<a name="l01797"></a>01797       iterator last(p1, head);
<a name="l01798"></a>01798       <span class="keywordflow">if</span> (!p1)
<a name="l01799"></a>01799         last.m_incr_bucket();
<a name="l01800"></a>01800       <span class="keywordflow">return</span> std::make_pair(first, last);
<a name="l01801"></a>01801     }
<a name="l01802"></a>01802       <span class="keywordflow">else</span>
<a name="l01803"></a>01803     <span class="keywordflow">return</span> std::make_pair(this-&gt;end(), this-&gt;end());
<a name="l01804"></a>01804     }
<a name="l01805"></a>01805 
<a name="l01806"></a>01806   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V, 
<a name="l01807"></a>01807        <span class="keyword">typename</span> A, <span class="keyword">typename</span> Ex, <span class="keyword">typename</span> Eq,
<a name="l01808"></a>01808        <span class="keyword">typename</span> H1, <span class="keyword">typename</span> H2, <span class="keyword">typename</span> H, <span class="keyword">typename</span> RP,
<a name="l01809"></a>01809        <span class="keywordtype">bool</span> c, <span class="keywordtype">bool</span> ci, <span class="keywordtype">bool</span> u&gt;
<a name="l01810"></a>01810     std::pair&lt;<span class="keyword">typename</span> hashtable&lt;K, V, A, Ex, Eq, H1,
<a name="l01811"></a>01811                  H2, H, RP, c, ci, u&gt;::const_iterator,
<a name="l01812"></a>01812           <span class="keyword">typename</span> hashtable&lt;K, V, A, Ex, Eq, H1,
<a name="l01813"></a>01813                  H2, H, RP, c, ci, u&gt;::const_iterator&gt;
<a name="l01814"></a>01814     hashtable&lt;K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u&gt;::
<a name="l01815"></a>01815     equal_range(<span class="keyword">const</span> key_type&amp; k)<span class="keyword"> const</span>
<a name="l01816"></a>01816 <span class="keyword">    </span>{
<a name="l01817"></a>01817       <span class="keyword">typename</span> hashtable::hash_code_t code = this-&gt;m_hash_code(k);
<a name="l01818"></a>01818       std::size_t n = this-&gt;bucket_index(k, code, this-&gt;bucket_count());
<a name="l01819"></a>01819       node** head = m_buckets + n;
<a name="l01820"></a>01820       node* p = find_node(*head, k, code);
<a name="l01821"></a>01821 
<a name="l01822"></a>01822       <span class="keywordflow">if</span> (p)
<a name="l01823"></a>01823     {
<a name="l01824"></a>01824       node* p1 = p-&gt;m_next;
<a name="l01825"></a>01825       <span class="keywordflow">for</span> (; p1 ; p1 = p1-&gt;m_next)
<a name="l01826"></a>01826         <span class="keywordflow">if</span> (!this-&gt;<a class="code" href="../../da/d8a/namespaceAmg.html#ab845c2de1ce866d4b91a11fc7c1a9ca8">compare</a>(k, code, p1))
<a name="l01827"></a>01827           <span class="keywordflow">break</span>;
<a name="l01828"></a>01828 
<a name="l01829"></a>01829       const_iterator first(p, head);
<a name="l01830"></a>01830       const_iterator last(p1, head);
<a name="l01831"></a>01831       <span class="keywordflow">if</span> (!p1)
<a name="l01832"></a>01832         last.m_incr_bucket();
<a name="l01833"></a>01833       <span class="keywordflow">return</span> std::make_pair(first, last);
<a name="l01834"></a>01834     }
<a name="l01835"></a>01835       <span class="keywordflow">else</span>
<a name="l01836"></a>01836     <span class="keywordflow">return</span> std::make_pair(this-&gt;end(), this-&gt;end());
<a name="l01837"></a>01837     }
<a name="l01838"></a>01838 
<a name="l01839"></a>01839   <span class="comment">// Find the node whose key compares equal to k, beginning the search</span>
<a name="l01840"></a>01840   <span class="comment">// at p (usually the head of a bucket).  Return nil if no node is found.</span>
<a name="l01841"></a>01841   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V, 
<a name="l01842"></a>01842        <span class="keyword">typename</span> A, <span class="keyword">typename</span> Ex, <span class="keyword">typename</span> Eq,
<a name="l01843"></a>01843        <span class="keyword">typename</span> H1, <span class="keyword">typename</span> H2, <span class="keyword">typename</span> H, <span class="keyword">typename</span> RP,
<a name="l01844"></a>01844        <span class="keywordtype">bool</span> c, <span class="keywordtype">bool</span> ci, <span class="keywordtype">bool</span> u&gt;
<a name="l01845"></a>01845     <span class="keyword">typename</span> hashtable&lt;K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u&gt;::node* 
<a name="l01846"></a>01846     hashtable&lt;K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u&gt;::
<a name="l01847"></a>01847     find_node(node* p, <span class="keyword">const</span> key_type&amp; k,
<a name="l01848"></a>01848           <span class="keyword">typename</span> hashtable::hash_code_t code)<span class="keyword"> const</span>
<a name="l01849"></a>01849 <span class="keyword">    </span>{
<a name="l01850"></a>01850       <span class="keywordflow">for</span> ( ; p ; p = p-&gt;m_next)
<a name="l01851"></a>01851     <span class="keywordflow">if</span> (this-&gt;compare (k, code, p))
<a name="l01852"></a>01852       <span class="keywordflow">return</span> p;
<a name="l01853"></a>01853       <span class="keywordflow">return</span> 0;
<a name="l01854"></a>01854     }
<a name="l01855"></a>01855 
<a name="l01856"></a>01856   <span class="comment">// Insert v if no element with its key is already present.</span>
<a name="l01857"></a>01857   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V, 
<a name="l01858"></a>01858        <span class="keyword">typename</span> A, <span class="keyword">typename</span> Ex, <span class="keyword">typename</span> Eq,
<a name="l01859"></a>01859        <span class="keyword">typename</span> H1, <span class="keyword">typename</span> H2, <span class="keyword">typename</span> H, <span class="keyword">typename</span> RP,
<a name="l01860"></a>01860        <span class="keywordtype">bool</span> c, <span class="keywordtype">bool</span> ci, <span class="keywordtype">bool</span> u&gt;
<a name="l01861"></a>01861     std::pair&lt;<span class="keyword">typename</span> hashtable&lt;K, V, A, Ex, Eq, H1,
<a name="l01862"></a>01862                  H2, H, RP, c, ci, u&gt;::iterator, <span class="keywordtype">bool</span>&gt;
<a name="l01863"></a>01863     hashtable&lt;K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u&gt;::
<a name="l01864"></a>01864     insert(<span class="keyword">const</span> value_type&amp; v, CxxUtils_Internal<span class="comment">/*std::tr1*/</span>::true_type) <span class="comment">// sss</span>
<a name="l01865"></a>01865     {
<a name="l01866"></a>01866       <span class="keyword">const</span> key_type&amp; k = this-&gt;m_extract(v);
<a name="l01867"></a>01867       <span class="keyword">typename</span> hashtable::hash_code_t code = this-&gt;m_hash_code(k);
<a name="l01868"></a>01868       size_type n = this-&gt;bucket_index(k, code, m_bucket_count);
<a name="l01869"></a>01869       
<a name="l01870"></a>01870       <span class="keywordflow">if</span> (node* p = find_node(m_buckets[n], k, code))
<a name="l01871"></a>01871     <span class="keywordflow">return</span> std::make_pair(iterator(p, m_buckets + n), <span class="keyword">false</span>);
<a name="l01872"></a>01872 
<a name="l01873"></a>01873       std::pair&lt;bool, size_t&gt; do_rehash
<a name="l01874"></a>01874     = m_rehash_policy.need_rehash(m_bucket_count, m_element_count, 1);
<a name="l01875"></a>01875 
<a name="l01876"></a>01876       <span class="comment">// Allocate the new node before doing the rehash so that we don&apos;t</span>
<a name="l01877"></a>01877       <span class="comment">// do a rehash if the allocation throws.</span>
<a name="l01878"></a>01878       node* new_node = m_allocate_node (v);
<a name="l01879"></a>01879       
<a name="l01880"></a>01880       <span class="keywordflow">try</span>
<a name="l01881"></a>01881     {
<a name="l01882"></a>01882       <span class="keywordflow">if</span> (do_rehash.first)
<a name="l01883"></a>01883         {
<a name="l01884"></a>01884           n = this-&gt;bucket_index(k, code, do_rehash.second);
<a name="l01885"></a>01885           m_rehash(do_rehash.second);
<a name="l01886"></a>01886         }
<a name="l01887"></a>01887 
<a name="l01888"></a>01888       new_node-&gt;m_next = m_buckets[n];
<a name="l01889"></a>01889       this-&gt;store_code(new_node, code);
<a name="l01890"></a>01890       m_buckets[n] = new_node;
<a name="l01891"></a>01891       ++m_element_count;
<a name="l01892"></a>01892       <span class="keywordflow">return</span> std::make_pair(iterator(new_node, m_buckets + n), <span class="keyword">true</span>);
<a name="l01893"></a>01893     }
<a name="l01894"></a>01894       <span class="keywordflow">catch</span> (...)
<a name="l01895"></a>01895     {
<a name="l01896"></a>01896       m_deallocate_node (new_node);
<a name="l01897"></a>01897       <span class="keywordflow">throw</span>;
<a name="l01898"></a>01898     }
<a name="l01899"></a>01899     }
<a name="l01900"></a>01900   
<a name="l01901"></a>01901   <span class="comment">// Insert v unconditionally.</span>
<a name="l01902"></a>01902   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V, 
<a name="l01903"></a>01903        <span class="keyword">typename</span> A, <span class="keyword">typename</span> Ex, <span class="keyword">typename</span> Eq,
<a name="l01904"></a>01904        <span class="keyword">typename</span> H1, <span class="keyword">typename</span> H2, <span class="keyword">typename</span> H, <span class="keyword">typename</span> RP,
<a name="l01905"></a>01905        <span class="keywordtype">bool</span> c, <span class="keywordtype">bool</span> ci, <span class="keywordtype">bool</span> u&gt;
<a name="l01906"></a>01906     <span class="keyword">typename</span> hashtable&lt;K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u&gt;::iterator
<a name="l01907"></a>01907     hashtable&lt;K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u&gt;::
<a name="l01908"></a>01908     insert(<span class="keyword">const</span> value_type&amp; v, CxxUtils_Internal<span class="comment">/*std::tr1*/</span>::false_type) <span class="comment">// sss</span>
<a name="l01909"></a>01909     {
<a name="l01910"></a>01910       std::pair&lt;bool, std::size_t&gt; do_rehash
<a name="l01911"></a>01911     = m_rehash_policy.need_rehash(m_bucket_count, m_element_count, 1);
<a name="l01912"></a>01912       <span class="keywordflow">if</span> (do_rehash.first)
<a name="l01913"></a>01913     m_rehash(do_rehash.second);
<a name="l01914"></a>01914 
<a name="l01915"></a>01915       <span class="keyword">const</span> key_type&amp; k = this-&gt;m_extract(v);
<a name="l01916"></a>01916       <span class="keyword">typename</span> hashtable::hash_code_t code = this-&gt;m_hash_code(k);
<a name="l01917"></a>01917       size_type n = this-&gt;bucket_index(k, code, m_bucket_count);
<a name="l01918"></a>01918       
<a name="l01919"></a>01919       node* new_node = m_allocate_node (v);
<a name="l01920"></a>01920       node* prev = find_node(m_buckets[n], k, code);
<a name="l01921"></a>01921       <span class="keywordflow">if</span> (prev)
<a name="l01922"></a>01922     {
<a name="l01923"></a>01923       new_node-&gt;m_next = prev-&gt;m_next;
<a name="l01924"></a>01924       prev-&gt;m_next = new_node;
<a name="l01925"></a>01925     }
<a name="l01926"></a>01926       <span class="keywordflow">else</span>
<a name="l01927"></a>01927     {
<a name="l01928"></a>01928       new_node-&gt;m_next = m_buckets[n];
<a name="l01929"></a>01929       m_buckets[n] = new_node;
<a name="l01930"></a>01930     }
<a name="l01931"></a>01931       this-&gt;store_code(new_node, code);
<a name="l01932"></a>01932 
<a name="l01933"></a>01933       ++m_element_count;
<a name="l01934"></a>01934       <span class="keywordflow">return</span> iterator(new_node, m_buckets + n);
<a name="l01935"></a>01935     }
<a name="l01936"></a>01936 
<a name="l01937"></a>01937   <span class="comment">// For erase(iterator) and erase(const_iterator).</span>
<a name="l01938"></a>01938   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V, 
<a name="l01939"></a>01939        <span class="keyword">typename</span> A, <span class="keyword">typename</span> Ex, <span class="keyword">typename</span> Eq,
<a name="l01940"></a>01940        <span class="keyword">typename</span> H1, <span class="keyword">typename</span> H2, <span class="keyword">typename</span> H, <span class="keyword">typename</span> RP,
<a name="l01941"></a>01941        <span class="keywordtype">bool</span> c, <span class="keywordtype">bool</span> ci, <span class="keywordtype">bool</span> u&gt;
<a name="l01942"></a>01942     <span class="keywordtype">void</span>
<a name="l01943"></a>01943     hashtable&lt;K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u&gt;::
<a name="l01944"></a>01944     erase_node(node* p, node** b)
<a name="l01945"></a>01945     {
<a name="l01946"></a>01946       node* cur = *b;
<a name="l01947"></a>01947       <span class="keywordflow">if</span> (cur == p)
<a name="l01948"></a>01948     *b = cur-&gt;m_next;
<a name="l01949"></a>01949       <span class="keywordflow">else</span>
<a name="l01950"></a>01950     {
<a name="l01951"></a>01951       node* next = cur-&gt;m_next;
<a name="l01952"></a>01952       <span class="keywordflow">while</span> (next != p)
<a name="l01953"></a>01953         {
<a name="l01954"></a>01954           cur = next;
<a name="l01955"></a>01955           next = cur-&gt;m_next;
<a name="l01956"></a>01956         }
<a name="l01957"></a>01957       cur-&gt;m_next = next-&gt;m_next;
<a name="l01958"></a>01958     }
<a name="l01959"></a>01959 
<a name="l01960"></a>01960       m_deallocate_node (p);
<a name="l01961"></a>01961       --m_element_count;
<a name="l01962"></a>01962     }
<a name="l01963"></a>01963 
<a name="l01964"></a>01964   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V, 
<a name="l01965"></a>01965        <span class="keyword">typename</span> A, <span class="keyword">typename</span> Ex, <span class="keyword">typename</span> Eq,
<a name="l01966"></a>01966        <span class="keyword">typename</span> H1, <span class="keyword">typename</span> H2, <span class="keyword">typename</span> H, <span class="keyword">typename</span> RP,
<a name="l01967"></a>01967        <span class="keywordtype">bool</span> c, <span class="keywordtype">bool</span> ci, <span class="keywordtype">bool</span> u&gt;
<a name="l01968"></a>01968     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> InIter&gt;
<a name="l01969"></a>01969       <span class="keywordtype">void</span> 
<a name="l01970"></a>01970       hashtable&lt;K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u&gt;::
<a name="l01971"></a>01971       insert(InIter first, InIter last)
<a name="l01972"></a>01972       {
<a name="l01973"></a>01973     size_type n_elt = Internal::distance_fw (first, last);
<a name="l01974"></a>01974     std::pair&lt;bool, std::size_t&gt; do_rehash
<a name="l01975"></a>01975       = m_rehash_policy.need_rehash(m_bucket_count, m_element_count, n_elt);
<a name="l01976"></a>01976     <span class="keywordflow">if</span> (do_rehash.first)
<a name="l01977"></a>01977       m_rehash(do_rehash.second);
<a name="l01978"></a>01978 
<a name="l01979"></a>01979     <span class="keywordflow">for</span> (; first != last; ++first)
<a name="l01980"></a>01980       this-&gt;insert (*first);
<a name="l01981"></a>01981       }
<a name="l01982"></a>01982 
<a name="l01983"></a>01983   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V, 
<a name="l01984"></a>01984        <span class="keyword">typename</span> A, <span class="keyword">typename</span> Ex, <span class="keyword">typename</span> Eq,
<a name="l01985"></a>01985        <span class="keyword">typename</span> H1, <span class="keyword">typename</span> H2, <span class="keyword">typename</span> H, <span class="keyword">typename</span> RP,
<a name="l01986"></a>01986        <span class="keywordtype">bool</span> c, <span class="keywordtype">bool</span> ci, <span class="keywordtype">bool</span> u&gt;
<a name="l01987"></a>01987     <span class="keyword">typename</span> hashtable&lt;K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u&gt;::iterator
<a name="l01988"></a>01988     hashtable&lt;K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u&gt;::
<a name="l01989"></a>01989     erase(iterator i)
<a name="l01990"></a>01990     {
<a name="l01991"></a>01991       iterator result = i;
<a name="l01992"></a>01992       ++result;
<a name="l01993"></a>01993       <span class="comment">//erase_node(i.m_cur_node, i.m_cur_bucket);</span>
<a name="l01994"></a>01994       i.erase_node(*<span class="keyword">this</span>); <span class="comment">// sss</span>
<a name="l01995"></a>01995       <span class="keywordflow">return</span> result;
<a name="l01996"></a>01996     }
<a name="l01997"></a>01997   
<a name="l01998"></a>01998   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V, 
<a name="l01999"></a>01999        <span class="keyword">typename</span> A, <span class="keyword">typename</span> Ex, <span class="keyword">typename</span> Eq,
<a name="l02000"></a>02000        <span class="keyword">typename</span> H1, <span class="keyword">typename</span> H2, <span class="keyword">typename</span> H, <span class="keyword">typename</span> RP,
<a name="l02001"></a>02001        <span class="keywordtype">bool</span> c, <span class="keywordtype">bool</span> ci, <span class="keywordtype">bool</span> u&gt;
<a name="l02002"></a>02002     <span class="keyword">typename</span> hashtable&lt;K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u&gt;::const_iterator
<a name="l02003"></a>02003     hashtable&lt;K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u&gt;::
<a name="l02004"></a>02004     erase(const_iterator i)
<a name="l02005"></a>02005     {
<a name="l02006"></a>02006       const_iterator result = i;
<a name="l02007"></a>02007       ++result;
<a name="l02008"></a>02008       <span class="comment">//erase_node(i.m_cur_node, i.m_cur_bucket);</span>
<a name="l02009"></a>02009       i.erase_node (*<span class="keyword">this</span>); <span class="comment">// sss</span>
<a name="l02010"></a>02010       <span class="keywordflow">return</span> result;
<a name="l02011"></a>02011     }
<a name="l02012"></a>02012 
<a name="l02013"></a>02013   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V, 
<a name="l02014"></a>02014        <span class="keyword">typename</span> A, <span class="keyword">typename</span> Ex, <span class="keyword">typename</span> Eq,
<a name="l02015"></a>02015        <span class="keyword">typename</span> H1, <span class="keyword">typename</span> H2, <span class="keyword">typename</span> H, <span class="keyword">typename</span> RP,
<a name="l02016"></a>02016        <span class="keywordtype">bool</span> c, <span class="keywordtype">bool</span> ci, <span class="keywordtype">bool</span> u&gt;
<a name="l02017"></a>02017     <span class="keyword">typename</span> hashtable&lt;K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u&gt;::size_type
<a name="l02018"></a>02018     hashtable&lt;K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u&gt;::
<a name="l02019"></a>02019     erase(<span class="keyword">const</span> key_type&amp; k)
<a name="l02020"></a>02020     {
<a name="l02021"></a>02021       <span class="keyword">typename</span> hashtable::hash_code_t code = this-&gt;m_hash_code(k);
<a name="l02022"></a>02022       size_type n = this-&gt;bucket_index(k, code, m_bucket_count);
<a name="l02023"></a>02023       size_type result = 0;
<a name="l02024"></a>02024       
<a name="l02025"></a>02025       node** slot = m_buckets + n;
<a name="l02026"></a>02026       <span class="keywordflow">while</span> (*slot &amp;&amp; ! this-&gt;<a class="code" href="../../da/d8a/namespaceAmg.html#ab845c2de1ce866d4b91a11fc7c1a9ca8">compare</a>(k, code, *slot))
<a name="l02027"></a>02027     slot = &amp;((*slot)-&gt;m_next);
<a name="l02028"></a>02028 
<a name="l02029"></a>02029       <span class="keywordflow">while</span> (*slot &amp;&amp; this-&gt;<a class="code" href="../../da/d8a/namespaceAmg.html#ab845c2de1ce866d4b91a11fc7c1a9ca8">compare</a>(k, code, *slot))
<a name="l02030"></a>02030     {
<a name="l02031"></a>02031       node* n = *slot;
<a name="l02032"></a>02032       *slot = n-&gt;m_next;
<a name="l02033"></a>02033       m_deallocate_node (n);
<a name="l02034"></a>02034       --m_element_count;
<a name="l02035"></a>02035       ++result;
<a name="l02036"></a>02036     }
<a name="l02037"></a>02037 
<a name="l02038"></a>02038       <span class="keywordflow">return</span> result;
<a name="l02039"></a>02039     }
<a name="l02040"></a>02040 
<a name="l02041"></a>02041   <span class="comment">// ??? This could be optimized by taking advantage of the bucket</span>
<a name="l02042"></a>02042   <span class="comment">// structure, but it&apos;s not clear that it&apos;s worth doing.  It probably</span>
<a name="l02043"></a>02043   <span class="comment">// wouldn&apos;t even be an optimization unless the load factor is large.</span>
<a name="l02044"></a>02044   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V, 
<a name="l02045"></a>02045        <span class="keyword">typename</span> A, <span class="keyword">typename</span> Ex, <span class="keyword">typename</span> Eq,
<a name="l02046"></a>02046        <span class="keyword">typename</span> H1, <span class="keyword">typename</span> H2, <span class="keyword">typename</span> H, <span class="keyword">typename</span> RP,
<a name="l02047"></a>02047        <span class="keywordtype">bool</span> c, <span class="keywordtype">bool</span> ci, <span class="keywordtype">bool</span> u&gt;
<a name="l02048"></a>02048     <span class="keyword">typename</span> hashtable&lt;K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u&gt;::iterator
<a name="l02049"></a>02049     hashtable&lt;K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u&gt;::
<a name="l02050"></a>02050     erase(iterator first, iterator last)
<a name="l02051"></a>02051     {
<a name="l02052"></a>02052       <span class="keywordflow">while</span> (first != last)
<a name="l02053"></a>02053     first = this-&gt;erase(first);
<a name="l02054"></a>02054       <span class="keywordflow">return</span> last;
<a name="l02055"></a>02055     }
<a name="l02056"></a>02056   
<a name="l02057"></a>02057   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V, 
<a name="l02058"></a>02058        <span class="keyword">typename</span> A, <span class="keyword">typename</span> Ex, <span class="keyword">typename</span> Eq,
<a name="l02059"></a>02059        <span class="keyword">typename</span> H1, <span class="keyword">typename</span> H2, <span class="keyword">typename</span> H, <span class="keyword">typename</span> RP,
<a name="l02060"></a>02060        <span class="keywordtype">bool</span> c, <span class="keywordtype">bool</span> ci, <span class="keywordtype">bool</span> u&gt;
<a name="l02061"></a>02061     <span class="keyword">typename</span> hashtable&lt;K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u&gt;::const_iterator
<a name="l02062"></a>02062     hashtable&lt;K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u&gt;::
<a name="l02063"></a>02063     erase(const_iterator first, const_iterator last)
<a name="l02064"></a>02064     {
<a name="l02065"></a>02065       <span class="keywordflow">while</span> (first != last)
<a name="l02066"></a>02066     first = this-&gt;erase(first);
<a name="l02067"></a>02067       <span class="keywordflow">return</span> last;
<a name="l02068"></a>02068     }
<a name="l02069"></a>02069 
<a name="l02070"></a>02070   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V, 
<a name="l02071"></a>02071        <span class="keyword">typename</span> A, <span class="keyword">typename</span> Ex, <span class="keyword">typename</span> Eq,
<a name="l02072"></a>02072        <span class="keyword">typename</span> H1, <span class="keyword">typename</span> H2, <span class="keyword">typename</span> H, <span class="keyword">typename</span> RP,
<a name="l02073"></a>02073        <span class="keywordtype">bool</span> c, <span class="keywordtype">bool</span> ci, <span class="keywordtype">bool</span> u&gt;
<a name="l02074"></a>02074     <span class="keywordtype">void</span>
<a name="l02075"></a>02075     hashtable&lt;K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u&gt;::
<a name="l02076"></a>02076     clear()
<a name="l02077"></a>02077     {
<a name="l02078"></a>02078       m_deallocate_nodes(m_buckets, m_bucket_count);
<a name="l02079"></a>02079       m_element_count = 0;
<a name="l02080"></a>02080     }
<a name="l02081"></a>02081 
<a name="l02082"></a>02082   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V, 
<a name="l02083"></a>02083        <span class="keyword">typename</span> A, <span class="keyword">typename</span> Ex, <span class="keyword">typename</span> Eq,
<a name="l02084"></a>02084        <span class="keyword">typename</span> H1, <span class="keyword">typename</span> H2, <span class="keyword">typename</span> H, <span class="keyword">typename</span> RP,
<a name="l02085"></a>02085        <span class="keywordtype">bool</span> c, <span class="keywordtype">bool</span> ci, <span class="keywordtype">bool</span> u&gt;
<a name="l02086"></a>02086     <span class="keywordtype">void</span>
<a name="l02087"></a>02087     hashtable&lt;K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u&gt;::
<a name="l02088"></a>02088     rehash(size_type n)
<a name="l02089"></a>02089     {
<a name="l02090"></a>02090       m_rehash(std::max(m_rehash_policy.next_bkt(n),
<a name="l02091"></a>02091             m_rehash_policy.bkt_for_elements(m_element_count
<a name="l02092"></a>02092                              + 1)));
<a name="l02093"></a>02093     }
<a name="l02094"></a>02094 
<a name="l02095"></a>02095   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V, 
<a name="l02096"></a>02096        <span class="keyword">typename</span> A, <span class="keyword">typename</span> Ex, <span class="keyword">typename</span> Eq,
<a name="l02097"></a>02097        <span class="keyword">typename</span> H1, <span class="keyword">typename</span> H2, <span class="keyword">typename</span> H, <span class="keyword">typename</span> RP,
<a name="l02098"></a>02098        <span class="keywordtype">bool</span> c, <span class="keywordtype">bool</span> ci, <span class="keywordtype">bool</span> u&gt;
<a name="l02099"></a>02099     <span class="keywordtype">void</span>
<a name="l02100"></a>02100     hashtable&lt;K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u&gt;::
<a name="l02101"></a>02101     m_rehash(size_type N)
<a name="l02102"></a>02102     {
<a name="l02103"></a>02103       node** new_array = m_allocate_buckets (N);
<a name="l02104"></a>02104       <span class="keywordflow">try</span>
<a name="l02105"></a>02105     {
<a name="l02106"></a>02106       <span class="keywordflow">for</span> (size_type i = 0; i &lt; m_bucket_count; ++i)
<a name="l02107"></a>02107         <span class="keywordflow">while</span> (node* p = m_buckets[i])
<a name="l02108"></a>02108           {
<a name="l02109"></a>02109         size_type new_index = this-&gt;bucket_index (p, N);
<a name="l02110"></a>02110         m_buckets[i] = p-&gt;m_next;
<a name="l02111"></a>02111         p-&gt;m_next = new_array[new_index];
<a name="l02112"></a>02112         new_array[new_index] = p;
<a name="l02113"></a>02113           }
<a name="l02114"></a>02114       m_deallocate_buckets(m_buckets, m_bucket_count);
<a name="l02115"></a>02115       m_bucket_count = N;
<a name="l02116"></a>02116       m_buckets = new_array;
<a name="l02117"></a>02117     }
<a name="l02118"></a>02118       <span class="keywordflow">catch</span> (...)
<a name="l02119"></a>02119     {
<a name="l02120"></a>02120       <span class="comment">// A failure here means that a hash function threw an exception.</span>
<a name="l02121"></a>02121       <span class="comment">// We can&apos;t restore the previous state without calling the hash</span>
<a name="l02122"></a>02122       <span class="comment">// function again, so the only sensible recovery is to delete</span>
<a name="l02123"></a>02123       <span class="comment">// everything.</span>
<a name="l02124"></a>02124       m_deallocate_nodes(new_array, N);
<a name="l02125"></a>02125       m_deallocate_buckets(new_array, N);
<a name="l02126"></a>02126       m_deallocate_nodes(m_buckets, m_bucket_count);
<a name="l02127"></a>02127       m_element_count = 0;
<a name="l02128"></a>02128       <span class="keywordflow">throw</span>;
<a name="l02129"></a>02129     }
<a name="l02130"></a>02130     }
<a name="l02131"></a>02131 <span class="preprocessor">#undef Internal // sss</span>
<a name="l02132"></a>02132 <span class="preprocessor"></span><span class="comment">//} sss</span>
<a name="l02133"></a>02133 }               <span class="comment">// Namespace std::tr1</span>
<a name="l02134"></a>02134 
<a name="l02135"></a>02135 <span class="preprocessor">#endif </span><span class="comment">/* GNU_LIBSTDCXX_TR1_HASHTABLE_ */</span>
<a name="l02136"></a>02136 
</pre></div></div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 27 Apr 2017 for RootCore Packages by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
