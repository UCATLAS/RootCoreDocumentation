<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>RootCore Packages: /cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.31/AthContainers/AthContainers/DataList.h File Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">RootCore Packages
   &#160;<span id="projectnumber">2.4.31</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../files.html"><span>File&#160;List</span></a></li>
      <li><a href="../../globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../dir_6389297dfc687cd70752e8ae0b42586a.html">cvmfs</a></li><li class="navelem"><a class="el" href="../../dir_62892ac20956129f9eb822bab0336060.html">atlas.cern.ch</a></li><li class="navelem"><a class="el" href="../../dir_5ab4f853507b29eb302fccade2c88498.html">repo</a></li><li class="navelem"><a class="el" href="../../dir_ada49346adeed4120cdd9652d3e45109.html">sw</a></li><li class="navelem"><a class="el" href="../../dir_e58915b0aa9b467606f66665c240947f.html">ASG</a></li><li class="navelem"><a class="el" href="../../dir_a8b55eac85754bca9c4f1c73437a2720.html">AnalysisBase</a></li><li class="navelem"><a class="el" href="../../dir_f287f45277d6fd24c09469e8bfda983b.html">2.4.31</a></li><li class="navelem"><a class="el" href="../../dir_7c3fce4683dc634eedc7bfb84f99a92d.html">AthContainers</a></li><li class="navelem"><a class="el" href="../../dir_986d7cf0193d8fa6c715de511127a670.html">AthContainers</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">DataList.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>An STL list of pointers that by default owns its pointed-to elements.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;list&gt;</code><br/>
<code>#include &lt;typeinfo&gt;</code><br/>
<code>#include &lt;functional&gt;</code><br/>
<code>#include &lt;iostream&gt;</code><br/>
<code>#include &lt;algorithm&gt;</code><br/>
<code>#include &lt;iterator&gt;</code><br/>
<code>#include &lt;boost/static_assert.hpp&gt;</code><br/>
<code>#include &lt;boost/type_traits.hpp&gt;</code><br/>
<code>#include &lt;boost/iterator/iterator_adaptor.hpp&gt;</code><br/>
<code>#include &quot;SGTools/BaseInfo.h&quot;</code><br/>
<code>#include &quot;SGTools/DataBucketTraitFwd.h&quot;</code><br/>
<code>#include &quot;SGTools/ClassName.h&quot;</code><br/>
<code>#include &quot;AthContainers/OwnershipPolicy.h&quot;</code><br/>
<code>#include &quot;<a class="el" href="../../d4/d03/exceptions_8h_source.html">AthContainers/exceptions.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="../../d7/d92/DVLNoBase_8h_source.html">AthContainers/tools/DVLNoBase.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="../../d3/d2e/DVLInfo_8h_source.html">AthContainers/tools/DVLInfo.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="../../d4/d16/DVLDataBucket_8h_source.html">AthContainers/tools/DVLDataBucket.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="../../df/d5c/DVLCast_8h_source.html">AthContainers/tools/DVLCast.h</a>&quot;</code><br/>
<code>#include &quot;AthContainers/tools/DVLIterator.h&quot;</code><br/>
<code>#include &quot;<a class="el" href="../../d6/ddb/DVL__iter__swap_8h_source.html">AthContainers/tools/DVL_iter_swap.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="../../d0/d7a/DVL__algorithms_8h_source.html">AthContainers/tools/DVL_algorithms.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="../../db/d26/ElementProxy_8h_source.html">AthContainers/tools/ElementProxy.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="../../d5/dfa/IsMostDerivedFlag_8h_source.html">AthContainers/tools/IsMostDerivedFlag.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="../../d3/dec/selection__ns_8h_source.html">AthLinks/tools/selection_ns.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="../../d5/ddf/DataList_8icc.html">AthContainers/DataList.icc</a>&quot;</code><br/>
</div>
<p><a href="../../d1/d43/DataList_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dfb/classDataList.html">DataList&lt; T, BASE &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a>&lt;T&gt;</code>.  <a href="../../d9/dfb/classDataList.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dec/structDataList__detail_1_1VirtBases.html">DataList_detail::VirtBases&lt; B1, B2, B3 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/dec/structDataList__detail_1_1VirtBases.html" title="VirtBases for three classes. ">VirtBases</a> for three classes.  <a href="../../d5/dec/structDataList__detail_1_1VirtBases.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de9/structDataListBase.html">DataListBase&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derivation information for <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code>.  <a href="../../d2/de9/structDataListBase.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7c/classConstDataList.html">ConstDataList&lt; DL &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code> adapter that acts like it holds const pointers.  <a href="../../d3/d7c/classConstDataList.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dfb/classDataList.html">DataList&lt; T, BASE &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a>&lt;T&gt;</code>.  <a href="../../d9/dfb/classDataList.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html">DataList&lt; T, DataModel_detail::NoBase &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base specialization for <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a>&lt;T&gt;</code>.  <a href="../../d0/d3c/classDataList_3_01T_00_01DataModel__detail_1_1NoBase_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d9d/classClassName_3_01DataList_3_01T_01_4_01_4.html">ClassName&lt; DataList&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <code>ClassName</code> for <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code>.  <a href="../../df/d9d/classClassName_3_01DataList_3_01T_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dfb/classDataList.html">DataList&lt; T, BASE &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a>&lt;T&gt;</code>.  <a href="../../d9/dfb/classDataList.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d34/structSG_1_1DataBucketTrait_3_01DataList_3_01T_01_4_00_01U_01_4.html">SG::DataBucketTrait&lt; DataList&lt; T &gt;, U &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunction to find the proper <code>DataBucket</code> class for <code>T</code>.  <a href="../../dc/d34/structSG_1_1DataBucketTrait_3_01DataList_3_01T_01_4_00_01U_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:dd/d59/namespaceSG"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d59/namespaceSG.html">SG</a></td></tr>
<tr class="memdesc:dd/d59/namespaceSG"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from a payload object. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a7a29fa6695c3cb02dbb0faf32c779d54"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a29fa6695c3cb02dbb0faf32c779d54"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HAVE_CONSTDATAVECTOR</b></td></tr>
<tr class="separator:a7a29fa6695c3cb02dbb0faf32c779d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9051b45fea61ed235640253b4efdb86b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d43/DataList_8h.html#a9051b45fea61ed235640253b4efdb86b">DATALIST_BASE</a>(T, BASE)</td></tr>
<tr class="memdesc:a9051b45fea61ed235640253b4efdb86b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare base class info to <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code>. Single, non-virtual derivation.  <a href="#a9051b45fea61ed235640253b4efdb86b">More...</a><br/></td></tr>
<tr class="separator:a9051b45fea61ed235640253b4efdb86b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfa1a94e27e2aa31a9e5de856c459b41"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d43/DataList_8h.html#abfa1a94e27e2aa31a9e5de856c459b41">DATALIST_VIRTBASES1</a>(T, B1)</td></tr>
<tr class="memdesc:abfa1a94e27e2aa31a9e5de856c459b41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare base class info to <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code>. Single, virtual derivation.  <a href="#abfa1a94e27e2aa31a9e5de856c459b41">More...</a><br/></td></tr>
<tr class="separator:abfa1a94e27e2aa31a9e5de856c459b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ad3d1a23e99411007da14017fad6c8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d43/DataList_8h.html#ad7ad3d1a23e99411007da14017fad6c8">DATALIST_VIRTBASES2</a>(T, B1, B2)</td></tr>
<tr class="memdesc:ad7ad3d1a23e99411007da14017fad6c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare base class info to <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code>. Multiple derivation.  <a href="#ad7ad3d1a23e99411007da14017fad6c8">More...</a><br/></td></tr>
<tr class="separator:ad7ad3d1a23e99411007da14017fad6c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2f8a00c08d0ffcb32fc1592a4a52d3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d43/DataList_8h.html#a3c2f8a00c08d0ffcb32fc1592a4a52d3">DATALIST_VIRTBASES3</a>(T, B1, B2, B3)</td></tr>
<tr class="memdesc:a3c2f8a00c08d0ffcb32fc1592a4a52d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare base class info to <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code>. Multiple derivation.  <a href="#a3c2f8a00c08d0ffcb32fc1592a4a52d3">More...</a><br/></td></tr>
<tr class="separator:a3c2f8a00c08d0ffcb32fc1592a4a52d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3453f27ee85f00ae76a71c3d2d52ca61"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3453f27ee85f00ae76a71c3d2d52ca61"></a>
template&lt;class DL &gt; </td></tr>
<tr class="memitem:a3453f27ee85f00ae76a71c3d2d52ca61"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>test2_assignelement1</b> ()</td></tr>
<tr class="separator:a3453f27ee85f00ae76a71c3d2d52ca61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23672b73979c2bef800470a4aa12b43"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac23672b73979c2bef800470a4aa12b43"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d43/DataList_8h.html#ac23672b73979c2bef800470a4aa12b43">operator==</a> (const <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T &gt; &amp;a, const <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T &gt; &amp;b)</td></tr>
<tr class="memdesc:ac23672b73979c2bef800470a4aa12b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">List equality comparison.  <a href="#ac23672b73979c2bef800470a4aa12b43">More...</a><br/></td></tr>
<tr class="separator:ac23672b73979c2bef800470a4aa12b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa48b3dccb4d1a8e3c9acb17f9557f534"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa48b3dccb4d1a8e3c9acb17f9557f534"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa48b3dccb4d1a8e3c9acb17f9557f534"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d43/DataList_8h.html#aa48b3dccb4d1a8e3c9acb17f9557f534">operator!=</a> (const <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T &gt; &amp;a, const <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T &gt; &amp;b)</td></tr>
<tr class="memdesc:aa48b3dccb4d1a8e3c9acb17f9557f534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Based on operator==. <br/></td></tr>
<tr class="separator:aa48b3dccb4d1a8e3c9acb17f9557f534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f545af795991d4ea90a9bc52e9863d8"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a6f545af795991d4ea90a9bc52e9863d8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d43/DataList_8h.html#a6f545af795991d4ea90a9bc52e9863d8">operator&lt;</a> (const <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T &gt; &amp;a, const <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T &gt; &amp;b)</td></tr>
<tr class="memdesc:a6f545af795991d4ea90a9bc52e9863d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">List ordering relation.  <a href="#a6f545af795991d4ea90a9bc52e9863d8">More...</a><br/></td></tr>
<tr class="separator:a6f545af795991d4ea90a9bc52e9863d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a496e1954158a223feb9b25e580f59c02"><td class="memTemplParams" colspan="2"><a class="anchor" id="a496e1954158a223feb9b25e580f59c02"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a496e1954158a223feb9b25e580f59c02"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d43/DataList_8h.html#a496e1954158a223feb9b25e580f59c02">operator&gt;</a> (const <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T &gt; &amp;a, const <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T &gt; &amp;b)</td></tr>
<tr class="memdesc:a496e1954158a223feb9b25e580f59c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Based on operator&lt;. <br/></td></tr>
<tr class="separator:a496e1954158a223feb9b25e580f59c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a849c9f5d8d58e56f2923ccbb53a7cb08"><td class="memTemplParams" colspan="2"><a class="anchor" id="a849c9f5d8d58e56f2923ccbb53a7cb08"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a849c9f5d8d58e56f2923ccbb53a7cb08"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d43/DataList_8h.html#a849c9f5d8d58e56f2923ccbb53a7cb08">operator&lt;=</a> (const <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T &gt; &amp;a, const <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T &gt; &amp;b)</td></tr>
<tr class="memdesc:a849c9f5d8d58e56f2923ccbb53a7cb08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Based on operator&lt;. <br/></td></tr>
<tr class="separator:a849c9f5d8d58e56f2923ccbb53a7cb08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a837e95c3cb570fdfe70131c0c2911054"><td class="memTemplParams" colspan="2"><a class="anchor" id="a837e95c3cb570fdfe70131c0c2911054"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a837e95c3cb570fdfe70131c0c2911054"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d43/DataList_8h.html#a837e95c3cb570fdfe70131c0c2911054">operator&gt;=</a> (const <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T &gt; &amp;a, const <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T &gt; &amp;b)</td></tr>
<tr class="memdesc:a837e95c3cb570fdfe70131c0c2911054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Based on operator&lt;. <br/></td></tr>
<tr class="separator:a837e95c3cb570fdfe70131c0c2911054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9681a82cd13d8cb83cfaa64a8ebe9c07"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a9681a82cd13d8cb83cfaa64a8ebe9c07"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d43/DataList_8h.html#a9681a82cd13d8cb83cfaa64a8ebe9c07">swap</a> (<a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T &gt; &amp;a, <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T &gt; &amp;b)</td></tr>
<tr class="memdesc:a9681a82cd13d8cb83cfaa64a8ebe9c07"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <code>DataList&lt;T, BASE&gt;::swap()</code>.  <a href="#a9681a82cd13d8cb83cfaa64a8ebe9c07">More...</a><br/></td></tr>
<tr class="separator:a9681a82cd13d8cb83cfaa64a8ebe9c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An STL list of pointers that by default owns its pointed-to elements. </p>
<dl class="section author"><dt>Author</dt><dd>Srini Rajagopalan, Sebastien Binet - ATLAS Collaboration </dd></dl>
<dl class="section date"><dt>Date</dt><dd>February 2006; rewritten from earlier version. For further information, see <a href="https://twiki.cern.ch/twiki/bin/view/Atlas/DataVector">https://twiki.cern.ch/twiki/bin/view/Atlas/DataVector</a></dd></dl>
<p>A <code>DataList&lt;T&gt;</code> acts like a <code>std::list&lt;T*&gt;</code>, except that it can optionally manage the memory that it contains. The constructors take an (optional) extra argument, which can be either <code><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8a1f65f0fb55784cfd27d9d4d6d7986d4d" title="this data object owns its elements ">SG::OWN_ELEMENTS</a></code> or <code><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8ad7d4cf2303700f0966e4140f236c4bf1" title="this data object is a view, it does not own its elmts ">SG::VIEW_ELEMENTS</a></code> (defaulting to <code><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8a1f65f0fb55784cfd27d9d4d6d7986d4d" title="this data object owns its elements ">SG::OWN_ELEMENTS</a></code> except for a copy constructor). This tells whether the <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code> owns its contained elements or not.</p>
<p>If a <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code> owns its elements, then they are deleted when the container itself is. Further, they are deleted by actions which erase elements from the container (i.e.: <code>erase()</code>, <code>pop_back()</code> ). A replacement (such as <code> (*l.front()) = new T; </code>) will result in the old element being deleted and the container taking ownership of the new element. It is an error to assign directly between two owning containers (<code> (*list1.front()) = (*list2.front());</code>).</p>
<p>Beware of ownership issues when modify a <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code> . Obviously you should not delete explicitly a <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code> element (because this is already taken care of by this object). A <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code> should never have two elements pointing to the same object. This may seem obvious but certain STL algorithms (eg: <code>remove_if</code> ) may leave a <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code> with two copies of the same element in the "left-over" range. To avoid a crash when clearing the list (eg: in the destructor we have introduced a <img class="formulaInl" alt="$ n\log n $" src="../../form_0.png"/> helper function that searches and removes duplicates in the <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code> . This is used by the destructor by <code>clear()</code> and by <code>erase(first, last)</code>. As this may change in the future to improve performance, do not rely on this functionality and do avoid introducing duplicated elements in a <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code> .</p>
<p>All these cautions do not apply when a <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code> it is created with the flag <code><a class="el" href="../../dd/d59/namespaceSG.html#acd9d1a31242c6243cc1c6fab0fbc7cd8ad7d4cf2303700f0966e4140f236c4bf1" title="this data object is a view, it does not own its elmts ">SG::VIEW_ELEMENTS</a></code> (see <code>enum OwnershipPolicy</code>) and hence does not own its elements. This is typically used to have <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code> elements allocated by <code>DataPool</code>. Otherwise consider the cleaner alternative of using a <code>list&lt;T*&gt;</code>.</p>
<p>The interface for <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code> should be mostly compatible with that of <code>std::list</code>. There are a few differences which should not make much difference in practice. For example, methods which would return a reference return a proxy object instead. Also <code>value_type</code> is used instead of <code>const_reference</code>; this is justified by the fact that the elements are always pointers.</p>
<p>Note that algorithms which modify their range may not work correctly if the container owns its contents. Specializations that work properly for <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code> are available for some algorithms. These include:</p>
<ul>
<li><code>std::remove</code> </li>
<li><code>std::remove_if</code> </li>
<li><code>std::unique</code> </li>
<li><code>std::reverse</code> </li>
<li><code>std::rotate</code> </li>
<li><code>std::partition</code> </li>
<li><code>std::stable_partition</code> </li>
</ul>
<p>There are a few other additions to the standard <code>std::list</code> interface.</p>
<ul>
<li>The method <code>stdcont</code> may be used to get access to the underlying <code>std::list</code> representation.</li>
<li>The type <code>PtrList</code> is the type of the underlying <code>std::List</code>. <code>BaseContainer</code> is a synonym for this.</li>
<li>The method <code>ownPolicy</code> returns the ownership policy of the container.</li>
<li>An additional overload of <code>clear()</code> is provided that takes as an argument a new ownership policy for the container. This is the only way to change the ownership policy.</li>
</ul>
<p>Note that since <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a>&lt;T&gt;</code> has an element type of <code>T*</code>, it is not possible to directly insert a <code>const T*</code>. If you want to do that, see <code><a class="el" href="../../d3/d7c/classConstDataList.html" title="DataList adapter that acts like it holds const pointers. ">ConstDataList</a></code>. (In some cases, such as if the destination container is not being recorded in StoreGate, it may be more appropriate to simply use a <code>std::list&lt;const T*&gt;</code>.) Don't just use a <code>const_cast!</code> </p>
<p>Finally, <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a>'s</code> may inherit from one another. If you have class <code>D</code> which derives from class <code>B</code>, you can set things up so that <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a>&lt;D&gt;</code> derives from <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a>&lt;B&gt;</code>. This allows you do to the same sort of conversions on the <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a>'s</code> as on the element pointers themselves. The key to doing this is to add the declaration</p>
<div class="fragment"><div class="line">*   <a class="code" href="../../d1/d43/DataList_8h.html#a9051b45fea61ed235640253b4efdb86b">DATALIST_BASE</a> (D, B);</div>
</div><!-- fragment --><p>before using <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a>&lt;D&gt;</code>. A few caveats about doing this. The pointers are actually stored in the base <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code> instance, and the type that <code>stdcont</code> returns will reflect this. For example, in the example given above, <code><a class="el" href="../../d9/dfb/classDataList.html#a4f0cca5ce1808d7e1c95a9c00b694007" title="Return the underlying std::list of the container. ">DataList&lt;D&gt;::stdcont()</a></code> will return a reference to std::list&lt;B*&gt;. Second, in order to preserve the invariant that a <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a>&lt;D&gt;</code> contains only elements that actually derive from <code>D</code>, while at the same time not requiring that the contained objects be polymorphic, there is a restriction that you cannot insert into a <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code> if you're not referring to it as the most derived type (even if such an insertion would not actually break the invariant). This is implemented as a runtime check.</p>
<p>Example:</p>
<div class="fragment"><div class="line">*   <a class="code" href="../../d9/dfb/classDataList.html">DataList&lt;D&gt;</a> ld;</div>
<div class="line">*   ld.<a class="code" href="../../d9/dfb/classDataList.html#a87c05187af67b866631aba4d5dab7f1e">push_back</a> (<span class="keyword">new</span> D);  <span class="comment">// This is ok.</span></div>
<div class="line">*   ld.<a class="code" href="../../d9/dfb/classDataList.html#a87c05187af67b866631aba4d5dab7f1e">push_back</a> (<span class="keyword">new</span> B);  <span class="comment">// This will give a compilation error</span></div>
<div class="line">*                             (it would <span class="keywordflow">break</span> the invariant).</div>
<div class="line">*   <a class="code" href="../../d9/dfb/classDataList.html">DataList&lt;B&gt;</a>&amp; lb = ld;</div>
<div class="line">*   lb.<a class="code" href="../../d9/dfb/classDataList.html#a87c05187af67b866631aba4d5dab7f1e">push_back</a> (<span class="keyword">new</span> B);  <span class="comment">// This will give a run-time error</span></div>
<div class="line">*                             (it breaks the invariant).</div>
<div class="line">*   lb.push_back (<span class="keyword">new</span> D);  <span class="comment">// This will also give a run-time error.</span></div>
<div class="line">*                             (It<span class="stringliteral">&#39;s actually ok, but there&#39;</span>s no good way</div>
<div class="line">*                             to distinguish it from the previous <span class="keywordflow">case</span>.)</div>
</div><!-- fragment --><p>Note also this (related to a common atlas idiom). If we have the above, and also:</p>
<div class="fragment"><div class="line">*   <span class="keyword">class </span>B_List : <span class="keyword">public</span> <a class="code" href="../../d9/dfb/classDataList.html">DataList</a>&lt;B&gt; { ... };</div>
<div class="line">*   <span class="keyword">class </span>D_List : <span class="keyword">public</span> <a class="code" href="../../d9/dfb/classDataList.html">DataList</a>&lt;D&gt; { ... };</div>
</div><!-- fragment --><p>Then a <code>D_List</code> will be convertible to a <a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a>&lt;B&gt;, but <em>not</em> to a <code>B_List</code>.</p>
<p>Multiple and virtual inheritance are also supported. In this case, use <code>DATALIST_VIRTBASES</code><em>n</em> (where <em>n</em> is 1, 2, or 3) instead of <code>DATALIST_BASE</code>. Example: Given:</p>
<div class="fragment"><div class="line">*   <span class="keyword">class </span>M { ... };</div>
<div class="line">*   <span class="keyword">class </span>N : <span class="keyword">virtual</span> <span class="keyword">public</span> M { ... };</div>
<div class="line">*   <span class="keyword">class </span>O : <span class="keyword">virtual</span> <span class="keyword">public</span> M { ... };</div>
<div class="line">*   <span class="keyword">class </span>P : <span class="keyword">virtual</span> <span class="keyword">public</span> N, <span class="keyword">virtual</span> <span class="keyword">public</span> O { ... };</div>
</div><!-- fragment --><p>declare this with</p>
<div class="fragment"><div class="line">*   <a class="code" href="../../d1/d43/DataList_8h.html#abfa1a94e27e2aa31a9e5de856c459b41">DATALIST_VIRTBASES1</a>(N, M);</div>
<div class="line">*   <a class="code" href="../../d1/d43/DataList_8h.html#abfa1a94e27e2aa31a9e5de856c459b41">DATALIST_VIRTBASES1</a>(O, M);</div>
<div class="line">*   <a class="code" href="../../d1/d43/DataList_8h.html#ad7ad3d1a23e99411007da14017fad6c8">DATALIST_VIRTBASES2</a>(P, N, O);</div>
</div><!-- fragment --><p>There is a restriction that there must be a unique base class that does not derive from anything else. For example, the diamond configuration above is ok, but this would not be:</p>
<div class="fragment"><div class="line">*   <span class="keyword">class </span>L { ... };</div>
<div class="line">*   <span class="keyword">class </span>M { ... };</div>
<div class="line">*   <span class="keyword">class </span>N : <span class="keyword">virtual</span> <span class="keyword">public</span> M, <span class="keyword">virtual</span> <span class="keyword">public</span> L { ... };</div>
<div class="line">*   <span class="keyword">class </span>O : <span class="keyword">virtual</span> <span class="keyword">public</span> M { ... };</div>
<div class="line">*   <span class="keyword">class </span>P : <span class="keyword">virtual</span> <span class="keyword">public</span> N, <span class="keyword">virtual</span> <span class="keyword">public</span> O { ... };</div>
<div class="line">*</div>
<div class="line">*   <a class="code" href="../../d1/d43/DataList_8h.html#ad7ad3d1a23e99411007da14017fad6c8">DATALIST_VIRTBASES2</a>(N, M, L);</div>
<div class="line">*   <a class="code" href="../../d1/d43/DataList_8h.html#abfa1a94e27e2aa31a9e5de856c459b41">DATALIST_VIRTBASES1</a>(O, M);</div>
<div class="line">*   <a class="code" href="../../d1/d43/DataList_8h.html#ad7ad3d1a23e99411007da14017fad6c8">DATALIST_VIRTBASES2</a>(P, N, O);</div>
</div><!-- fragment --><p>Note, however, that you don't have to tell <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code> about the complete hierarchy; leaving the <code>L</code> out of <code>DATALIST_VIRTBASES</code> would work (you just wouldn't be able to convert to <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a>&lt;L&gt;</code> ).</p>
<p>If you use <code>DATALIST_VIRTBASES</code>, there is an additional time penalty to retrieve elements from the collection. This does not apply for <code>DATALIST_BASES</code>.</p>
<p>All applicable <code>DATALIST_*</code> macros must be visible at the point at which a <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code> is instantiated. A confusing compilation error is likely to result otherwise. Note that this means that if you have the <code>DATALIST_*</code> macros within a container header file, then the header for the derived container must include the header for the base container. Be alert to this when converting existing code to use the inheritance scheme. For example, if class D2 derives from D which derives from B:</p>
<p>BList.h: </p>
<div class="fragment"><div class="line">*  #include <span class="stringliteral">&quot;B.h&quot;</span></div>
<div class="line">*  #include <span class="stringliteral">&quot;DataList.h&quot;</span></div>
<div class="line">*  <span class="keyword">typedef</span> <a class="code" href="../../d9/dfb/classDataList.html">DataList&lt;B&gt;</a> BVec;</div>
</div><!-- fragment --><p>DList.h: </p>
<div class="fragment"><div class="line">*  #include <span class="stringliteral">&quot;D.h&quot;</span></div>
<div class="line">*  #include <span class="stringliteral">&quot;DataList.h&quot;</span></div>
<div class="line">*  <a class="code" href="../../d1/d43/DataList_8h.html#a9051b45fea61ed235640253b4efdb86b">DATALIST_BASE</a>(D,B);</div>
<div class="line">*  <span class="keyword">typedef</span> <a class="code" href="../../d9/dfb/classDataList.html">DataList&lt;D&gt;</a> DVec;</div>
</div><!-- fragment --><p>D2List.h: </p>
<div class="fragment"><div class="line">*  #include <span class="stringliteral">&quot;D2.h&quot;</span></div>
<div class="line">*  #include <span class="stringliteral">&quot;DataList.h&quot;</span></div>
<div class="line">*  #include <span class="stringliteral">&quot;DList.h&quot;</span> <span class="comment">// This is required</span></div>
<div class="line">*  <a class="code" href="../../d1/d43/DataList_8h.html#a9051b45fea61ed235640253b4efdb86b">DATALIST_BASE</a>(D2,D);</div>
<div class="line">*  <span class="keyword">typedef</span> <a class="code" href="../../d9/dfb/classDataList.html">DataList&lt;D2&gt;</a> DVec;</div>
</div><!-- fragment --><p>Using <code>DATALIST_BASE</code> will also set up the corresponding <code>SG::BaseInfo</code> definitions, both for the vectors themselves and for the contained objects. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a9051b45fea61ed235640253b4efdb86b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DATALIST_BASE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BASE&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span><a class="code" href="../../d2/de9/structDataListBase.html">DataListBase</a>&lt;T&gt;      \</div>
<div class="line">{ <span class="keyword">typedef</span> <a class="code" href="../../d9/dfb/classDataList.html">DataList&lt;BASE&gt;</a> Base; };       \</div>
<div class="line">SG_BASE(<a class="code" href="../../d9/dfb/classDataList.html">DataList&lt;T&gt;</a>, <a class="code" href="../../d9/dfb/classDataList.html">DataList&lt;BASE&gt;</a>); \</div>
<div class="line">template <span class="keyword">struct </span>DataList_detail::DVLEltBaseInit&lt;T&gt;</div>
<div class="ttc" id="classDataList_html"><div class="ttname"><a href="../../d9/dfb/classDataList.html">DataList</a></div><div class="ttdoc">Derived DataList&amp;lt;T&amp;gt;. </div><div class="ttdef"><b>Definition:</b> DataList.h:260</div></div>
<div class="ttc" id="structDataListBase_html"><div class="ttname"><a href="../../d2/de9/structDataListBase.html">DataListBase</a></div><div class="ttdoc">Derivation information for DataList. </div><div class="ttdef"><b>Definition:</b> DataList.h:298</div></div>
</div><!-- fragment -->
<p>Declare base class info to <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code>. Single, non-virtual derivation. </p>
<p><code><a class="el" href="../../d1/d43/DataList_8h.html#a9051b45fea61ed235640253b4efdb86b" title="Declare base class info to DataList. Single, non-virtual derivation. ">DATALIST_BASE(D, B)</a></code> says that <code>D</code> derives non-virtually from <code>B</code>.</p>
<p>This macro creates an appropriate specialization of <code><a class="el" href="../../d2/de9/structDataListBase.html" title="Derivation information for DataList. ">DataListBase</a></code>. </p>

</div>
</div>
<a class="anchor" id="abfa1a94e27e2aa31a9e5de856c459b41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DATALIST_VIRTBASES1</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">B1&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span><a class="code" href="../../d2/de9/structDataListBase.html">DataListBase</a>&lt;T&gt;                  \</div>
<div class="line">{ <span class="keyword">typedef</span> <a class="code" href="../../d5/dec/structDataList__detail_1_1VirtBases.html">DataList_detail::VirtBases&lt;B1&gt;</a> Base; };   \</div>
<div class="line">SG_BASES1(<a class="code" href="../../d9/dfb/classDataList.html">DataList&lt;T&gt;</a>, SG_VIRTUAL(<a class="code" href="../../d9/dfb/classDataList.html">DataList&lt;B1&gt;</a>)); \</div>
<div class="line">template <span class="keyword">struct </span>DataList_detail::DVLEltBaseInit&lt;T&gt;</div>
<div class="ttc" id="structDataList__detail_1_1VirtBases_html"><div class="ttname"><a href="../../d5/dec/structDataList__detail_1_1VirtBases.html">DataList_detail::VirtBases</a></div><div class="ttdoc">VirtBases for three classes. </div><div class="ttdef"><b>Definition:</b> DataList.h:285</div></div>
<div class="ttc" id="classDataList_html"><div class="ttname"><a href="../../d9/dfb/classDataList.html">DataList</a></div><div class="ttdoc">Derived DataList&amp;lt;T&amp;gt;. </div><div class="ttdef"><b>Definition:</b> DataList.h:260</div></div>
<div class="ttc" id="structDataListBase_html"><div class="ttname"><a href="../../d2/de9/structDataListBase.html">DataListBase</a></div><div class="ttdoc">Derivation information for DataList. </div><div class="ttdef"><b>Definition:</b> DataList.h:298</div></div>
</div><!-- fragment -->
<p>Declare base class info to <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code>. Single, virtual derivation. </p>
<p><code>DATALIST_VIRTBASES(D, B1)</code> says that <code>D</code> derives virtually from <code>B1</code>.</p>
<p>This macro creates an appropriate specialization of <code><a class="el" href="../../d2/de9/structDataListBase.html" title="Derivation information for DataList. ">DataListBase</a></code>. </p>

</div>
</div>
<a class="anchor" id="ad7ad3d1a23e99411007da14017fad6c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DATALIST_VIRTBASES2</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">B1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">B2&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span><a class="code" href="../../d2/de9/structDataListBase.html">DataListBase</a>&lt;T&gt;                    \</div>
<div class="line">{ <span class="keyword">typedef</span> <a class="code" href="../../d5/dec/structDataList__detail_1_1VirtBases.html">DataList_detail::VirtBases&lt;B1, B2&gt;</a> Base; }; \</div>
<div class="line">SG_BASES2(<a class="code" href="../../d9/dfb/classDataList.html">DataList&lt;T&gt;</a>, SG_VIRTUAL(<a class="code" href="../../d9/dfb/classDataList.html">DataList&lt;B1&gt;</a>),      \</div>
<div class="line">                       SG_VIRTUAL(<a class="code" href="../../d9/dfb/classDataList.html">DataList&lt;B2&gt;</a>)); \</div>
<div class="line">template <span class="keyword">struct </span>DataList_detail::DVLEltBaseInit&lt;T&gt;</div>
<div class="ttc" id="structDataList__detail_1_1VirtBases_html"><div class="ttname"><a href="../../d5/dec/structDataList__detail_1_1VirtBases.html">DataList_detail::VirtBases</a></div><div class="ttdoc">VirtBases for three classes. </div><div class="ttdef"><b>Definition:</b> DataList.h:285</div></div>
<div class="ttc" id="classDataList_html"><div class="ttname"><a href="../../d9/dfb/classDataList.html">DataList</a></div><div class="ttdoc">Derived DataList&amp;lt;T&amp;gt;. </div><div class="ttdef"><b>Definition:</b> DataList.h:260</div></div>
<div class="ttc" id="structDataListBase_html"><div class="ttname"><a href="../../d2/de9/structDataListBase.html">DataListBase</a></div><div class="ttdoc">Derivation information for DataList. </div><div class="ttdef"><b>Definition:</b> DataList.h:298</div></div>
</div><!-- fragment -->
<p>Declare base class info to <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code>. Multiple derivation. </p>
<p><code>DATALIST_VIRTBASES(D, B1)</code> says that <code>D</code> derives from both <code>B1</code> and <code>B2</code>.</p>
<p>This macro creates an appropriate specialization of <code><a class="el" href="../../d2/de9/structDataListBase.html" title="Derivation information for DataList. ">DataListBase</a></code>. </p>

</div>
</div>
<a class="anchor" id="a3c2f8a00c08d0ffcb32fc1592a4a52d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DATALIST_VIRTBASES3</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">B1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">B2, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">B3&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span><a class="code" href="../../d2/de9/structDataListBase.html">DataListBase</a>&lt;T&gt;                    \</div>
<div class="line">{ <span class="keyword">typedef</span> <a class="code" href="../../d5/dec/structDataList__detail_1_1VirtBases.html">DataList_detail::VirtBases&lt;B1, B2, B3&gt;</a> Base; }; \</div>
<div class="line">SG_BASES3(<a class="code" href="../../d9/dfb/classDataList.html">DataList&lt;T&gt;</a>, SG_VIRTUAL(<a class="code" href="../../d9/dfb/classDataList.html">DataList&lt;B1&gt;</a>),          \</div>
<div class="line">               SG_VIRTUAL(<a class="code" href="../../d9/dfb/classDataList.html">DataList&lt;B2&gt;</a>),          \</div>
<div class="line">               SG_VIRTUAL(<a class="code" href="../../d9/dfb/classDataList.html">DataList&lt;B3&gt;</a>)); \</div>
<div class="line">template <span class="keyword">struct </span>DataList_detail::DVLEltBaseInit&lt;T&gt;</div>
<div class="ttc" id="structDataList__detail_1_1VirtBases_html"><div class="ttname"><a href="../../d5/dec/structDataList__detail_1_1VirtBases.html">DataList_detail::VirtBases</a></div><div class="ttdoc">VirtBases for three classes. </div><div class="ttdef"><b>Definition:</b> DataList.h:285</div></div>
<div class="ttc" id="classDataList_html"><div class="ttname"><a href="../../d9/dfb/classDataList.html">DataList</a></div><div class="ttdoc">Derived DataList&amp;lt;T&amp;gt;. </div><div class="ttdef"><b>Definition:</b> DataList.h:260</div></div>
<div class="ttc" id="structDataListBase_html"><div class="ttname"><a href="../../d2/de9/structDataListBase.html">DataListBase</a></div><div class="ttdoc">Derivation information for DataList. </div><div class="ttdef"><b>Definition:</b> DataList.h:298</div></div>
</div><!-- fragment -->
<p>Declare base class info to <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code>. Multiple derivation. </p>
<p><code>DATALIST_VIRTBASES(D, B1)</code> says that <code>D</code> derives from all of <code>B1</code>, <code>B2</code>, and <code>B3</code>.</p>
<p>This macro creates an appropriate specialization of <code><a class="el" href="../../d2/de9/structDataListBase.html" title="Derivation information for DataList. ">DataListBase</a></code>. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a6f545af795991d4ea90a9bc52e9863d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List ordering relation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code>. </td></tr>
    <tr><td class="paramname">b</td><td>A <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code> of the same type as <em>a</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>a</em> is lexicographically less than <em>b</em>.</dd></dl>
<p>This is a total ordering relation. It is linear in the size of the lists. Comparisons are done on the pointer values of the elements.</p>
<p>See <code>std::lexicographical_compare()</code> for how the determination is made.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code>. </td></tr>
    <tr><td class="paramname">b</td><td>A <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code> of the same type as <em>x</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True iff <em>x</em> is lexicographically less than <em>y</em>.</dd></dl>
<p>This is a total ordering relation. It is linear in the size of the lists. Comparisons are done on the pointer values of the elements.</p>
<p>See <code>std::lexicographical_compare()</code> for how the determination is made. </p>

</div>
</div>
<a class="anchor" id="ac23672b73979c2bef800470a4aa12b43"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List equality comparison. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code>. </td></tr>
    <tr><td class="paramname">b</td><td>A <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code> of the same type as <em>a</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the size and elements of the lists are equal.</dd></dl>
<p>This is an equivalence relation. It is linear in the size of the lists. Lists are considered equivalent if their sizes are equal, and if corresponding elements compare equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code>. </td></tr>
    <tr><td class="paramname">b</td><td>A <code><a class="el" href="../../d9/dfb/classDataList.html" title="Derived DataList&lt;T&gt;. ">DataList</a></code> of the same type as <em>x</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True iff the size and elements of the lists are equal.</dd></dl>
<p>This is an equivalence relation. It is linear in the size of the lists. Lists are considered equivalent if their sizes are equal, and if corresponding elements compare equal. </p>

</div>
</div>
<a class="anchor" id="a9681a82cd13d8cb83cfaa64a8ebe9c07"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dfb/classDataList.html">DataList</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <code>DataList&lt;T, BASE&gt;::swap()</code>. </p>
<p>See <code>DataList&lt;T, BASE&gt;::swap()</code>. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Dec 1 2017 11:08:36 for RootCore Packages by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
