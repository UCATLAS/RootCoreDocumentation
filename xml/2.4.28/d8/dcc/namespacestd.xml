<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.6.1">
  <compounddef id="d8/dcc/namespacestd" kind="namespace">
    <compoundname>std</compoundname>
    <innernamespace refid="d2/db7/namespacestd_1_1tr1">std::tr1</innernamespace>
      <sectiondef kind="func">
      <memberdef kind="function" id="d8/dcc/namespacestd_1a52052a6375c7e083417e604ead7510eb" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class DVL</type>
          </param>
          <param>
            <type>class <ref refid="d1/def/classT" kindref="compound">T</ref></type>
          </param>
        </templateparamlist>
        <type><ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt;</type>
        <definition>DataModel_detail::iterator&lt;DVL&gt; std::remove</definition>
        <argsstring>(typename DataModel_detail::iterator&lt; DVL &gt; beg, typename DataModel_detail::iterator&lt; DVL &gt; end, const T &amp;value)</argsstring>
        <name>remove</name>
        <param>
          <type>typename <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt;</type>
          <declname>beg</declname>
        </param>
        <param>
          <type>typename <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt;</type>
          <declname>end</declname>
        </param>
        <param>
          <type>const <ref refid="d1/def/classT" kindref="compound">T</ref> &amp;</type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>Specialization of <computeroutput>remove</computeroutput> for <computeroutput>DataVector/List</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>beg</parametername>
</parameternamelist>
<parameterdescription>
<para>The start iterator for the remove. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>The end iterator for the remove. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>value</parametername>
</parameternamelist>
<parameterdescription>
<para>The value to remove.</para></parameterdescription>
</parameteritem>
</parameterlist>
<computeroutput>beg</computeroutput> and <computeroutput>end</computeroutput> should both be iterators from the same <computeroutput>DataVector/List</computeroutput>. This performs the remove in a way that doesn&apos;t run afoul of <computeroutput>DataVector/List&apos;s</computeroutput> object ownership rules. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" line="47" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" bodystart="44" bodyend="50"/>
      </memberdef>
      <memberdef kind="function" id="d8/dcc/namespacestd_1af001793d497144cfbb7bccf0318ff2ac" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class DVL</type>
          </param>
          <param>
            <type>class Predicate</type>
          </param>
        </templateparamlist>
        <type><ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt;</type>
        <definition>DataModel_detail::iterator&lt;DVL&gt; std::remove_if</definition>
        <argsstring>(typename DataModel_detail::iterator&lt; DVL &gt; beg, typename DataModel_detail::iterator&lt; DVL &gt; end, Predicate pred)</argsstring>
        <name>remove_if</name>
        <param>
          <type>typename <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt;</type>
          <declname>beg</declname>
        </param>
        <param>
          <type>typename <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt;</type>
          <declname>end</declname>
        </param>
        <param>
          <type>Predicate</type>
          <declname>pred</declname>
        </param>
        <briefdescription>
<para>Specialization of <computeroutput>remove_if</computeroutput> for <computeroutput>DataVector/List</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>beg</parametername>
</parameternamelist>
<parameterdescription>
<para>The start iterator for the remove. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>The end iterator for the remove. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pred</parametername>
</parameternamelist>
<parameterdescription>
<para>The predicate for the removal.</para></parameterdescription>
</parameteritem>
</parameterlist>
<computeroutput>beg</computeroutput> and <computeroutput>end</computeroutput> should both be iterators from the same <computeroutput>DataVector/List</computeroutput>. This performs the remove in a way that doesn&apos;t run afoul of <computeroutput>DataVector/List&apos;s</computeroutput> object ownership rules. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" line="68" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" bodystart="65" bodyend="71"/>
      </memberdef>
      <memberdef kind="function" id="d8/dcc/namespacestd_1a9849cf20655131c591361f1581910663" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class DVL</type>
          </param>
          <param>
            <type>class <ref refid="d1/def/classT" kindref="compound">T</ref></type>
          </param>
        </templateparamlist>
        <type>std::reverse_iterator&lt; <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt; &gt;</type>
        <definition>std::reverse_iterator&lt;DataModel_detail::iterator&lt;DVL&gt; &gt; std::remove</definition>
        <argsstring>(typename std::reverse_iterator&lt; DataModel_detail::iterator&lt; DVL &gt; &gt; beg, typename std::reverse_iterator&lt; DataModel_detail::iterator&lt; DVL &gt; &gt; end, const T &amp;value)</argsstring>
        <name>remove</name>
        <param>
          <type>typename std::reverse_iterator&lt; <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt; &gt;</type>
          <declname>beg</declname>
        </param>
        <param>
          <type>typename std::reverse_iterator&lt; <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt; &gt;</type>
          <declname>end</declname>
        </param>
        <param>
          <type>const <ref refid="d1/def/classT" kindref="compound">T</ref> &amp;</type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>Specialization of <computeroutput>remove</computeroutput> for <computeroutput>DataVector/List</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>beg</parametername>
</parameternamelist>
<parameterdescription>
<para>The start reverse_iterator for the remove. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>The end reverse_iterator for the remove. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>value</parametername>
</parameternamelist>
<parameterdescription>
<para>The value to remove.</para></parameterdescription>
</parameteritem>
</parameterlist>
<computeroutput>beg</computeroutput> and <computeroutput>end</computeroutput> should both be reverseIterators from the same <computeroutput>DataVector/List</computeroutput>. This performs the remove in a way that doesn&apos;t run afoul of <computeroutput>DataVector/List&apos;s</computeroutput> object ownership rules. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" line="90" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" bodystart="87" bodyend="93"/>
      </memberdef>
      <memberdef kind="function" id="d8/dcc/namespacestd_1a0e2e64aa483ba74b54e362e247c41be1" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class DVL</type>
          </param>
          <param>
            <type>class Predicate</type>
          </param>
        </templateparamlist>
        <type>std::reverse_iterator&lt; <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt; &gt;</type>
        <definition>std::reverse_iterator&lt;DataModel_detail::iterator&lt;DVL&gt; &gt; std::remove_if</definition>
        <argsstring>(typename std::reverse_iterator&lt; DataModel_detail::iterator&lt; DVL &gt; &gt; beg, typename std::reverse_iterator&lt; DataModel_detail::iterator&lt; DVL &gt; &gt; end, Predicate pred)</argsstring>
        <name>remove_if</name>
        <param>
          <type>typename std::reverse_iterator&lt; <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt; &gt;</type>
          <declname>beg</declname>
        </param>
        <param>
          <type>typename std::reverse_iterator&lt; <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt; &gt;</type>
          <declname>end</declname>
        </param>
        <param>
          <type>Predicate</type>
          <declname>pred</declname>
        </param>
        <briefdescription>
<para>Specialization of <computeroutput>remove_if</computeroutput> for <computeroutput>DataVector/List</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>beg</parametername>
</parameternamelist>
<parameterdescription>
<para>The start reverse_iterator for the remove. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>The end reverse_iterator for the remove. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pred</parametername>
</parameternamelist>
<parameterdescription>
<para>The predicate for the removal.</para></parameterdescription>
</parameteritem>
</parameterlist>
<computeroutput>beg</computeroutput> and <computeroutput>end</computeroutput> should both be reverse_iterators from the same <computeroutput>DataVector/List</computeroutput>. This performs the remove in a way that doesn&apos;t run afoul of <computeroutput>DataVector/List&apos;s</computeroutput> object ownership rules. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" line="112" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" bodystart="109" bodyend="115"/>
      </memberdef>
      <memberdef kind="function" id="d8/dcc/namespacestd_1a93ccd8189817199986fe997437ce745f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class DVL</type>
          </param>
        </templateparamlist>
        <type><ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt;</type>
        <definition>DataModel_detail::iterator&lt;DVL&gt; std::unique</definition>
        <argsstring>(typename DataModel_detail::iterator&lt; DVL &gt; beg, typename DataModel_detail::iterator&lt; DVL &gt; end)</argsstring>
        <name>unique</name>
        <param>
          <type>typename <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt;</type>
          <declname>beg</declname>
        </param>
        <param>
          <type>typename <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt;</type>
          <declname>end</declname>
        </param>
        <briefdescription>
<para>Specialization of <computeroutput>unique</computeroutput> for <computeroutput>DataVector/List</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>beg</parametername>
</parameternamelist>
<parameterdescription>
<para>The start iterator for the unique operation. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>The end iterator for the unique operation. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>value</parametername>
</parameternamelist>
<parameterdescription>
<para>The value to remove.</para></parameterdescription>
</parameteritem>
</parameterlist>
<computeroutput>beg</computeroutput> and <computeroutput>end</computeroutput> should both be iterators from the same <computeroutput>DataVector/List</computeroutput>. This performs the operation in a way that doesn&apos;t run afoul of <computeroutput>DataVector/List&apos;s</computeroutput> object ownership rules. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" line="132" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" bodystart="130" bodyend="135"/>
      </memberdef>
      <memberdef kind="function" id="d8/dcc/namespacestd_1a28671c92723d9a572bc542edcbe66743" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class DVL</type>
          </param>
          <param>
            <type>class BinaryPredicate</type>
          </param>
        </templateparamlist>
        <type><ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt;</type>
        <definition>DataModel_detail::iterator&lt;DVL&gt; std::unique</definition>
        <argsstring>(typename DataModel_detail::iterator&lt; DVL &gt; beg, typename DataModel_detail::iterator&lt; DVL &gt; end, BinaryPredicate pred)</argsstring>
        <name>unique</name>
        <param>
          <type>typename <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt;</type>
          <declname>beg</declname>
        </param>
        <param>
          <type>typename <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt;</type>
          <declname>end</declname>
        </param>
        <param>
          <type>BinaryPredicate</type>
          <declname>pred</declname>
        </param>
        <briefdescription>
<para>Specialization of <computeroutput>unique</computeroutput> for <computeroutput>DataVector/List</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>beg</parametername>
</parameternamelist>
<parameterdescription>
<para>The start iterator for the unique operation. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>The end iterator for the unique operation. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pred</parametername>
</parameternamelist>
<parameterdescription>
<para>The predicate for the operation.</para></parameterdescription>
</parameteritem>
</parameterlist>
<computeroutput>beg</computeroutput> and <computeroutput>end</computeroutput> should both be iterators from the same <computeroutput>DataVector/List</computeroutput>. This performs the operation in a way that doesn&apos;t run afoul of <computeroutput>DataVector/List&apos;s</computeroutput> object ownership rules. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" line="153" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" bodystart="150" bodyend="156"/>
      </memberdef>
      <memberdef kind="function" id="d8/dcc/namespacestd_1a926187a68787316a24bb8509a45ae552" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class DVL</type>
          </param>
        </templateparamlist>
        <type>std::reverse_iterator&lt; <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt; &gt;</type>
        <definition>std::reverse_iterator&lt;DataModel_detail::iterator&lt;DVL&gt; &gt; std::unique</definition>
        <argsstring>(typename std::reverse_iterator&lt; DataModel_detail::iterator&lt; DVL &gt; &gt; beg, typename std::reverse_iterator&lt; DataModel_detail::iterator&lt; DVL &gt; &gt; end)</argsstring>
        <name>unique</name>
        <param>
          <type>typename std::reverse_iterator&lt; <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt; &gt;</type>
          <declname>beg</declname>
        </param>
        <param>
          <type>typename std::reverse_iterator&lt; <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt; &gt;</type>
          <declname>end</declname>
        </param>
        <briefdescription>
<para>Specialization of <computeroutput>unique</computeroutput> for <computeroutput>DataVector/List</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>beg</parametername>
</parameternamelist>
<parameterdescription>
<para>The start reverse_iterator for the unique operation. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>The end reverse_iterator for the unique operation. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>value</parametername>
</parameternamelist>
<parameterdescription>
<para>The value to remove.</para></parameterdescription>
</parameteritem>
</parameterlist>
<computeroutput>beg</computeroutput> and <computeroutput>end</computeroutput> should both be reverse_iterators from the same <computeroutput>DataVector/List</computeroutput>. This performs the operation in a way that doesn&apos;t run afoul of <computeroutput>DataVector/List&apos;s</computeroutput> object ownership rules. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" line="174" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" bodystart="172" bodyend="177"/>
      </memberdef>
      <memberdef kind="function" id="d8/dcc/namespacestd_1af9abad5247179d9cb586e5703f285195" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class DVL</type>
          </param>
          <param>
            <type>class BinaryPredicate</type>
          </param>
        </templateparamlist>
        <type>std::reverse_iterator&lt; <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt; &gt;</type>
        <definition>std::reverse_iterator&lt;DataModel_detail::iterator&lt;DVL&gt; &gt; std::unique</definition>
        <argsstring>(typename std::reverse_iterator&lt; DataModel_detail::iterator&lt; DVL &gt; &gt; beg, typename std::reverse_iterator&lt; DataModel_detail::iterator&lt; DVL &gt; &gt; end, BinaryPredicate pred)</argsstring>
        <name>unique</name>
        <param>
          <type>typename std::reverse_iterator&lt; <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt; &gt;</type>
          <declname>beg</declname>
        </param>
        <param>
          <type>typename std::reverse_iterator&lt; <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt; &gt;</type>
          <declname>end</declname>
        </param>
        <param>
          <type>BinaryPredicate</type>
          <declname>pred</declname>
        </param>
        <briefdescription>
<para>Specialization of <computeroutput>unique</computeroutput> for <computeroutput>DataVector/List</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>beg</parametername>
</parameternamelist>
<parameterdescription>
<para>The start reverse_iterator for the unique operation. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>The end reverse_iterator for the unique operation. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pred</parametername>
</parameternamelist>
<parameterdescription>
<para>The predicate for the operation.</para></parameterdescription>
</parameteritem>
</parameterlist>
<computeroutput>beg</computeroutput> and <computeroutput>end</computeroutput> should both be reverse_iterators from the same <computeroutput>DataVector/List</computeroutput>. This performs the operation in a way that doesn&apos;t run afoul of <computeroutput>DataVector/List&apos;s</computeroutput> object ownership rules. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" line="197" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" bodystart="194" bodyend="200"/>
      </memberdef>
      <memberdef kind="function" id="d8/dcc/namespacestd_1a26f6b28fcc5a734b2a96e5de0e316246" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class DVL</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void std::rotate</definition>
        <argsstring>(typename DataModel_detail::iterator&lt; DVL &gt; beg, typename DataModel_detail::iterator&lt; DVL &gt; mid, typename DataModel_detail::iterator&lt; DVL &gt; end)</argsstring>
        <name>rotate</name>
        <param>
          <type>typename <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt;</type>
          <declname>beg</declname>
        </param>
        <param>
          <type>typename <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt;</type>
          <declname>mid</declname>
        </param>
        <param>
          <type>typename <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt;</type>
          <declname>end</declname>
        </param>
        <briefdescription>
<para>Specialization of <computeroutput>rotate</computeroutput> for <computeroutput>DataVector/List</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>beg</parametername>
</parameternamelist>
<parameterdescription>
<para>The start iterator for the rotate operation. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mid</parametername>
</parameternamelist>
<parameterdescription>
<para>The middle iterator for the rotate operation. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>The end iterator for the rotate operation.</para></parameterdescription>
</parameteritem>
</parameterlist>
<computeroutput>beg</computeroutput> and <computeroutput>end</computeroutput> should both be iterators from the same <computeroutput>DataVector/List</computeroutput>. This performs the operation in a way that doesn&apos;t run afoul of <computeroutput>DataVector/List&apos;s</computeroutput> object ownership rules. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" line="219" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" bodystart="216" bodyend="222"/>
      </memberdef>
      <memberdef kind="function" id="d8/dcc/namespacestd_1aca89581d3d0ca54509414e0cc5a3185c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class DVL</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void std::rotate</definition>
        <argsstring>(typename std::reverse_iterator&lt; DataModel_detail::iterator&lt; DVL &gt; &gt; beg, typename std::reverse_iterator&lt; DataModel_detail::iterator&lt; DVL &gt; &gt; mid, typename std::reverse_iterator&lt; DataModel_detail::iterator&lt; DVL &gt; &gt; end)</argsstring>
        <name>rotate</name>
        <param>
          <type>typename std::reverse_iterator&lt; <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt; &gt;</type>
          <declname>beg</declname>
        </param>
        <param>
          <type>typename std::reverse_iterator&lt; <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt; &gt;</type>
          <declname>mid</declname>
        </param>
        <param>
          <type>typename std::reverse_iterator&lt; <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt; &gt;</type>
          <declname>end</declname>
        </param>
        <briefdescription>
<para>Specialization of <computeroutput>rotate</computeroutput> for <computeroutput>DataVector/List</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>beg</parametername>
</parameternamelist>
<parameterdescription>
<para>The start reverse_iterator for the rotate operation. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mid</parametername>
</parameternamelist>
<parameterdescription>
<para>The middle reverse_iterator for the rotate operation. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>The end reverse_iterator for the rotate operation.</para></parameterdescription>
</parameteritem>
</parameterlist>
<computeroutput>beg</computeroutput> and <computeroutput>end</computeroutput> should both be reverse_iterators from the same <computeroutput>DataVector/List</computeroutput>. This performs the operation in a way that doesn&apos;t run afoul of <computeroutput>DataVector/List&apos;s</computeroutput> object ownership rules. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" line="242" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" bodystart="239" bodyend="248"/>
      </memberdef>
      <memberdef kind="function" id="d8/dcc/namespacestd_1ac9bf18198cb4037a6989c70e9226e370" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class DVL</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void std::reverse</definition>
        <argsstring>(typename DataModel_detail::iterator&lt; DVL &gt; beg, typename DataModel_detail::iterator&lt; DVL &gt; end)</argsstring>
        <name>reverse</name>
        <param>
          <type>typename <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt;</type>
          <declname>beg</declname>
        </param>
        <param>
          <type>typename <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt;</type>
          <declname>end</declname>
        </param>
        <briefdescription>
<para>Specialization of <computeroutput>reverse</computeroutput> for <computeroutput>DataVector/List</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>beg</parametername>
</parameternamelist>
<parameterdescription>
<para>The start iterator for the reverse operation. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>The end iterator for the reverse operation.</para></parameterdescription>
</parameteritem>
</parameterlist>
<computeroutput>beg</computeroutput> and <computeroutput>end</computeroutput> should both be iterators from the same <computeroutput>DataVector/List</computeroutput>. This performs the operation in a way that doesn&apos;t run afoul of <computeroutput>DataVector/List&apos;s</computeroutput> object ownership rules. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" line="277" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" bodystart="275" bodyend="280"/>
      </memberdef>
      <memberdef kind="function" id="d8/dcc/namespacestd_1a7feb83fa64839a08207bf4b2ff049f17" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class DVL</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void std::reverse</definition>
        <argsstring>(typename std::reverse_iterator&lt; DataModel_detail::iterator&lt; DVL &gt; &gt; beg, typename std::reverse_iterator&lt; DataModel_detail::iterator&lt; DVL &gt; &gt; end)</argsstring>
        <name>reverse</name>
        <param>
          <type>typename std::reverse_iterator&lt; <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt; &gt;</type>
          <declname>beg</declname>
        </param>
        <param>
          <type>typename std::reverse_iterator&lt; <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt; &gt;</type>
          <declname>end</declname>
        </param>
        <briefdescription>
<para>Specialization of <computeroutput>reverse</computeroutput> for <computeroutput>DataVector/List</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>beg</parametername>
</parameternamelist>
<parameterdescription>
<para>The start reverse_iterator for the reverse operation. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>The end reverse_iterator for the reverse operation.</para></parameterdescription>
</parameteritem>
</parameterlist>
<computeroutput>beg</computeroutput> and <computeroutput>end</computeroutput> should both be reverse_iterators from the same <computeroutput>DataVector/List</computeroutput>. This performs the operation in a way that doesn&apos;t run afoul of <computeroutput>DataVector/List&apos;s</computeroutput> object ownership rules. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" line="298" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" bodystart="296" bodyend="302"/>
      </memberdef>
      <memberdef kind="function" id="d8/dcc/namespacestd_1af47f9d9500ca1727963547da76d9e674" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class DVL</type>
          </param>
          <param>
            <type>class Predicate</type>
          </param>
        </templateparamlist>
        <type><ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt;</type>
        <definition>DataModel_detail::iterator&lt;DVL&gt; std::partition</definition>
        <argsstring>(typename DataModel_detail::iterator&lt; DVL &gt; beg, typename DataModel_detail::iterator&lt; DVL &gt; end, Predicate pred)</argsstring>
        <name>partition</name>
        <param>
          <type>typename <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt;</type>
          <declname>beg</declname>
        </param>
        <param>
          <type>typename <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt;</type>
          <declname>end</declname>
        </param>
        <param>
          <type>Predicate</type>
          <declname>pred</declname>
        </param>
        <briefdescription>
<para>Specialization of <computeroutput>partition</computeroutput> for <computeroutput>DataVector/List</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>beg</parametername>
</parameternamelist>
<parameterdescription>
<para>The start iterator for the partition operation. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>The end iterator for the partition operation. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pred</parametername>
</parameternamelist>
<parameterdescription>
<para>The predicate for the partition.</para></parameterdescription>
</parameteritem>
</parameterlist>
<computeroutput>beg</computeroutput> and <computeroutput>end</computeroutput> should both be iterators from the same <computeroutput>DataVector/List</computeroutput>. This performs the operation in a way that doesn&apos;t run afoul of <computeroutput>DataVector/List&apos;s</computeroutput> object ownership rules. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" line="322" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" bodystart="319" bodyend="329"/>
      </memberdef>
      <memberdef kind="function" id="d8/dcc/namespacestd_1a3ff02fd796e6cfda1b0b2856f3b824ee" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class DVL</type>
          </param>
          <param>
            <type>class Predicate</type>
          </param>
        </templateparamlist>
        <type>std::reverse_iterator&lt; <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt; &gt;</type>
        <definition>std::reverse_iterator&lt;DataModel_detail::iterator&lt;DVL&gt; &gt; std::partition</definition>
        <argsstring>(typename std::reverse_iterator&lt; DataModel_detail::iterator&lt; DVL &gt; &gt; beg, typename std::reverse_iterator&lt; DataModel_detail::iterator&lt; DVL &gt; &gt; end, Predicate pred)</argsstring>
        <name>partition</name>
        <param>
          <type>typename std::reverse_iterator&lt; <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt; &gt;</type>
          <declname>beg</declname>
        </param>
        <param>
          <type>typename std::reverse_iterator&lt; <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt; &gt;</type>
          <declname>end</declname>
        </param>
        <param>
          <type>Predicate</type>
          <declname>pred</declname>
        </param>
        <briefdescription>
<para>Specialization of <computeroutput>partition</computeroutput> for <computeroutput>DataVector/List</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>beg</parametername>
</parameternamelist>
<parameterdescription>
<para>The start reverse_iterator for the partition operation. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>The end reverse_iterator for the partition operation. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pred</parametername>
</parameternamelist>
<parameterdescription>
<para>The predicate for the partition.</para></parameterdescription>
</parameteritem>
</parameterlist>
<computeroutput>beg</computeroutput> and <computeroutput>end</computeroutput> should both be reverse_iterators from the same <computeroutput>DataVector/List</computeroutput>. This performs the operation in a way that doesn&apos;t run afoul of <computeroutput>DataVector/List&apos;s</computeroutput> object ownership rules. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" line="349" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" bodystart="346" bodyend="360"/>
      </memberdef>
      <memberdef kind="function" id="d8/dcc/namespacestd_1ad88a83b279a8b59a11dc4391902d17b0" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class DVL</type>
          </param>
          <param>
            <type>class Predicate</type>
          </param>
        </templateparamlist>
        <type><ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt;</type>
        <definition>DataModel_detail::iterator&lt;DVL&gt; std::stable_partition</definition>
        <argsstring>(typename DataModel_detail::iterator&lt; DVL &gt; beg, typename DataModel_detail::iterator&lt; DVL &gt; end, Predicate pred)</argsstring>
        <name>stable_partition</name>
        <param>
          <type>typename <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt;</type>
          <declname>beg</declname>
        </param>
        <param>
          <type>typename <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt;</type>
          <declname>end</declname>
        </param>
        <param>
          <type>Predicate</type>
          <declname>pred</declname>
        </param>
        <briefdescription>
<para>Specialization of <computeroutput>stable_partition</computeroutput> for <computeroutput>DataVector/List</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>beg</parametername>
</parameternamelist>
<parameterdescription>
<para>The start iterator for the partition operation. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>The end iterator for the partition operation. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pred</parametername>
</parameternamelist>
<parameterdescription>
<para>The predicate for the partition.</para></parameterdescription>
</parameteritem>
</parameterlist>
<computeroutput>beg</computeroutput> and <computeroutput>end</computeroutput> should both be iterators from the same <computeroutput>DataVector/List</computeroutput>. This performs the operation in a way that doesn&apos;t run afoul of <computeroutput>DataVector/List&apos;s</computeroutput> object ownership rules. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" line="380" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" bodystart="377" bodyend="388"/>
      </memberdef>
      <memberdef kind="function" id="d8/dcc/namespacestd_1ab67faf66a9baa5d17c94efa3df53f989" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class DVL</type>
          </param>
          <param>
            <type>class Predicate</type>
          </param>
        </templateparamlist>
        <type>std::reverse_iterator&lt; <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt; &gt;</type>
        <definition>std::reverse_iterator&lt;DataModel_detail::iterator&lt;DVL&gt; &gt; std::stable_partition</definition>
        <argsstring>(typename std::reverse_iterator&lt; DataModel_detail::iterator&lt; DVL &gt; &gt; beg, typename std::reverse_iterator&lt; DataModel_detail::iterator&lt; DVL &gt; &gt; end, Predicate pred)</argsstring>
        <name>stable_partition</name>
        <param>
          <type>typename std::reverse_iterator&lt; <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt; &gt;</type>
          <declname>beg</declname>
        </param>
        <param>
          <type>typename std::reverse_iterator&lt; <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt; &gt;</type>
          <declname>end</declname>
        </param>
        <param>
          <type>Predicate</type>
          <declname>pred</declname>
        </param>
        <briefdescription>
<para>Specialization of <computeroutput>stable_partition</computeroutput> for <computeroutput>DataVector/List</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>beg</parametername>
</parameternamelist>
<parameterdescription>
<para>The start reverse_iterator for the partition operation. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>The end reverse_iterator for the partition operation. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pred</parametername>
</parameternamelist>
<parameterdescription>
<para>The predicate for the partition.</para></parameterdescription>
</parameteritem>
</parameterlist>
<computeroutput>beg</computeroutput> and <computeroutput>end</computeroutput> should both be reverse_iterators from the same <computeroutput>DataVector/List</computeroutput>. This performs the operation in a way that doesn&apos;t run afoul of <computeroutput>DataVector/List&apos;s</computeroutput> object ownership rules. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" line="409" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" bodystart="406" bodyend="420"/>
      </memberdef>
      <memberdef kind="function" id="d8/dcc/namespacestd_1aa261ebfd0f7a8a9a1b6360d9f5754934" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class DVL</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void std::inplace_merge</definition>
        <argsstring>(typename DataModel_detail::iterator&lt; DVL &gt; beg, typename DataModel_detail::iterator&lt; DVL &gt; mid, typename DataModel_detail::iterator&lt; DVL &gt; end)</argsstring>
        <name>inplace_merge</name>
        <param>
          <type>typename <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt;</type>
          <declname>beg</declname>
        </param>
        <param>
          <type>typename <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt;</type>
          <declname>mid</declname>
        </param>
        <param>
          <type>typename <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt;</type>
          <declname>end</declname>
        </param>
        <briefdescription>
<para>Specialization of <computeroutput>inplace_merge</computeroutput> for <computeroutput>DataVector/List</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>beg</parametername>
</parameternamelist>
<parameterdescription>
<para>The start iterator for the merge operation. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mid</parametername>
</parameternamelist>
<parameterdescription>
<para>Divider between the two sequences to be merged. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>The end iterator for the merge operation.</para></parameterdescription>
</parameteritem>
</parameterlist>
<computeroutput>beg</computeroutput>, <computeroutput>mid</computeroutput>, and <computeroutput>end</computeroutput> should both be iterators from the same <computeroutput>DataVector/List</computeroutput>. This performs the operation in a way that doesn&apos;t run afoul of <computeroutput>DataVector/List&apos;s</computeroutput> object ownership rules. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" line="440" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" bodystart="437" bodyend="443"/>
      </memberdef>
      <memberdef kind="function" id="d8/dcc/namespacestd_1ad0841ae58d6553e0521b4937550a0ed1" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class DVL</type>
          </param>
          <param>
            <type>class Compare</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void std::inplace_merge</definition>
        <argsstring>(typename DataModel_detail::iterator&lt; DVL &gt; beg, typename DataModel_detail::iterator&lt; DVL &gt; mid, typename DataModel_detail::iterator&lt; DVL &gt; end, Compare comp)</argsstring>
        <name>inplace_merge</name>
        <param>
          <type>typename <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt;</type>
          <declname>beg</declname>
        </param>
        <param>
          <type>typename <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt;</type>
          <declname>mid</declname>
        </param>
        <param>
          <type>typename <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt;</type>
          <declname>end</declname>
        </param>
        <param>
          <type>Compare</type>
          <declname>comp</declname>
        </param>
        <briefdescription>
<para>Specialization of <computeroutput>inplace_merge</computeroutput> for <computeroutput>DataVector/List</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>beg</parametername>
</parameternamelist>
<parameterdescription>
<para>The start iterator for the merge operation. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mid</parametername>
</parameternamelist>
<parameterdescription>
<para>Divider between the two sequences to be merged. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>The end iterator for the merge operation. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>comp</parametername>
</parameternamelist>
<parameterdescription>
<para>The comparison object.</para></parameterdescription>
</parameteritem>
</parameterlist>
<computeroutput>beg</computeroutput>, <computeroutput>mid</computeroutput>, and <computeroutput>end</computeroutput> should both be iterators from the same <computeroutput>DataVector/List</computeroutput>. This performs the operation in a way that doesn&apos;t run afoul of <computeroutput>DataVector/List&apos;s</computeroutput> object ownership rules. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" line="465" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" bodystart="461" bodyend="469"/>
      </memberdef>
      <memberdef kind="function" id="d8/dcc/namespacestd_1a2e92fd31ed38a78da2553ecc79ac4e5a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class DVL</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void std::inplace_merge</definition>
        <argsstring>(typename std::reverse_iterator&lt; DataModel_detail::iterator&lt; DVL &gt; &gt; beg, typename std::reverse_iterator&lt; DataModel_detail::iterator&lt; DVL &gt; &gt; mid, typename std::reverse_iterator&lt; DataModel_detail::iterator&lt; DVL &gt; &gt; end)</argsstring>
        <name>inplace_merge</name>
        <param>
          <type>typename std::reverse_iterator&lt; <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt; &gt;</type>
          <declname>beg</declname>
        </param>
        <param>
          <type>typename std::reverse_iterator&lt; <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt; &gt;</type>
          <declname>mid</declname>
        </param>
        <param>
          <type>typename std::reverse_iterator&lt; <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt; &gt;</type>
          <declname>end</declname>
        </param>
        <briefdescription>
<para>Specialization of <computeroutput>inplace_merge</computeroutput> for <computeroutput>DataVector/List</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>beg</parametername>
</parameternamelist>
<parameterdescription>
<para>The start iterator for the merge operation. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mid</parametername>
</parameternamelist>
<parameterdescription>
<para>Divider between the two sequences to be merged. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>The end iterator for the merge operation.</para></parameterdescription>
</parameteritem>
</parameterlist>
<computeroutput>beg</computeroutput>, <computeroutput>mid</computeroutput>, and <computeroutput>end</computeroutput> should both be iterators from the same <computeroutput>DataVector/List</computeroutput>. This performs the operation in a way that doesn&apos;t run afoul of <computeroutput>DataVector/List&apos;s</computeroutput> object ownership rules. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" line="489" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" bodystart="486" bodyend="495"/>
      </memberdef>
      <memberdef kind="function" id="d8/dcc/namespacestd_1ae66c9187445112a585c018aec5558849" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class DVL</type>
          </param>
          <param>
            <type>class Compare</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void std::inplace_merge</definition>
        <argsstring>(typename std::reverse_iterator&lt; DataModel_detail::iterator&lt; DVL &gt; &gt; beg, typename std::reverse_iterator&lt; DataModel_detail::iterator&lt; DVL &gt; &gt; mid, typename std::reverse_iterator&lt; DataModel_detail::iterator&lt; DVL &gt; &gt; end, Compare comp)</argsstring>
        <name>inplace_merge</name>
        <param>
          <type>typename std::reverse_iterator&lt; <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt; &gt;</type>
          <declname>beg</declname>
        </param>
        <param>
          <type>typename std::reverse_iterator&lt; <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt; &gt;</type>
          <declname>mid</declname>
        </param>
        <param>
          <type>typename std::reverse_iterator&lt; <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt; &gt;</type>
          <declname>end</declname>
        </param>
        <param>
          <type>Compare</type>
          <declname>comp</declname>
        </param>
        <briefdescription>
<para>Specialization of <computeroutput>inplace_merge</computeroutput> for <computeroutput>DataVector/List</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>beg</parametername>
</parameternamelist>
<parameterdescription>
<para>The start iterator for the merge operation. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mid</parametername>
</parameternamelist>
<parameterdescription>
<para>Divider between the two sequences to be merged. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>The end iterator for the merge operation. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>comp</parametername>
</parameternamelist>
<parameterdescription>
<para>The comparison object.</para></parameterdescription>
</parameteritem>
</parameterlist>
<computeroutput>beg</computeroutput>, <computeroutput>mid</computeroutput>, and <computeroutput>end</computeroutput> should both be iterators from the same <computeroutput>DataVector/List</computeroutput>. This performs the operation in a way that doesn&apos;t run afoul of <computeroutput>DataVector/List&apos;s</computeroutput> object ownership rules. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" line="517" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" bodystart="513" bodyend="524"/>
      </memberdef>
      <memberdef kind="function" id="d8/dcc/namespacestd_1adf3217fcad0d4c18264925b8ca191b7c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class DVL</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void std::sort</definition>
        <argsstring>(typename DataModel_detail::iterator&lt; DVL &gt; beg, typename DataModel_detail::iterator&lt; DVL &gt; end)</argsstring>
        <name>sort</name>
        <param>
          <type>typename <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt;</type>
          <declname>beg</declname>
        </param>
        <param>
          <type>typename <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt;</type>
          <declname>end</declname>
        </param>
        <briefdescription>
<para>Specialization of <computeroutput>sort</computeroutput> for <computeroutput>DataVector/List</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>beg</parametername>
</parameternamelist>
<parameterdescription>
<para>The start iterator for the sort. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>The end iterator for the sort.</para></parameterdescription>
</parameteritem>
</parameterlist>
<computeroutput>beg</computeroutput> and <computeroutput>end</computeroutput> should both be iterators from the same <computeroutput>DataVector/List</computeroutput>. This performs the sort in a way that doesn&apos;t run afoul of <computeroutput>DataVector/List&apos;s</computeroutput> object ownership rules. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" line="551" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" bodystart="549" bodyend="558"/>
      </memberdef>
      <memberdef kind="function" id="d8/dcc/namespacestd_1a723ddb8e2f257ec9671bb7b2feb052fa" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class DVL</type>
          </param>
          <param>
            <type>class Compare</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void std::sort</definition>
        <argsstring>(typename DataModel_detail::iterator&lt; DVL &gt; beg, typename DataModel_detail::iterator&lt; DVL &gt; end, Compare comp)</argsstring>
        <name>sort</name>
        <param>
          <type>typename <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt;</type>
          <declname>beg</declname>
        </param>
        <param>
          <type>typename <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt;</type>
          <declname>end</declname>
        </param>
        <param>
          <type>Compare</type>
          <declname>comp</declname>
        </param>
        <briefdescription>
<para>Specialization of <computeroutput>sort</computeroutput> for <computeroutput>DataVector/List</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>beg</parametername>
</parameternamelist>
<parameterdescription>
<para>The start iterator for the sort. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>The end iterator for the sort. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>comp</parametername>
</parameternamelist>
<parameterdescription>
<para>The comparison functional object.</para></parameterdescription>
</parameteritem>
</parameterlist>
<computeroutput>beg</computeroutput> and <computeroutput>end</computeroutput> should both be iterators from the same <computeroutput>DataVector/List</computeroutput>. This performs the sort in a way that doesn&apos;t run afoul of <computeroutput>DataVector/List&apos;s</computeroutput> object ownership rules. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" line="575" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" bodystart="572" bodyend="579"/>
      </memberdef>
      <memberdef kind="function" id="d8/dcc/namespacestd_1a6dcf64fbdeb3bfd03564e78e776bb350" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class DVL</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void std::sort</definition>
        <argsstring>(typename std::reverse_iterator&lt; DataModel_detail::iterator&lt; DVL &gt; &gt; beg, typename std::reverse_iterator&lt; DataModel_detail::iterator&lt; DVL &gt; &gt; end)</argsstring>
        <name>sort</name>
        <param>
          <type>typename std::reverse_iterator&lt; <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt; &gt;</type>
          <declname>beg</declname>
        </param>
        <param>
          <type>typename std::reverse_iterator&lt; <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt; &gt;</type>
          <declname>end</declname>
        </param>
        <briefdescription>
<para>Specialization of <computeroutput>sort</computeroutput> for <computeroutput>DataVector/List</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>beg</parametername>
</parameternamelist>
<parameterdescription>
<para>The start reverse_iterator for the sort. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>The end reverse_iterator for the sort.</para></parameterdescription>
</parameteritem>
</parameterlist>
<computeroutput>beg</computeroutput> and <computeroutput>end</computeroutput> should both be reverse iterators from the same <computeroutput>DataVector/List</computeroutput>. This performs the sort in a way that doesn&apos;t run afoul of <computeroutput>DataVector/List&apos;s</computeroutput> object ownership rules. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" line="595" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" bodystart="593" bodyend="603"/>
      </memberdef>
      <memberdef kind="function" id="d8/dcc/namespacestd_1ab8cff2c99164878f127bd2c36fff1eea" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class DVL</type>
          </param>
          <param>
            <type>class Compare</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void std::sort</definition>
        <argsstring>(typename std::reverse_iterator&lt; DataModel_detail::iterator&lt; DVL &gt; &gt; beg, typename std::reverse_iterator&lt; DataModel_detail::iterator&lt; DVL &gt; &gt; end, const Compare &amp;comp)</argsstring>
        <name>sort</name>
        <param>
          <type>typename std::reverse_iterator&lt; <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt; &gt;</type>
          <declname>beg</declname>
        </param>
        <param>
          <type>typename std::reverse_iterator&lt; <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt; &gt;</type>
          <declname>end</declname>
        </param>
        <param>
          <type>const Compare &amp;</type>
          <declname>comp</declname>
        </param>
        <briefdescription>
<para>Specialization of <computeroutput>sort</computeroutput> for <computeroutput>DataVector/List</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>beg</parametername>
</parameternamelist>
<parameterdescription>
<para>The start reverse_iterator for the sort. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>The end reverse_iterator for the sort. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>comp</parametername>
</parameternamelist>
<parameterdescription>
<para>The comparison functional object.</para></parameterdescription>
</parameteritem>
</parameterlist>
<computeroutput>beg</computeroutput> and <computeroutput>end</computeroutput> should both be reverse iterators from the same <computeroutput>DataVector/List</computeroutput>. This performs the sort in a way that doesn&apos;t run afoul of <computeroutput>DataVector/List&apos;s</computeroutput> object ownership rules. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" line="621" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" bodystart="618" bodyend="626"/>
      </memberdef>
      <memberdef kind="function" id="d8/dcc/namespacestd_1a9466c5474be5de8bf561ac0af20ea496" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class DVL</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void std::stable_sort</definition>
        <argsstring>(DataModel_detail::iterator&lt; DVL &gt; beg, DataModel_detail::iterator&lt; DVL &gt; end)</argsstring>
        <name>stable_sort</name>
        <param>
          <type><ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt;</type>
          <declname>beg</declname>
        </param>
        <param>
          <type><ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt;</type>
          <declname>end</declname>
        </param>
        <briefdescription>
<para>Specialization of <computeroutput>stable_sort</computeroutput> for <computeroutput>DataVector/List</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>beg</parametername>
</parameternamelist>
<parameterdescription>
<para>The start iterator for the sort. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>The end iterator for the sort.</para></parameterdescription>
</parameteritem>
</parameterlist>
<computeroutput>beg</computeroutput> and <computeroutput>end</computeroutput> should both be iterators from the same <computeroutput>DataVector/List</computeroutput>. This performs the sort in a way that doesn&apos;t run afoul of <computeroutput>DataVector/List&apos;s</computeroutput> object ownership rules. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" line="641" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" bodystart="639" bodyend="648"/>
      </memberdef>
      <memberdef kind="function" id="d8/dcc/namespacestd_1a17ba5f1fefaaf42af3481d586b4b1afb" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class DVL</type>
          </param>
          <param>
            <type>class Compare</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void std::stable_sort</definition>
        <argsstring>(DataModel_detail::iterator&lt; DVL &gt; beg, DataModel_detail::iterator&lt; DVL &gt; end, Compare comp)</argsstring>
        <name>stable_sort</name>
        <param>
          <type><ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt;</type>
          <declname>beg</declname>
        </param>
        <param>
          <type><ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt;</type>
          <declname>end</declname>
        </param>
        <param>
          <type>Compare</type>
          <declname>comp</declname>
        </param>
        <briefdescription>
<para>Specialization of <computeroutput>stable_sort</computeroutput> for <computeroutput>DataVector/List</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>beg</parametername>
</parameternamelist>
<parameterdescription>
<para>The start iterator for the sort. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>The end iterator for the sort.</para></parameterdescription>
</parameteritem>
</parameterlist>
<computeroutput>beg</computeroutput> and <computeroutput>end</computeroutput> should both be iterators from the same <computeroutput>DataVector/List</computeroutput>. This performs the sort in a way that doesn&apos;t run afoul of <computeroutput>DataVector/List&apos;s</computeroutput> object ownership rules. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" line="664" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" bodystart="661" bodyend="668"/>
      </memberdef>
      <memberdef kind="function" id="d8/dcc/namespacestd_1aaec7d2be5dab85bddc299406a812b1e7" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class DVL</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void std::stable_sort</definition>
        <argsstring>(std::reverse_iterator&lt; DataModel_detail::iterator&lt; DVL &gt; &gt; beg, std::reverse_iterator&lt; DataModel_detail::iterator&lt; DVL &gt; &gt; end)</argsstring>
        <name>stable_sort</name>
        <param>
          <type>std::reverse_iterator&lt; <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt; &gt;</type>
          <declname>beg</declname>
        </param>
        <param>
          <type>std::reverse_iterator&lt; <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt; &gt;</type>
          <declname>end</declname>
        </param>
        <briefdescription>
<para>Specialization of <computeroutput>stable_sort</computeroutput> for <computeroutput>DataVector/List</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>beg</parametername>
</parameternamelist>
<parameterdescription>
<para>The start reverse_iterator for the sort. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>The end reverse_iterator for the sort.</para></parameterdescription>
</parameteritem>
</parameterlist>
<computeroutput>beg</computeroutput> and <computeroutput>end</computeroutput> should both be reverse_iterators from the same <computeroutput>DataVector/List</computeroutput>. This performs the sort in a way that doesn&apos;t run afoul of <computeroutput>DataVector/List&apos;s</computeroutput> object ownership rules. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" line="684" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" bodystart="682" bodyend="692"/>
      </memberdef>
      <memberdef kind="function" id="d8/dcc/namespacestd_1abb5ce9886414b1c1a3bed04a05d5b050" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class DVL</type>
          </param>
          <param>
            <type>class Compare</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void std::stable_sort</definition>
        <argsstring>(std::reverse_iterator&lt; DataModel_detail::iterator&lt; DVL &gt; &gt; beg, std::reverse_iterator&lt; DataModel_detail::iterator&lt; DVL &gt; &gt; end, Compare comp)</argsstring>
        <name>stable_sort</name>
        <param>
          <type>std::reverse_iterator&lt; <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt; &gt;</type>
          <declname>beg</declname>
        </param>
        <param>
          <type>std::reverse_iterator&lt; <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt; &gt;</type>
          <declname>end</declname>
        </param>
        <param>
          <type>Compare</type>
          <declname>comp</declname>
        </param>
        <briefdescription>
<para>Specialization of <computeroutput>stable_sort</computeroutput> for <computeroutput>DataVector/List</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>beg</parametername>
</parameternamelist>
<parameterdescription>
<para>The start reverse_iterator for the sort. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>The end reverse_iterator for the sort.</para></parameterdescription>
</parameteritem>
</parameterlist>
<computeroutput>beg</computeroutput> and <computeroutput>end</computeroutput> should both be reverse_iterators from the same <computeroutput>DataVector/List</computeroutput>. This performs the sort in a way that doesn&apos;t run afoul of <computeroutput>DataVector/List&apos;s</computeroutput> object ownership rules. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" line="709" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" bodystart="706" bodyend="714"/>
      </memberdef>
      <memberdef kind="function" id="d8/dcc/namespacestd_1a9974e9a993cfebdb5f163f141c0df31b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class DVL</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void std::partial_sort</definition>
        <argsstring>(DataModel_detail::iterator&lt; DVL &gt; beg, DataModel_detail::iterator&lt; DVL &gt; mid, DataModel_detail::iterator&lt; DVL &gt; end)</argsstring>
        <name>partial_sort</name>
        <param>
          <type><ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt;</type>
          <declname>beg</declname>
        </param>
        <param>
          <type><ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt;</type>
          <declname>mid</declname>
        </param>
        <param>
          <type><ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt;</type>
          <declname>end</declname>
        </param>
        <briefdescription>
<para>Specialization of <computeroutput>partial_sort</computeroutput> for <computeroutput>DataVector/List</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>beg</parametername>
</parameternamelist>
<parameterdescription>
<para>The start iterator for the sort. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mid</parametername>
</parameternamelist>
<parameterdescription>
<para>The middle iterator for the sort. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>The end iterator for the sort.</para></parameterdescription>
</parameteritem>
</parameterlist>
<computeroutput>beg</computeroutput>, <computeroutput>mid</computeroutput>, and <computeroutput>end</computeroutput> should both be iterators from the same <computeroutput>DataVector/List</computeroutput>. This performs the sort in a way that doesn&apos;t run afoul of <computeroutput>DataVector/List&apos;s</computeroutput> object ownership rules. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" line="732" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" bodystart="729" bodyend="739"/>
      </memberdef>
      <memberdef kind="function" id="d8/dcc/namespacestd_1a759d426ac26bbdba6eb6214b33d3c9f8" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class DVL</type>
          </param>
          <param>
            <type>class Compare</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void std::partial_sort</definition>
        <argsstring>(DataModel_detail::iterator&lt; DVL &gt; beg, DataModel_detail::iterator&lt; DVL &gt; mid, DataModel_detail::iterator&lt; DVL &gt; end, Compare comp)</argsstring>
        <name>partial_sort</name>
        <param>
          <type><ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt;</type>
          <declname>beg</declname>
        </param>
        <param>
          <type><ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt;</type>
          <declname>mid</declname>
        </param>
        <param>
          <type><ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt;</type>
          <declname>end</declname>
        </param>
        <param>
          <type>Compare</type>
          <declname>comp</declname>
        </param>
        <briefdescription>
<para>Specialization of <computeroutput>partial_sort</computeroutput> for <computeroutput>DataVector/List</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>beg</parametername>
</parameternamelist>
<parameterdescription>
<para>The start iterator for the sort. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mid</parametername>
</parameternamelist>
<parameterdescription>
<para>The middle iterator for the sort. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>The end iterator for the sort.</para></parameterdescription>
</parameteritem>
</parameterlist>
<computeroutput>beg</computeroutput>, <computeroutput>mid</computeroutput>, and <computeroutput>end</computeroutput> should both be iterators from the same <computeroutput>DataVector/List</computeroutput>. This performs the sort in a way that doesn&apos;t run afoul of <computeroutput>DataVector/List&apos;s</computeroutput> object ownership rules. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" line="758" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" bodystart="754" bodyend="762"/>
      </memberdef>
      <memberdef kind="function" id="d8/dcc/namespacestd_1ac3e63b05bd814bdaa6ba1b281f8dea70" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class DVL</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void std::partial_sort</definition>
        <argsstring>(std::reverse_iterator&lt; DataModel_detail::iterator&lt; DVL &gt; &gt; beg, std::reverse_iterator&lt; DataModel_detail::iterator&lt; DVL &gt; &gt; mid, std::reverse_iterator&lt; DataModel_detail::iterator&lt; DVL &gt; &gt; end)</argsstring>
        <name>partial_sort</name>
        <param>
          <type>std::reverse_iterator&lt; <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt; &gt;</type>
          <declname>beg</declname>
        </param>
        <param>
          <type>std::reverse_iterator&lt; <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt; &gt;</type>
          <declname>mid</declname>
        </param>
        <param>
          <type>std::reverse_iterator&lt; <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt; &gt;</type>
          <declname>end</declname>
        </param>
        <briefdescription>
<para>Specialization of <computeroutput>partial_sort</computeroutput> for <computeroutput>DataVector/List</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>beg</parametername>
</parameternamelist>
<parameterdescription>
<para>The start reverse_iterator for the sort. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mid</parametername>
</parameternamelist>
<parameterdescription>
<para>The middle reverse_iterator for the sort. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>The end reverse_iterator for the sort.</para></parameterdescription>
</parameteritem>
</parameterlist>
<computeroutput>beg</computeroutput>, <computeroutput>mid</computeroutput>, and <computeroutput>end</computeroutput> should both be reverse_iterators from the same <computeroutput>DataVector/List</computeroutput>. This performs the sort in a way that doesn&apos;t run afoul of <computeroutput>DataVector/List&apos;s</computeroutput> object ownership rules. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" line="780" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" bodystart="777" bodyend="791"/>
      </memberdef>
      <memberdef kind="function" id="d8/dcc/namespacestd_1aa252b9e77e523a8cfe1426f6b1447067" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class DVL</type>
          </param>
          <param>
            <type>class Compare</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void std::partial_sort</definition>
        <argsstring>(std::reverse_iterator&lt; DataModel_detail::iterator&lt; DVL &gt; &gt; beg, std::reverse_iterator&lt; DataModel_detail::iterator&lt; DVL &gt; &gt; mid, std::reverse_iterator&lt; DataModel_detail::iterator&lt; DVL &gt; &gt; end, Compare comp)</argsstring>
        <name>partial_sort</name>
        <param>
          <type>std::reverse_iterator&lt; <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt; &gt;</type>
          <declname>beg</declname>
        </param>
        <param>
          <type>std::reverse_iterator&lt; <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt; &gt;</type>
          <declname>mid</declname>
        </param>
        <param>
          <type>std::reverse_iterator&lt; <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt; &gt;</type>
          <declname>end</declname>
        </param>
        <param>
          <type>Compare</type>
          <declname>comp</declname>
        </param>
        <briefdescription>
<para>Specialization of <computeroutput>partial_sort</computeroutput> for <computeroutput>DataVector/List</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>beg</parametername>
</parameternamelist>
<parameterdescription>
<para>The start reverse_iterator for the sort. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mid</parametername>
</parameternamelist>
<parameterdescription>
<para>The middle reverse_iterator for the sort. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>The end reverse_iterator for the sort.</para></parameterdescription>
</parameteritem>
</parameterlist>
<computeroutput>beg</computeroutput>, <computeroutput>mid</computeroutput>, and <computeroutput>end</computeroutput> should both be reverse_iterators from the same <computeroutput>DataVector/List</computeroutput>. This performs the sort in a way that doesn&apos;t run afoul of <computeroutput>DataVector/List&apos;s</computeroutput> object ownership rules. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" line="810" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" bodystart="806" bodyend="818"/>
      </memberdef>
      <memberdef kind="function" id="d8/dcc/namespacestd_1a45ef3d8687ec5d622ad8d008a9ff8edf" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class DVL</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void std::random_shuffle</definition>
        <argsstring>(typename DataModel_detail::iterator&lt; DVL &gt; beg, typename DataModel_detail::iterator&lt; DVL &gt; end)</argsstring>
        <name>random_shuffle</name>
        <param>
          <type>typename <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt;</type>
          <declname>beg</declname>
        </param>
        <param>
          <type>typename <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt;</type>
          <declname>end</declname>
        </param>
        <briefdescription>
<para>Specialization of <computeroutput>random_shuffle</computeroutput> for <computeroutput>DataVector/List</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>beg</parametername>
</parameternamelist>
<parameterdescription>
<para>The start iterator for the shuffle operation. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>The end iterator for the shuffle operation.</para></parameterdescription>
</parameteritem>
</parameterlist>
<computeroutput>beg</computeroutput> and <computeroutput>end</computeroutput> should both be iterators from the same <computeroutput>DataVector/List</computeroutput>. This performs the operation in a way that doesn&apos;t run afoul of <computeroutput>DataVector/List&apos;s</computeroutput> object ownership rules. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" line="835" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" bodystart="833" bodyend="838"/>
      </memberdef>
      <memberdef kind="function" id="d8/dcc/namespacestd_1af0cff6ab84cf6e09b30baa28a4c49a91" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class DVL</type>
          </param>
          <param>
            <type>class Random</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void std::random_shuffle</definition>
        <argsstring>(typename DataModel_detail::iterator&lt; DVL &gt; beg, typename DataModel_detail::iterator&lt; DVL &gt; end, Random &amp;rand)</argsstring>
        <name>random_shuffle</name>
        <param>
          <type>typename <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt;</type>
          <declname>beg</declname>
        </param>
        <param>
          <type>typename <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt;</type>
          <declname>end</declname>
        </param>
        <param>
          <type>Random &amp;</type>
          <declname>rand</declname>
        </param>
        <briefdescription>
<para>Specialization of <computeroutput>random_shuffle</computeroutput> for <computeroutput>DataVector/List</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>beg</parametername>
</parameternamelist>
<parameterdescription>
<para>The start iterator for the shuffle operation. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>The end iterator for the shuffle operation. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rand</parametername>
</parameternamelist>
<parameterdescription>
<para>The random generator.</para></parameterdescription>
</parameteritem>
</parameterlist>
<computeroutput>beg</computeroutput> and <computeroutput>end</computeroutput> should both be iterators from the same <computeroutput>DataVector/List</computeroutput>. This performs the operation in a way that doesn&apos;t run afoul of <computeroutput>DataVector/List&apos;s</computeroutput> object ownership rules. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" line="857" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" bodystart="854" bodyend="860"/>
      </memberdef>
      <memberdef kind="function" id="d8/dcc/namespacestd_1adce733d7fd1d81a5a2ce29f15ecfdda2" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class DVL</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void std::random_shuffle</definition>
        <argsstring>(typename std::reverse_iterator&lt; DataModel_detail::iterator&lt; DVL &gt; &gt; beg, typename std::reverse_iterator&lt; DataModel_detail::iterator&lt; DVL &gt; &gt; end)</argsstring>
        <name>random_shuffle</name>
        <param>
          <type>typename std::reverse_iterator&lt; <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt; &gt;</type>
          <declname>beg</declname>
        </param>
        <param>
          <type>typename std::reverse_iterator&lt; <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt; &gt;</type>
          <declname>end</declname>
        </param>
        <briefdescription>
<para>Specialization of <computeroutput>random_shuffle</computeroutput> for <computeroutput>DataVector/List</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>beg</parametername>
</parameternamelist>
<parameterdescription>
<para>The start reverse_iterator for the shuffle operation. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>The end reverse_iterator for the shuffle operation.</para></parameterdescription>
</parameteritem>
</parameterlist>
<computeroutput>beg</computeroutput> and <computeroutput>end</computeroutput> should both be reverse_iterators from the same <computeroutput>DataVector/List</computeroutput>. This performs the operation in a way that doesn&apos;t run afoul of <computeroutput>DataVector/List&apos;s</computeroutput> object ownership rules. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" line="879" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" bodystart="877" bodyend="884"/>
      </memberdef>
      <memberdef kind="function" id="d8/dcc/namespacestd_1a03725acd6268d8e724e3c3f642fdfba1" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class DVL</type>
          </param>
          <param>
            <type>class Random</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void std::random_shuffle</definition>
        <argsstring>(typename std::reverse_iterator&lt; DataModel_detail::iterator&lt; DVL &gt; &gt; beg, typename std::reverse_iterator&lt; DataModel_detail::iterator&lt; DVL &gt; &gt; end, Random &amp;rand)</argsstring>
        <name>random_shuffle</name>
        <param>
          <type>typename std::reverse_iterator&lt; <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt; &gt;</type>
          <declname>beg</declname>
        </param>
        <param>
          <type>typename std::reverse_iterator&lt; <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt; &gt;</type>
          <declname>end</declname>
        </param>
        <param>
          <type>Random &amp;</type>
          <declname>rand</declname>
        </param>
        <briefdescription>
<para>Specialization of <computeroutput>random_shuffle</computeroutput> for <computeroutput>DataVector/List</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>beg</parametername>
</parameternamelist>
<parameterdescription>
<para>The start reverse_iterator for the shuffle operation. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>The end reverse_iterator for the shuffle operation. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rand</parametername>
</parameternamelist>
<parameterdescription>
<para>The random generator.</para></parameterdescription>
</parameteritem>
</parameterlist>
<computeroutput>beg</computeroutput> and <computeroutput>end</computeroutput> should both be reverse_iterators from the same <computeroutput>DataVector/List</computeroutput>. This performs the operation in a way that doesn&apos;t run afoul of <computeroutput>DataVector/List&apos;s</computeroutput> object ownership rules. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" line="905" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.h" bodystart="902" bodyend="911"/>
      </memberdef>
      <memberdef kind="function" id="d8/dcc/namespacestd_1a87609104041ef8a98fc7e191c163c27f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class <ref refid="d3/d78/structDV" kindref="compound">DV</ref></type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void std::iter_swap</definition>
        <argsstring>(typename DataModel_detail::iterator&lt; DV &gt; a, typename DataModel_detail::iterator&lt; DV &gt; b)</argsstring>
        <name>iter_swap</name>
        <param>
          <type>typename <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; <ref refid="d3/d78/structDV" kindref="compound">DV</ref> &gt;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>typename <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; <ref refid="d3/d78/structDV" kindref="compound">DV</ref> &gt;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Specialization of <computeroutput>iter_swap</computeroutput> for <computeroutput>DataVector/<computeroutput><ref refid="d9/dfb/classDataList" kindref="compound">DataList</ref></computeroutput>.</computeroutput> </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>First iterator for the swap. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Second iterator for the swap.</para></parameterdescription>
</parameteritem>
</parameterlist>
Swaps <computeroutput>*a</computeroutput> with <computeroutput>*b</computeroutput>, respecting the <computeroutput>DataVector/List</computeroutput> ownership rules. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_iter_swap.h" line="33" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_iter_swap.h" bodystart="31" bodyend="35"/>
      </memberdef>
      <memberdef kind="function" id="d8/dcc/namespacestd_1abe32a596378cbacde07bef21826f6535" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class <ref refid="d3/d78/structDV" kindref="compound">DV</ref></type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void std::iter_swap</definition>
        <argsstring>(typename std::reverse_iterator&lt; DataModel_detail::iterator&lt; DV &gt; &gt; a, typename std::reverse_iterator&lt; DataModel_detail::iterator&lt; DV &gt; &gt; b)</argsstring>
        <name>iter_swap</name>
        <param>
          <type>typename std::reverse_iterator&lt; <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; <ref refid="d3/d78/structDV" kindref="compound">DV</ref> &gt; &gt;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>typename std::reverse_iterator&lt; <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; <ref refid="d3/d78/structDV" kindref="compound">DV</ref> &gt; &gt;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Specialization of <computeroutput>iter_swap</computeroutput> for <computeroutput>DataVector/<computeroutput><ref refid="d9/dfb/classDataList" kindref="compound">DataList</ref></computeroutput>.</computeroutput> </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>First reverse_iterator for the swap. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Second reverse_iterator for the swap.</para></parameterdescription>
</parameteritem>
</parameterlist>
Swaps <computeroutput>*a</computeroutput> with <computeroutput>*b</computeroutput>, respecting the <computeroutput>DataVector/List</computeroutput> ownership rules. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_iter_swap.h" line="49" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_iter_swap.h" bodystart="47" bodyend="55"/>
      </memberdef>
      <memberdef kind="function" id="d8/dcc/namespacestd_1a86fe569a291bdd328d80597ce1541fe9" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class <ref refid="d3/d78/structDV" kindref="compound">DV</ref></type>
          </param>
        </templateparamlist>
        <type><ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; <ref refid="d3/d78/structDV" kindref="compound">DV</ref> &gt;</type>
        <definition>DataModel_detail::iterator&lt;DV&gt; std::swap_ranges</definition>
        <argsstring>(DataModel_detail::iterator&lt; DV &gt; first1, DataModel_detail::iterator&lt; DV &gt; last1, DataModel_detail::iterator&lt; DV &gt; first2)</argsstring>
        <name>swap_ranges</name>
        <param>
          <type><ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; <ref refid="d3/d78/structDV" kindref="compound">DV</ref> &gt;</type>
          <declname>first1</declname>
        </param>
        <param>
          <type><ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; <ref refid="d3/d78/structDV" kindref="compound">DV</ref> &gt;</type>
          <declname>last1</declname>
        </param>
        <param>
          <type><ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; <ref refid="d3/d78/structDV" kindref="compound">DV</ref> &gt;</type>
          <declname>first2</declname>
        </param>
        <briefdescription>
<para>Specialization of <computeroutput>swap_ranges</computeroutput> for <computeroutput>DataVector/<computeroutput><ref refid="d9/dfb/classDataList" kindref="compound">DataList</ref></computeroutput>.</computeroutput> </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first1</parametername>
</parameternamelist>
<parameterdescription>
<para>Start of the first range. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>End of the first range. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first2</parametername>
</parameternamelist>
<parameterdescription>
<para>Start of the second range.</para></parameterdescription>
</parameteritem>
</parameterlist>
Swap, element-by-element, the two ranges [first1, last) and [first2, first2+(last-first1)). </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_iter_swap.h" line="72" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_iter_swap.h" bodystart="69" bodyend="77"/>
      </memberdef>
      <memberdef kind="function" id="d8/dcc/namespacestd_1a2f7de23b8b2cd2445d5ff27e6d21d452" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class <ref refid="d3/d78/structDV" kindref="compound">DV</ref></type>
          </param>
        </templateparamlist>
        <type>std::reverse_iterator&lt; <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; <ref refid="d3/d78/structDV" kindref="compound">DV</ref> &gt; &gt;</type>
        <definition>std::reverse_iterator&lt;DataModel_detail::iterator&lt;DV&gt; &gt; std::swap_ranges</definition>
        <argsstring>(std::reverse_iterator&lt; DataModel_detail::iterator&lt; DV &gt; &gt; first1, std::reverse_iterator&lt; DataModel_detail::iterator&lt; DV &gt; &gt; last1, std::reverse_iterator&lt; DataModel_detail::iterator&lt; DV &gt; &gt; first2)</argsstring>
        <name>swap_ranges</name>
        <param>
          <type>std::reverse_iterator&lt; <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; <ref refid="d3/d78/structDV" kindref="compound">DV</ref> &gt; &gt;</type>
          <declname>first1</declname>
        </param>
        <param>
          <type>std::reverse_iterator&lt; <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; <ref refid="d3/d78/structDV" kindref="compound">DV</ref> &gt; &gt;</type>
          <declname>last1</declname>
        </param>
        <param>
          <type>std::reverse_iterator&lt; <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; <ref refid="d3/d78/structDV" kindref="compound">DV</ref> &gt; &gt;</type>
          <declname>first2</declname>
        </param>
        <briefdescription>
<para>Specialization of <computeroutput>swap_ranges</computeroutput> for <computeroutput>DataVector/<computeroutput><ref refid="d9/dfb/classDataList" kindref="compound">DataList</ref></computeroutput>.</computeroutput> </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first1</parametername>
</parameternamelist>
<parameterdescription>
<para>Start of the first range. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>End of the first range. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first2</parametername>
</parameternamelist>
<parameterdescription>
<para>Start of the second range.</para></parameterdescription>
</parameteritem>
</parameterlist>
Swap, element-by-element, the two ranges [first1, last) and [first2, first2+(last-first1)). </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_iter_swap.h" line="94" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_iter_swap.h" bodystart="91" bodyend="99"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/Asg_GoogleTest/include/gtest/internal/gtest-tuple.h" line="112"/>
  </compounddef>
</doxygen>
