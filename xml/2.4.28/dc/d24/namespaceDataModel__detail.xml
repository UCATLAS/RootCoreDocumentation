<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.6.1">
  <compounddef id="dc/d24/namespaceDataModel__detail" kind="namespace">
    <compoundname>DataModel_detail</compoundname>
    <innerclass refid="d6/dfe/structDataModel__detail_1_1can__pack" prot="public">DataModel_detail::can_pack</innerclass>
    <innerclass refid="d3/dc4/structDataModel__detail_1_1can__pack_3_01uint64__t_01_4" prot="public">DataModel_detail::can_pack&lt; uint64_t &gt;</innerclass>
    <innerclass refid="d1/dd0/structDataModel__detail_1_1can__pack_3_01int64__t_01_4" prot="public">DataModel_detail::can_pack&lt; int64_t &gt;</innerclass>
    <innerclass refid="d0/d1c/structDataModel__detail_1_1can__pack_3_01long_01double_01_4" prot="public">DataModel_detail::can_pack&lt; long double &gt;</innerclass>
    <innerclass refid="d5/dc2/structDataModel__detail_1_1can__pack_3_01std_1_1vector_3_01T_01_4_01_4" prot="public">DataModel_detail::can_pack&lt; std::vector&lt; T &gt; &gt;</innerclass>
    <innerclass refid="d7/d24/classDataModel__detail_1_1CompareAndPrint" prot="public">DataModel_detail::CompareAndPrint</innerclass>
    <innerclass refid="d1/d8a/structDataModel__detail_1_1Compwrapper" prot="public">DataModel_detail::Compwrapper</innerclass>
    <innerclass refid="dd/d3b/structDataModel__detail_1_1Compwrapper_3_01DVL_00_01Compare_00_01DataModel__detail_1_1NoBase_01_4" prot="public">DataModel_detail::Compwrapper&lt; DVL, Compare, DataModel_detail::NoBase &gt;</innerclass>
    <innerclass refid="d0/d75/structDataModel__detail_1_1Predwrapper" prot="public">DataModel_detail::Predwrapper</innerclass>
    <innerclass refid="d4/d31/structDataModel__detail_1_1Predwrapper_3_01DV_00_01Predicate_00_01DataModel__detail_1_1NoBase_01_4" prot="public">DataModel_detail::Predwrapper&lt; DV, Predicate, DataModel_detail::NoBase &gt;</innerclass>
    <innerclass refid="de/d59/structDataModel__detail_1_1DVLCast" prot="public">DataModel_detail::DVLCast</innerclass>
    <innerclass refid="d2/d49/structDataModel__detail_1_1DVLCast_3_01DVL_00_01false_01_4" prot="public">DataModel_detail::DVLCast&lt; DVL, false &gt;</innerclass>
    <innerclass refid="de/d66/structDataModel__detail_1_1DVLCast_3_01DVL_00_01true_01_4" prot="public">DataModel_detail::DVLCast&lt; DVL, true &gt;</innerclass>
    <innerclass refid="d1/d1d/classDataModel__detail_1_1DVLIteratorBase" prot="public">DataModel_detail::DVLIteratorBase</innerclass>
    <innerclass refid="da/d8a/classDataModel__detail_1_1DVLInfoBase" prot="public">DataModel_detail::DVLInfoBase</innerclass>
    <innerclass refid="df/d12/classDataModel__detail_1_1DVLInfo" prot="public">DataModel_detail::DVLInfo</innerclass>
    <innerclass refid="d3/df8/classDataModel__detail_1_1DVLIterator" prot="public">DataModel_detail::DVLIterator</innerclass>
    <innerclass refid="d7/d17/classDataModel__detail_1_1const__iterator" prot="public">DataModel_detail::const_iterator</innerclass>
    <innerclass refid="d5/d70/classDataModel__detail_1_1iterator" prot="public">DataModel_detail::iterator</innerclass>
    <innerclass refid="d4/d21/structDataModel__detail_1_1NoBase" prot="public">DataModel_detail::NoBase</innerclass>
    <innerclass refid="d7/d05/classDataModel__detail_1_1ElementProxy" prot="public">DataModel_detail::ElementProxy</innerclass>
    <innerclass refid="d2/d6f/structDataModel__detail_1_1dvlmapdel" prot="public">DataModel_detail::dvlmapdel</innerclass>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="dc/d24/namespaceDataModel__detail_1a79db0d3162ee10c4ed6a568bf388ad55" prot="public" static="no">
        <type><ref refid="d1/d3b/classSG_1_1unordered__map" kindref="compound">SG_STD_OR_SG::unordered_map</ref>&lt; const std::type_info *, <ref refid="da/d8a/classDataModel__detail_1_1DVLInfoBase" kindref="compound">DVLInfoBase</ref> * &gt;</type>
        <definition>typedef SG_STD_OR_SG::unordered_map&lt;const std::type_info*, DVLInfoBase*&gt; DataModel_detail::dvl_tinfo_map_t</definition>
        <argsstring></argsstring>
        <name>dvl_tinfo_map_t</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Maps from tinfo pointers and CLID to <computeroutput><ref refid="df/d12/classDataModel__detail_1_1DVLInfo" kindref="compound">DVLInfo</ref></computeroutput> instances. Note that we don&apos;t rely on static initialization here, to avoid initialization ordering problems. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/Root/DVLInfo.cxx" line="39" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/Root/DVLInfo.cxx" bodystart="39" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="var">
      <memberdef kind="variable" id="dc/d24/namespaceDataModel__detail_1afc99ca3dbad3e199d489f7f146e2b440" prot="public" static="no" mutable="no">
        <type><ref refid="d1/d3b/classSG_1_1unordered__map" kindref="compound">dvl_tinfo_map_t</ref> *</type>
        <definition>dvl_tinfo_map_t* DataModel_detail::s_dvl_tinfo_map</definition>
        <argsstring></argsstring>
        <name>s_dvl_tinfo_map</name>
        <initializer> 0</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/Root/DVLInfo.cxx" line="40" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/Root/DVLInfo.cxx" bodystart="40" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="dc/d24/namespaceDataModel__detail_1a0828ea44df4016727d17b17ea914775d" prot="public" static="no" mutable="no">
        <type>struct <ref refid="d2/d6f/structDataModel__detail_1_1dvlmapdel" kindref="compound">DataModel_detail::dvlmapdel</ref></type>
        <definition>struct DataModel_detail::dvlmapdel  DataModel_detail::s_dvlmapdel</definition>
        <argsstring></argsstring>
        <name>s_dvlmapdel</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/Root/DVLInfo.cxx" line="44"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="dc/d24/namespaceDataModel__detail_1a603dd11955bc2c1056541d4b5a5b54cb" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class VEC</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool DataModel_detail::setOptionHelper</definition>
        <argsstring>(VEC *vec, const SG::AuxDataOption &amp;option, SG_STD_OR_BOOST::true_type)</argsstring>
        <name>setOptionHelper</name>
        <param>
          <type>VEC *</type>
          <declname>vec</declname>
        </param>
        <param>
          <type>const <ref refid="d7/d31/classSG_1_1AuxDataOption" kindref="compound">SG::AuxDataOption</ref> &amp;</type>
          <declname>option</declname>
        </param>
        <param>
          <type>SG_STD_OR_BOOST::true_type</type>
        </param>
        <briefdescription>
<para>Make an option setting. VEC derives from <computeroutput>IAuxSetOption</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/AuxTypeVector.icc" line="131" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/AuxTypeVector.icc" bodystart="130" bodyend="134"/>
      </memberdef>
      <memberdef kind="function" id="dc/d24/namespaceDataModel__detail_1aa239a5215f34a1542a9e876cd0cb0777" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class VEC</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool DataModel_detail::setOptionHelper</definition>
        <argsstring>(VEC *, const SG::AuxDataOption &amp;, SG_STD_OR_BOOST::false_type)</argsstring>
        <name>setOptionHelper</name>
        <param>
          <type>VEC *</type>
        </param>
        <param>
          <type>const <ref refid="d7/d31/classSG_1_1AuxDataOption" kindref="compound">SG::AuxDataOption</ref> &amp;</type>
        </param>
        <param>
          <type>SG_STD_OR_BOOST::false_type</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Make an option setting. VEC does not derive from <computeroutput>IAuxSetOption</computeroutput>, so this just returns failure. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/AuxTypeVector.icc" line="141" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/AuxTypeVector.icc" bodystart="140" bodyend="143"/>
      </memberdef>
      <memberdef kind="function" id="dc/d24/namespaceDataModel__detail_1a5aad6d6fb3e3c1b7f0e719678d37e53b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class <ref refid="d1/def/classT" kindref="compound">T</ref></type>
          </param>
        </templateparamlist>
        <type><ref refid="de/d12/classSG_1_1IAuxTypeVector" kindref="compound">SG::IAuxTypeVector</ref> *</type>
        <definition>SG::IAuxTypeVector* DataModel_detail::makePacked</definition>
        <argsstring>(std::vector&lt; T &gt; &amp;v, SG_STD_OR_BOOST::true_type)</argsstring>
        <name>makePacked</name>
        <param>
          <type>std::vector&lt; <ref refid="d1/def/classT" kindref="compound">T</ref> &gt; &amp;</type>
          <declname>v</declname>
        </param>
        <param>
          <type>SG_STD_OR_BOOST::true_type</type>
        </param>
        <briefdescription>
<para>Specialization for the case of types that can be packed. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/AuxTypeVector.icc" line="227" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/AuxTypeVector.icc" bodystart="226" bodyend="233"/>
      </memberdef>
      <memberdef kind="function" id="dc/d24/namespaceDataModel__detail_1a22e238c5ef22f313acbe05654889fd84" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class <ref refid="d1/def/classT" kindref="compound">T</ref></type>
          </param>
          <param>
            <type>class FLAG</type>
          </param>
        </templateparamlist>
        <type><ref refid="de/d12/classSG_1_1IAuxTypeVector" kindref="compound">SG::IAuxTypeVector</ref> *</type>
        <definition>SG::IAuxTypeVector* DataModel_detail::makePacked</definition>
        <argsstring>(T &amp;, FLAG)</argsstring>
        <name>makePacked</name>
        <param>
          <type><ref refid="d1/def/classT" kindref="compound">T</ref> &amp;</type>
        </param>
        <param>
          <type>FLAG</type>
        </param>
        <briefdescription>
<para>Specialization for the case of types that cannot be packed. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/AuxTypeVector.icc" line="239" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/AuxTypeVector.icc" bodystart="238" bodyend="241"/>
      </memberdef>
      <memberdef kind="function" id="dc/d24/namespaceDataModel__detail_1a4a501bc846c4144cbfcdf16c51cc39cf" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Iterator</type>
          </param>
          <param>
            <type>class <ref refid="d1/def/classT" kindref="compound">T</ref></type>
          </param>
        </templateparamlist>
        <type>Iterator</type>
        <definition>Iterator DataModel_detail::dvl_remove</definition>
        <argsstring>(Iterator beg, Iterator end, const T &amp;value)</argsstring>
        <name>dvl_remove</name>
        <param>
          <type>Iterator</type>
          <declname>beg</declname>
        </param>
        <param>
          <type>Iterator</type>
          <declname>end</declname>
        </param>
        <param>
          <type>const <ref refid="d1/def/classT" kindref="compound">T</ref> &amp;</type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>Specialization of <computeroutput>remove</computeroutput> for <computeroutput>DataVector/List</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>beg</parametername>
</parameternamelist>
<parameterdescription>
<para>The start <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">iterator</ref> for the remove. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>The end <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">iterator</ref> for the remove. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>value</parametername>
</parameternamelist>
<parameterdescription>
<para>The value to remove.</para></parameterdescription>
</parameteritem>
</parameterlist>
<computeroutput>beg</computeroutput> and <computeroutput>end</computeroutput> should both be iterators from the same <computeroutput>DataVector/List</computeroutput>. This performs the remove in a way that doesn&apos;t run afoul of <computeroutput>DataVector/List&apos;s</computeroutput> object ownership rules. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.icc" line="121" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.icc" bodystart="118" bodyend="137"/>
      </memberdef>
      <memberdef kind="function" id="dc/d24/namespaceDataModel__detail_1a58ead6de2ff1e6140d0070fe89d8f29f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Iterator</type>
          </param>
          <param>
            <type>class Predicate</type>
          </param>
        </templateparamlist>
        <type>Iterator</type>
        <definition>Iterator DataModel_detail::dvl_remove_if</definition>
        <argsstring>(Iterator beg, Iterator end, Predicate pred)</argsstring>
        <name>dvl_remove_if</name>
        <param>
          <type>Iterator</type>
          <declname>beg</declname>
        </param>
        <param>
          <type>Iterator</type>
          <declname>end</declname>
        </param>
        <param>
          <type>Predicate</type>
          <declname>pred</declname>
        </param>
        <briefdescription>
<para>Specialization of <computeroutput>remove_if</computeroutput> for <computeroutput>DataVector/List</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>beg</parametername>
</parameternamelist>
<parameterdescription>
<para>The start <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">iterator</ref> for the remove. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>The end <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">iterator</ref> for the remove. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pred</parametername>
</parameternamelist>
<parameterdescription>
<para>The predicate for the removal.</para></parameterdescription>
</parameteritem>
</parameterlist>
<computeroutput>beg</computeroutput> and <computeroutput>end</computeroutput> should both be iterators from the same <computeroutput>DataVector/List</computeroutput>. This performs the remove in a way that doesn&apos;t run afoul of <computeroutput>DataVector/List&apos;s</computeroutput> object ownership rules. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.icc" line="155" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.icc" bodystart="152" bodyend="171"/>
      </memberdef>
      <memberdef kind="function" id="dc/d24/namespaceDataModel__detail_1a5f3eda32e163d40fc555bd7fdc0c8dc5" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Iterator</type>
          </param>
        </templateparamlist>
        <type>Iterator</type>
        <definition>Iterator DataModel_detail::dvl_unique</definition>
        <argsstring>(Iterator beg, Iterator end)</argsstring>
        <name>dvl_unique</name>
        <param>
          <type>Iterator</type>
          <declname>beg</declname>
        </param>
        <param>
          <type>Iterator</type>
          <declname>end</declname>
        </param>
        <briefdescription>
<para>Specialization of <computeroutput>unique</computeroutput> for <computeroutput>DataVector/List</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>beg</parametername>
</parameternamelist>
<parameterdescription>
<para>The start <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">iterator</ref> for the unique operation. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>The end <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">iterator</ref> for the unique operation.</para></parameterdescription>
</parameteritem>
</parameterlist>
<computeroutput>beg</computeroutput> and <computeroutput>end</computeroutput> should both be iterators from the same <computeroutput>DataVector/List</computeroutput>. This performs the operation in a way that doesn&apos;t run afoul of <computeroutput>DataVector/List&apos;s</computeroutput> object ownership rules. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.icc" line="187" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.icc" bodystart="185" bodyend="201"/>
      </memberdef>
      <memberdef kind="function" id="dc/d24/namespaceDataModel__detail_1a872437a2637fc7200363c17f1b9a26ba" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Iterator</type>
          </param>
          <param>
            <type>class BinaryPredicate</type>
          </param>
        </templateparamlist>
        <type>Iterator</type>
        <definition>Iterator DataModel_detail::dvl_unique</definition>
        <argsstring>(Iterator beg, Iterator end, BinaryPredicate pred)</argsstring>
        <name>dvl_unique</name>
        <param>
          <type>Iterator</type>
          <declname>beg</declname>
        </param>
        <param>
          <type>Iterator</type>
          <declname>end</declname>
        </param>
        <param>
          <type>BinaryPredicate</type>
          <declname>pred</declname>
        </param>
        <briefdescription>
<para>Specialization of <computeroutput>unique</computeroutput> for <computeroutput>DataVector/List</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>beg</parametername>
</parameternamelist>
<parameterdescription>
<para>The start <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">iterator</ref> for the unique operation. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>The end <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">iterator</ref> for the unique operation. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pred</parametername>
</parameternamelist>
<parameterdescription>
<para>The predicate for the operation.</para></parameterdescription>
</parameteritem>
</parameterlist>
<computeroutput>beg</computeroutput> and <computeroutput>end</computeroutput> should both be iterators from the same <computeroutput>DataVector/List</computeroutput>. This performs the operation in a way that doesn&apos;t run afoul of <computeroutput>DataVector/List&apos;s</computeroutput> object ownership rules. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.icc" line="220" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.icc" bodystart="217" bodyend="234"/>
      </memberdef>
      <memberdef kind="function" id="dc/d24/namespaceDataModel__detail_1ad2e1c99fe8c8ba3ae226208fc07c74ab" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class ForwardIterator</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void DataModel_detail::resortAux</definition>
        <argsstring>(ForwardIterator beg, ForwardIterator end)</argsstring>
        <name>resortAux</name>
        <param>
          <type>ForwardIterator</type>
          <declname>beg</declname>
        </param>
        <param>
          <type>ForwardIterator</type>
          <declname>end</declname>
        </param>
        <briefdescription>
<para>Reset indices / reorder aux data after elements have been permuted. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>beg</parametername>
</parameternamelist>
<parameterdescription>
<para>Start of the range of elements to process. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>End of the range of elements to process.</para></parameterdescription>
</parameteritem>
</parameterlist>
Call this after some operation that has permuted the elements in the container (such as sort). The index information in the elements will be used to permute all auxiliary data in the same way. Finally, all the indices will be reset in the correct order.</para><para><computeroutput>ForwardIterator</computeroutput> should be an <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">iterator</ref> over the <computeroutput><ref refid="d0/d4d/classDataVector" kindref="compound">DataVector</ref></computeroutput> (not a base <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">iterator</ref>). </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.icc" line="254" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.icc" bodystart="252" bodyend="259"/>
      </memberdef>
      <memberdef kind="function" id="dc/d24/namespaceDataModel__detail_1a8461b8239373e53c9760e8cb7b027e71" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class DVL</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void DataModel_detail::resortAux1</definition>
        <argsstring>(const SG_STD_OR_BOOST::true_type &amp;, typename DataModel_detail::iterator&lt; DVL &gt; beg, typename DataModel_detail::iterator&lt; DVL &gt; end)</argsstring>
        <name>resortAux1</name>
        <param>
          <type>const SG_STD_OR_BOOST::true_type &amp;</type>
        </param>
        <param>
          <type>typename <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt;</type>
          <declname>beg</declname>
        </param>
        <param>
          <type>typename <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt;</type>
          <declname>end</declname>
        </param>
        <briefdescription>
<para>Reset indices / reorder aux data after elements have been permuted. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>beg</parametername>
</parameternamelist>
<parameterdescription>
<para>Start of the range of elements to process. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>End of the range of elements to process.</para></parameterdescription>
</parameteritem>
</parameterlist>
Aux data case. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.icc" line="273" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.icc" bodystart="270" bodyend="279"/>
      </memberdef>
      <memberdef kind="function" id="dc/d24/namespaceDataModel__detail_1ae124a81785c42edc7c5dfe773efb897e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class DVL</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void DataModel_detail::resortAux1</definition>
        <argsstring>(const SG_STD_OR_BOOST::true_type &amp;, typename std::reverse_iterator&lt; typename DataModel_detail::iterator&lt; DVL &gt; &gt; beg, typename std::reverse_iterator&lt; typename DataModel_detail::iterator&lt; DVL &gt; &gt; end)</argsstring>
        <name>resortAux1</name>
        <param>
          <type>const SG_STD_OR_BOOST::true_type &amp;</type>
        </param>
        <param>
          <type>typename std::reverse_iterator&lt; typename <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt; &gt;</type>
          <declname>beg</declname>
        </param>
        <param>
          <type>typename std::reverse_iterator&lt; typename <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; DVL &gt; &gt;</type>
          <declname>end</declname>
        </param>
        <briefdescription>
<para>Reset indices / reorder aux data after elements have been permuted. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>beg</parametername>
</parameternamelist>
<parameterdescription>
<para>Start of the range of elements to process. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>End of the range of elements to process.</para></parameterdescription>
</parameteritem>
</parameterlist>
Aux data case with reverse iterators. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.icc" line="293" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.icc" bodystart="290" bodyend="299"/>
      </memberdef>
      <memberdef kind="function" id="dc/d24/namespaceDataModel__detail_1a70b41edac2feac37da128e4ee9e2fa6f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class ForwardIterator</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void DataModel_detail::resortAux1</definition>
        <argsstring>(const SG_STD_OR_BOOST::false_type &amp;, ForwardIterator, ForwardIterator)</argsstring>
        <name>resortAux1</name>
        <param>
          <type>const SG_STD_OR_BOOST::false_type &amp;</type>
        </param>
        <param>
          <type>ForwardIterator</type>
        </param>
        <param>
          <type>ForwardIterator</type>
        </param>
        <briefdescription>
<para>Reset indices / reorder aux data after elements have been permuted. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>beg</parametername>
</parameternamelist>
<parameterdescription>
<para>Start of the range of elements to process. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>End of the range of elements to process.</para></parameterdescription>
</parameteritem>
</parameterlist>
No-auxdata case; just a no-op. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.icc" line="314" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVL_algorithms.icc" bodystart="311" bodyend="315"/>
      </memberdef>
      <memberdef kind="function" id="dc/d24/namespaceDataModel__detail_1aca4891afa8668d79a6ef99812ad6f7e8" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class <ref refid="d1/def/classT" kindref="compound">T</ref></type>
          </param>
        </templateparamlist>
        <type>void *</type>
        <definition>void * DataModel_detail::dvl_convert</definition>
        <argsstring>(const T &amp;src, const DVLInfoBase &amp;targ_info)</argsstring>
        <name>dvl_convert</name>
        <param>
          <type>const <ref refid="d1/def/classT" kindref="compound">T</ref> &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>const <ref refid="da/d8a/classDataModel__detail_1_1DVLInfoBase" kindref="compound">DVLInfoBase</ref> &amp;</type>
          <declname>targ_info</declname>
        </param>
        <briefdescription>
<para>Perform <computeroutput>DataVector/<computeroutput><ref refid="d9/dfb/classDataList" kindref="compound">DataList</ref></computeroutput> conversion</computeroutput> copying. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>src</parametername>
</parameternamelist>
<parameterdescription>
<para>The source container. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>targ_info</parametername>
</parameternamelist>
<parameterdescription>
<para>The <computeroutput><ref refid="df/d12/classDataModel__detail_1_1DVLInfo" kindref="compound">DVLInfo</ref></computeroutput> for the target container type. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The new container, or 0.</para></simplesect>
If the elements of <emphasis>src</emphasis> can be converted to elements of a <emphasis>targ_tinfo</emphasis> container, then we make a new (view) container of that type and populate it with elements copied from <emphasis>src</emphasis>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVLInfo.h" line="341" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVLInfo.icc" bodystart="341" bodyend="368"/>
      </memberdef>
      <memberdef kind="function" id="dc/d24/namespaceDataModel__detail_1af6aae1ab8e9369048eec860b65335b63" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class <ref refid="d1/def/classT" kindref="compound">T</ref></type>
          </param>
        </templateparamlist>
        <type>void *</type>
        <definition>void * DataModel_detail::dvl_convert</definition>
        <argsstring>(const T &amp;src, const std::type_info &amp;targ_tinfo, DVLInfoBase *&amp;targ_info)</argsstring>
        <name>dvl_convert</name>
        <param>
          <type>const <ref refid="d1/def/classT" kindref="compound">T</ref> &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>const std::type_info &amp;</type>
          <declname>targ_tinfo</declname>
        </param>
        <param>
          <type><ref refid="da/d8a/classDataModel__detail_1_1DVLInfoBase" kindref="compound">DVLInfoBase</ref> *&amp;</type>
          <declname>targ_info</declname>
        </param>
        <briefdescription>
<para>Perform <computeroutput>DataVector/<computeroutput><ref refid="d9/dfb/classDataList" kindref="compound">DataList</ref></computeroutput> conversion</computeroutput> copying. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>src</parametername>
</parameternamelist>
<parameterdescription>
<para>The source container. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>targ_tinfo</parametername>
</parameternamelist>
<parameterdescription>
<para><computeroutput>type_info</computeroutput> for the desired container type. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>targ_info[out]</parametername>
</parameternamelist>
<parameterdescription>
<para>The <computeroutput><ref refid="df/d12/classDataModel__detail_1_1DVLInfo" kindref="compound">DVLInfo</ref></computeroutput> for the target container type. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The new container, or 0.</para></simplesect>
If the elements of <emphasis>src</emphasis> can be converted to elements of a <emphasis>targ_tinfo</emphasis> container, then we make a new (view) container of that type and populate it with elements copied from <emphasis>src</emphasis>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVLInfo.h" line="358" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVLInfo.icc" bodystart="385" bodyend="395"/>
      </memberdef>
      <memberdef kind="function" id="dc/d24/namespaceDataModel__detail_1a98e97bceea1f629a7a9015bd5207883d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class <ref refid="d1/def/classT" kindref="compound">T</ref></type>
          </param>
        </templateparamlist>
        <type>void *</type>
        <definition>void * DataModel_detail::dvl_convert</definition>
        <argsstring>(const T &amp;src, CLID clid, DVLInfoBase *&amp;targ_info)</argsstring>
        <name>dvl_convert</name>
        <param>
          <type>const <ref refid="d1/def/classT" kindref="compound">T</ref> &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type><ref refid="d0/d66/ClassID__traits_8h_1a2d7068444af754bf943f1dcbc5893801" kindref="member">CLID</ref></type>
          <declname>clid</declname>
        </param>
        <param>
          <type><ref refid="da/d8a/classDataModel__detail_1_1DVLInfoBase" kindref="compound">DVLInfoBase</ref> *&amp;</type>
          <declname>targ_info</declname>
        </param>
        <briefdescription>
<para>Perform <computeroutput>DataVector/<computeroutput><ref refid="d9/dfb/classDataList" kindref="compound">DataList</ref></computeroutput> conversion</computeroutput> copying. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>src</parametername>
</parameternamelist>
<parameterdescription>
<para>The source container. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>clid</parametername>
</parameternamelist>
<parameterdescription>
<para>CLID for the desired container type. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>targ_info[out]</parametername>
</parameternamelist>
<parameterdescription>
<para>The <computeroutput><ref refid="df/d12/classDataModel__detail_1_1DVLInfo" kindref="compound">DVLInfo</ref></computeroutput> for the target container type. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The new container, or 0.</para></simplesect>
If the elements of <emphasis>src</emphasis> can be converted to elements of a <emphasis>targ_tinfo</emphasis> container, then we make a new (view) container of that type and populate it with elements copied from <emphasis>src</emphasis>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVLInfo.h" line="375" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVLInfo.icc" bodystart="410" bodyend="420"/>
      </memberdef>
      <memberdef kind="function" id="dc/d24/namespaceDataModel__detail_1a0c920d2162b908431484be2001d5282a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class <ref refid="d1/def/classT" kindref="compound">T</ref></type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void DataModel_detail::dvl_update</definition>
        <argsstring>(const T &amp;src, void *target, const DVLInfoBase *targ_info)</argsstring>
        <name>dvl_update</name>
        <param>
          <type>const <ref refid="d1/def/classT" kindref="compound">T</ref> &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>target</declname>
        </param>
        <param>
          <type>const <ref refid="da/d8a/classDataModel__detail_1_1DVLInfoBase" kindref="compound">DVLInfoBase</ref> *</type>
          <declname>targ_info</declname>
        </param>
        <briefdescription>
<para>Update the elements in the target container from the source. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>src</parametername>
</parameternamelist>
<parameterdescription>
<para>The source container. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>target</parametername>
</parameternamelist>
<parameterdescription>
<para>The target container. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>targ_info</parametername>
</parameternamelist>
<parameterdescription>
<para>The <computeroutput><ref refid="df/d12/classDataModel__detail_1_1DVLInfo" kindref="compound">DVLInfo</ref></computeroutput> for the target container type.</para></parameterdescription>
</parameteritem>
</parameterlist>
The target container is cleared and then repopulated from the elements of the source container. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVLInfo.h" line="390" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVLInfo.icc" bodystart="443" bodyend="468"/>
      </memberdef>
      <memberdef kind="function" id="dc/d24/namespaceDataModel__detail_1afbf794e5a3af6f690663ccb5f42cde97" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class CONTAINER</type>
          </param>
          <param>
            <type>class ELT</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void DataModel_detail::dvlPush</definition>
        <argsstring>(CONTAINER &amp;cont, ELT *elt, const SG_STD_OR_BOOST::true_type &amp;)</argsstring>
        <name>dvlPush</name>
        <param>
          <type>CONTAINER &amp;</type>
          <declname>cont</declname>
        </param>
        <param>
          <type>ELT *</type>
          <declname>elt</declname>
        </param>
        <param>
          <type>const SG_STD_OR_BOOST::true_type &amp;</type>
        </param>
        <briefdescription>
<para>Helper function to do <computeroutput>push_back</computeroutput> on a container. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>cont</parametername>
</parameternamelist>
<parameterdescription>
<para>The container. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>elt</parametername>
</parameternamelist>
<parameterdescription>
<para>The element to push</para></parameterdescription>
</parameteritem>
</parameterlist>
This specialization is for the case when the container holds pointers. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVLInfo.icc" line="38" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVLInfo.icc" bodystart="37" bodyend="40"/>
      </memberdef>
      <memberdef kind="function" id="dc/d24/namespaceDataModel__detail_1a238c67cea559169cc7501f29f6d7afbf" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class CONTAINER</type>
          </param>
          <param>
            <type>class ELT</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void DataModel_detail::dvlPush</definition>
        <argsstring>(CONTAINER &amp;cont, ELT *elt, const SG_STD_OR_BOOST::false_type &amp;)</argsstring>
        <name>dvlPush</name>
        <param>
          <type>CONTAINER &amp;</type>
          <declname>cont</declname>
        </param>
        <param>
          <type>ELT *</type>
          <declname>elt</declname>
        </param>
        <param>
          <type>const SG_STD_OR_BOOST::false_type &amp;</type>
        </param>
        <briefdescription>
<para>Helper function to do <computeroutput>push_back</computeroutput> on a container. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>cont</parametername>
</parameternamelist>
<parameterdescription>
<para>The container. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>elt</parametername>
</parameternamelist>
<parameterdescription>
<para>The element to push</para></parameterdescription>
</parameteritem>
</parameterlist>
This specialization is for the case when the container does not hold pointers. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVLInfo.icc" line="54" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVLInfo.icc" bodystart="53" bodyend="56"/>
      </memberdef>
      <memberdef kind="function" id="dc/d24/namespaceDataModel__detail_1ac59c59a62fde42eb10cac0dacda7dabc" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class ITERATOR</type>
          </param>
        </templateparamlist>
        <type>const void *</type>
        <definition>const void* DataModel_detail::dvlGetPointer</definition>
        <argsstring>(ITERATOR &amp;it, const SG_STD_OR_BOOST::true_type &amp;)</argsstring>
        <name>dvlGetPointer</name>
        <param>
          <type>ITERATOR &amp;</type>
          <declname>it</declname>
        </param>
        <param>
          <type>const SG_STD_OR_BOOST::true_type &amp;</type>
        </param>
        <briefdescription>
<para>Helper function to return a pointer from an <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">iterator</ref>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>it</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">iterator</ref>.</para></parameterdescription>
</parameteritem>
</parameterlist>
This specialization is for the case when the container holds pointers. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVLInfo.icc" line="68" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVLInfo.icc" bodystart="67" bodyend="70"/>
      </memberdef>
      <memberdef kind="function" id="dc/d24/namespaceDataModel__detail_1a48e4240b0ab33822ea6bebfd8f971f25" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class ITERATOR</type>
          </param>
        </templateparamlist>
        <type>const void *</type>
        <definition>const void* DataModel_detail::dvlGetPointer</definition>
        <argsstring>(ITERATOR &amp;it, const SG_STD_OR_BOOST::false_type &amp;)</argsstring>
        <name>dvlGetPointer</name>
        <param>
          <type>ITERATOR &amp;</type>
          <declname>it</declname>
        </param>
        <param>
          <type>const SG_STD_OR_BOOST::false_type &amp;</type>
        </param>
        <briefdescription>
<para>Helper function to return a pointer from an <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">iterator</ref>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>it</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">iterator</ref>.</para></parameterdescription>
</parameteritem>
</parameterlist>
This specialization is for the case when the container does not hold pointers. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVLInfo.icc" line="83" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVLInfo.icc" bodystart="82" bodyend="85"/>
      </memberdef>
      <memberdef kind="function" id="dc/d24/namespaceDataModel__detail_1a3c5fa6eba72e32e8a48fef0cebb67d74" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class <ref refid="d1/def/classT" kindref="compound">T</ref></type>
          </param>
        </templateparamlist>
        <type><ref refid="dd/da5/classSG_1_1AuxVectorBase" kindref="compound">SG::AuxVectorBase</ref> *</type>
        <definition>SG::AuxVectorBase* DataModel_detail::dvlGetBase</definition>
        <argsstring>(T *p, const SG_STD_OR_BOOST::true_type &amp;)</argsstring>
        <name>dvlGetBase</name>
        <param>
          <type><ref refid="d1/def/classT" kindref="compound">T</ref> *</type>
          <declname>p</declname>
        </param>
        <param>
          <type>const SG_STD_OR_BOOST::true_type &amp;</type>
        </param>
        <briefdescription>
<para>Helper for converting a container to  AuxVectorBase. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVLInfo.icc" line="93" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVLInfo.icc" bodystart="92" bodyend="95"/>
      </memberdef>
      <memberdef kind="function" id="dc/d24/namespaceDataModel__detail_1a8aef6a455cb57f66be65a22447f854d8" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class <ref refid="d1/def/classT" kindref="compound">T</ref></type>
          </param>
        </templateparamlist>
        <type><ref refid="dd/da5/classSG_1_1AuxVectorBase" kindref="compound">SG::AuxVectorBase</ref> *</type>
        <definition>SG::AuxVectorBase* DataModel_detail::dvlGetBase</definition>
        <argsstring>(T *, const SG_STD_OR_BOOST::false_type &amp;)</argsstring>
        <name>dvlGetBase</name>
        <param>
          <type><ref refid="d1/def/classT" kindref="compound">T</ref> *</type>
        </param>
        <param>
          <type>const SG_STD_OR_BOOST::false_type &amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVLInfo.icc" line="98" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVLInfo.icc" bodystart="97" bodyend="100"/>
      </memberdef>
      <memberdef kind="function" id="dc/d24/namespaceDataModel__detail_1a720b19048fa8712a297c0a01c1fc72cf" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class <ref refid="d1/def/classT" kindref="compound">T</ref></type>
          </param>
        </templateparamlist>
        <type>size_t</type>
        <definition>size_t DataModel_detail::dvl_size_const</definition>
        <argsstring>(const T &amp;c)</argsstring>
        <name>dvl_size_const</name>
        <param>
          <type>const <ref refid="d1/def/classT" kindref="compound">T</ref> &amp;</type>
          <declname>c</declname>
        </param>
        <briefdescription>
<para>Return container size in constant time, or 0. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>The container.</para></parameterdescription>
</parameteritem>
</parameterlist>
This will return the size of container <emphasis>c</emphasis>, if it is possible to do so in constant time. Otherwise, it returns 0. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVLInfo.icc" line="302" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVLInfo.icc" bodystart="301" bodyend="304"/>
      </memberdef>
      <memberdef kind="function" id="dc/d24/namespaceDataModel__detail_1a8dac04886d9b9256439dc753345e75ef" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class <ref refid="d1/def/classT" kindref="compound">T</ref></type>
          </param>
        </templateparamlist>
        <type>size_t</type>
        <definition>size_t DataModel_detail::dvl_size_const</definition>
        <argsstring>(const std::list&lt; T &gt; &amp;)</argsstring>
        <name>dvl_size_const</name>
        <param>
          <type>const std::list&lt; <ref refid="d1/def/classT" kindref="compound">T</ref> &gt; &amp;</type>
        </param>
        <briefdescription>
<para>Return container size in constant time, or 0. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>The container.</para></parameterdescription>
</parameteritem>
</parameterlist>
This is a specialization for <computeroutput>list</computeroutput>; here we just return 0. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVLInfo.icc" line="316" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/DVLInfo.icc" bodystart="315" bodyend="318"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/tools/AuxTypeVector.icc" line="125"/>
  </compounddef>
</doxygen>
