<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.6.1">
  <compounddef id="d0/d4d/classDataVector" kind="class" prot="public">
    <compoundname>DataVector</compoundname>
    <basecompoundref refid="d6/de5/classKeepFirstTemplateArguments" prot="private" virt="non-virtual">KeepFirstTemplateArguments&lt; 1 &gt;</basecompoundref>
    <includes refid="d7/dd6/DataVector_8h" local="no">DataVector.h</includes>
    <templateparamlist>
      <param>
        <type>class</type>
        <declname>T</declname>
        <defname>T</defname>
      </param>
      <param>
        <type>class</type>
        <declname>BASE</declname>
        <defname>BASE</defname>
        <defval>typename <ref refid="dd/d4c/structDataVectorBase" kindref="compound">DataVectorBase</ref>&lt;<ref refid="d1/def/classT" kindref="compound">T</ref>&gt;::<ref refid="d5/dd9/classtypename_01DataVectorBase_1_1Base" kindref="compound">Base</ref></defval>
      </param>
    </templateparamlist>
      <sectiondef kind="user-defined">
      <header>Internal operations.</header>
      <description><para><anchor id="_1amgrp18fcc315290ab5188be82cc8bf66dc29"/> </para></description>
      <memberdef kind="friend" id="d0/d4d/classDataVector_1a2cf6a773e2f312ccade13b686b8f01d6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>friend class</type>
        <definition>friend class DataModel_detail::ElementProxy&lt; DataVector &gt;</definition>
        <argsstring></argsstring>
        <name>DataModel_detail::ElementProxy&lt; DataVector &gt;</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1770" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" bodystart="1770" bodyend="-1"/>
      </memberdef>
      <memberdef kind="friend" id="d0/d4d/classDataVector_1a872beca4ae4bd23ae0ca85253466b96b" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>friend class</type>
        <definition>friend class ConstDataVector&lt; DataVector &gt;</definition>
        <argsstring></argsstring>
        <name>ConstDataVector&lt; DataVector &gt;</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1771" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" bodystart="1771" bodyend="-1"/>
      </memberdef>
      <memberdef kind="friend" id="d0/d4d/classDataVector_1a1119a539ef95e66a83ed73e65ce4acb9" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>friend void</type>
        <definition>void test2_assignelement1</definition>
        <argsstring>()</argsstring>
        <name>test2_assignelement1</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1772" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/test/DataList_test.cxx" bodystart="3170" bodyend="3181"/>
      </memberdef>
      <memberdef kind="friend" id="d0/d4d/classDataVector_1a5d549df8562ac32795e7bebf440b830d" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>friend void</type>
        <definition>void test2_assignelement2</definition>
        <argsstring>()</argsstring>
        <name>test2_assignelement2</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1773" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/test/DataVector_test.icc" bodystart="5659" bodyend="5707"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1af1d9fb01d514c009d7acefc7ac7b02c1" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void DataVector&lt; T, BASE &gt;::resortAux</definition>
        <argsstring>(iterator beg, iterator end)</argsstring>
        <name>resortAux</name>
        <param>
          <type><ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">iterator</ref></type>
          <declname>beg</declname>
        </param>
        <param>
          <type><ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">iterator</ref></type>
          <declname>end</declname>
        </param>
        <briefdescription>
<para>Reset indices / reorder aux data after elements have been permuted. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>beg</parametername>
</parameternamelist>
<parameterdescription>
<para>Start of the range of elements to process. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>End of the range of elements to process.</para></parameterdescription>
</parameteritem>
</parameterlist>
Call this after some operation that has permuted the elements in the container (such as sort). The index information in the elements will be used to permute all auxiliary data in the same way. Finally, all the indices will be reset in the correct order. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1740" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="1735" bodyend="1742"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1a3a87c3dae960c19e5108bbacad44b557" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void DataVector&lt; T, BASE &gt;::testInsert</definition>
        <argsstring>(const char *op)</argsstring>
        <name>testInsert</name>
        <param>
          <type>const char *</type>
          <declname>op</declname>
        </param>
        <briefdescription>
<para>Test if we can insert; raise an exception if not. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>op</parametername>
</parameternamelist>
<parameterdescription>
<para>Description of the attempted operation.</para></parameterdescription>
</parameteritem>
</parameterlist>
In order to maintain type-safety, we can only allow insertions using the most-derived instance of <computeroutput><ref refid="d0/d4d/classDataVector" kindref="compound">DataVector</ref></computeroutput>. This checks this by testing the <computeroutput>m_isMostDerived</computeroutput>, which is set by the constructors to true only for the most-derived instance. If the test fails, we call to potentially out-of-line code to continue. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1753" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="1757" bodyend="1762"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1aebc91510c38d2fd8e413736faa744258" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void DataVector&lt; T, BASE &gt;::testInsertOol</definition>
        <argsstring>(const char *op)</argsstring>
        <name>testInsertOol</name>
        <param>
          <type>const char *</type>
          <declname>op</declname>
        </param>
        <briefdescription>
<para>Test if we can insert; raise an exception if not. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>op</parametername>
</parameternamelist>
<parameterdescription>
<para>Description of the attempted operation.</para></parameterdescription>
</parameteritem>
</parameterlist>
This continues the test of <computeroutput>testInsert</computeroutput>. There is one case where <computeroutput>m_isMostDerived</computeroutput> may not be set correctly. If this container was made via copy construction, then all the <computeroutput>m_isMostDerived</computeroutput> flags will be false. So we call <computeroutput>setMostDerived</computeroutput> to set the flags correctly and test again. If the test fails again, then we raise an exception. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1766" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="1776" bodyend="1781"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1ad1616eb350fff0fc40908c62bb8fd9da" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>int DataVector&lt; T, BASE &gt;::baseOffset1</definition>
        <argsstring>(const char *p, const DataVector &amp;dv, const std::type_info &amp;ti)</argsstring>
        <name>baseOffset1</name>
        <param>
          <type>const char *</type>
          <declname>p</declname>
        </param>
        <param>
          <type>const <ref refid="d0/d4d/classDataVector" kindref="compound">DataVector</ref> &amp;</type>
          <declname>dv</declname>
        </param>
        <param>
          <type>const std::type_info &amp;</type>
          <declname>ti</declname>
        </param>
        <briefdescription>
<para>Helper for <computeroutput>baseOffset</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the start of the top-level object. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dv</parametername>
</parameternamelist>
<parameterdescription>
<para>Reference to the <ref refid="d0/d4d/classDataVector" kindref="compound">DataVector</ref> object. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ti</parametername>
</parameternamelist>
<parameterdescription>
<para><computeroutput>std::type_info</computeroutput> of the desired class.</para></parameterdescription>
</parameteritem>
</parameterlist>
If <computeroutput>ti</computeroutput> represents a <computeroutput><ref refid="d0/d4d/classDataVector" kindref="compound">DataVector</ref></computeroutput> base class of this one, then return the offset of that base class. Otherwise, return -1. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1727" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="1715" bodyend="1721"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1abf16cf8a9eb9c1c6a4419be395208ca0" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>const <ref refid="d1/def/classT" kindref="compound">T</ref> *</type>
        <definition>const T * DataVector&lt; T, BASE &gt;::do_cast</definition>
        <argsstring>(const typename PtrVector::value_type p)</argsstring>
        <name>do_cast</name>
        <param>
          <type>const typename PtrVector::value_type</type>
          <declname>p</declname>
        </param>
        <briefdescription>
<para>Helper to shorten calls to <computeroutput><ref refid="de/d59/structDataModel__detail_1_1DVLCast" kindref="compound">DataModel_detail::DVLCast</ref></computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para>Helper to shorten calls to <computeroutput>DataVector_detail::DVLCast</computeroutput>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>The value to convert. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The value as a <computeroutput>const</computeroutput> <computeroutput>T*</computeroutput>.</para></simplesect>
The conversion will be done with <computeroutput>static_cast</computeroutput> if possible, with <computeroutput>dynamic_cast</computeroutput> otherwise. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1852" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="1901" bodyend="1904"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1af08a0fb0d5e1655c63479b6c3e2c06da" prot="private" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void DataVector&lt; T, BASE &gt;::assignElement</definition>
        <argsstring>(typename BaseContainer::iterator pos, value_type newElem)</argsstring>
        <name>assignElement</name>
        <param>
          <type>typename BaseContainer::iterator</type>
          <declname>pos</declname>
        </param>
        <param>
          <type><ref refid="d1/def/classT" kindref="compound">value_type</ref></type>
          <declname>newElem</declname>
        </param>
        <briefdescription>
<para>Handle element assignment. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pos</parametername>
</parameternamelist>
<parameterdescription>
<para>Position in the container to assign. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>newElem</parametername>
</parameternamelist>
<parameterdescription>
<para>The new element to assign.</para></parameterdescription>
</parameteritem>
</parameterlist>
The old element is freed if this container owns elements. Auxiliary data are copied if appropriate. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1784" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="1793" bodyend="1803"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1af5800a07e6b959507c45e25fc0b1cc2c" prot="private" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void DataVector&lt; T, BASE &gt;::assignBaseElement</definition>
        <argsstring>(typename BaseContainer::iterator pos, typename BaseContainer::value_type newElem)</argsstring>
        <name>assignBaseElement</name>
        <param>
          <type>typename BaseContainer::iterator</type>
          <declname>pos</declname>
        </param>
        <param>
          <type>typename BaseContainer::value_type</type>
          <declname>newElem</declname>
        </param>
        <briefdescription>
<para>Handle element assignment from a base pointer. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pos</parametername>
</parameternamelist>
<parameterdescription>
<para>Position in the container to assign. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>newElem</parametername>
</parameternamelist>
<parameterdescription>
<para>The new element to assign.</para></parameterdescription>
</parameteritem>
</parameterlist>
The old element is freed if this container owns elements. Auxiliary data are copied if appropriate. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1812" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="1845" bodyend="1857"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1a24c0a6410e85f44373c379aa8ba2d3ee" prot="private" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void DataVector&lt; T, BASE &gt;::shift</definition>
        <argsstring>(size_t pos, ptrdiff_t offs)</argsstring>
        <name>shift</name>
        <param>
          <type>size_t</type>
          <declname>pos</declname>
        </param>
        <param>
          <type>ptrdiff_t</type>
          <declname>offs</declname>
        </param>
        <briefdescription>
<para>Shift the auxiliary elements of the container. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pos</parametername>
</parameternamelist>
<parameterdescription>
<para>The starting index for the shift. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>offs</parametername>
</parameternamelist>
<parameterdescription>
<para>The (signed) amount of the shift.</para></parameterdescription>
</parameteritem>
</parameterlist>
The elements in the container should have already been shifted; this operation will then adjust the element indices and also shift the elements in the vectors for all aux data items. <computeroutput>offs</computeroutput> may be either positive or negative.</para><para>If <computeroutput>offs</computeroutput> is positive, then the container is growing. The container size should be increased by <computeroutput>offs</computeroutput>, the element at <computeroutput>pos</computeroutput> moved to <computeroutput>pos</computeroutput> + <computeroutput>offs</computeroutput>, and similarly for following elements. The elements between <computeroutput>pos</computeroutput> and <computeroutput>pos</computeroutput> + <computeroutput>offs</computeroutput> should be default-initialized.</para><para>If <computeroutput>offs</computeroutput> is negative, then the container is shrinking. The element at <computeroutput>pos</computeroutput> should be moved to <computeroutput>pos</computeroutput> + <computeroutput>offs</computeroutput>, and similarly for following elements. The container should then be shrunk by <computeroutput>-offs</computeroutput> elements (running destructors as appropriate). </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1838" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="1884" bodyend="1887"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1a9ffd936a428c6cacdc3547946901a6a9" prot="private" static="no" const="yes" explicit="no" inline="yes" virt="virtual">
        <type>const std::type_info &amp;</type>
        <definition>const std::type_info &amp; DataVector&lt; T, BASE &gt;::dv_typeid</definition>
        <argsstring>() const </argsstring>
        <name>dv_typeid</name>
        <reimplementedby refid="df/d07/structDataVector__detail_1_1VirtBases_1a5ecdc7a5b742fbcef0f4f80232b9a634">dv_typeid</reimplementedby>
        <reimplementedby refid="df/d4a/structDataVector__detail_1_1VirtBases_3_01B1_00_01B2_00_01DataModel__detail_1_1NoBase_01_4_1a926abef837fa466046f3f77b06d287e3">dv_typeid</reimplementedby>
        <reimplementedby refid="db/d76/structDataVector__detail_1_1VirtBases_3_01B1_00_01DataModel__detail_1_1NoBase_00_01DataModel__detail_1_1NoBase_01_4_1ab2fd06acf1b5b7962d1beb07aae55588">dv_typeid</reimplementedby>
        <briefdescription>
<para>Find the most-derived <computeroutput><ref refid="d0/d4d/classDataVector" kindref="compound">DataVector</ref></computeroutput> class in the hierarchy. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>The <computeroutput>type_info</computeroutput> for the class for which this method gets run.</para></simplesect>
This is used to generate a nice error message when the most-derived check for insertions fails. Every <computeroutput><ref refid="d0/d4d/classDataVector" kindref="compound">DataVector</ref></computeroutput> defines this virtual method, so when it&apos;s called, the one corresponding to the most-derived <computeroutput><ref refid="d0/d4d/classDataVector" kindref="compound">DataVector</ref></computeroutput> gets run. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1866" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="1918" bodyend="1921"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1a94c4e1b8437edab8296380c7d620faac" prot="protected" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void DataVector&lt; T, BASE &gt;::clearMostDerived</definition>
        <argsstring>()</argsstring>
        <name>clearMostDerived</name>
        <reimplementedby refid="df/d07/structDataVector__detail_1_1VirtBases_1a4367c18ffa34a80310f5514544d53be5">clearMostDerived</reimplementedby>
        <reimplementedby refid="df/d4a/structDataVector__detail_1_1VirtBases_3_01B1_00_01B2_00_01DataModel__detail_1_1NoBase_01_4_1ad24a52ca335bd4c96557d50f0982f59f">clearMostDerived</reimplementedby>
        <reimplementedby refid="db/d76/structDataVector__detail_1_1VirtBases_3_01B1_00_01DataModel__detail_1_1NoBase_00_01DataModel__detail_1_1NoBase_01_4_1a3bc05bc8ef5d92ff27088403889dc10b">clearMostDerived</reimplementedby>
        <briefdescription>
<para>Clear <computeroutput>m_isMostDerived</computeroutput> for this instance and for all bases. </para>        </briefdescription>
        <detaileddescription>
<para>Called from the constructor after setting <computeroutput>m_isMostDerived</computeroutput>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1875" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="1931" bodyend="1935"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1ac4e7932eb52095ae3e88c913a77f4685" prot="protected" static="no" const="no" explicit="no" inline="yes" virt="virtual">
        <type>void</type>
        <definition>void DataVector&lt; T, BASE &gt;::setMostDerived</definition>
        <argsstring>()</argsstring>
        <name>setMostDerived</name>
        <reimplementedby refid="df/d07/structDataVector__detail_1_1VirtBases_1a3b067558b537dd886157d06ee2708940">setMostDerived</reimplementedby>
        <reimplementedby refid="df/d4a/structDataVector__detail_1_1VirtBases_3_01B1_00_01B2_00_01DataModel__detail_1_1NoBase_01_4_1aeb62d8dcd8009b28ec03ca524515b146">setMostDerived</reimplementedby>
        <reimplementedby refid="db/d76/structDataVector__detail_1_1VirtBases_3_01B1_00_01DataModel__detail_1_1NoBase_00_01DataModel__detail_1_1NoBase_01_4_1a4572877b6ca43b9412ef745264c7325d">setMostDerived</reimplementedby>
        <briefdescription>
<para>Set <computeroutput>m_isMostDerived</computeroutput> for this instance and clear it for all bases. </para>        </briefdescription>
        <detaileddescription>
<para>Called from <computeroutput>testInsert</computeroutput> if the test fails. The flag may not have been set if this container was made via copy construction, so set it appropriately now so we can test again. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1885" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="1946" bodyend="1950"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Constructors, destructors, assignment.</header>
      <description><para><anchor id="_1amgrpb39bb9cb1bc18cddc74e7f363d4e2167"/> </para></description>
      <memberdef kind="function" id="d0/d4d/classDataVector_1a16bded828caf6b976bd7052d3439b5b6" prot="public" static="no" const="no" explicit="yes" inline="yes" virt="non-virtual">
        <type></type>
        <definition>EXIT_ROOT_SELECTION_NS DataVector&lt; T, BASE &gt;::DataVector</definition>
        <argsstring>(SG::OwnershipPolicy ownPolicy=SG::OWN_ELEMENTS, SG::IndexTrackingPolicy trackIndices=SG::DEFAULT_TRACK_INDICES)</argsstring>
        <name>DataVector</name>
        <param>
          <type><ref refid="dd/d59/namespaceSG_1acd9d1a31242c6243cc1c6fab0fbc7cd8" kindref="member">SG::OwnershipPolicy</ref></type>
          <declname>ownPolicy</declname>
          <defval>SG::OWN_ELEMENTS</defval>
        </param>
        <param>
          <type><ref refid="dd/d59/namespaceSG_1a9f3d699f65390b7f8baf54d9cd634573" kindref="member">SG::IndexTrackingPolicy</ref></type>
          <declname>trackIndices</declname>
          <defval>SG::DEFAULT_TRACK_INDICES</defval>
        </param>
        <briefdescription>
<para>Default constructor. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ownPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The ownership mode for the container. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>trackIndices</parametername>
</parameternamelist>
<parameterdescription>
<para>The index tracking policy.</para></parameterdescription>
</parameteritem>
</parameterlist>
By default, a <computeroutput><ref refid="d0/d4d/classDataVector" kindref="compound">DataVector</ref></computeroutput> will own its elements. To avoid this, pass <computeroutput><ref refid="dd/d59/namespaceSG_1acd9d1a31242c6243cc1c6fab0fbc7cd8ad7d4cf2303700f0966e4140f236c4bf1" kindref="member">SG::VIEW_ELEMENTS</ref></computeroutput> for <emphasis>ownPolicy</emphasis>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ownPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The ownership mode for the container. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>trackIndices</parametername>
</parameternamelist>
<parameterdescription>
<para>The index tracking policy.</para></parameterdescription>
</parameteritem>
</parameterlist>
By default, a <computeroutput><ref refid="d0/d4d/classDataVector" kindref="compound">DataVector</ref></computeroutput> will own its elements. To avoid this, pass <computeroutput><ref refid="dd/d59/namespaceSG_1acd9d1a31242c6243cc1c6fab0fbc7cd8ad7d4cf2303700f0966e4140f236c4bf1" kindref="member">SG::VIEW_ELEMENTS</ref></computeroutput> for <emphasis>ownPolicy</emphasis>.</para><para>Note that we do the complete initialization here in the derived class, using the default constructors for the base classes. The reason for this is to be able to deal nicely with the virtual derivation case. We can arrange to call the proper base class from here to get things initialized in the virtual derivation case. But then anyone who derives from us must also know to explicitly reference that base class. Doing the initialization explicitly here means that other classes who derive from us need only know about the most derived <ref refid="d0/d4d/classDataVector" kindref="compound">DataVector</ref> class. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="791" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="385" bodyend="392"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1a10e3c4b4b0de95c7fd13ad9a3be5fb58" prot="public" static="no" const="no" explicit="yes" inline="yes" virt="non-virtual">
        <type></type>
        <definition>DataVector&lt; T, BASE &gt;::DataVector</definition>
        <argsstring>(size_type n, SG::OwnershipPolicy ownPolicy=SG::OWN_ELEMENTS, SG::IndexTrackingPolicy trackIndices=SG::DEFAULT_TRACK_INDICES)</argsstring>
        <name>DataVector</name>
        <param>
          <type>size_type</type>
          <declname>n</declname>
        </param>
        <param>
          <type><ref refid="dd/d59/namespaceSG_1acd9d1a31242c6243cc1c6fab0fbc7cd8" kindref="member">SG::OwnershipPolicy</ref></type>
          <declname>ownPolicy</declname>
          <defval>SG::OWN_ELEMENTS</defval>
        </param>
        <param>
          <type><ref refid="dd/d59/namespaceSG_1a9f3d699f65390b7f8baf54d9cd634573" kindref="member">SG::IndexTrackingPolicy</ref></type>
          <declname>trackIndices</declname>
          <defval>SG::DEFAULT_TRACK_INDICES</defval>
        </param>
        <briefdescription>
<para>Sized constructor. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>The size of the container. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ownPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The ownership mode for the container. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>trackIndices</parametername>
</parameternamelist>
<parameterdescription>
<para>The index tracking policy.</para></parameterdescription>
</parameteritem>
</parameterlist>
Note that unlike the standard vector constructor, you can&apos;t specify an initial value here. The container will be initialized with 0&apos;s.</para><para>By default, a <computeroutput><ref refid="d0/d4d/classDataVector" kindref="compound">DataVector</ref></computeroutput> will own its elements. To avoid this, pass <computeroutput><ref refid="dd/d59/namespaceSG_1acd9d1a31242c6243cc1c6fab0fbc7cd8ad7d4cf2303700f0966e4140f236c4bf1" kindref="member">SG::VIEW_ELEMENTS</ref></computeroutput> for <emphasis>ownPolicy</emphasis>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>The size of the container. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ownPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The ownership mode for the container. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>trackIndices</parametername>
</parameternamelist>
<parameterdescription>
<para>The index tracking policy.</para></parameterdescription>
</parameteritem>
</parameterlist>
Note that unlike the standard vector constructor, you can&apos;t specify an initial value here. The container will be initialized with 0&apos;s.</para><para>By default, a <computeroutput><ref refid="d0/d4d/classDataVector" kindref="compound">DataVector</ref></computeroutput> will own its elements. To avoid this, pass <computeroutput><ref refid="dd/d59/namespaceSG_1acd9d1a31242c6243cc1c6fab0fbc7cd8ad7d4cf2303700f0966e4140f236c4bf1" kindref="member">SG::VIEW_ELEMENTS</ref></computeroutput> for <emphasis>ownPolicy</emphasis>.</para><para>Note that we do the complete initialization here in the derived class, using the default constructors for the base classes. The reason for this is to be able to deal nicely with the virtual derivation case. We can arrange to call the proper base class from here to get things initialized in the virtual derivation case. But then anyone who derives from us must also know to explicitly reference that base class. Doing the initialization explicitly here means that other classes who derive from us need only know about the most derived <ref refid="d0/d4d/classDataVector" kindref="compound">DataVector</ref> class. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="809" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="420" bodyend="429"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1ac113b3ae53f2d1254efc34bbacd25f14" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class InputIterator</type>
          </param>
        </templateparamlist>
        <type></type>
        <definition>DataVector&lt; T, BASE &gt;::DataVector</definition>
        <argsstring>(InputIterator first, InputIterator last, SG::OwnershipPolicy ownPolicy=SG::VIEW_ELEMENTS, SG::IndexTrackingPolicy trackIndices=SG::DEFAULT_TRACK_INDICES, SG::IAuxStore *store=0)</argsstring>
        <name>DataVector</name>
        <param>
          <type>InputIterator</type>
          <declname>first</declname>
        </param>
        <param>
          <type>InputIterator</type>
          <declname>last</declname>
        </param>
        <param>
          <type><ref refid="dd/d59/namespaceSG_1acd9d1a31242c6243cc1c6fab0fbc7cd8" kindref="member">SG::OwnershipPolicy</ref></type>
          <declname>ownPolicy</declname>
          <defval>SG::VIEW_ELEMENTS</defval>
        </param>
        <param>
          <type><ref refid="dd/d59/namespaceSG_1a9f3d699f65390b7f8baf54d9cd634573" kindref="member">SG::IndexTrackingPolicy</ref></type>
          <declname>trackIndices</declname>
          <defval>SG::DEFAULT_TRACK_INDICES</defval>
        </param>
        <param>
          <type><ref refid="dc/d05/classSG_1_1IAuxStore" kindref="compound">SG::IAuxStore</ref> *</type>
          <declname>store</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
<para>Copy constructor. </para>        </briefdescription>
        <detaileddescription>
<para>Constructor from iterators.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>rhs</parametername>
</parameternamelist>
<parameterdescription>
<para>The container from which to copy.</para></parameterdescription>
</parameteritem>
</parameterlist>
This is a `shallow&apos; copy; the new container will not own its elements. Constructor from iterators. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>The start of the range to put in the new container. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>The end of the range to put in the new container. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ownPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The ownership mode for the container. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>trackIndices</parametername>
</parameternamelist>
<parameterdescription>
<para>The index tracking policy. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>store</parametername>
</parameternamelist>
<parameterdescription>
<para>An associated auxiliary data store.</para></parameterdescription>
</parameteritem>
</parameterlist>
By default, a <computeroutput><ref refid="d0/d4d/classDataVector" kindref="compound">DataVector</ref></computeroutput> will own its elements (and take ownership of the pointers passed to this constructor). To avoid this, pass <computeroutput><ref refid="dd/d59/namespaceSG_1acd9d1a31242c6243cc1c6fab0fbc7cd8ad7d4cf2303700f0966e4140f236c4bf1" kindref="member">SG::VIEW_ELEMENTS</ref></computeroutput> for <emphasis>ownPolicy</emphasis>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>The start of the range to put in the new container. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>The end of the range to put in the new container. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ownPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The ownership mode for the container. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>trackIndices</parametername>
</parameternamelist>
<parameterdescription>
<para>The index tracking policy. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>store</parametername>
</parameternamelist>
<parameterdescription>
<para>An associated auxiliary data store.</para></parameterdescription>
</parameteritem>
</parameterlist>
By default, a <computeroutput><ref refid="d0/d4d/classDataVector" kindref="compound">DataVector</ref></computeroutput> will own its elements (and take ownership of the pointers passed to this constructor). To avoid this, pass <computeroutput><ref refid="dd/d59/namespaceSG_1acd9d1a31242c6243cc1c6fab0fbc7cd8ad7d4cf2303700f0966e4140f236c4bf1" kindref="member">SG::VIEW_ELEMENTS</ref></computeroutput> for <emphasis>ownPolicy</emphasis>.</para><para>Note that we do the complete initialization here in the derived class, using the default constructors for the base classes. The reason for this is to be able to deal nicely with the virtual derivation case. We can arrange to call the proper base class from here to get things initialized in the virtual derivation case. But then anyone who derives from us must also know to explicitly reference that base class. Doing the initialization explicitly here means that other classes who derive from us need only know about the most derived <ref refid="d0/d4d/classDataVector" kindref="compound">DataVector</ref> class. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="860" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="479" bodyend="502"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1a31f28630872abd2e694534c7cc8fa4ec" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="d0/d4d/classDataVector" kindref="compound">DataVector</ref> &amp;</type>
        <definition>DataVector&lt; T, BASE &gt; &amp; DataVector&lt; T, BASE &gt;::operator=</definition>
        <argsstring>(const DataVector &amp;rhs)</argsstring>
        <name>operator=</name>
        <param>
          <type>const <ref refid="d0/d4d/classDataVector" kindref="compound">DataVector</ref> &amp;</type>
          <declname>rhs</declname>
        </param>
        <briefdescription>
<para>Assignment operator. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>rhs</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="d0/d4d/classDataVector" kindref="compound">DataVector</ref> from which to assign. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>This object.</para></simplesect>
This is a `shallow&apos; copy; after the completion of this, the <computeroutput><ref refid="d0/d4d/classDataVector" kindref="compound">DataVector</ref></computeroutput> will not own its elements. Any elements it owned prior to this call will be released.</para><para>Note: this method may only be called using the most derived <computeroutput><ref refid="d0/d4d/classDataVector" kindref="compound">DataVector</ref></computeroutput> in the hierarchy.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>rhs</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="d0/d4d/classDataVector" kindref="compound">DataVector</ref> from which to assign. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>This object.</para></simplesect>
This is a `shallow&apos; copy; after the completion of this, the <ref refid="d0/d4d/classDataVector" kindref="compound">DataVector</ref> will not own its elements. Any elements it owned prior to this call will be released.</para><para>Note: this method may only be called using the most derived <computeroutput><ref refid="d0/d4d/classDataVector" kindref="compound">DataVector</ref></computeroutput> in the hierarchy. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="894" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="554" bodyend="567"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1a39b727c555a667c66094016314050332" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class InputIterator</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void DataVector&lt; T, BASE &gt;::assign</definition>
        <argsstring>(InputIterator first, InputIterator last)</argsstring>
        <name>assign</name>
        <param>
          <type>InputIterator</type>
          <declname>first</declname>
        </param>
        <param>
          <type>InputIterator</type>
          <declname>last</declname>
        </param>
        <briefdescription>
<para>Assign from iterators. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>The start of the range to put in the container. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>The end of the range to put in the container.</para></parameterdescription>
</parameteritem>
</parameterlist>
Any existing owned elements will be released. The <computeroutput>DataVector&apos;s</computeroutput> ownership policy determines whether it will take ownership of the new elements. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="931" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="628" bodyend="635"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Size and capacity.</header>
      <description><para><anchor id="_1amgrp91690d5f8f79d42f64e62a4bfc370024"/> </para></description>
      <memberdef kind="function" id="d0/d4d/classDataVector_1aa4d259c267222003a6d2592fbe9809af" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>size_type</type>
        <definition>DataVector&lt; T, BASE &gt;::size_type DataVector&lt; T, BASE &gt;::size</definition>
        <argsstring>() const </argsstring>
        <name>size</name>
        <briefdescription>
<para>Returns the number of elements in the collection. </para>        </briefdescription>
        <detaileddescription>
<para>Could in principle be inherited from the base class, but redeclared in the derived class to avoid root6 bugs. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="963" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="665" bodyend="668"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1a15eb577a199c519cb5126233b04cc429" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void DataVector&lt; T, BASE &gt;::resize</definition>
        <argsstring>(size_type sz)</argsstring>
        <name>resize</name>
        <reimplementedby refid="d0/d58/classxAOD_1_1MissingETComponentMap__v1_1a5acc242b0dbaa4d76b85857fb0ebd696">resize</reimplementedby>
        <reimplementedby refid="d5/d3a/classxAOD_1_1MissingETAssociationMap__v1_1a8861947e2f00404e85cbf2f59f0102a4">resize</reimplementedby>
        <param>
          <type>size_type</type>
          <declname>sz</declname>
        </param>
        <briefdescription>
<para>Resizes the collection to the specified number of elements. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sz</parametername>
</parameternamelist>
<parameterdescription>
<para>The new size of the collection.</para></parameterdescription>
</parameteritem>
</parameterlist>
Note that this function differs from the standard in that it does not allow specifying the value of any inserted elements. They will always be 0.</para><para>If the container is shrunk, elements will be deleted as with <computeroutput><ref refid="d0/d4d/classDataVector_1a249b08ecb8260e288fe9087e3db48950" kindref="member">erase()</ref></computeroutput>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="984" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="682" bodyend="691"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1a3827d1fa4f134ba36346893715dd5bc1" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void DataVector&lt; T, BASE &gt;::reserve</definition>
        <argsstring>(size_type n)</argsstring>
        <name>reserve</name>
        <param>
          <type>size_type</type>
          <declname>n</declname>
        </param>
        <briefdescription>
<para>Attempt to preallocate enough memory for a specified number of elements. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of elements required. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1008" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="701" bodyend="705"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1afaa2425da1ced3fa685a37a2a0561b05" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>size_type</type>
        <definition>size_type DataVector&lt; T, BASE &gt;::max_size</definition>
        <argsstring>() const </argsstring>
        <name>max_size</name>
        <briefdescription>
<para>Returns the <computeroutput><ref refid="d0/d4d/classDataVector_1aa4d259c267222003a6d2592fbe9809af" kindref="member">size()</ref></computeroutput> of the largest possible collection. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1697"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1a60c5cb0eab20bb3f2325ca9037ec3b5b" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>size_type</type>
        <definition>size_type DataVector&lt; T, BASE &gt;::capacity</definition>
        <argsstring>() const </argsstring>
        <name>capacity</name>
        <briefdescription>
<para>Returns the total number of elements that the collection can hold before needing to allocate more memory. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1699"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1a85aede44dff3bf86318e9d7ee71f0de5" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool DataVector&lt; T, BASE &gt;::empty</definition>
        <argsstring>() const </argsstring>
        <name>empty</name>
        <briefdescription>
<para>Returns <computeroutput>true</computeroutput> if the collection is empty. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1700"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Element access.</header>
      <description><para><anchor id="_1amgrp03f08060dbcda9a05f3dd6a98ff9f981"/>Change the vector capacity to match the current size.</para><para>Note: this does not affect auxiliary data. </para></description>
      <memberdef kind="function" id="d0/d4d/classDataVector_1ab22de888b8cf10f2b05fe6bc48465381" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>const <ref refid="d1/def/classT" kindref="compound">T</ref> *</type>
        <definition>const T * DataVector&lt; T, BASE &gt;::operator[]</definition>
        <argsstring>(size_type n) const </argsstring>
        <name>operator[]</name>
        <param>
          <type>size_type</type>
          <declname>n</declname>
        </param>
        <briefdescription>
<para>Access an element, as an rvalue. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>Array index to access. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The element at <emphasis>n</emphasis>.</para></simplesect>
No bounds checking is done. Note that we return a <computeroutput>const</computeroutput> <computeroutput>T*</computeroutput> rather than a reference. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1033" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="721" bodyend="724"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1aee535632a89bd041be90a3fa3058e36b" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>const <ref refid="d1/def/classT" kindref="compound">T</ref> *</type>
        <definition>const T * DataVector&lt; T, BASE &gt;::get</definition>
        <argsstring>(size_type n) const </argsstring>
        <name>get</name>
        <param>
          <type>size_type</type>
          <declname>n</declname>
        </param>
        <briefdescription>
<para>Access an element, as an rvalue. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>Array index to access. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The element at <emphasis>n</emphasis>.</para></simplesect>
This is a synonym for operator[] const, to be used when calling from root (where we can&apos;t readily call just the const version of a method). </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1044" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="737" bodyend="740"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1a9e0e83fd312a9ebdc94666283bf65de9" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="d7/d05/classDataModel__detail_1_1ElementProxy" kindref="compound">ElementProxy</ref></type>
        <definition>DataVector&lt; T, BASE &gt;::ElementProxy DataVector&lt; T, BASE &gt;::operator[]</definition>
        <argsstring>(size_type n)</argsstring>
        <name>operator[]</name>
        <param>
          <type>size_type</type>
          <declname>n</declname>
        </param>
        <briefdescription>
<para>Access an element, as an lvalue. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>Array index to access. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Proxy to the element at <emphasis>n</emphasis>.</para></simplesect>
No bounds checking is done. Note that we return a proxy object rather than a reference; the proxy will handle deleting an owned element if it&apos;s assigned to. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1056" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="755" bodyend="758"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1a3f598b345c9b1eb8793fd9cc6c16abe3" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>const <ref refid="d1/def/classT" kindref="compound">T</ref> *</type>
        <definition>const T * DataVector&lt; T, BASE &gt;::at</definition>
        <argsstring>(size_type n) const </argsstring>
        <name>at</name>
        <param>
          <type>size_type</type>
          <declname>n</declname>
        </param>
        <briefdescription>
<para>Access an element, as an rvalue. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>Array index to access. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The element at <emphasis>n</emphasis>.</para></simplesect>
Will raise <computeroutput>std::out_of_range</computeroutput> if the index is out-of-bounds. Note that we return a <computeroutput>const</computeroutput> <computeroutput>T*</computeroutput> rather than a reference. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1067" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="771" bodyend="774"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1ac9c3322bdb72e9bc502a578715937807" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="d7/d05/classDataModel__detail_1_1ElementProxy" kindref="compound">ElementProxy</ref></type>
        <definition>DataVector&lt; T, BASE &gt;::ElementProxy DataVector&lt; T, BASE &gt;::at</definition>
        <argsstring>(size_type n)</argsstring>
        <name>at</name>
        <param>
          <type>size_type</type>
          <declname>n</declname>
        </param>
        <briefdescription>
<para>Access an element, as an lvalue. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>Array index to access. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Proxy to the element at <emphasis>n</emphasis>.</para></simplesect>
Will raise <computeroutput>std::out_of_range</computeroutput> if the index is out-of-bounds. Note that we return a proxy object rather than a reference; the proxy will handle deleting an owned element if it&apos;s assigned to. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1079" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="789" bodyend="796"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1ad60c996521bcea5c5a57bc078b08b876" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>const <ref refid="d1/def/classT" kindref="compound">T</ref> *</type>
        <definition>const T * DataVector&lt; T, BASE &gt;::front</definition>
        <argsstring>() const </argsstring>
        <name>front</name>
        <briefdescription>
<para>Access the first element in the collection as an rvalue. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>The first element in the collection.</para></simplesect>
No checking is done to ensure that the container is not empty. Note that we return a <computeroutput>const</computeroutput> <computeroutput>T*</computeroutput> rather than a reference. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1089" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="808" bodyend="811"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1aee6b47538e67f772011367fccbf0e83f" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>const <ref refid="d1/def/classT" kindref="compound">T</ref> *</type>
        <definition>const T * DataVector&lt; T, BASE &gt;::back</definition>
        <argsstring>() const </argsstring>
        <name>back</name>
        <briefdescription>
<para>Access the last element in the collection as an rvalue. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>The last element in the collection.</para></simplesect>
No checking is done to ensure that the container is not empty. Note that we return a <computeroutput>const</computeroutput> <computeroutput>T*</computeroutput> rather than a reference. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1099" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="823" bodyend="826"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1a1ad4290a3853f0a10ea79452c4a0b423" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="d7/d05/classDataModel__detail_1_1ElementProxy" kindref="compound">ElementProxy</ref></type>
        <definition>DataVector&lt; T, BASE &gt;::ElementProxy DataVector&lt; T, BASE &gt;::front</definition>
        <argsstring>()</argsstring>
        <name>front</name>
        <briefdescription>
<para>Access the first element in the collection as an lvalue. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>Proxy to the first element in the collection.</para></simplesect>
No checking is done to ensure that the container is not empty. Note that we return a proxy object rather than a reference; the proxy will handle deleting an owned element if it&apos;s assigned to. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1110" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="840" bodyend="843"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1a56c7d05bd0d914c446598aab3402e020" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="d7/d05/classDataModel__detail_1_1ElementProxy" kindref="compound">ElementProxy</ref></type>
        <definition>DataVector&lt; T, BASE &gt;::ElementProxy DataVector&lt; T, BASE &gt;::back</definition>
        <argsstring>()</argsstring>
        <name>back</name>
        <briefdescription>
<para>Access the last element in the collection as an lvalue. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>Proxy to the last element in the collection.</para></simplesect>
No checking is done to ensure that the container is not empty. Note that we return a proxy object rather than a reference; the proxy will handle deleting an owned element if it&apos;s assigned to. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1121" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="857" bodyend="860"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Iterator creation.</header>
      <description><para><anchor id="_1amgrp04fea93d7622927e954392dcd5690674"/> </para></description>
      <memberdef kind="function" id="d0/d4d/classDataVector_1a66c78bd83eeb15e5616a898557598b36" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="d7/d17/classDataModel__detail_1_1const__iterator" kindref="compound">const_iterator</ref></type>
        <definition>DataVector&lt; T, BASE &gt;::const_iterator DataVector&lt; T, BASE &gt;::begin</definition>
        <argsstring>() const </argsstring>
        <name>begin</name>
        <briefdescription>
<para>Return a <computeroutput>const_iterator</computeroutput> pointing at the beginning of the collection. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para><ref refid="d4/dc4/structA" kindref="compound">A</ref> <computeroutput>const_iterator</computeroutput>.</para></simplesect>
Note that dereferencing the iterator will yield a <computeroutput>const</computeroutput> <computeroutput>T*</computeroutput> rather than a reference. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1138" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="877" bodyend="880"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1a1d5dd5515d2c9bc20f417830f5d05b5e" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="d7/d17/classDataModel__detail_1_1const__iterator" kindref="compound">const_iterator</ref></type>
        <definition>DataVector&lt; T, BASE &gt;::const_iterator DataVector&lt; T, BASE &gt;::end</definition>
        <argsstring>() const </argsstring>
        <name>end</name>
        <briefdescription>
<para>Return a <computeroutput>const_iterator</computeroutput> pointing past the end of the collection. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para><ref refid="d4/dc4/structA" kindref="compound">A</ref> <computeroutput>const_iterator</computeroutput>.</para></simplesect>
Note that dereferencing the iterator will yield a <computeroutput>const</computeroutput> <computeroutput>T*</computeroutput> rather than a reference. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1149" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="894" bodyend="897"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1a2c42ec99129008304681ddef6b812c15" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">iterator</ref></type>
        <definition>DataVector&lt; T, BASE &gt;::iterator DataVector&lt; T, BASE &gt;::begin</definition>
        <argsstring>()</argsstring>
        <name>begin</name>
        <briefdescription>
<para>Return an <computeroutput>iterator</computeroutput> pointing at the beginning of the collection. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>An <computeroutput>iterator</computeroutput>.</para></simplesect>
Note that dereferencing the iterator will yield a proxy rather than a reference; the proxy will handle deleting an owned element if it&apos;s assigned to. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1161" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="912" bodyend="915"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1ad7a08d945fb1698fcb3ea07ab1dccbec" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">iterator</ref></type>
        <definition>DataVector&lt; T, BASE &gt;::iterator DataVector&lt; T, BASE &gt;::end</definition>
        <argsstring>()</argsstring>
        <name>end</name>
        <briefdescription>
<para>Return an <computeroutput>iterator</computeroutput> pointing past the end of the collection. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>An <computeroutput>iterator</computeroutput>.</para></simplesect>
Note that dereferencing the iterator will yield a proxy rather than a reference; the proxy will handle deleting an owned element if it&apos;s assigned to. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1173" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="930" bodyend="933"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1a71dc1d0d8666c71cdbd98cf12ed58832" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="d0/d4d/classDataVector_1ab289e00e978a3cbcbb642ab9dc28617c" kindref="member">const_reverse_iterator</ref></type>
        <definition>DataVector&lt; T, BASE &gt;::const_reverse_iterator DataVector&lt; T, BASE &gt;::rbegin</definition>
        <argsstring>() const </argsstring>
        <name>rbegin</name>
        <briefdescription>
<para>Return a <computeroutput>const_reverse_iterator</computeroutput> pointing past the end of the collection. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para><ref refid="d4/dc4/structA" kindref="compound">A</ref> <computeroutput>const_reverse_iterator</computeroutput>.</para></simplesect>
Note that dereferencing the iterator will yield a <computeroutput>const</computeroutput> <computeroutput>T*</computeroutput> rather than a reference. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1184" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="947" bodyend="950"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1ae09c48f39c028009bf8dbc0bc9340e80" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="d0/d4d/classDataVector_1ab289e00e978a3cbcbb642ab9dc28617c" kindref="member">const_reverse_iterator</ref></type>
        <definition>DataVector&lt; T, BASE &gt;::const_reverse_iterator DataVector&lt; T, BASE &gt;::rend</definition>
        <argsstring>() const </argsstring>
        <name>rend</name>
        <briefdescription>
<para>Return a <computeroutput>const_reverse_iterator</computeroutput> pointing at the beginning of the collection. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para><ref refid="d4/dc4/structA" kindref="compound">A</ref> <computeroutput>const_reverse_iterator</computeroutput>.</para></simplesect>
Note that dereferencing the iterator will yield a <computeroutput>const</computeroutput> <computeroutput>T*</computeroutput> rather than a reference. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1195" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="964" bodyend="967"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1ab216c17baaede1e4a8dd98f53071b354" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="d0/d4d/classDataVector_1a48b8aeb52be5374ae659f1c383e6e172" kindref="member">reverse_iterator</ref></type>
        <definition>DataVector&lt; T, BASE &gt;::reverse_iterator DataVector&lt; T, BASE &gt;::rbegin</definition>
        <argsstring>()</argsstring>
        <name>rbegin</name>
        <briefdescription>
<para>Return a <computeroutput>reverse_iterator</computeroutput> pointing past the end of the collection. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para><ref refid="d4/dc4/structA" kindref="compound">A</ref> <computeroutput>reverse_iterator</computeroutput>.</para></simplesect>
Note that dereferencing the iterator will yield a proxy rather than a reference; the proxy will handle deleting an owned element if it&apos;s assigned to. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1207" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="982" bodyend="985"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1a49e6422f38b1483a45b642534c7f83f4" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="d0/d4d/classDataVector_1a48b8aeb52be5374ae659f1c383e6e172" kindref="member">reverse_iterator</ref></type>
        <definition>DataVector&lt; T, BASE &gt;::reverse_iterator DataVector&lt; T, BASE &gt;::rend</definition>
        <argsstring>()</argsstring>
        <name>rend</name>
        <briefdescription>
<para>Return a <computeroutput>reverse_iterator</computeroutput> pointing at the beginning of the collection. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para><ref refid="d4/dc4/structA" kindref="compound">A</ref> <computeroutput>reverse_iterator</computeroutput>.</para></simplesect>
Note that dereferencing the iterator will yield a proxy rather than a reference; the proxy will handle deleting an owned element if it&apos;s assigned to. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1219" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="1000" bodyend="1003"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1a2ba633ea0a2c1c0a8413ca4897817e4e" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="d7/d17/classDataModel__detail_1_1const__iterator" kindref="compound">const_iterator</ref></type>
        <definition>DataVector&lt; T, BASE &gt;::const_iterator DataVector&lt; T, BASE &gt;::cbegin</definition>
        <argsstring>() const </argsstring>
        <name>cbegin</name>
        <briefdescription>
<para>Return a <computeroutput>const_iterator</computeroutput> pointing at the beginning of the collection. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para><ref refid="d4/dc4/structA" kindref="compound">A</ref> <computeroutput>const_iterator</computeroutput>.</para></simplesect>
Note that dereferencing the iterator will yield a <computeroutput>const</computeroutput> <computeroutput>T*</computeroutput> rather than a reference. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1230" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="1017" bodyend="1020"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1aa42d00ed3a26858f32f25e2e1010ca4f" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="d7/d17/classDataModel__detail_1_1const__iterator" kindref="compound">const_iterator</ref></type>
        <definition>DataVector&lt; T, BASE &gt;::const_iterator DataVector&lt; T, BASE &gt;::cend</definition>
        <argsstring>() const </argsstring>
        <name>cend</name>
        <briefdescription>
<para>Return a <computeroutput>const_iterator</computeroutput> pointing past the end of the collection. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para><ref refid="d4/dc4/structA" kindref="compound">A</ref> <computeroutput>const_iterator</computeroutput>.</para></simplesect>
Note that dereferencing the iterator will yield a <computeroutput>const</computeroutput> <computeroutput>T*</computeroutput> rather than a reference. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1241" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="1034" bodyend="1037"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1ade43c536beab58ae6b2e037fd67ff8e2" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="d0/d4d/classDataVector_1ab289e00e978a3cbcbb642ab9dc28617c" kindref="member">const_reverse_iterator</ref></type>
        <definition>DataVector&lt; T, BASE &gt;::const_reverse_iterator DataVector&lt; T, BASE &gt;::crbegin</definition>
        <argsstring>() const </argsstring>
        <name>crbegin</name>
        <briefdescription>
<para>Return a <computeroutput>const_reverse_iterator</computeroutput> pointing past the end of the collection. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para><ref refid="d4/dc4/structA" kindref="compound">A</ref> <computeroutput>const_reverse_iterator</computeroutput>.</para></simplesect>
Note that dereferencing the iterator will yield a <computeroutput>const</computeroutput> <computeroutput>T*</computeroutput> rather than a reference. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1252" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="1051" bodyend="1054"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1a07fbb4e8bddec66621cc3f78defbc92b" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="d0/d4d/classDataVector_1ab289e00e978a3cbcbb642ab9dc28617c" kindref="member">const_reverse_iterator</ref></type>
        <definition>DataVector&lt; T, BASE &gt;::const_reverse_iterator DataVector&lt; T, BASE &gt;::crend</definition>
        <argsstring>() const </argsstring>
        <name>crend</name>
        <briefdescription>
<para>Return a <computeroutput>const_reverse_iterator</computeroutput> pointing at the beginning of the collection. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para><ref refid="d4/dc4/structA" kindref="compound">A</ref> <computeroutput>const_reverse_iterator</computeroutput>.</para></simplesect>
Note that dereferencing the iterator will yield a <computeroutput>const</computeroutput> <computeroutput>T*</computeroutput> rather than a reference. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1263" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="1068" bodyend="1071"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Insertion operations.</header>
      <description><para><anchor id="_1amgrpc4ff45e64b9f41cc82677be76808116c"/> </para></description>
      <memberdef kind="function" id="d0/d4d/classDataVector_1a486aeb4868e7c29331717adb06ea0df2" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void DataVector&lt; T, BASE &gt;::push_back</definition>
        <argsstring>(value_type pElem)</argsstring>
        <name>push_back</name>
        <param>
          <type><ref refid="d1/def/classT" kindref="compound">value_type</ref></type>
          <declname>pElem</declname>
        </param>
        <briefdescription>
<para>Add an element to the end of the collection. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pElem</parametername>
</parameternamelist>
<parameterdescription>
<para>The element to add to the collection.</para></parameterdescription>
</parameteritem>
</parameterlist>
The container&apos;s ownership policy will determine if it takes ownership of the new element.</para><para>Note: this method may only be called using the most derived <computeroutput><ref refid="d0/d4d/classDataVector" kindref="compound">DataVector</ref></computeroutput> in the hierarchy. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1282" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="1089" bodyend="1097"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1af6206e99fb0d7d2e2fce1eafe99877f1" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void DataVector&lt; T, BASE &gt;::emplace_back</definition>
        <argsstring>(value_type pElem)</argsstring>
        <name>emplace_back</name>
        <param>
          <type><ref refid="d1/def/classT" kindref="compound">value_type</ref></type>
          <declname>pElem</declname>
        </param>
        <briefdescription>
<para>Add an element to the end of the collection. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pElem</parametername>
</parameternamelist>
<parameterdescription>
<para>The element to add to the collection.</para></parameterdescription>
</parameteritem>
</parameterlist>
The container&apos;s ownership policy will determine if it takes ownership of the new element.</para><para>Note: this method may only be called using the most derived <computeroutput><ref refid="d0/d4d/classDataVector" kindref="compound">DataVector</ref></computeroutput> in the hierarchy.</para><para>For <computeroutput><ref refid="d0/d4d/classDataVector" kindref="compound">DataVector</ref></computeroutput>, this is just the same as <computeroutput>push_back</computeroutput>. It&apos;s included just for interface compatibility with `stdvector`. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1314" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="1146" bodyend="1149"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1a4bfe807fd5835ae4e484eb505bb03533" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">iterator</ref></type>
        <definition>DataVector&lt; T, BASE &gt;::iterator DataVector&lt; T, BASE &gt;::insert</definition>
        <argsstring>(iterator position, value_type pElem)</argsstring>
        <name>insert</name>
        <param>
          <type><ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">iterator</ref></type>
          <declname>position</declname>
        </param>
        <param>
          <type><ref refid="d1/def/classT" kindref="compound">value_type</ref></type>
          <declname>pElem</declname>
        </param>
        <briefdescription>
<para>Add a new element to the collection. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>position</parametername>
</parameternamelist>
<parameterdescription>
<para>Iterator before which the element will be added. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pElem</parametername>
</parameternamelist>
<parameterdescription>
<para>The element to add to the collection. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>An iterator that points to the inserted data.</para></simplesect>
The container&apos;s ownership policy will determine if it takes ownership of the new element.</para><para>Note: this method may only be called using the most derived <computeroutput><ref refid="d0/d4d/classDataVector" kindref="compound">DataVector</ref></computeroutput> in the hierarchy. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1329" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="1166" bodyend="1174"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1ac6f57a40acf210dfbb95205bb078be3b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">iterator</ref></type>
        <definition>DataVector&lt; T, BASE &gt;::iterator DataVector&lt; T, BASE &gt;::emplace</definition>
        <argsstring>(iterator position, value_type pElem)</argsstring>
        <name>emplace</name>
        <param>
          <type><ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">iterator</ref></type>
          <declname>position</declname>
        </param>
        <param>
          <type><ref refid="d1/def/classT" kindref="compound">value_type</ref></type>
          <declname>pElem</declname>
        </param>
        <briefdescription>
<para>Add a new element to the collection. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>position</parametername>
</parameternamelist>
<parameterdescription>
<para>Iterator before which the element will be added. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pElem</parametername>
</parameternamelist>
<parameterdescription>
<para>The element to add to the collection. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>An iterator that points to the inserted data.</para></simplesect>
The container&apos;s ownership policy will determine if it takes ownership of the new element.</para><para>Note: this method may only be called using the most derived <computeroutput><ref refid="d0/d4d/classDataVector" kindref="compound">DataVector</ref></computeroutput> in the hierarchy.</para><para>For <computeroutput><ref refid="d0/d4d/classDataVector" kindref="compound">DataVector</ref></computeroutput>, this is just the same as <computeroutput>insert</computeroutput>. It&apos;s included just for interface compatibility with `stdvector`. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1365" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="1228" bodyend="1231"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1a173e4fcf883f04507805618118c444a9" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class InputIterator</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void DataVector&lt; T, BASE &gt;::insert</definition>
        <argsstring>(iterator position, InputIterator first, InputIterator last)</argsstring>
        <name>insert</name>
        <param>
          <type><ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">iterator</ref></type>
          <declname>position</declname>
        </param>
        <param>
          <type>InputIterator</type>
          <declname>first</declname>
        </param>
        <param>
          <type>InputIterator</type>
          <declname>last</declname>
        </param>
        <briefdescription>
<para>Add a group of new elements to the collection. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>position</parametername>
</parameternamelist>
<parameterdescription>
<para>Iterator before which the element will be added. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>The start of the range to put in the container. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>The end of the range to put in the container.</para></parameterdescription>
</parameteritem>
</parameterlist>
The container&apos;s ownership policy will determine if it takes ownership of the new element.</para><para>Note: this method may only be called using the most derived <computeroutput><ref refid="d0/d4d/classDataVector" kindref="compound">DataVector</ref></computeroutput> in the hierarchy. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1381" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="1248" bodyend="1270"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Erasure operations.</header>
      <description><para><anchor id="_1amgrp5dd35913d37b538bffc58eac1d7946e3"/> </para></description>
      <memberdef kind="function" id="d0/d4d/classDataVector_1a249b08ecb8260e288fe9087e3db48950" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">iterator</ref></type>
        <definition>DataVector&lt; T, BASE &gt;::iterator DataVector&lt; T, BASE &gt;::erase</definition>
        <argsstring>(iterator position)</argsstring>
        <name>erase</name>
        <reimplementedby refid="d0/d58/classxAOD_1_1MissingETComponentMap__v1_1a44b8b3e159c8229c086ede659d87d88a">erase</reimplementedby>
        <reimplementedby refid="d5/d3a/classxAOD_1_1MissingETAssociationMap__v1_1a83193dcb7c9c8063fa232efb638b094b">erase</reimplementedby>
        <param>
          <type><ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">iterator</ref></type>
          <declname>position</declname>
        </param>
        <briefdescription>
<para>Remove element at a given position. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>position</parametername>
</parameternamelist>
<parameterdescription>
<para>Iterator pointing to the element to be removed. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>An iterator pointing to the next element (or <computeroutput><ref refid="d0/d4d/classDataVector_1ad7a08d945fb1698fcb3ea07ab1dccbec" kindref="member">end()</ref></computeroutput>).</para></simplesect>
If the container owns its elements, then the pointed-to element will be deleted. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1414" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="1307" bodyend="1314"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1acaf33a6392cb774a35ee362d140fd17c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">iterator</ref></type>
        <definition>DataVector&lt; T, BASE &gt;::iterator DataVector&lt; T, BASE &gt;::erase</definition>
        <argsstring>(iterator first, iterator last)</argsstring>
        <name>erase</name>
        <reimplementedby refid="d0/d58/classxAOD_1_1MissingETComponentMap__v1_1a0d4b08a35784be97f20c4df4878a2f42">erase</reimplementedby>
        <reimplementedby refid="d5/d3a/classxAOD_1_1MissingETAssociationMap__v1_1a68eca1c9433d1ee9e460ead6430781a8">erase</reimplementedby>
        <param>
          <type><ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">iterator</ref></type>
          <declname>first</declname>
        </param>
        <param>
          <type><ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">iterator</ref></type>
          <declname>last</declname>
        </param>
        <briefdescription>
<para>Remove a range of elements. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Iterator pointing to the first element to be removed. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Iterator pointing one past the last element to be removed. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>An iterator pointing to the element pointed to by <emphasis>last</emphasis> prior to erasing (or <computeroutput><ref refid="d0/d4d/classDataVector_1ad7a08d945fb1698fcb3ea07ab1dccbec" kindref="member">end()</ref></computeroutput>).</para></simplesect>
If the container owns its elements, then the removed elements will be deleted. Any duplicates will be removed in this process, but don&apos;t rely on this. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1428" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="1330" bodyend="1337"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1a52881ff983e0d0dd21b23c4d03824b68" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void DataVector&lt; T, BASE &gt;::pop_back</definition>
        <argsstring>()</argsstring>
        <name>pop_back</name>
        <reimplementedby refid="d0/d58/classxAOD_1_1MissingETComponentMap__v1_1afc4b4a4eccabae3091372560a5fdc807">pop_back</reimplementedby>
        <reimplementedby refid="d5/d3a/classxAOD_1_1MissingETAssociationMap__v1_1a0371c68bf1814b952d8ee28c6e53a167">pop_back</reimplementedby>
        <briefdescription>
<para>Remove the last element from the collection. </para>        </briefdescription>
        <detaileddescription>
<para>If the container owns its elements, then the removed element will be deleted. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1438" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="1347" bodyend="1357"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1af2b028c097d741794a59b03c184fb70a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void DataVector&lt; T, BASE &gt;::clear</definition>
        <argsstring>()</argsstring>
        <name>clear</name>
        <reimplementedby refid="d0/d58/classxAOD_1_1MissingETComponentMap__v1_1a37d1a8e2caeb7d1dae2dd744fc808302">clear</reimplementedby>
        <reimplementedby refid="d5/d3a/classxAOD_1_1MissingETAssociationMap__v1_1afe21a96b578e2cc5dda649287db258e3">clear</reimplementedby>
        <briefdescription>
<para>Erase all the elements in the collection. </para>        </briefdescription>
        <detaileddescription>
<para>Erase all the elements in the collection, and reset the ownership mode.</para><para>If the container owns its elements, then the removed elements will be deleted. Any duplicates will be removed in this process, but don&apos;t rely on this.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ownPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The new ownership policy of the container. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>trackIndices</parametername>
</parameternamelist>
<parameterdescription>
<para>The index tracking policy.</para></parameterdescription>
</parameteritem>
</parameterlist>
If the container owns its elements, then the removed elements will be deleted. Any duplicates will be removed in this process, but don&apos;t rely on this. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1449" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="1369" bodyend="1373"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Swap and sort.</header>
      <description><para><anchor id="_1amgrp48740572230bf871bbbe3f4450b8e26c"/> </para></description>
      <memberdef kind="function" id="d0/d4d/classDataVector_1a53d2dcc591d07cc817b06d2523442432" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void DataVector&lt; T, BASE &gt;::swap</definition>
        <argsstring>(DataVector &amp;rhs)</argsstring>
        <name>swap</name>
        <param>
          <type><ref refid="d0/d4d/classDataVector" kindref="compound">DataVector</ref> &amp;</type>
          <declname>rhs</declname>
        </param>
        <briefdescription>
<para>Swap this collection with another. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>rhs</parametername>
</parameternamelist>
<parameterdescription>
<para>The collection with which to swap.</para></parameterdescription>
</parameteritem>
</parameterlist>
Ownership is swapped along with the collection content.</para><para>Note: this method may only be called using the most-derived <computeroutput><ref refid="d0/d4d/classDataVector" kindref="compound">DataVector</ref></computeroutput> in the hierarchy. The <emphasis>rhs</emphasis> must also be referenced using the most-derived <computeroutput><ref refid="d0/d4d/classDataVector" kindref="compound">DataVector</ref></computeroutput>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>rhs</parametername>
</parameternamelist>
<parameterdescription>
<para>The collection with which to swap.</para></parameterdescription>
</parameteritem>
</parameterlist>
Ownership is swapped along with the collection content.</para><para>Note: this method may only be called using the most-derived <computeroutput><ref refid="d0/d4d/classDataVector" kindref="compound">DataVector</ref></computeroutput> in the hierarchy. The <emphasis>rhs</emphasis> must also be referenced using the most-derived <computeroutput><ref refid="d0/d4d/classDataVector" kindref="compound">DataVector</ref></computeroutput>.</para><para>Warning: If this container has auxiliary data, then this is an O(N) operation, not O(1). </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1468" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="1393" bodyend="1402"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1a33ee222cacf6bcdf7a561a8505ec09c1" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void DataVector&lt; T, BASE &gt;::sort</definition>
        <argsstring>()</argsstring>
        <name>sort</name>
        <reimplementedby refid="d0/d58/classxAOD_1_1MissingETComponentMap__v1_1a782b33852df8afc2db5f72e3756125eb">sort</reimplementedby>
        <reimplementedby refid="d5/d3a/classxAOD_1_1MissingETAssociationMap__v1_1ab5ec2e56e5e3022c897652598b3c3409">sort</reimplementedby>
        <briefdescription>
<para>Sort the container. </para>        </briefdescription>
        <detaileddescription>
<para>This just sorts by pointer value, so it&apos;s probably not very useful. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1484" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="1434" bodyend="1440"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1a81fae208d38453acd5d3aaccafe5c10d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class COMPARE</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void DataVector&lt; T, BASE &gt;::sort</definition>
        <argsstring>(COMPARE comp)</argsstring>
        <name>sort</name>
        <reimplementedby refid="d0/d58/classxAOD_1_1MissingETComponentMap__v1_1aaf524f276a71cdbd2b4684f0ce5bd425">sort</reimplementedby>
        <reimplementedby refid="d5/d3a/classxAOD_1_1MissingETAssociationMap__v1_1a2357d31742978f613868e25b1ac69cc3">sort</reimplementedby>
        <param>
          <type>COMPARE</type>
          <declname>comp</declname>
        </param>
        <briefdescription>
<para>Sort the container with a user-specified comparison operator. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>comp</parametername>
</parameternamelist>
<parameterdescription>
<para>Functional to compare two values. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1492" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="1449" bodyend="1454"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1a309f0e29bcde5ca107c5232cbf6b9d4c" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void DataVector&lt; T, BASE &gt;::iter_swap</definition>
        <argsstring>(iterator a, iterator b)</argsstring>
        <name>iter_swap</name>
        <param>
          <type><ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">iterator</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">iterator</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Swap the referents of two <computeroutput><ref refid="d0/d4d/classDataVector" kindref="compound">DataVector</ref></computeroutput> iterators. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>The first iterator for the swap. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>The second iterator for the swap/ </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1476" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="1411" bodyend="1425"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Non-standard operations.</header>
      <description><para><anchor id="_1amgrp67b3645f65a6afd377578740fa3b4ed2"/> </para></description>
      <memberdef kind="function" id="d0/d4d/classDataVector_1a9a0337f2ef172c59b899e4aaf816891d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void DataVector&lt; T, BASE &gt;::swapElement</definition>
        <argsstring>(size_type index, value_type newElem, reference oldElem)</argsstring>
        <name>swapElement</name>
        <param>
          <type>size_type</type>
          <declname>index</declname>
        </param>
        <param>
          <type><ref refid="d1/def/classT" kindref="compound">value_type</ref></type>
          <declname>newElem</declname>
        </param>
        <param>
          <type><ref refid="d1/def/classT" kindref="compound">reference</ref></type>
          <declname>oldElem</declname>
        </param>
        <briefdescription>
<para>Swap one element out of the container. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>index</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of the element in the container to swap. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>newElem</parametername>
</parameternamelist>
<parameterdescription>
<para>New element to put in the container. May be 0. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>oldElem</parametername>
</parameternamelist>
<parameterdescription>
<para>Reference to receive the element removed from the container.</para></parameterdescription>
</parameteritem>
</parameterlist>
Reference <emphasis>oldElem</emphasis> is initialized with element <emphasis>index</emphasis> of the collection (no bounds checking). Then element <emphasis>index</emphasis> is set to <computeroutput>newElem</computeroutput>. If the collection owns its elements, then it will take ownership of <emphasis>newElem</emphasis> and release (without deleting) the element returned through <emphasis>oldElem</emphasis>.</para><para>Note: this method may only be called using the most derived <computeroutput><ref refid="d0/d4d/classDataVector" kindref="compound">DataVector</ref></computeroutput> in the hierarchy.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>index</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of the element in the container to swap. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>newElement</parametername>
</parameternamelist>
<parameterdescription>
<para>New element to put in the container. May be 0. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>oldElem</parametername>
</parameternamelist>
<parameterdescription>
<para>Reference to receive the element removed from the container.</para></parameterdescription>
</parameteritem>
</parameterlist>
Reference <emphasis>oldElem</emphasis> is initialized with element <emphasis>index</emphasis> of the collection (no bounds checking). Then element <emphasis>index</emphasis> is set to . If the collection owns its elements, then it will take ownership of <emphasis>newElem</emphasis> and release (without deleting) the element returned through <emphasis>oldElem</emphasis>.</para><para>Note: this method may only be called using the most derived <computeroutput><ref refid="d0/d4d/classDataVector" kindref="compound">DataVector</ref></computeroutput> in the hierarchy. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1519" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="1478" bodyend="1488"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1abe2ea523c0d8d9afc0e2cbfb643b72cc" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void DataVector&lt; T, BASE &gt;::swapElement</definition>
        <argsstring>(iterator pos, value_type newElem, reference oldElem)</argsstring>
        <name>swapElement</name>
        <param>
          <type><ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">iterator</ref></type>
          <declname>pos</declname>
        </param>
        <param>
          <type><ref refid="d1/def/classT" kindref="compound">value_type</ref></type>
          <declname>newElem</declname>
        </param>
        <param>
          <type><ref refid="d1/def/classT" kindref="compound">reference</ref></type>
          <declname>oldElem</declname>
        </param>
        <briefdescription>
<para>Swap one element out of the container. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pos</parametername>
</parameternamelist>
<parameterdescription>
<para>The element in the container to swap. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>newElem</parametername>
</parameternamelist>
<parameterdescription>
<para>New element to put in the container. May be 0. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>oldElem</parametername>
</parameternamelist>
<parameterdescription>
<para>Reference to receive the element removed from the container.</para></parameterdescription>
</parameteritem>
</parameterlist>
Reference <emphasis>oldElem</emphasis> is initialized with element <emphasis>pos</emphasis> of the collection (no bounds checking). Then element <emphasis>index</emphasis> is set to <computeroutput>newElem</computeroutput>. If the collection owns its elements, then it will take ownership of <emphasis>newElem</emphasis> and release (without deleting) the element returned through <emphasis>oldElem</emphasis>.</para><para>Note: this method may only be called using the most derived <computeroutput><ref refid="d9/dfb/classDataList" kindref="compound">DataList</ref></computeroutput> in the hierarchy.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pos</parametername>
</parameternamelist>
<parameterdescription>
<para>The element in the container to swap. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>newElem</parametername>
</parameternamelist>
<parameterdescription>
<para>New element to put in the container. May be 0. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>oldElem</parametername>
</parameternamelist>
<parameterdescription>
<para>Reference to receive the element removed from the container.</para></parameterdescription>
</parameteritem>
</parameterlist>
Reference <emphasis>oldElem</emphasis> is initialized with element <emphasis>pos</emphasis> of the collection (no bounds checking). Then element <emphasis>index</emphasis> is set to <computeroutput>newElem</computeroutput>. If the collection owns its elements, then it will take ownership of <emphasis>newElem</emphasis> and release (without deleting) the element returned through <emphasis>oldElem</emphasis>.</para><para>Note: this method may only be called using the most derived <computeroutput><ref refid="d0/d4d/classDataVector" kindref="compound">DataVector</ref></computeroutput> in the hierarchy. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1539" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="1509" bodyend="1519"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1ae40a6a2cf044fdeb1defe4889213c5e2" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void DataVector&lt; T, BASE &gt;::clear</definition>
        <argsstring>(SG::OwnershipPolicy ownPolicy)</argsstring>
        <name>clear</name>
        <reimplementedby refid="d0/d58/classxAOD_1_1MissingETComponentMap__v1_1a8c078565a19b37e6dca4e17a93f3fb48">clear</reimplementedby>
        <reimplementedby refid="d5/d3a/classxAOD_1_1MissingETAssociationMap__v1_1a5cc78d90ec2a3d5c90bc6c1ac2db294a">clear</reimplementedby>
        <param>
          <type><ref refid="dd/d59/namespaceSG_1acd9d1a31242c6243cc1c6fab0fbc7cd8" kindref="member">SG::OwnershipPolicy</ref></type>
          <declname>ownPolicy</declname>
        </param>
        <briefdescription>
<para>Erase all the elements in the collection, and reset the ownership mode. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ownPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The new ownership policy of the container.</para></parameterdescription>
</parameteritem>
</parameterlist>
If the container owns its elements, then the removed elements will be deleted. Any duplicates will be removed in this process, but don&apos;t rely on this. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1623" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="1612" bodyend="1618"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1a70c20dac9bc136ec903ae571a203314f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void DataVector&lt; T, BASE &gt;::clear</definition>
        <argsstring>(SG::OwnershipPolicy ownPolicy, SG::IndexTrackingPolicy trackIndices)</argsstring>
        <name>clear</name>
        <reimplementedby refid="d0/d58/classxAOD_1_1MissingETComponentMap__v1_1a3bf9c9742788c62ba811bf0ca104916c">clear</reimplementedby>
        <reimplementedby refid="d5/d3a/classxAOD_1_1MissingETAssociationMap__v1_1ade371e0810ff04cd5371c06b773f6906">clear</reimplementedby>
        <param>
          <type><ref refid="dd/d59/namespaceSG_1acd9d1a31242c6243cc1c6fab0fbc7cd8" kindref="member">SG::OwnershipPolicy</ref></type>
          <declname>ownPolicy</declname>
        </param>
        <param>
          <type><ref refid="dd/d59/namespaceSG_1a9f3d699f65390b7f8baf54d9cd634573" kindref="member">SG::IndexTrackingPolicy</ref></type>
          <declname>trackIndices</declname>
        </param>
        <briefdescription>
<para>Erase all the elements in the collection, and reset the ownership mode. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ownPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The new ownership policy of the container. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>trackIndices</parametername>
</parameternamelist>
<parameterdescription>
<para>The index tracking policy.</para></parameterdescription>
</parameteritem>
</parameterlist>
If the container owns its elements, then the removed elements will be deleted. Any duplicates will be removed in this process, but don&apos;t rely on this. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1638" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="1632" bodyend="1638"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1ac7fb23bf395a0e3894f454fc7f072764" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="virtual">
        <type>const <ref refid="da/d8a/classDataModel__detail_1_1DVLInfoBase" kindref="compound">DataModel_detail::DVLInfoBase</ref> &amp;</type>
        <definition>const DataModel_detail::DVLInfoBase &amp; DataVector&lt; T, BASE &gt;::dvlinfo_v</definition>
        <argsstring>() const </argsstring>
        <name>dvlinfo_v</name>
        <reimplementedby refid="df/d07/structDataVector__detail_1_1VirtBases_1a45d866334d646b7923f23fb418c7e3f1">dvlinfo_v</reimplementedby>
        <reimplementedby refid="df/d4a/structDataVector__detail_1_1VirtBases_3_01B1_00_01B2_00_01DataModel__detail_1_1NoBase_01_4_1a5625b6e17d2eca61ce8c28e5b9358632">dvlinfo_v</reimplementedby>
        <reimplementedby refid="db/d76/structDataVector__detail_1_1VirtBases_3_01B1_00_01DataModel__detail_1_1NoBase_00_01DataModel__detail_1_1NoBase_01_4_1a5c239fae50314a12b537cdabe26847a0">dvlinfo_v</reimplementedby>
        <briefdescription>
<para>Return the DV/DL info struct for this class. </para>        </briefdescription>
        <detaileddescription>
<para>This can be used to make sure that it&apos;s instantiated. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1654" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="1659" bodyend="1662"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1a749ffc30735b0fbd0269df4e750851a7" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>const <ref refid="dd/da5/classSG_1_1AuxVectorBase" kindref="compound">SG::AuxVectorBase</ref> &amp;</type>
        <definition>const SG::AuxVectorBase &amp; DataVector&lt; T, BASE &gt;::auxbase</definition>
        <argsstring>() const </argsstring>
        <name>auxbase</name>
        <briefdescription>
<para>Convert to <computeroutput>AuxVectorBase</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para>Needed to get  AuxVectorBase from a <computeroutput><ref refid="de/db1/classConstDataVector" kindref="compound">ConstDataVector</ref></computeroutput>. Present in <computeroutput><ref refid="d0/d4d/classDataVector" kindref="compound">DataVector</ref></computeroutput> as well for consistency. We only really need it in the base class; however, root6 fails constructing a <computeroutput>TMethodCall</computeroutput> for this if there is virtual derivation. <ref refid="d4/dc4/structA" kindref="compound">A</ref> workaround is to redeclare this in the derived classes too. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1682" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="1695" bodyend="1698"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1a0e2e64a35d842a206c96ccfec265df21" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>const <ref refid="d0/d4d/classDataVector_1ac8d41eaf271f444aeacb80705fde49d9" kindref="member">PtrVector</ref> &amp;</type>
        <definition>const PtrVector &amp; DataVector&lt; T, BASE &gt;::stdcont</definition>
        <argsstring>() const </argsstring>
        <name>stdcont</name>
        <briefdescription>
<para>Return the underlying <computeroutput>std::vector</computeroutput> of the container. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>Reference to the <computeroutput>std::vector</computeroutput> actually holding the collection.</para></simplesect>
Note that <computeroutput><ref refid="d0/d4d/classDataVector_1a0e2e64a35d842a206c96ccfec265df21" kindref="member">DataVector&lt;T&gt;::stdcont</ref></computeroutput> does not necessarily return a <computeroutput>std::vector&lt;T*&gt;</computeroutput> if <computeroutput><ref refid="d0/d4d/classDataVector" kindref="compound">DataVector</ref></computeroutput> inheritance is being used. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1704"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1a23689a65fe5243d0bd00c3aa79640f98" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="dd/d59/namespaceSG_1acd9d1a31242c6243cc1c6fab0fbc7cd8" kindref="member">SG::OwnershipPolicy</ref></type>
        <definition>SG::OwnershipPolicy DataVector&lt; T, BASE &gt;::ownPolicy</definition>
        <argsstring>() const </argsstring>
        <name>ownPolicy</name>
        <briefdescription>
<para>Return the ownership policy setting for this container. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1705"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1a4831de47c79708079d0c1e1e1c9e4363" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>const <ref refid="da/d8a/classDataModel__detail_1_1DVLInfoBase" kindref="compound">DataModel_detail::DVLInfoBase</ref> &amp;</type>
        <definition>const DataModel_detail::DVLInfoBase &amp; DataVector&lt; T, BASE &gt;::dvlinfo</definition>
        <argsstring>()</argsstring>
        <name>dvlinfo</name>
        <briefdescription>
<para>Return the DV/DL info struct for this class. </para>        </briefdescription>
        <detaileddescription>
<para>This can be used to make sure that it&apos;s instantiated. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1646" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="1647" bodyend="1650"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1a3af6f600eec6df2c3652211ba80fc031" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>int DataVector&lt; T, BASE &gt;::baseOffset</definition>
        <argsstring>(const std::type_info &amp;ti)</argsstring>
        <name>baseOffset</name>
        <param>
          <type>const std::type_info &amp;</type>
          <declname>ti</declname>
        </param>
        <briefdescription>
<para>Return the offset of a base <computeroutput><ref refid="d0/d4d/classDataVector" kindref="compound">DataVector</ref></computeroutput> class. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ti</parametername>
</parameternamelist>
<parameterdescription>
<para><computeroutput>std::type_info</computeroutput> of the desired class.</para></parameterdescription>
</parameteritem>
</parameterlist>
If <computeroutput>ti</computeroutput> represents a <computeroutput><ref refid="d0/d4d/classDataVector" kindref="compound">DataVector</ref></computeroutput> base class of this one, then return the offset of that base class. Otherwise, return -1.</para><para>This function is here due to limitations of root 6, which can&apos;t calculate these offsets correctly from the dictionary if virtual derivation is used. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1669" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.icc" bodystart="1677" bodyend="1681"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-type">
      <memberdef kind="typedef" id="d0/d4d/classDataVector_1adbb7524fe05522edf000e397dc36a183" prot="public" static="no">
        <type>BASE</type>
        <definition>typedef BASE DataVector&lt; T, BASE &gt;::DataVector_BASE</definition>
        <argsstring></argsstring>
        <name>DataVector_BASE</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="722" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" bodystart="722" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="d0/d4d/classDataVector_1abced550e4bb02a91c1b1c660ddf9071d" prot="public" static="no">
        <type>BASE</type>
        <definition>typedef BASE DataVector&lt; T, BASE &gt;::DVL_BASE</definition>
        <argsstring></argsstring>
        <name>DVL_BASE</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="723" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" bodystart="723" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="d0/d4d/classDataVector_1ac8d41eaf271f444aeacb80705fde49d9" prot="public" static="no">
        <type>BASE::PtrVector</type>
        <definition>typedef BASE::PtrVector DataVector&lt; T, BASE &gt;::PtrVector</definition>
        <argsstring></argsstring>
        <name>PtrVector</name>
        <reimplementedby refid="df/d07/structDataVector__detail_1_1VirtBases_1a9f33ece5c65db45e9ccb00878c6f7b49">PtrVector</reimplementedby>
        <reimplementedby refid="df/d4a/structDataVector__detail_1_1VirtBases_3_01B1_00_01B2_00_01DataModel__detail_1_1NoBase_01_4_1ac5ed6bb2de5c9616d9cc5f4a15b3a046">PtrVector</reimplementedby>
        <reimplementedby refid="db/d76/structDataVector__detail_1_1VirtBases_3_01B1_00_01DataModel__detail_1_1NoBase_00_01DataModel__detail_1_1NoBase_01_4_1a568d00610300f40d961ac8fe2384c5cc">PtrVector</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This is the type of the underlying <computeroutput>std::vector</computeroutput> (what <computeroutput>stdcont</computeroutput> returns). </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="731" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" bodystart="731" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="d0/d4d/classDataVector_1a6a6d678ca42e0eee8fec9e17eae6c0a4" prot="public" static="no">
        <type>BASE::PtrVector</type>
        <definition>typedef BASE::PtrVector DataVector&lt; T, BASE &gt;::BaseContainer</definition>
        <argsstring></argsstring>
        <name>BaseContainer</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="732" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" bodystart="732" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="d0/d4d/classDataVector_1a93d4d960378dca6d5b26597d06247ae7" prot="public" static="no">
        <type><ref refid="d1/def/classT" kindref="compound">T</ref> *&amp;</type>
        <definition>typedef T*&amp; DataVector&lt; T, BASE &gt;::reference</definition>
        <argsstring></argsstring>
        <name>reference</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="737" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" bodystart="737" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="d0/d4d/classDataVector_1a00f78b0e29b4b50cea072aaa82800311" prot="public" static="no">
        <type><ref refid="d1/def/classT" kindref="compound">T</ref> *const &amp;</type>
        <definition>typedef T* const&amp; DataVector&lt; T, BASE &gt;::const_reference</definition>
        <argsstring></argsstring>
        <name>const_reference</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="738" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" bodystart="738" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="d0/d4d/classDataVector_1a2d11ee2f3a2528ce3ea9f0791dcb58c9" prot="public" static="no">
        <type>BASE::size_type</type>
        <definition>typedef BASE::size_type DataVector&lt; T, BASE &gt;::size_type</definition>
        <argsstring></argsstring>
        <name>size_type</name>
        <reimplementedby refid="df/d07/structDataVector__detail_1_1VirtBases_1a1f5139b5beb6c9ceb30073c8c086dd83">size_type</reimplementedby>
        <reimplementedby refid="df/d4a/structDataVector__detail_1_1VirtBases_3_01B1_00_01B2_00_01DataModel__detail_1_1NoBase_01_4_1a459d913bb59e87f0601ef05e20b16396">size_type</reimplementedby>
        <reimplementedby refid="db/d76/structDataVector__detail_1_1VirtBases_3_01B1_00_01DataModel__detail_1_1NoBase_00_01DataModel__detail_1_1NoBase_01_4_1a4969902c4937fd9704611f47ab102656">size_type</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="739" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" bodystart="739" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="d0/d4d/classDataVector_1aab17483aa47f11399ccaafb2931de121" prot="public" static="no">
        <type>BASE::difference_type</type>
        <definition>typedef BASE::difference_type DataVector&lt; T, BASE &gt;::difference_type</definition>
        <argsstring></argsstring>
        <name>difference_type</name>
        <reimplementedby refid="df/d07/structDataVector__detail_1_1VirtBases_1a7cc8472e49193846b1bf808ddc105a75">difference_type</reimplementedby>
        <reimplementedby refid="df/d4a/structDataVector__detail_1_1VirtBases_3_01B1_00_01B2_00_01DataModel__detail_1_1NoBase_01_4_1a73a43f120be22144d4cda42a4445b8b3">difference_type</reimplementedby>
        <reimplementedby refid="db/d76/structDataVector__detail_1_1VirtBases_3_01B1_00_01DataModel__detail_1_1NoBase_00_01DataModel__detail_1_1NoBase_01_4_1acb90c7e541526e8088f356b1e2a3b8f8">difference_type</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="740" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" bodystart="740" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="d0/d4d/classDataVector_1a1055f8ad9a5f8ed057a4f047a87def97" prot="public" static="no">
        <type><ref refid="d1/def/classT" kindref="compound">T</ref> *</type>
        <definition>typedef T* DataVector&lt; T, BASE &gt;::value_type</definition>
        <argsstring></argsstring>
        <name>value_type</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="741" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" bodystart="741" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="d0/d4d/classDataVector_1a058fe076dee6b863cedbe61025ebf24e" prot="public" static="no">
        <type>BASE::allocator_type</type>
        <definition>typedef BASE::allocator_type DataVector&lt; T, BASE &gt;::allocator_type</definition>
        <argsstring></argsstring>
        <name>allocator_type</name>
        <reimplementedby refid="df/d07/structDataVector__detail_1_1VirtBases_1ae3a47f90377be06166f910e66d538146">allocator_type</reimplementedby>
        <reimplementedby refid="df/d4a/structDataVector__detail_1_1VirtBases_3_01B1_00_01B2_00_01DataModel__detail_1_1NoBase_01_4_1a39eb47544b9dbe05a6c3488e26282b34">allocator_type</reimplementedby>
        <reimplementedby refid="db/d76/structDataVector__detail_1_1VirtBases_3_01B1_00_01DataModel__detail_1_1NoBase_00_01DataModel__detail_1_1NoBase_01_4_1a220e5141b1259571ca3f125375e5be4d">allocator_type</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="742" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" bodystart="742" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="d0/d4d/classDataVector_1a27b9433721506dc44069b1b6c91c873e" prot="public" static="no">
        <type><ref refid="d1/def/classT" kindref="compound">T</ref> **</type>
        <definition>typedef T** DataVector&lt; T, BASE &gt;::pointer</definition>
        <argsstring></argsstring>
        <name>pointer</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="743" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" bodystart="743" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="d0/d4d/classDataVector_1ad64bda7c082445e7612279b8d8fe45b5" prot="public" static="no">
        <type><ref refid="d1/def/classT" kindref="compound">T</ref> *const *</type>
        <definition>typedef T* const* DataVector&lt; T, BASE &gt;::const_pointer</definition>
        <argsstring></argsstring>
        <name>const_pointer</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="744" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" bodystart="744" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="d0/d4d/classDataVector_1a6b0c09ea08315b3675274f96c1c30f0e" prot="public" static="no">
        <type>const <ref refid="d1/def/classT" kindref="compound">T</ref> *</type>
        <definition>typedef const T* DataVector&lt; T, BASE &gt;::const_value_type</definition>
        <argsstring></argsstring>
        <name>const_value_type</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="746" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" bodystart="746" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="d0/d4d/classDataVector_1af41f7b0dcfd7647422459e4386d6cc8e" prot="public" static="no">
        <type><ref refid="d1/def/classT" kindref="compound">T</ref></type>
        <definition>typedef T DataVector&lt; T, BASE &gt;::base_value_type</definition>
        <argsstring></argsstring>
        <name>base_value_type</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The <computeroutput><ref refid="d1/def/classT" kindref="compound">T</ref></computeroutput> value used as the template parameter. Note that this is different from <computeroutput>value_type</computeroutput> (that&apos;s <computeroutput>T*</computeroutput>). </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="750" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" bodystart="750" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="d0/d4d/classDataVector_1a51e5972e57ba800d8f93b781c7af58e3" prot="public" static="no">
        <type><ref refid="d7/d05/classDataModel__detail_1_1ElementProxy" kindref="compound">DataModel_detail::ElementProxy</ref>&lt; <ref refid="d0/d4d/classDataVector" kindref="compound">DataVector</ref> &gt;</type>
        <definition>typedef DataModel_detail::ElementProxy&lt;DataVector&gt; DataVector&lt; T, BASE &gt;::ElementProxy</definition>
        <argsstring></argsstring>
        <name>ElementProxy</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This type is used to proxy lvalue accesses to <computeroutput><ref refid="d0/d4d/classDataVector" kindref="compound">DataVector</ref></computeroutput> elements, in order to handle ownership. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="754" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" bodystart="754" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="d0/d4d/classDataVector_1a105a683f8b36d88454de49c757747fde" prot="public" static="no">
        <type><ref refid="d7/d17/classDataModel__detail_1_1const__iterator" kindref="compound">DataModel_detail::const_iterator</ref>&lt; <ref refid="d0/d4d/classDataVector" kindref="compound">DataVector</ref> &gt;</type>
        <definition>typedef DataModel_detail::const_iterator&lt;DataVector&gt; DataVector&lt; T, BASE &gt;::const_iterator</definition>
        <argsstring></argsstring>
        <name>const_iterator</name>
        <briefdescription>
<para>Standard <computeroutput>const_iterator</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="759" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" bodystart="759" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="d0/d4d/classDataVector_1a720d2b9643ffc12ed1725cec9ecc691e" prot="public" static="no">
        <type><ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">DataModel_detail::iterator</ref>&lt; <ref refid="d0/d4d/classDataVector" kindref="compound">DataVector</ref> &gt;</type>
        <definition>typedef DataModel_detail::iterator&lt;DataVector&gt; DataVector&lt; T, BASE &gt;::iterator</definition>
        <argsstring></argsstring>
        <name>iterator</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Standard <computeroutput>iterator</computeroutput>. Note that lvalue references here will yield an <computeroutput>ElementProxy</computeroutput>, not a <computeroutput>reference</computeroutput>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="763" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" bodystart="763" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="d0/d4d/classDataVector_1ab289e00e978a3cbcbb642ab9dc28617c" prot="public" static="no">
        <type>std::reverse_iterator&lt; <ref refid="d7/d17/classDataModel__detail_1_1const__iterator" kindref="compound">const_iterator</ref> &gt;</type>
        <definition>typedef std::reverse_iterator&lt;const_iterator&gt; DataVector&lt; T, BASE &gt;::const_reverse_iterator</definition>
        <argsstring></argsstring>
        <name>const_reverse_iterator</name>
        <briefdescription>
<para>Standard <computeroutput>const_reverse_iterator</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="768" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" bodystart="768" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="d0/d4d/classDataVector_1a48b8aeb52be5374ae659f1c383e6e172" prot="public" static="no">
        <type>std::reverse_iterator&lt; <ref refid="d5/d70/classDataModel__detail_1_1iterator" kindref="compound">iterator</ref> &gt;</type>
        <definition>typedef std::reverse_iterator&lt;iterator&gt; DataVector&lt; T, BASE &gt;::reverse_iterator</definition>
        <argsstring></argsstring>
        <name>reverse_iterator</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Standard <computeroutput>reverse_iterator</computeroutput>. Note that lvalue references here will yield an <computeroutput>ElementProxy</computeroutput>, not a <computeroutput>reference</computeroutput>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="773" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" bodystart="773" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="d0/d4d/classDataVector_1ae8b99ec086854d309f18be7c803984f1" prot="public" static="no">
        <type><ref refid="d0/d4d/classDataVector" kindref="compound">DataVector</ref>&lt; <ref refid="d1/def/classT" kindref="compound">T</ref>, BASE &gt;</type>
        <definition>typedef DataVector&lt; T, BASE &gt; DataVector&lt; T, BASE &gt;::self</definition>
        <argsstring></argsstring>
        <name>self</name>
        <reimplementedby refid="df/d07/structDataVector__detail_1_1VirtBases_1aed90a9d3953313ac3e9298fd8dc0af39">self</reimplementedby>
        <reimplementedby refid="df/d07/structDataVector__detail_1_1VirtBases_1a5cd95bcdff72f693f2d73d8189dbf23c">self</reimplementedby>
        <reimplementedby refid="df/d4a/structDataVector__detail_1_1VirtBases_3_01B1_00_01B2_00_01DataModel__detail_1_1NoBase_01_4_1a1d44f2b15e66cfc93e5e77fc258ca9df">self</reimplementedby>
        <reimplementedby refid="db/d76/structDataVector__detail_1_1VirtBases_3_01B1_00_01DataModel__detail_1_1NoBase_00_01DataModel__detail_1_1NoBase_01_4_1a9375a04688a47a0172f7508edd1c1e72">self</reimplementedby>
        <briefdescription>
<para><ref refid="d4/dc4/structA" kindref="compound">A</ref> helper typedef. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="3224" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" bodystart="3224" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-type">
      <memberdef kind="typedef" id="d0/d4d/classDataVector_1a251be9ad176cb5c3ed2cb316278fa396" prot="private" static="no">
        <type>ROOT_SELECTION_NS::DataVector&lt; <ref refid="d1/def/classT" kindref="compound">T</ref>, DataVector_BASE &gt;::self</type>
        <definition>typedef ROOT_SELECTION_NS::DataVector&lt;T, DataVector_BASE&gt;::self DataVector&lt; T, BASE &gt;::self</definition>
        <argsstring></argsstring>
        <name>self</name>
        <reimplementedby refid="df/d07/structDataVector__detail_1_1VirtBases_1aed90a9d3953313ac3e9298fd8dc0af39">self</reimplementedby>
        <reimplementedby refid="df/d07/structDataVector__detail_1_1VirtBases_1a5cd95bcdff72f693f2d73d8189dbf23c">self</reimplementedby>
        <reimplementedby refid="df/d4a/structDataVector__detail_1_1VirtBases_3_01B1_00_01B2_00_01DataModel__detail_1_1NoBase_01_4_1a1d44f2b15e66cfc93e5e77fc258ca9df">self</reimplementedby>
        <reimplementedby refid="db/d76/structDataVector__detail_1_1VirtBases_3_01B1_00_01DataModel__detail_1_1NoBase_00_01DataModel__detail_1_1NoBase_01_4_1a9375a04688a47a0172f7508edd1c1e72">self</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1903" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" bodystart="1903" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-static-attrib">
      <memberdef kind="variable" id="d0/d4d/classDataVector_1a353125037b2c1b2472f49c7e0adeb7f3" prot="public" static="yes" mutable="no">
        <type>const bool</type>
        <definition>const bool DataVector&lt; T, BASE &gt;::has_virtual</definition>
        <argsstring></argsstring>
        <name>has_virtual</name>
        <reimplementedby refid="df/d07/structDataVector__detail_1_1VirtBases_1a25d53971208cb87640a4734212ee8e1f">has_virtual</reimplementedby>
        <reimplementedby refid="df/d4a/structDataVector__detail_1_1VirtBases_3_01B1_00_01B2_00_01DataModel__detail_1_1NoBase_01_4_1a9e58dabc78f4e08b9fbf5032be91daa3">has_virtual</reimplementedby>
        <reimplementedby refid="db/d76/structDataVector__detail_1_1VirtBases_3_01B1_00_01DataModel__detail_1_1NoBase_00_01DataModel__detail_1_1NoBase_01_4_1a4daa99b9bc5c5a5b65ababfdbb695300">has_virtual</reimplementedby>
        <initializer> BASE::has_virtual</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This is true for any <computeroutput><ref refid="d0/d4d/classDataVector" kindref="compound">DataVector</ref></computeroutput> class if we need to use virtual derivation to get to the base <computeroutput><ref refid="d0/d4d/classDataVector" kindref="compound">DataVector</ref></computeroutput> class. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="727" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" bodystart="727" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="d0/d4d/classDataVector_1ad414da8827a5f69b3a560b6d47a07416" prot="private" static="no" mutable="no">
        <type><ref refid="df/d76/classSG_1_1IsMostDerivedFlag" kindref="compound">SG::IsMostDerivedFlag</ref></type>
        <definition>SG::IsMostDerivedFlag DataVector&lt; T, BASE &gt;::m_isMostDerived</definition>
        <argsstring></argsstring>
        <name>m_isMostDerived</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This flag is true if this <ref refid="d3/d78/structDV" kindref="compound">DV</ref> instance is the most-derived one. We set this to true in the top-level constructor; the constructor then calls <computeroutput>clearMostDerived</computeroutput> on the base classes. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1895" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" bodystart="1895" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-static-attrib">
      <memberdef kind="variable" id="d0/d4d/classDataVector_1a3261a3980e28dd4ad949b3474b20b5f7" prot="private" static="yes" mutable="no">
        <type><ref refid="df/d12/classDataModel__detail_1_1DVLInfo" kindref="compound">DataModel_detail::DVLInfo</ref>&lt; <ref refid="d0/d4d/classDataVector" kindref="compound">DataVector</ref>&lt; <ref refid="d1/def/classT" kindref="compound">T</ref> &gt; &gt;</type>
        <definition>DataModel_detail::DVLInfo&lt; DataVector&lt; T &gt; &gt; DataVector&lt; T, BASE &gt;::s_info</definition>
        <argsstring></argsstring>
        <name>s_info</name>
        <briefdescription>
<para>The DV/DL info struct for this class. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1899" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" bodystart="1899" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-attrib">
      <memberdef kind="variable" id="d0/d4d/classDataVector_1a731423a95c8a02f9ced02e25b8197cc9" prot="public" static="no" mutable="no">
        <type>ROOT_SELECTION_NS::MemberAttributes&lt; kTransient &gt;</type>
        <definition>ROOT_SELECTION_NS::MemberAttributes&lt; kTransient &gt; DataVector&lt; T, BASE &gt;::m_isMostDerived</definition>
        <argsstring></argsstring>
        <name>m_isMostDerived</name>
        <briefdescription>
<para>Automatically generate dictionary for contained vector. </para>        </briefdescription>
        <detaileddescription>
<para>Declare the automatically created variable transient </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="3231" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" bodystart="3231" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="d0/d4d/classDataVector_1a15eb577a199c519cb5126233b04cc429" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void DataVector&lt; T, BASE &gt;::resize</definition>
        <argsstring>(size_type sz)</argsstring>
        <name>resize</name>
        <reimplementedby refid="d0/d58/classxAOD_1_1MissingETComponentMap__v1_1a5acc242b0dbaa4d76b85857fb0ebd696">resize</reimplementedby>
        <reimplementedby refid="d5/d3a/classxAOD_1_1MissingETAssociationMap__v1_1a8861947e2f00404e85cbf2f59f0102a4">resize</reimplementedby>
        <param>
          <type>size_type</type>
          <declname>sz</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1698"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1a8edc54fe5f97284d23ef5e88319c7a86" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void DataVector&lt; T, BASE &gt;::shrink_to_fit</definition>
        <argsstring>()</argsstring>
        <name>shrink_to_fit</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1701"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1a52881ff983e0d0dd21b23c4d03824b68" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void DataVector&lt; T, BASE &gt;::pop_back</definition>
        <argsstring>()</argsstring>
        <name>pop_back</name>
        <reimplementedby refid="d0/d58/classxAOD_1_1MissingETComponentMap__v1_1afc4b4a4eccabae3091372560a5fdc807">pop_back</reimplementedby>
        <reimplementedby refid="d5/d3a/classxAOD_1_1MissingETAssociationMap__v1_1a0371c68bf1814b952d8ee28c6e53a167">pop_back</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1702"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1af2b028c097d741794a59b03c184fb70a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void DataVector&lt; T, BASE &gt;::clear</definition>
        <argsstring>()</argsstring>
        <name>clear</name>
        <reimplementedby refid="d0/d58/classxAOD_1_1MissingETComponentMap__v1_1a37d1a8e2caeb7d1dae2dd744fc808302">clear</reimplementedby>
        <reimplementedby refid="d5/d3a/classxAOD_1_1MissingETAssociationMap__v1_1afe21a96b578e2cc5dda649287db258e3">clear</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1703"/>
      </memberdef>
      <memberdef kind="function" id="d0/d4d/classDataVector_1a2871d04482709adc5ad14fdd4780e934" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void DataVector&lt; T, BASE &gt;::clear</definition>
        <argsstring>(SG::OwnershipPolicy ownPolicy, SG::IndexTrackingPolicy trackIndices=SG::DEFAULT_TRACK_INDICES)</argsstring>
        <name>clear</name>
        <reimplementedby refid="d0/d58/classxAOD_1_1MissingETComponentMap__v1_1a3bf9c9742788c62ba811bf0ca104916c">clear</reimplementedby>
        <reimplementedby refid="d5/d3a/classxAOD_1_1MissingETAssociationMap__v1_1ade371e0810ff04cd5371c06b773f6906">clear</reimplementedby>
        <param>
          <type><ref refid="dd/d59/namespaceSG_1acd9d1a31242c6243cc1c6fab0fbc7cd8" kindref="member">SG::OwnershipPolicy</ref></type>
          <declname>ownPolicy</declname>
        </param>
        <param>
          <type><ref refid="dd/d59/namespaceSG_1a9f3d699f65390b7f8baf54d9cd634573" kindref="member">SG::IndexTrackingPolicy</ref></type>
          <declname>trackIndices</declname>
          <defval>SG::DEFAULT_TRACK_INDICES</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="1707"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Derived <computeroutput><ref refid="d0/d4d/classDataVector" kindref="compound">DataVector</ref>&lt;<ref refid="d1/def/classT" kindref="compound">T</ref>&gt;</computeroutput>. </para>    </briefdescription>
    <detaileddescription>
<para>This is used for the case where <computeroutput><ref refid="d1/def/classT" kindref="compound">T</ref></computeroutput> derives from other classes. The vector of pointers is actually held in the (unique) base class of the hierarchy.</para><para>See the file comments for full details. </para>    </detaileddescription>
    <inheritancegraph>
      <node id="4810">
        <label>KeepFirstTemplateArguments&lt; 1 &gt;</label>
        <link refid="d6/de5/classKeepFirstTemplateArguments"/>
      </node>
      <node id="4809">
        <label>DataVector&lt; T, BASE &gt;</label>
        <link refid="d0/d4d/classDataVector"/>
        <childnode refid="4810" relation="private-inheritance">
        </childnode>
      </node>
    </inheritancegraph>
    <collaborationgraph>
      <node id="4815">
        <label>SG::IsMostDerivedFlag</label>
        <link refid="df/d76/classSG_1_1IsMostDerivedFlag"/>
      </node>
      <node id="4812">
        <label>KeepFirstTemplateArguments&lt; 1 &gt;</label>
        <link refid="d6/de5/classKeepFirstTemplateArguments"/>
      </node>
      <node id="4814">
        <label>DataModel_detail::DVLInfoBase</label>
        <link refid="da/d8a/classDataModel__detail_1_1DVLInfoBase"/>
      </node>
      <node id="4811">
        <label>DataVector&lt; T, BASE &gt;</label>
        <link refid="d0/d4d/classDataVector"/>
        <childnode refid="4812" relation="private-inheritance">
        </childnode>
        <childnode refid="4813" relation="usage">
          <edgelabel>s_info</edgelabel>
        </childnode>
        <childnode refid="4815" relation="usage">
          <edgelabel>m_isMostDerived</edgelabel>
        </childnode>
      </node>
      <node id="4813">
        <label>DataModel_detail::DVLInfo&lt; DataVector&lt; T &gt; &gt;</label>
        <link refid="df/d12/classDataModel__detail_1_1DVLInfo"/>
        <childnode refid="4814" relation="public-inheritance">
        </childnode>
      </node>
    </collaborationgraph>
    <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" line="720" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/AthContainers/AthContainers/DataVector.h" bodystart="719" bodyend="1904"/>
    <listofallmembers>
      <member refid="d0/d4d/classDataVector_1a058fe076dee6b863cedbe61025ebf24e" prot="public" virt="non-virtual"><scope>DataVector</scope><name>allocator_type</name></member>
      <member refid="d0/d4d/classDataVector_1a39b727c555a667c66094016314050332" prot="public" virt="non-virtual"><scope>DataVector</scope><name>assign</name></member>
      <member refid="d0/d4d/classDataVector_1af5800a07e6b959507c45e25fc0b1cc2c" prot="private" virt="non-virtual"><scope>DataVector</scope><name>assignBaseElement</name></member>
      <member refid="d0/d4d/classDataVector_1af08a0fb0d5e1655c63479b6c3e2c06da" prot="private" virt="non-virtual"><scope>DataVector</scope><name>assignElement</name></member>
      <member refid="d0/d4d/classDataVector_1a3f598b345c9b1eb8793fd9cc6c16abe3" prot="public" virt="non-virtual"><scope>DataVector</scope><name>at</name></member>
      <member refid="d0/d4d/classDataVector_1ac9c3322bdb72e9bc502a578715937807" prot="public" virt="non-virtual"><scope>DataVector</scope><name>at</name></member>
      <member refid="d0/d4d/classDataVector_1a749ffc30735b0fbd0269df4e750851a7" prot="public" virt="non-virtual"><scope>DataVector</scope><name>auxbase</name></member>
      <member refid="d0/d4d/classDataVector_1aee6b47538e67f772011367fccbf0e83f" prot="public" virt="non-virtual"><scope>DataVector</scope><name>back</name></member>
      <member refid="d0/d4d/classDataVector_1a56c7d05bd0d914c446598aab3402e020" prot="public" virt="non-virtual"><scope>DataVector</scope><name>back</name></member>
      <member refid="d0/d4d/classDataVector_1af41f7b0dcfd7647422459e4386d6cc8e" prot="public" virt="non-virtual"><scope>DataVector</scope><name>base_value_type</name></member>
      <member refid="d0/d4d/classDataVector_1a6a6d678ca42e0eee8fec9e17eae6c0a4" prot="public" virt="non-virtual"><scope>DataVector</scope><name>BaseContainer</name></member>
      <member refid="d0/d4d/classDataVector_1a3af6f600eec6df2c3652211ba80fc031" prot="public" virt="non-virtual"><scope>DataVector</scope><name>baseOffset</name></member>
      <member refid="d0/d4d/classDataVector_1ad1616eb350fff0fc40908c62bb8fd9da" prot="public" virt="non-virtual"><scope>DataVector</scope><name>baseOffset1</name></member>
      <member refid="d0/d4d/classDataVector_1a66c78bd83eeb15e5616a898557598b36" prot="public" virt="non-virtual"><scope>DataVector</scope><name>begin</name></member>
      <member refid="d0/d4d/classDataVector_1a2c42ec99129008304681ddef6b812c15" prot="public" virt="non-virtual"><scope>DataVector</scope><name>begin</name></member>
      <member refid="d0/d4d/classDataVector_1a60c5cb0eab20bb3f2325ca9037ec3b5b" prot="public" virt="non-virtual"><scope>DataVector</scope><name>capacity</name></member>
      <member refid="d0/d4d/classDataVector_1a2ba633ea0a2c1c0a8413ca4897817e4e" prot="public" virt="non-virtual"><scope>DataVector</scope><name>cbegin</name></member>
      <member refid="d0/d4d/classDataVector_1aa42d00ed3a26858f32f25e2e1010ca4f" prot="public" virt="non-virtual"><scope>DataVector</scope><name>cend</name></member>
      <member refid="d0/d4d/classDataVector_1af2b028c097d741794a59b03c184fb70a" prot="public" virt="non-virtual"><scope>DataVector</scope><name>clear</name></member>
      <member refid="d0/d4d/classDataVector_1ae40a6a2cf044fdeb1defe4889213c5e2" prot="public" virt="non-virtual"><scope>DataVector</scope><name>clear</name></member>
      <member refid="d0/d4d/classDataVector_1a70c20dac9bc136ec903ae571a203314f" prot="public" virt="non-virtual"><scope>DataVector</scope><name>clear</name></member>
      <member refid="d0/d4d/classDataVector_1af2b028c097d741794a59b03c184fb70a" prot="public" virt="non-virtual"><scope>DataVector</scope><name>clear</name></member>
      <member refid="d0/d4d/classDataVector_1a2871d04482709adc5ad14fdd4780e934" prot="public" virt="non-virtual"><scope>DataVector</scope><name>clear</name></member>
      <member refid="d0/d4d/classDataVector_1a94c4e1b8437edab8296380c7d620faac" prot="protected" virt="non-virtual"><scope>DataVector</scope><name>clearMostDerived</name></member>
      <member refid="d0/d4d/classDataVector_1a105a683f8b36d88454de49c757747fde" prot="public" virt="non-virtual"><scope>DataVector</scope><name>const_iterator</name></member>
      <member refid="d0/d4d/classDataVector_1ad64bda7c082445e7612279b8d8fe45b5" prot="public" virt="non-virtual"><scope>DataVector</scope><name>const_pointer</name></member>
      <member refid="d0/d4d/classDataVector_1a00f78b0e29b4b50cea072aaa82800311" prot="public" virt="non-virtual"><scope>DataVector</scope><name>const_reference</name></member>
      <member refid="d0/d4d/classDataVector_1ab289e00e978a3cbcbb642ab9dc28617c" prot="public" virt="non-virtual"><scope>DataVector</scope><name>const_reverse_iterator</name></member>
      <member refid="d0/d4d/classDataVector_1a6b0c09ea08315b3675274f96c1c30f0e" prot="public" virt="non-virtual"><scope>DataVector</scope><name>const_value_type</name></member>
      <member refid="d0/d4d/classDataVector_1a872beca4ae4bd23ae0ca85253466b96b" prot="private" virt="non-virtual"><scope>DataVector</scope><name>ConstDataVector&lt; DataVector &gt;</name></member>
      <member refid="d0/d4d/classDataVector_1ade43c536beab58ae6b2e037fd67ff8e2" prot="public" virt="non-virtual"><scope>DataVector</scope><name>crbegin</name></member>
      <member refid="d0/d4d/classDataVector_1a07fbb4e8bddec66621cc3f78defbc92b" prot="public" virt="non-virtual"><scope>DataVector</scope><name>crend</name></member>
      <member refid="d0/d4d/classDataVector_1a2cf6a773e2f312ccade13b686b8f01d6" prot="public" virt="non-virtual"><scope>DataVector</scope><name>DataModel_detail::ElementProxy&lt; DataVector &gt;</name></member>
      <member refid="d0/d4d/classDataVector_1a16bded828caf6b976bd7052d3439b5b6" prot="public" virt="non-virtual"><scope>DataVector</scope><name>DataVector</name></member>
      <member refid="d0/d4d/classDataVector_1a10e3c4b4b0de95c7fd13ad9a3be5fb58" prot="public" virt="non-virtual"><scope>DataVector</scope><name>DataVector</name></member>
      <member refid="d0/d4d/classDataVector_1ac113b3ae53f2d1254efc34bbacd25f14" prot="public" virt="non-virtual"><scope>DataVector</scope><name>DataVector</name></member>
      <member refid="d0/d4d/classDataVector_1adbb7524fe05522edf000e397dc36a183" prot="public" virt="non-virtual"><scope>DataVector</scope><name>DataVector_BASE</name></member>
      <member refid="d0/d4d/classDataVector_1aab17483aa47f11399ccaafb2931de121" prot="public" virt="non-virtual"><scope>DataVector</scope><name>difference_type</name></member>
      <member refid="d0/d4d/classDataVector_1abf16cf8a9eb9c1c6a4419be395208ca0" prot="public" virt="non-virtual"><scope>DataVector</scope><name>do_cast</name></member>
      <member refid="d0/d4d/classDataVector_1a9ffd936a428c6cacdc3547946901a6a9" prot="private" virt="virtual"><scope>DataVector</scope><name>dv_typeid</name></member>
      <member refid="d0/d4d/classDataVector_1abced550e4bb02a91c1b1c660ddf9071d" prot="public" virt="non-virtual"><scope>DataVector</scope><name>DVL_BASE</name></member>
      <member refid="d0/d4d/classDataVector_1a4831de47c79708079d0c1e1e1c9e4363" prot="public" virt="non-virtual"><scope>DataVector</scope><name>dvlinfo</name></member>
      <member refid="d0/d4d/classDataVector_1ac7fb23bf395a0e3894f454fc7f072764" prot="public" virt="virtual"><scope>DataVector</scope><name>dvlinfo_v</name></member>
      <member refid="d0/d4d/classDataVector_1a51e5972e57ba800d8f93b781c7af58e3" prot="public" virt="non-virtual"><scope>DataVector</scope><name>ElementProxy</name></member>
      <member refid="d0/d4d/classDataVector_1ac6f57a40acf210dfbb95205bb078be3b" prot="public" virt="non-virtual"><scope>DataVector</scope><name>emplace</name></member>
      <member refid="d0/d4d/classDataVector_1af6206e99fb0d7d2e2fce1eafe99877f1" prot="public" virt="non-virtual"><scope>DataVector</scope><name>emplace_back</name></member>
      <member refid="d0/d4d/classDataVector_1a85aede44dff3bf86318e9d7ee71f0de5" prot="public" virt="non-virtual"><scope>DataVector</scope><name>empty</name></member>
      <member refid="d0/d4d/classDataVector_1a1d5dd5515d2c9bc20f417830f5d05b5e" prot="public" virt="non-virtual"><scope>DataVector</scope><name>end</name></member>
      <member refid="d0/d4d/classDataVector_1ad7a08d945fb1698fcb3ea07ab1dccbec" prot="public" virt="non-virtual"><scope>DataVector</scope><name>end</name></member>
      <member refid="d0/d4d/classDataVector_1a249b08ecb8260e288fe9087e3db48950" prot="public" virt="non-virtual"><scope>DataVector</scope><name>erase</name></member>
      <member refid="d0/d4d/classDataVector_1acaf33a6392cb774a35ee362d140fd17c" prot="public" virt="non-virtual"><scope>DataVector</scope><name>erase</name></member>
      <member refid="d0/d4d/classDataVector_1ad60c996521bcea5c5a57bc078b08b876" prot="public" virt="non-virtual"><scope>DataVector</scope><name>front</name></member>
      <member refid="d0/d4d/classDataVector_1a1ad4290a3853f0a10ea79452c4a0b423" prot="public" virt="non-virtual"><scope>DataVector</scope><name>front</name></member>
      <member refid="d0/d4d/classDataVector_1aee535632a89bd041be90a3fa3058e36b" prot="public" virt="non-virtual"><scope>DataVector</scope><name>get</name></member>
      <member refid="d0/d4d/classDataVector_1a353125037b2c1b2472f49c7e0adeb7f3" prot="public" virt="non-virtual"><scope>DataVector</scope><name>has_virtual</name></member>
      <member refid="d0/d4d/classDataVector_1a4bfe807fd5835ae4e484eb505bb03533" prot="public" virt="non-virtual"><scope>DataVector</scope><name>insert</name></member>
      <member refid="d0/d4d/classDataVector_1a173e4fcf883f04507805618118c444a9" prot="public" virt="non-virtual"><scope>DataVector</scope><name>insert</name></member>
      <member refid="d0/d4d/classDataVector_1a309f0e29bcde5ca107c5232cbf6b9d4c" prot="public" virt="non-virtual"><scope>DataVector</scope><name>iter_swap</name></member>
      <member refid="d0/d4d/classDataVector_1a720d2b9643ffc12ed1725cec9ecc691e" prot="public" virt="non-virtual"><scope>DataVector</scope><name>iterator</name></member>
      <member refid="d0/d4d/classDataVector_1ad414da8827a5f69b3a560b6d47a07416" prot="private" virt="non-virtual"><scope>DataVector</scope><name>m_isMostDerived</name></member>
      <member refid="d0/d4d/classDataVector_1a731423a95c8a02f9ced02e25b8197cc9" prot="public" virt="non-virtual"><scope>DataVector</scope><name>m_isMostDerived</name></member>
      <member refid="d0/d4d/classDataVector_1afaa2425da1ced3fa685a37a2a0561b05" prot="public" virt="non-virtual"><scope>DataVector</scope><name>max_size</name></member>
      <member refid="d0/d4d/classDataVector_1a31f28630872abd2e694534c7cc8fa4ec" prot="public" virt="non-virtual"><scope>DataVector</scope><name>operator=</name></member>
      <member refid="d0/d4d/classDataVector_1ab22de888b8cf10f2b05fe6bc48465381" prot="public" virt="non-virtual"><scope>DataVector</scope><name>operator[]</name></member>
      <member refid="d0/d4d/classDataVector_1a9e0e83fd312a9ebdc94666283bf65de9" prot="public" virt="non-virtual"><scope>DataVector</scope><name>operator[]</name></member>
      <member refid="d0/d4d/classDataVector_1a23689a65fe5243d0bd00c3aa79640f98" prot="public" virt="non-virtual"><scope>DataVector</scope><name>ownPolicy</name></member>
      <member refid="d0/d4d/classDataVector_1a27b9433721506dc44069b1b6c91c873e" prot="public" virt="non-virtual"><scope>DataVector</scope><name>pointer</name></member>
      <member refid="d0/d4d/classDataVector_1a52881ff983e0d0dd21b23c4d03824b68" prot="public" virt="non-virtual"><scope>DataVector</scope><name>pop_back</name></member>
      <member refid="d0/d4d/classDataVector_1a52881ff983e0d0dd21b23c4d03824b68" prot="public" virt="non-virtual"><scope>DataVector</scope><name>pop_back</name></member>
      <member refid="d0/d4d/classDataVector_1ac8d41eaf271f444aeacb80705fde49d9" prot="public" virt="non-virtual"><scope>DataVector</scope><name>PtrVector</name></member>
      <member refid="d0/d4d/classDataVector_1a486aeb4868e7c29331717adb06ea0df2" prot="public" virt="non-virtual"><scope>DataVector</scope><name>push_back</name></member>
      <member refid="d0/d4d/classDataVector_1a71dc1d0d8666c71cdbd98cf12ed58832" prot="public" virt="non-virtual"><scope>DataVector</scope><name>rbegin</name></member>
      <member refid="d0/d4d/classDataVector_1ab216c17baaede1e4a8dd98f53071b354" prot="public" virt="non-virtual"><scope>DataVector</scope><name>rbegin</name></member>
      <member refid="d0/d4d/classDataVector_1a93d4d960378dca6d5b26597d06247ae7" prot="public" virt="non-virtual"><scope>DataVector</scope><name>reference</name></member>
      <member refid="d0/d4d/classDataVector_1ae09c48f39c028009bf8dbc0bc9340e80" prot="public" virt="non-virtual"><scope>DataVector</scope><name>rend</name></member>
      <member refid="d0/d4d/classDataVector_1a49e6422f38b1483a45b642534c7f83f4" prot="public" virt="non-virtual"><scope>DataVector</scope><name>rend</name></member>
      <member refid="d0/d4d/classDataVector_1a3827d1fa4f134ba36346893715dd5bc1" prot="public" virt="non-virtual"><scope>DataVector</scope><name>reserve</name></member>
      <member refid="d0/d4d/classDataVector_1a15eb577a199c519cb5126233b04cc429" prot="public" virt="non-virtual"><scope>DataVector</scope><name>resize</name></member>
      <member refid="d0/d4d/classDataVector_1a15eb577a199c519cb5126233b04cc429" prot="public" virt="non-virtual"><scope>DataVector</scope><name>resize</name></member>
      <member refid="d0/d4d/classDataVector_1af1d9fb01d514c009d7acefc7ac7b02c1" prot="public" virt="non-virtual"><scope>DataVector</scope><name>resortAux</name></member>
      <member refid="d0/d4d/classDataVector_1a48b8aeb52be5374ae659f1c383e6e172" prot="public" virt="non-virtual"><scope>DataVector</scope><name>reverse_iterator</name></member>
      <member refid="d0/d4d/classDataVector_1a3261a3980e28dd4ad949b3474b20b5f7" prot="private" virt="non-virtual"><scope>DataVector</scope><name>s_info</name></member>
      <member refid="d0/d4d/classDataVector_1a251be9ad176cb5c3ed2cb316278fa396" prot="private" virt="non-virtual"><scope>DataVector</scope><name>self</name></member>
      <member refid="d0/d4d/classDataVector_1ae8b99ec086854d309f18be7c803984f1" prot="public" virt="non-virtual"><scope>DataVector</scope><name>self</name></member>
      <member refid="d0/d4d/classDataVector_1ac4e7932eb52095ae3e88c913a77f4685" prot="protected" virt="virtual"><scope>DataVector</scope><name>setMostDerived</name></member>
      <member refid="d0/d4d/classDataVector_1a24c0a6410e85f44373c379aa8ba2d3ee" prot="private" virt="non-virtual"><scope>DataVector</scope><name>shift</name></member>
      <member refid="d0/d4d/classDataVector_1a8edc54fe5f97284d23ef5e88319c7a86" prot="public" virt="non-virtual"><scope>DataVector</scope><name>shrink_to_fit</name></member>
      <member refid="d0/d4d/classDataVector_1aa4d259c267222003a6d2592fbe9809af" prot="public" virt="non-virtual"><scope>DataVector</scope><name>size</name></member>
      <member refid="d0/d4d/classDataVector_1a2d11ee2f3a2528ce3ea9f0791dcb58c9" prot="public" virt="non-virtual"><scope>DataVector</scope><name>size_type</name></member>
      <member refid="d0/d4d/classDataVector_1a33ee222cacf6bcdf7a561a8505ec09c1" prot="public" virt="non-virtual"><scope>DataVector</scope><name>sort</name></member>
      <member refid="d0/d4d/classDataVector_1a81fae208d38453acd5d3aaccafe5c10d" prot="public" virt="non-virtual"><scope>DataVector</scope><name>sort</name></member>
      <member refid="d0/d4d/classDataVector_1a0e2e64a35d842a206c96ccfec265df21" prot="public" virt="non-virtual"><scope>DataVector</scope><name>stdcont</name></member>
      <member refid="d0/d4d/classDataVector_1a53d2dcc591d07cc817b06d2523442432" prot="public" virt="non-virtual"><scope>DataVector</scope><name>swap</name></member>
      <member refid="d0/d4d/classDataVector_1a9a0337f2ef172c59b899e4aaf816891d" prot="public" virt="non-virtual"><scope>DataVector</scope><name>swapElement</name></member>
      <member refid="d0/d4d/classDataVector_1abe2ea523c0d8d9afc0e2cbfb643b72cc" prot="public" virt="non-virtual"><scope>DataVector</scope><name>swapElement</name></member>
      <member refid="d0/d4d/classDataVector_1a1119a539ef95e66a83ed73e65ce4acb9" prot="private" virt="non-virtual"><scope>DataVector</scope><name>test2_assignelement1</name></member>
      <member refid="d0/d4d/classDataVector_1a5d549df8562ac32795e7bebf440b830d" prot="private" virt="non-virtual"><scope>DataVector</scope><name>test2_assignelement2</name></member>
      <member refid="d0/d4d/classDataVector_1a3a87c3dae960c19e5108bbacad44b557" prot="public" virt="non-virtual"><scope>DataVector</scope><name>testInsert</name></member>
      <member refid="d0/d4d/classDataVector_1aebc91510c38d2fd8e413736faa744258" prot="public" virt="non-virtual"><scope>DataVector</scope><name>testInsertOol</name></member>
      <member refid="d0/d4d/classDataVector_1a1055f8ad9a5f8ed057a4f047a87def97" prot="public" virt="non-virtual"><scope>DataVector</scope><name>value_type</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
