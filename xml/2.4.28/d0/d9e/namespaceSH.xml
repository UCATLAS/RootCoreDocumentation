<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.6.1">
  <compounddef id="d0/d9e/namespaceSH" kind="namespace">
    <compoundname>SH</compoundname>
    <innerclass refid="d1/d5b/classSH_1_1DiskList" prot="public">SH::DiskList</innerclass>
    <innerclass refid="da/d47/classSH_1_1DiskListEOS" prot="public">SH::DiskListEOS</innerclass>
    <innerclass refid="d5/d9f/classSH_1_1DiskListLocal" prot="public">SH::DiskListLocal</innerclass>
    <innerclass refid="d0/d9b/classSH_1_1DiskListSRM" prot="public">SH::DiskListSRM</innerclass>
    <innerclass refid="d8/d5e/classSH_1_1DiskListXRD" prot="public">SH::DiskListXRD</innerclass>
    <innerclass refid="d6/d99/classSH_1_1DiskOutput" prot="public">SH::DiskOutput</innerclass>
    <innerclass refid="d5/d89/classSH_1_1DiskOutputLocal" prot="public">SH::DiskOutputLocal</innerclass>
    <innerclass refid="d6/d4d/classSH_1_1DiskOutputXRD" prot="public">SH::DiskOutputXRD</innerclass>
    <innerclass refid="db/dd1/classSH_1_1DiskWriter" prot="public">SH::DiskWriter</innerclass>
    <innerclass refid="d2/d69/classSH_1_1DiskWriterLocal" prot="public">SH::DiskWriterLocal</innerclass>
    <innerclass refid="dc/d85/classSH_1_1DiskWriterXRD" prot="public">SH::DiskWriterXRD</innerclass>
    <innerclass refid="d3/def/structSH_1_1RucioListDidsEntry" prot="public">SH::RucioListDidsEntry</innerclass>
    <innerclass refid="d4/d39/structSH_1_1RucioListFileReplicasEntry" prot="public">SH::RucioListFileReplicasEntry</innerclass>
    <innerclass refid="d0/d98/structSH_1_1RucioDownloadResult" prot="public">SH::RucioDownloadResult</innerclass>
    <innerclass refid="d6/d6a/classSH_1_1Meta" prot="public">SH::Meta</innerclass>
    <innerclass refid="da/d63/classSH_1_1MetaData" prot="public">SH::MetaData</innerclass>
    <innerclass refid="de/d70/structSH_1_1MetaDataQuery" prot="public">SH::MetaDataQuery</innerclass>
    <innerclass refid="d2/d33/structSH_1_1MetaDataSample" prot="public">SH::MetaDataSample</innerclass>
    <innerclass refid="d7/d06/structSH_1_1MetaFields" prot="public">SH::MetaFields</innerclass>
    <innerclass refid="d2/d8c/structSH_1_1MetaNames" prot="public">SH::MetaNames</innerclass>
    <innerclass refid="db/d3a/classSH_1_1MetaObject" prot="public">SH::MetaObject</innerclass>
    <innerclass refid="de/d63/classSH_1_1MetaVector" prot="public">SH::MetaVector</innerclass>
    <innerclass refid="dd/d5f/classSH_1_1Sample" prot="public">SH::Sample</innerclass>
    <innerclass refid="d8/d64/classSH_1_1SampleComposite" prot="public">SH::SampleComposite</innerclass>
    <innerclass refid="d1/d36/classSH_1_1SampleGrid" prot="public">SH::SampleGrid</innerclass>
    <innerclass refid="d1/d56/classSH_1_1SampleHandler" prot="public">SH::SampleHandler</innerclass>
    <innerclass refid="d4/d76/classSH_1_1SampleHist" prot="public">SH::SampleHist</innerclass>
    <innerclass refid="d8/d31/classSH_1_1SampleLocal" prot="public">SH::SampleLocal</innerclass>
    <innerclass refid="dc/d78/classSH_1_1SampleMeta" prot="public">SH::SampleMeta</innerclass>
    <innerclass refid="d8/d8a/classSH_1_1SamplePtr" prot="public">SH::SamplePtr</innerclass>
    <innerclass refid="d2/dc5/structSH_1_1ScanDir" prot="public">SH::ScanDir</innerclass>
    <innerclass refid="dd/d41/classSH_1_1TagList" prot="public">SH::TagList</innerclass>
      <sectiondef kind="func">
      <memberdef kind="function" id="d0/d9e/namespaceSH_1aa0b7ce44ba17de01d4fa7626d145d4a2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void SH::fetchMetaData</definition>
        <argsstring>(MetaDataQuery &amp;query)</argsstring>
        <name>fetchMetaData</name>
        <param>
          <type><ref refid="de/d70/structSH_1_1MetaDataQuery" kindref="compound">MetaDataQuery</ref> &amp;</type>
          <declname>query</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>effects: fetch information on all the samples/datasets specified guarantee: basic </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/SampleHandler/Root/fetch.cxx" line="27"/>
      </memberdef>
      <memberdef kind="function" id="d0/d9e/namespaceSH_1ae106084fda781abadf6f25014af03c9a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void SH::fetchMetaData</definition>
        <argsstring>(SH::SampleHandler &amp;sh, bool override)</argsstring>
        <name>fetchMetaData</name>
        <param>
          <type><ref refid="d1/d56/classSH_1_1SampleHandler" kindref="compound">SampleHandler</ref> &amp;</type>
          <declname>sh</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>override</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>effects: fetch information on all the samples in the sample handler. if override is specified it will override the existing meta-data fields, otherwise they will only be used if the given fields do not yet exist guarantee: basic </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/SampleHandler/Root/fetch.cxx" line="53"/>
      </memberdef>
      <memberdef kind="function" id="d0/d9e/namespaceSH_1ace5d9d071743e96f94e6f186ee455bd7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool SH::checkVomsProxy</definition>
        <argsstring>()</argsstring>
        <name>checkVomsProxy</name>
        <briefdescription>
<para>return whether we have a valid VOMS proxy available </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="par"><title>Guarantee</title><para>basic </para></simplesect>
<simplesect kind="par"><title>Failures</title><para>grid utility failures </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/SampleHandler/Root/GridTools.cxx" line="178"/>
      </memberdef>
      <memberdef kind="function" id="d0/d9e/namespaceSH_1a38ab5027d7b5de75a857682b0ea7f766" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void SH::ensureVomsProxy</definition>
        <argsstring>()</argsstring>
        <name>ensureVomsProxy</name>
        <briefdescription>
<para>ensure that we have a valid VOMS proxy available </para>        </briefdescription>
        <detaileddescription>
<para>First this checks whether we have a valid PROXY, and if not it sets up a new certificate.</para><para><simplesect kind="par"><title>Guarantee</title><para>basic </para></simplesect>
<simplesect kind="par"><title>Failures</title><para>grid utility failures<linebreak/>
 failure to set up new VOMS proxy </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/SampleHandler/Root/GridTools.cxx" line="185"/>
      </memberdef>
      <memberdef kind="function" id="d0/d9e/namespaceSH_1a3541573890dcbf9738d9e0cc28e9c8bb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; std::string &gt;</type>
        <definition>std::vector&lt; std::string &gt; SH::faxListFilesGlob</definition>
        <argsstring>(const std::string &amp;name, const std::string &amp;filter)</argsstring>
        <name>faxListFilesGlob</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>name</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>filter</declname>
        </param>
        <briefdescription>
<para>list the FAX URLs for all the files in the dataset or dataset container matching the given filter (as glob expression) </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="par"><title>Guarantee</title><para>strong </para></simplesect>
<simplesect kind="par"><title>Failures</title><para>grid utility failures </para></simplesect>
<simplesect kind="pre"><para>!name.empty() </para><simplesectsep/><para>name.find(&apos;*&apos;) == std::string::npos </para><simplesectsep/><para>!filter.empty() </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/SampleHandler/Root/GridTools.cxx" line="193"/>
      </memberdef>
      <memberdef kind="function" id="d0/d9e/namespaceSH_1ad561ddee8a20d1fb0cf2ce96ccf3232f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; std::string &gt;</type>
        <definition>std::vector&lt; std::string &gt; SH::faxListFilesRegex</definition>
        <argsstring>(const std::string &amp;name, const std::string &amp;filter)</argsstring>
        <name>faxListFilesRegex</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>name</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>filter</declname>
        </param>
        <briefdescription>
<para>list the FAX URLs for all the files in the dataset or dataset container matching the given filter (as regular expression) </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="par"><title>Guarantee</title><para>strong </para></simplesect>
<simplesect kind="par"><title>Failures</title><para>grid utility failures </para></simplesect>
<simplesect kind="pre"><para>!name.empty() </para><simplesectsep/><para>name.find(&apos;*&apos;) == std::string::npos </para><simplesectsep/><para>!filter.empty() </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/SampleHandler/Root/GridTools.cxx" line="201"/>
      </memberdef>
      <memberdef kind="function" id="d0/d9e/namespaceSH_1a371bc3580e0a7420385db611cb60d8fa" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; <ref refid="d3/def/structSH_1_1RucioListDidsEntry" kindref="compound">RucioListDidsEntry</ref> &gt;</type>
        <definition>std::vector&lt; RucioListDidsEntry &gt; SH::rucioListDids</definition>
        <argsstring>(const std::string &amp;dataset)</argsstring>
        <name>rucioListDids</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>dataset</declname>
        </param>
        <briefdescription>
<para>run rucio-list-dids for the given dataset </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="par"><title>Guarantee</title><para>strong </para></simplesect>
<simplesect kind="par"><title>Failures</title><para>grid utility failures </para></simplesect>
<simplesect kind="pre"><para>!dataset.empty() </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/SampleHandler/Root/GridTools.cxx" line="247"/>
      </memberdef>
      <memberdef kind="function" id="d0/d9e/namespaceSH_1a3655fe15ee26f7dd352cd76300f6651b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; <ref refid="d4/d39/structSH_1_1RucioListFileReplicasEntry" kindref="compound">RucioListFileReplicasEntry</ref> &gt;</type>
        <definition>std::vector&lt; RucioListFileReplicasEntry &gt; SH::rucioListFileReplicas</definition>
        <argsstring>(const std::string &amp;dataset)</argsstring>
        <name>rucioListFileReplicas</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>dataset</declname>
        </param>
        <briefdescription>
<para>run rucio-list-file-replicas for the given dataset </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="par"><title>Guarantee</title><para>strong </para></simplesect>
<simplesect kind="par"><title>Failures</title><para>grid utility failures </para></simplesect>
<simplesect kind="pre"><para>!dataset.empty() </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/SampleHandler/Root/GridTools.cxx" line="283"/>
      </memberdef>
      <memberdef kind="function" id="d0/d9e/namespaceSH_1a3d55767dfa402d097eb36cad6af3e244" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::map&lt; std::string, std::unique_ptr&lt; <ref refid="db/d3a/classSH_1_1MetaObject" kindref="compound">MetaObject</ref> &gt; &gt;</type>
        <definition>std::map&lt; std::string, std::unique_ptr&lt; MetaObject &gt; &gt; SH::rucioGetMetadata</definition>
        <argsstring>(const std::set&lt; std::string &gt; &amp;datasets)</argsstring>
        <name>rucioGetMetadata</name>
        <param>
          <type>const std::set&lt; std::string &gt; &amp;</type>
          <declname>datasets</declname>
        </param>
        <briefdescription>
<para>run rucio-get-metadata for the given list of datasets </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="par"><title>Guarantee</title><para>strong </para></simplesect>
<simplesect kind="par"><title>Failures</title><para>grid utility failures </para></simplesect>
<simplesect kind="pre"><para>!datasets.empty() </para><simplesectsep/><para>!dataset.empty() (for each dataset) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/SampleHandler/Root/GridTools.cxx" line="325"/>
      </memberdef>
      <memberdef kind="function" id="d0/d9e/namespaceSH_1a09f12a6815d65245d5c01bff15fec7cc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="d0/d98/structSH_1_1RucioDownloadResult" kindref="compound">RucioDownloadResult</ref></type>
        <definition>RucioDownloadResult SH::rucioDownload</definition>
        <argsstring>(const std::string &amp;location, const std::string &amp;dataset)</argsstring>
        <name>rucioDownload</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>location</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>dataset</declname>
        </param>
        <briefdescription>
<para>run rucio-download </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="par"><title>Guarantee</title><para>basic </para></simplesect>
<simplesect kind="par"><title>Failures</title><para>grid utility failures </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/SampleHandler/Root/GridTools.cxx" line="395"/>
      </memberdef>
      <memberdef kind="function" id="d0/d9e/namespaceSH_1a08a97d09eb6664882be300a3d86acf9f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; <ref refid="d0/d98/structSH_1_1RucioDownloadResult" kindref="compound">RucioDownloadResult</ref> &gt;</type>
        <definition>std::vector&lt; RucioDownloadResult &gt; SH::rucioDownloadList</definition>
        <argsstring>(const std::string &amp;location, const std::vector&lt; std::string &gt; &amp;datasets)</argsstring>
        <name>rucioDownloadList</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>location</declname>
        </param>
        <param>
          <type>const std::vector&lt; std::string &gt; &amp;</type>
          <declname>datasets</declname>
        </param>
        <briefdescription>
<para>run rucio-download with multiple datasets </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="par"><title>Guarantee</title><para>basic </para></simplesect>
<simplesect kind="par"><title>Failures</title><para>grid utility failures </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/SampleHandler/Root/GridTools.cxx" line="422"/>
      </memberdef>
      <memberdef kind="function" id="d0/d9e/namespaceSH_1af3176ebf60dddfd41722e70a93c9967a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string SH::dbg</definition>
        <argsstring>(const Meta &amp;, unsigned)</argsstring>
        <name>dbg</name>
        <param>
          <type>const <ref refid="d6/d6a/classSH_1_1Meta" kindref="compound">Meta</ref> &amp;</type>
        </param>
        <param>
          <type>unsigned</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/SampleHandler/Root/Meta.cxx" line="25" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/SampleHandler/Root/Meta.cxx" bodystart="24" bodyend="27"/>
      </memberdef>
      <memberdef kind="function" id="d0/d9e/namespaceSH_1af2f538a77e1915ec1ce58d77f5b81fed" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string SH::dbg</definition>
        <argsstring>(const TagList &amp;obj, unsigned)</argsstring>
        <name>dbg</name>
        <param>
          <type>const <ref refid="dd/d41/classSH_1_1TagList" kindref="compound">TagList</ref> &amp;</type>
          <declname>obj</declname>
        </param>
        <param>
          <type>unsigned</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/SampleHandler/Root/TagList.cxx" line="27" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/SampleHandler/Root/TagList.cxx" bodystart="26" bodyend="38"/>
      </memberdef>
      <memberdef kind="function" id="d0/d9e/namespaceSH_1a218a2853cca0943f8a4f76c31bfa8730" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void SH::scanDir</definition>
        <argsstring>(SampleHandler &amp;sh, DiskList &amp;list, const std::string &amp;pattern, const std::string &amp;samplePattern, const std::string &amp;samplePostfix)</argsstring>
        <name>scanDir</name>
        <param>
          <type><ref refid="d1/d56/classSH_1_1SampleHandler" kindref="compound">SampleHandler</ref> &amp;</type>
          <declname>sh</declname>
        </param>
        <param>
          <type><ref refid="d1/d5b/classSH_1_1DiskList" kindref="compound">DiskList</ref> &amp;</type>
          <declname>list</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>pattern</declname>
          <defval>&quot;*.root*&quot;</defval>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>samplePattern</declname>
          <defval>&quot;*&quot;</defval>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>samplePostfix</declname>
          <defval>&quot;&quot;</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>effects: scan the given directory and add all subdirectories as samples that contain root files. if prefix is provided, use that instead of dir when constructing the file names. guarantee: basic, only some samples might be added failures: low level errors IV failures: directory not found failures: duplicate samples rationale: the prefix option is for the Tier 3 prototype, where you scan the local directory, but then access the files through xrootd </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/SampleHandler/Root/ToolsDiscovery.cxx" line="45"/>
      </memberdef>
      <memberdef kind="function" id="d0/d9e/namespaceSH_1aa2d89cb584a6655ba42abc5c6e6db489" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void SH::scanDir</definition>
        <argsstring>(SampleHandler &amp;sh, const std::string &amp;dir)</argsstring>
        <name>scanDir</name>
        <param>
          <type><ref refid="d1/d56/classSH_1_1SampleHandler" kindref="compound">SampleHandler</ref> &amp;</type>
          <declname>sh</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>dir</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/SampleHandler/Root/ToolsDiscovery.cxx" line="59"/>
      </memberdef>
      <memberdef kind="function" id="d0/d9e/namespaceSH_1aa32cbf2836f729b6ac5f91c6dadfcf70" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void SH::scanDir</definition>
        <argsstring>(SampleHandler &amp;sh, const std::string &amp;dir, const std::string &amp;prefix)</argsstring>
        <name>scanDir</name>
        <param>
          <type><ref refid="d1/d56/classSH_1_1SampleHandler" kindref="compound">SampleHandler</ref> &amp;</type>
          <declname>sh</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>dir</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>prefix</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/SampleHandler/Root/ToolsDiscovery.cxx" line="71"/>
      </memberdef>
      <memberdef kind="function" id="d0/d9e/namespaceSH_1abbf46cdb18ddb60894c3dbf6f748aa02" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void SH::scanFiles</definition>
        <argsstring>(SampleHandler &amp;sh, DiskList &amp;list, const std::string &amp;pattern)</argsstring>
        <name>scanFiles</name>
        <param>
          <type><ref refid="d1/d56/classSH_1_1SampleHandler" kindref="compound">SampleHandler</ref> &amp;</type>
          <declname>sh</declname>
        </param>
        <param>
          <type><ref refid="d1/d5b/classSH_1_1DiskList" kindref="compound">DiskList</ref> &amp;</type>
          <declname>list</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>pattern</declname>
          <defval>&quot;*.root*&quot;</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>effects: scan the given directory tree and make a separate sample for each file (using the file name before any &quot;.&quot; as the sample name). guarantee: basic, only some samples might be added failures: out of memory III failures: i/o errors failures: duplicate samples </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/SampleHandler/Root/ToolsDiscovery.cxx" line="84"/>
      </memberdef>
      <memberdef kind="function" id="d0/d9e/namespaceSH_1a31190573b3ca12428ca591e080edfe73" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="dd/d5f/classSH_1_1Sample" kindref="compound">Sample</ref> *</type>
        <definition>Sample * SH::makeFromTChain</definition>
        <argsstring>(const std::string &amp;name, const TChain &amp;chain)</argsstring>
        <name>makeFromTChain</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>name</declname>
        </param>
        <param>
          <type>const TChain &amp;</type>
          <declname>chain</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>effects: create a sample with the given name from the given TChain object guarantee: strong failures: out of memory II </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/SampleHandler/Root/ToolsDiscovery.cxx" line="95"/>
      </memberdef>
      <memberdef kind="function" id="d0/d9e/namespaceSH_1abf33b8bdbc36bfc1b9da9a05a8144fa1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void SH::scanSingleDir</definition>
        <argsstring>(SampleHandler &amp;sh, const std::string &amp;name, DiskList &amp;list, const std::string &amp;pattern)</argsstring>
        <name>scanSingleDir</name>
        <param>
          <type><ref refid="d1/d56/classSH_1_1SampleHandler" kindref="compound">SampleHandler</ref> &amp;</type>
          <declname>sh</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="d1/d5b/classSH_1_1DiskList" kindref="compound">DiskList</ref> &amp;</type>
          <declname>list</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>pattern</declname>
          <defval>&quot;*.root*&quot;</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>effects: scan the given directory tree and turn it into a single sample of the given name guarantee: strong failures: out of memory III </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/SampleHandler/Root/ToolsDiscovery.cxx" line="110"/>
      </memberdef>
      <memberdef kind="function" id="d0/d9e/namespaceSH_1a0f9184bf8c7ea029e2470460df5c0018" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void SH::scanDQ2</definition>
        <argsstring>(SampleHandler &amp;sh, const std::string &amp;pattern)</argsstring>
        <name>scanDQ2</name>
        <param>
          <type><ref refid="d1/d56/classSH_1_1SampleHandler" kindref="compound">SampleHandler</ref> &amp;</type>
          <declname>sh</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>pattern</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>effects: make a list from DQ2 using the given pattern guarantee: basic, may add partially failures: out of memory III failures: dq2-ls errors </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/SampleHandler/Root/ToolsDiscovery.cxx" line="121"/>
      </memberdef>
      <memberdef kind="function" id="d0/d9e/namespaceSH_1ab952a2257070fb18d9463201b1c3b2ef" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void SH::scanRucio</definition>
        <argsstring>(SampleHandler &amp;sh, const std::string &amp;pattern, bool alwaysQuery=false)</argsstring>
        <name>scanRucio</name>
        <param>
          <type><ref refid="d1/d56/classSH_1_1SampleHandler" kindref="compound">SampleHandler</ref> &amp;</type>
          <declname>sh</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>pattern</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>alwaysQuery</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>make a list of grid datasets using the given pattern </para>        </briefdescription>
        <detaileddescription>
<para>This will first look for dataset containers, and if none are found, it will instead look for datasets. If those are also not found it will produce an error.</para><para>For patterns that don&apos;t contain a wild-card (i.e. that can only match one dataset/container) it instead adds the dataset directly without querying rucio. This is a performance optimization based on the assumption that you probably checked the dataset names beforehand, and that if you made a mistake it will pop up at a later stage anyways. If you want to query rucio even in those cases set alwaysQuery to true.</para><para><simplesect kind="par"><title>Guarantee</title><para>basic, may add some datasets </para></simplesect>
<simplesect kind="par"><title>Failures</title><para>no pattern match<linebreak/>
 rucio failures<linebreak/>
 out of memory III </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/SampleHandler/Root/ToolsDiscovery.cxx" line="144"/>
      </memberdef>
      <memberdef kind="function" id="d0/d9e/namespaceSH_1a03e83d8148faf96766c6fb3f6b05e000" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void SH::addGrid</definition>
        <argsstring>(SampleHandler &amp;sh, const std::string &amp;ds)</argsstring>
        <name>addGrid</name>
        <param>
          <type><ref refid="d1/d56/classSH_1_1SampleHandler" kindref="compound">SampleHandler</ref> &amp;</type>
          <declname>sh</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>ds</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>effects: add a grid dataset for dataset ds guarantee: strong failures: out of memory II requires: ds.find (&quot;*&quot;) == std::string::npos </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/SampleHandler/Root/ToolsDiscovery.cxx" line="172"/>
      </memberdef>
      <memberdef kind="function" id="d0/d9e/namespaceSH_1a3e94deb54c1ea1133d0128ee84a37f35" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void SH::makeGridDirect</definition>
        <argsstring>(SampleHandler &amp;sh, const std::string &amp;disk, const std::string &amp;from, const std::string &amp;to, bool allow_partial)</argsstring>
        <name>makeGridDirect</name>
        <param>
          <type><ref refid="d1/d56/classSH_1_1SampleHandler" kindref="compound">SampleHandler</ref> &amp;</type>
          <declname>sh</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>disk</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>from</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>to</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>allow_partial</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>effects: update all grid samples in the sample handler that are located on the given disk to be opened directly. for that it replaces the from part of the file with the to part. if allow_partial is set, it allows for partial datasets (meaning you may lose some files that are not there). guarantee: basic, may convert only some samples failures: out of memory III failures: dq2-ls errors failures: from not part of file name </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/SampleHandler/Root/ToolsDiscovery.cxx" line="192"/>
      </memberdef>
      <memberdef kind="function" id="d0/d9e/namespaceSH_1a86284338332ed63a54ef4bbfb17bb01f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void SH::scanForTrees</definition>
        <argsstring>(SampleHandler &amp;sh, const Sample &amp;sample, const std::string &amp;pattern)</argsstring>
        <name>scanForTrees</name>
        <param>
          <type><ref refid="d1/d56/classSH_1_1SampleHandler" kindref="compound">SampleHandler</ref> &amp;</type>
          <declname>sh</declname>
        </param>
        <param>
          <type>const <ref refid="dd/d5f/classSH_1_1Sample" kindref="compound">Sample</ref> &amp;</type>
          <declname>sample</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>pattern</declname>
          <defval>&quot;.*&quot;</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>effects: scan for trees in the given sample (or sample handler), and create a separate sample for each tree. if pattern is specified it is applied to the allowed tree names. guarantee: strong failures: out of memory III failures: i/o errors </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/SampleHandler/Root/ToolsDiscovery.cxx" line="268"/>
      </memberdef>
      <memberdef kind="function" id="d0/d9e/namespaceSH_1a62d6288798d7f10e1d7aef57b80ec199" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void SH::scanForTrees</definition>
        <argsstring>(SampleHandler &amp;sh, const std::string &amp;pattern)</argsstring>
        <name>scanForTrees</name>
        <param>
          <type><ref refid="d1/d56/classSH_1_1SampleHandler" kindref="compound">SampleHandler</ref> &amp;</type>
          <declname>sh</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>pattern</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/SampleHandler/Root/ToolsDiscovery.cxx" line="298"/>
      </memberdef>
      <memberdef kind="function" id="d0/d9e/namespaceSH_1a194afcafddde244896bde31125db5c41" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void SH::readFileList</definition>
        <argsstring>(SampleHandler &amp;sh, const std::string &amp;name, const std::string &amp;file)</argsstring>
        <name>readFileList</name>
        <param>
          <type><ref refid="d1/d56/classSH_1_1SampleHandler" kindref="compound">SampleHandler</ref> &amp;</type>
          <declname>sh</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>name</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>file</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>effects: read a file list from a text file guarantee: strong failures: out of memory III failures: i/o errors </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/SampleHandler/Root/ToolsDiscovery.cxx" line="313"/>
      </memberdef>
      <memberdef kind="function" id="d0/d9e/namespaceSH_1a7760d745da599e79133a3377470d52a7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void SH::printDuplicateEvents</definition>
        <argsstring>(const Sample &amp;sample)</argsstring>
        <name>printDuplicateEvents</name>
        <param>
          <type>const <ref refid="dd/d5f/classSH_1_1Sample" kindref="compound">Sample</ref> &amp;</type>
          <declname>sample</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>effects: check the given sample for duplicate events and then print them out guarantee: basic, may print partially failures: out of memory III failures: i/o errors </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/SampleHandler/Root/ToolsDuplicates.cxx" line="145"/>
      </memberdef>
      <memberdef kind="function" id="d0/d9e/namespaceSH_1a5c26febcf499c79d8b5f300d7761da8f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void SH::printDuplicateEventsSplit</definition>
        <argsstring>(const SampleHandler &amp;sh)</argsstring>
        <name>printDuplicateEventsSplit</name>
        <param>
          <type>const <ref refid="d1/d56/classSH_1_1SampleHandler" kindref="compound">SampleHandler</ref> &amp;</type>
          <declname>sh</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>effects: check each sample for duplicate events and then print them out guarantee: basic, may print partially failures: out of memory III failures: i/o errors </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/SampleHandler/Root/ToolsDuplicates.cxx" line="154"/>
      </memberdef>
      <memberdef kind="function" id="d0/d9e/namespaceSH_1adde4965ab348cce4eee6e084c627d46e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void SH::printDuplicateEventsJoint</definition>
        <argsstring>(const SampleHandler &amp;sh)</argsstring>
        <name>printDuplicateEventsJoint</name>
        <param>
          <type>const <ref refid="d1/d56/classSH_1_1SampleHandler" kindref="compound">SampleHandler</ref> &amp;</type>
          <declname>sh</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>effects: check for duplicate events between all the samples and then print them out guarantee: basic, may print partially failures: out of memory III failures: i/o errors </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/SampleHandler/Root/ToolsDuplicates.cxx" line="165"/>
      </memberdef>
      <memberdef kind="function" id="d0/d9e/namespaceSH_1a395d783ebdcb48eb26537f48a7a7dd23" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void SH::mergeSamples</definition>
        <argsstring>(SampleHandler &amp;sh, const std::string &amp;sampleName, const std::string &amp;pattern)</argsstring>
        <name>mergeSamples</name>
        <param>
          <type><ref refid="d1/d56/classSH_1_1SampleHandler" kindref="compound">SampleHandler</ref> &amp;</type>
          <declname>sh</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>sampleName</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>pattern</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>effects: remove all samples matching the name pattern, and join them into a single sample named sampleName guarantee: strong failures: out of memory II failures: i/o errors </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/SampleHandler/Root/ToolsJoin.cxx" line="29"/>
      </memberdef>
      <memberdef kind="function" id="d0/d9e/namespaceSH_1a3ad11148548172678f19f8aadcae60ef" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void SH::readSusyMeta</definition>
        <argsstring>(const SampleHandler &amp;sh, const std::string &amp;inputFile)</argsstring>
        <name>readSusyMeta</name>
        <param>
          <type>const <ref refid="d1/d56/classSH_1_1SampleHandler" kindref="compound">SampleHandler</ref> &amp;</type>
          <declname>sh</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>inputFile</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>effects: read the susy-meta-data file and add its information to the samples from the given sample handler guarantee: basic failures: i/o errors warning: there are no checks for duplicate and inconsistent sample definitions </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/SampleHandler/Root/ToolsMeta.cxx" line="34"/>
      </memberdef>
      <memberdef kind="function" id="d0/d9e/namespaceSH_1a3b8fb791234933ae9182533c71d6d0ab" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void SH::readSusyMetaDir</definition>
        <argsstring>(const SampleHandler &amp;sh, const std::string &amp;inputDir)</argsstring>
        <name>readSusyMetaDir</name>
        <param>
          <type>const <ref refid="d1/d56/classSH_1_1SampleHandler" kindref="compound">SampleHandler</ref> &amp;</type>
          <declname>sh</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>inputDir</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>effects: read an entire directory of susy-meta-data files and add their information to the samples from the given sample handle. for that it assumes that all files ending in &quot;.txt&quot; are susy-meta-data files. guarantee: basic failures: i/o errors warning: there are no checks for duplicate and inconsistent sample definitions </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/SampleHandler/Root/ToolsMeta.cxx" line="75"/>
      </memberdef>
      <memberdef kind="function" id="d0/d9e/namespaceSH_1a597d456d5d0884fa8e37f6ced82f55b4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::unique_ptr&lt; TFile &gt;</type>
        <definition>std::unique_ptr&lt; TFile &gt; SH::openFile</definition>
        <argsstring>(const std::string &amp;name, const MetaObject &amp;options)</argsstring>
        <name>openFile</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>name</declname>
        </param>
        <param>
          <type>const <ref refid="db/d3a/classSH_1_1MetaObject" kindref="compound">MetaObject</ref> &amp;</type>
          <declname>options</declname>
        </param>
        <briefdescription>
<para>open a file with the given options </para>        </briefdescription>
        <detaileddescription>
<para>for now this is to allow opening files with retries, but in the future there may be other options as well. <simplesect kind="par"><title>Guarantee</title><para>strong </para></simplesect>
<simplesect kind="par"><title>Failures</title><para>i/o errors<linebreak/>
 file not found </para></simplesect>
<simplesect kind="post"><para>result != nullptr </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/SampleHandler/Root/ToolsOther.cxx" line="39"/>
      </memberdef>
      <memberdef kind="function" id="d0/d9e/namespaceSH_1a22f1f197aecfb90ccdfc06f2af63f8c9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::unique_ptr&lt; <ref refid="d8/d31/classSH_1_1SampleLocal" kindref="compound">SampleLocal</ref> &gt;</type>
        <definition>std::unique_ptr&lt; SampleLocal &gt; SH::mergeFiles</definition>
        <argsstring>(const Sample &amp;sample, const std::string &amp;location, bool overwrite)</argsstring>
        <name>mergeFiles</name>
        <param>
          <type>const <ref refid="dd/d5f/classSH_1_1Sample" kindref="compound">Sample</ref> &amp;</type>
          <declname>sample</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>location</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>overwrite</declname>
        </param>
        <briefdescription>
<para>merge all the files in the sample into a single file in the given location </para>        </briefdescription>
        <detaileddescription>
<para>This is mostly meant to allow merging histogram files (particularly in EventLoop), but in some cases it can also be used to merge n-tuple fiels together.</para><para><simplesect kind="return"><para>a sample containing the merged file </para></simplesect>
<simplesect kind="par"><title>Guarantee</title><para>basic </para></simplesect>
<simplesect kind="par"><title>Failures</title><para>i/o errors<linebreak/>
 out of memory III </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/SampleHandler/Root/ToolsOther.cxx" line="73"/>
      </memberdef>
      <memberdef kind="function" id="d0/d9e/namespaceSH_1af5d78958b196fdb211a17528b49946b4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="d1/d56/classSH_1_1SampleHandler" kindref="compound">SampleHandler</ref></type>
        <definition>SampleHandler SH::mergeFiles</definition>
        <argsstring>(const SampleHandler &amp;sh, const std::string &amp;location, bool overwrite)</argsstring>
        <name>mergeFiles</name>
        <param>
          <type>const <ref refid="d1/d56/classSH_1_1SampleHandler" kindref="compound">SampleHandler</ref> &amp;</type>
          <declname>sh</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>location</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>overwrite</declname>
        </param>
        <briefdescription>
<para>merge all the files in the sample handles into a single file per sample in the given location </para>        </briefdescription>
        <detaileddescription>
<para>This is mostly meant to allow merging histogram files (particularly in EventLoop), but in some cases it can also be used to merge n-tuple files together.</para><para><simplesect kind="return"><para>a sample handler containing the merged files </para></simplesect>
<simplesect kind="par"><title>Guarantee</title><para>basic </para></simplesect>
<simplesect kind="par"><title>Failures</title><para>i/o errors<linebreak/>
 out of memory III </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/SampleHandler/Root/ToolsOther.cxx" line="90"/>
      </memberdef>
      <memberdef kind="function" id="d0/d9e/namespaceSH_1a2e2d63946f5ce402c6456c8973adc241" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void SH::scanNEvents</definition>
        <argsstring>(SampleHandler &amp;sh)</argsstring>
        <name>scanNEvents</name>
        <param>
          <type><ref refid="d1/d56/classSH_1_1SampleHandler" kindref="compound">SampleHandler</ref> &amp;</type>
          <declname>sh</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>effects: scan each sample in the sample handler and store the number of entries per file in the meta-data guarantee: basic, may only scan some failures: out of memory failures: read errors failures: invalid sample type </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/SampleHandler/Root/ToolsSplit.cxx" line="35"/>
      </memberdef>
      <memberdef kind="function" id="d0/d9e/namespaceSH_1a58d3a57d32ec34440dc4e21ebd92f1b6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void SH::scanNEvents</definition>
        <argsstring>(Sample &amp;sample)</argsstring>
        <name>scanNEvents</name>
        <param>
          <type><ref refid="dd/d5f/classSH_1_1Sample" kindref="compound">Sample</ref> &amp;</type>
          <declname>sample</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>effects: scan the given sample and store the number of entries per file in the meta-data guarantee: strong failures: out of memory failures: read errors failures: invalid sample type </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/SampleHandler/Root/ToolsSplit.cxx" line="44"/>
      </memberdef>
      <memberdef kind="function" id="d0/d9e/namespaceSH_1afc2481fc630dc76adafeb035e97c92fe" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="d1/d56/classSH_1_1SampleHandler" kindref="compound">SampleHandler</ref></type>
        <definition>SampleHandler SH::splitSample</definition>
        <argsstring>(Sample &amp;sample, const Long64_t nevt)</argsstring>
        <name>splitSample</name>
        <param>
          <type><ref refid="dd/d5f/classSH_1_1Sample" kindref="compound">Sample</ref> &amp;</type>
          <declname>sample</declname>
        </param>
        <param>
          <type>Long64_t</type>
          <declname>nevt</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>effects: split the given sample into a set of samples, with each sample containing either exactly one file or at most nevt events side effects: if scanNEvents hasn&apos;t been run on this sample, run it. guarantee: strong failures: out of memory failures: scanning errors </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/SampleHandler/Root/ToolsSplit.cxx" line="76"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>This module provides a lot of global definitions, forward declarations and includes that are used by all modules. As such it doesn&apos;t fall into the user vs. expert classification. This module is considered to be in the pre-alpha stage.</para><para>This module defines utility functions used for joining samples. The interface provided in this module is intended for the general user. The module is considered to be in the pre-alpha stage.</para><para>This module defines utility functions used for splitting samples. The interface provided in this module is intended for the general user. The module is considered to be in the pre-alpha stage. </para>    </detaileddescription>
    <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/EventLoopGrid/EventLoopGrid/GridDriver.h" line="7"/>
  </compounddef>
</doxygen>
