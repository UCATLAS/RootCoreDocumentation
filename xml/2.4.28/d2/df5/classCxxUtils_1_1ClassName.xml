<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.6.1">
  <compounddef id="d2/df5/classCxxUtils_1_1ClassName" kind="class" prot="public">
    <compoundname>CxxUtils::ClassName</compoundname>
    <includes refid="d3/d7a/CxxUtils_2CxxUtils_2ClassName_8h" local="no">ClassName.h</includes>
    <innerclass refid="dc/d63/classCxxUtils_1_1ClassName_1_1ExcBadClassName" prot="public">CxxUtils::ClassName::ExcBadClassName</innerclass>
    <innerclass refid="de/d9a/classCxxUtils_1_1ClassName_1_1ExcMissingVariable" prot="public">CxxUtils::ClassName::ExcMissingVariable</innerclass>
    <innerclass refid="dd/d02/classCxxUtils_1_1ClassName_1_1Rules" prot="public">CxxUtils::ClassName::Rules</innerclass>
      <sectiondef kind="public-type">
      <memberdef kind="typedef" id="d2/df5/classCxxUtils_1_1ClassName_1a8152d9ea3ca2a3217c43be8a4d645c14" prot="public" static="no">
        <type>std::map&lt; std::string, <ref refid="d2/df5/classCxxUtils_1_1ClassName" kindref="compound">ClassName</ref> &gt;</type>
        <definition>typedef std::map&lt;std::string, ClassName&gt; CxxUtils::ClassName::match_t</definition>
        <argsstring></argsstring>
        <name>match_t</name>
        <briefdescription>
<para>Map used to hold variable assignments from matching. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/ClassName.h" line="199" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/ClassName.h" bodystart="199" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="d2/df5/classCxxUtils_1_1ClassName_1a3bbd276f0778552f83817f8b206dd8f0" prot="private" static="no" mutable="no">
        <type>bool</type>
        <definition>bool CxxUtils::ClassName::m_const</definition>
        <argsstring></argsstring>
        <name>m_const</name>
        <briefdescription>
<para>Is this expression const? </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/ClassName.h" line="454" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/ClassName.h" bodystart="454" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="d2/df5/classCxxUtils_1_1ClassName_1a1491da670a327df3058c30a7b133446e" prot="private" static="no" mutable="no">
        <type>std::vector&lt; <ref refid="d2/df5/classCxxUtils_1_1ClassName" kindref="compound">ClassName</ref> &gt;</type>
        <definition>std::vector&lt;ClassName&gt; CxxUtils::ClassName::m_namespace</definition>
        <argsstring></argsstring>
        <name>m_namespace</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The containing namespace. This vector is always either 0 or 1 elements long; this is a way of getting something sort of like a pointer but with completely automatic management. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/ClassName.h" line="460" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/ClassName.h" bodystart="460" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="d2/df5/classCxxUtils_1_1ClassName_1a4bed176e39731ed94355bf3f0282f0df" prot="private" static="no" mutable="no">
        <type>std::string</type>
        <definition>std::string CxxUtils::ClassName::m_name</definition>
        <argsstring></argsstring>
        <name>m_name</name>
        <briefdescription>
<para>The primary name part of this expression. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/ClassName.h" line="463" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/ClassName.h" bodystart="463" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="d2/df5/classCxxUtils_1_1ClassName_1a60ba93a1e9de2c23b0aaebea8e04fd2a" prot="private" static="no" mutable="no">
        <type>std::vector&lt; <ref refid="d2/df5/classCxxUtils_1_1ClassName" kindref="compound">ClassName</ref> &gt;</type>
        <definition>std::vector&lt;ClassName&gt; CxxUtils::ClassName::m_targs</definition>
        <argsstring></argsstring>
        <name>m_targs</name>
        <briefdescription>
<para>The template arguments for this name. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/ClassName.h" line="466" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/ClassName.h" bodystart="466" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="d2/df5/classCxxUtils_1_1ClassName_1a6705742f2fbe4b648be53846792b3483" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>CxxUtils::ClassName::ClassName</definition>
        <argsstring>()</argsstring>
        <name>ClassName</name>
        <briefdescription>
<para>Default constructor. </para>        </briefdescription>
        <detaileddescription>
<para>Needed for STL compatibility. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/ClassName.h" line="207" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/ClassName.cxx" bodystart="135" bodyend="138"/>
      </memberdef>
      <memberdef kind="function" id="d2/df5/classCxxUtils_1_1ClassName_1aa7f558d1fc51bcd9c3268e968099d1b8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>CxxUtils::ClassName::ClassName</definition>
        <argsstring>(const char *name)</argsstring>
        <name>ClassName</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <briefdescription>
<para>Parse a class name into component parts. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>The name to parse.</para></parameterdescription>
</parameteritem>
</parameterlist>
Raises a <computeroutput>BadClassName</computeroutput> exception if the name isn&apos;t completely parsed.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>The name to parse.</para></parameterdescription>
</parameteritem>
</parameterlist>
Raises a <computeroutput><ref refid="dc/d63/classCxxUtils_1_1ClassName_1_1ExcBadClassName" kindref="compound">ExcBadClassName</ref></computeroutput> exception if the name isn&apos;t completely parsed. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/ClassName.h" line="216" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/ClassName.cxx" bodystart="147" bodyend="156"/>
      </memberdef>
      <memberdef kind="function" id="d2/df5/classCxxUtils_1_1ClassName_1a8d8da4fd7f41e3d96b3368dd6065c935" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>CxxUtils::ClassName::ClassName</definition>
        <argsstring>(const std::string &amp;name)</argsstring>
        <name>ClassName</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>name</declname>
        </param>
        <briefdescription>
<para>Parse a class name into component parts. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>The name to parse.</para></parameterdescription>
</parameteritem>
</parameterlist>
Raises a <computeroutput>BadClassName</computeroutput> exception if the name isn&apos;t completely parsed.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>The name to parse.</para></parameterdescription>
</parameteritem>
</parameterlist>
Raises a <computeroutput><ref refid="dc/d63/classCxxUtils_1_1ClassName_1_1ExcBadClassName" kindref="compound">ExcBadClassName</ref></computeroutput> exception if the name isn&apos;t completely parsed. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/ClassName.h" line="225" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/ClassName.cxx" bodystart="165" bodyend="173"/>
      </memberdef>
      <memberdef kind="function" id="d2/df5/classCxxUtils_1_1ClassName_1a9287cfd35c7f801425fb895682ba62ad" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>CxxUtils::ClassName::ClassName</definition>
        <argsstring>(const std::string &amp;name, std::string::size_type &amp;pos)</argsstring>
        <name>ClassName</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::string::size_type &amp;</type>
          <declname>pos</declname>
        </param>
        <briefdescription>
<para>Parse a class name into component parts. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>String containing the name to parse. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pos</parametername>
</parameternamelist>
<parameterdescription>
<para>Position in the string at which parsing should start.</para></parameterdescription>
</parameteritem>
</parameterlist>
<computeroutput>pos</computeroutput> is updated to point to past the point where parsing stopped. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/ClassName.h" line="235" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/ClassName.cxx" bodystart="183" bodyend="187"/>
      </memberdef>
      <memberdef kind="function" id="d2/df5/classCxxUtils_1_1ClassName_1a8e16fe0dcb6be7a8746a47a7b38ca953" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void CxxUtils::ClassName::swap</definition>
        <argsstring>(ClassName &amp;other)</argsstring>
        <name>swap</name>
        <param>
          <type><ref refid="d2/df5/classCxxUtils_1_1ClassName" kindref="compound">ClassName</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
<para>Swap this expression with another one. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>other</parametername>
</parameternamelist>
<parameterdescription>
<para>The other expression with which to swap. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/ClassName.h" line="242" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/ClassName.cxx" bodystart="194" bodyend="200"/>
      </memberdef>
      <memberdef kind="function" id="d2/df5/classCxxUtils_1_1ClassName_1afb46cf0dd4a6b1bda705391466713eef" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void CxxUtils::ClassName::setConst</definition>
        <argsstring>()</argsstring>
        <name>setConst</name>
        <briefdescription>
<para>Set the const flag for this expression. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/ClassName.h" line="248" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/ClassName.cxx" bodystart="206" bodyend="209"/>
      </memberdef>
      <memberdef kind="function" id="d2/df5/classCxxUtils_1_1ClassName_1a1f49f8ecf0f6cb155d25337c9a8040d2" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string CxxUtils::ClassName::name</definition>
        <argsstring>() const </argsstring>
        <name>name</name>
        <briefdescription>
<para>Return the root name of the expression. </para>        </briefdescription>
        <detaileddescription>
<para>In `AB&lt;C&gt;`, the root name is `B`. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/ClassName.h" line="256" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/ClassName.cxx" bodystart="217" bodyend="220"/>
      </memberdef>
      <memberdef kind="function" id="d2/df5/classCxxUtils_1_1ClassName_1afac5cffe53dd2e346f2cf1148dac5713" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string CxxUtils::ClassName::qualifiedName</definition>
        <argsstring>() const </argsstring>
        <name>qualifiedName</name>
        <briefdescription>
<para>Return the namespace-qualified name of the expression. </para>        </briefdescription>
        <detaileddescription>
<para>Return the root name of the expression.</para><para>In `AB&lt;C&gt;`, this is `A<ref refid="d9/db3/structB" kindref="compound">B</ref>`.</para><para>In `AB&lt;C&gt;`, the root name is `B`. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/ClassName.h" line="264" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/ClassName.cxx" bodystart="228" bodyend="234"/>
      </memberdef>
      <memberdef kind="function" id="d2/df5/classCxxUtils_1_1ClassName_1abfa27284ab7fb9660ebffa0fe8159129" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string CxxUtils::ClassName::fullName</definition>
        <argsstring>() const </argsstring>
        <name>fullName</name>
        <briefdescription>
<para>Return the full name of the expression. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/ClassName.h" line="270" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/ClassName.cxx" bodystart="240" bodyend="257"/>
      </memberdef>
      <memberdef kind="function" id="d2/df5/classCxxUtils_1_1ClassName_1ab72ab23cf89c5fa217366b4c0e55896c" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool CxxUtils::ClassName::operator==</definition>
        <argsstring>(const ClassName &amp;other) const </argsstring>
        <name>operator==</name>
        <param>
          <type>const <ref refid="d2/df5/classCxxUtils_1_1ClassName" kindref="compound">ClassName</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
<para>Test two expressions for equality. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/ClassName.h" line="276" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/ClassName.cxx" bodystart="263" bodyend="286"/>
      </memberdef>
      <memberdef kind="function" id="d2/df5/classCxxUtils_1_1ClassName_1a830d0a5ab2061a7b93845e4b07f72365" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool CxxUtils::ClassName::operator!=</definition>
        <argsstring>(const ClassName &amp;other) const </argsstring>
        <name>operator!=</name>
        <param>
          <type>const <ref refid="d2/df5/classCxxUtils_1_1ClassName" kindref="compound">ClassName</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
<para>Test two expressions for inequality. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/ClassName.h" line="282" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/ClassName.cxx" bodystart="292" bodyend="295"/>
      </memberdef>
      <memberdef kind="function" id="d2/df5/classCxxUtils_1_1ClassName_1a8c977888cec29d2538ee51fde6934414" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool CxxUtils::ClassName::match</definition>
        <argsstring>(const ClassName &amp;pattern, match_t &amp;matches) const </argsstring>
        <name>match</name>
        <param>
          <type>const <ref refid="d2/df5/classCxxUtils_1_1ClassName" kindref="compound">ClassName</ref> &amp;</type>
          <declname>pattern</declname>
        </param>
        <param>
          <type><ref refid="d2/df5/classCxxUtils_1_1ClassName_1a8152d9ea3ca2a3217c43be8a4d645c14" kindref="member">match_t</ref> &amp;</type>
          <declname>matches</declname>
        </param>
        <briefdescription>
<para>Match this expression against a pattern. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pattern</parametername>
</parameternamelist>
<parameterdescription>
<para>The pattern to match. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">matches</parametername>
</parameternamelist>
<parameterdescription>
<para>Dictionary of pattern substitutions.</para></parameterdescription>
</parameteritem>
</parameterlist>
Return true if <computeroutput>pattern</computeroutput> matches the current expression. <computeroutput>pattern</computeroutput> may contain dummy variables of the form `$T`. On a successful return, the map <computeroutput>matches</computeroutput> contains the variable assignments needed for the match. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/ClassName.h" line="295" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/ClassName.cxx" bodystart="308" bodyend="312"/>
      </memberdef>
      <memberdef kind="function" id="d2/df5/classCxxUtils_1_1ClassName_1af128db26769f589d91221f3c6df44b4f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void CxxUtils::ClassName::subst</definition>
        <argsstring>(const match_t &amp;matches)</argsstring>
        <name>subst</name>
        <param>
          <type>const <ref refid="d2/df5/classCxxUtils_1_1ClassName_1a8152d9ea3ca2a3217c43be8a4d645c14" kindref="member">match_t</ref> &amp;</type>
          <declname>matches</declname>
        </param>
        <briefdescription>
<para>Substitute variables into this expression. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>The</parametername>
</parameternamelist>
<parameterdescription>
<para>dictionary of variables to substitute.</para></parameterdescription>
</parameteritem>
</parameterlist>
If this expression contains variables like `$T`, they are replaced with the corresponding values from <computeroutput>matches</computeroutput>. If a variable is present in the expression but is not in <computeroutput>matches</computeroutput>, <computeroutput><ref refid="de/d9a/classCxxUtils_1_1ClassName_1_1ExcMissingVariable" kindref="compound">ExcMissingVariable</ref></computeroutput> is thrown.</para><para>The substitutions are made in-place. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/ClassName.h" line="309" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/ClassName.cxx" bodystart="326" bodyend="345"/>
      </memberdef>
      <memberdef kind="function" id="d2/df5/classCxxUtils_1_1ClassName_1ade65e075ffad0e920593040136218b58" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="d2/df5/classCxxUtils_1_1ClassName" kindref="compound">ClassName</ref></type>
        <definition>ClassName CxxUtils::ClassName::substCopy</definition>
        <argsstring>(const match_t &amp;matches) const </argsstring>
        <name>substCopy</name>
        <param>
          <type>const <ref refid="d2/df5/classCxxUtils_1_1ClassName_1a8152d9ea3ca2a3217c43be8a4d645c14" kindref="member">match_t</ref> &amp;</type>
          <declname>matches</declname>
        </param>
        <briefdescription>
<para>Return a copy of this expression with variables substituted. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>The</parametername>
</parameternamelist>
<parameterdescription>
<para>dictionary of variables to substitute.</para></parameterdescription>
</parameteritem>
</parameterlist>
If this expression contains variables like `$T`, they are replaced with the corresponding values from <computeroutput>matches</computeroutput>. If a variable is present in the expression but is not in <computeroutput>matches</computeroutput>, <computeroutput><ref refid="de/d9a/classCxxUtils_1_1ClassName_1_1ExcMissingVariable" kindref="compound">ExcMissingVariable</ref></computeroutput> is thrown.</para><para>The substitutions are made in a copy of the expression, which is returned. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/ClassName.h" line="323" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/ClassName.cxx" bodystart="359" bodyend="364"/>
      </memberdef>
      <memberdef kind="function" id="d2/df5/classCxxUtils_1_1ClassName_1ad928b4f879a35defc22f2beca281e970" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void CxxUtils::ClassName::applyRules</definition>
        <argsstring>(const Rules &amp;rules)</argsstring>
        <name>applyRules</name>
        <param>
          <type>const <ref refid="dd/d02/classCxxUtils_1_1ClassName_1_1Rules" kindref="compound">Rules</ref> &amp;</type>
          <declname>rules</declname>
        </param>
        <briefdescription>
<para>Apply a set of transformation rules to this object. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>rules</parametername>
</parameternamelist>
<parameterdescription>
<para>The set of rules to apply.</para></parameterdescription>
</parameteritem>
</parameterlist>
Recursively walk this expression, trying to apply the transformation rules in <computeroutput>rules</computeroutput>. If any matches are found, this expression is modified in-place and the walk is repeated. This function terminates when no further matches are found.</para><para>Warning: An infinite loop is possible if the replacement for a pattern can always be matched by another pattern. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/ClassName.h" line="338" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/ClassName.cxx" bodystart="379" bodyend="383"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-static-func">
      <memberdef kind="function" id="d2/df5/classCxxUtils_1_1ClassName_1af5a4c19a613ef99e0b3f18a4fd44f9b8" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string CxxUtils::ClassName::applyRules</definition>
        <argsstring>(const std::string &amp;name, const Rules &amp;rules)</argsstring>
        <name>applyRules</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>name</declname>
        </param>
        <param>
          <type>const <ref refid="dd/d02/classCxxUtils_1_1ClassName_1_1Rules" kindref="compound">Rules</ref> &amp;</type>
          <declname>rules</declname>
        </param>
        <briefdescription>
<para>Apply a set of transformation rules a class name. param The name of the class to transform. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>rules</parametername>
</parameternamelist>
<parameterdescription>
<para>The set of rules to apply.</para></parameterdescription>
</parameteritem>
</parameterlist>
This is just shorthand for</para><para><programlisting><codeline><highlight class="normal"><sp/><sp/><ref refid="d2/df5/classCxxUtils_1_1ClassName_1a6705742f2fbe4b648be53846792b3483" kindref="member" tooltip="Default constructor.">ClassName</ref><sp/>cn<sp/>(name);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cn.applyRules<sp/>(rules);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>cn.fullName();</highlight></codeline>
</programlisting> </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/ClassName.h" line="355" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/ClassName.cxx" bodystart="399" bodyend="405"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-func">
      <memberdef kind="function" id="d2/df5/classCxxUtils_1_1ClassName_1a21fbdef21009682ae3b9643f43f66fd0" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void CxxUtils::ClassName::parse</definition>
        <argsstring>(const std::string &amp;name, std::string::size_type &amp;pos)</argsstring>
        <name>parse</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::string::size_type &amp;</type>
          <declname>pos</declname>
        </param>
        <briefdescription>
<para>Parse a string into a <computeroutput><ref refid="d2/df5/classCxxUtils_1_1ClassName" kindref="compound">ClassName</ref></computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>The string containing the name. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pos</parametername>
</parameternamelist>
<parameterdescription>
<para>Position in the string to start parsing.</para></parameterdescription>
</parameteritem>
</parameterlist>
On return, <computeroutput>pos</computeroutput> will be updated to point just past the last character consumed. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/ClassName.h" line="367" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/ClassName.cxx" bodystart="416" bodyend="442"/>
      </memberdef>
      <memberdef kind="function" id="d2/df5/classCxxUtils_1_1ClassName_1af62e826b7c628e821c306097890d3ccb" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string CxxUtils::ClassName::parsePrimary</definition>
        <argsstring>(const std::string &amp;name, std::string::size_type &amp;pos)</argsstring>
        <name>parsePrimary</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::string::size_type &amp;</type>
          <declname>pos</declname>
        </param>
        <briefdescription>
<para>Parse a primary part of the class name. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>The string containing the name. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pos</parametername>
</parameternamelist>
<parameterdescription>
<para>Position in the string to start parsing.</para></parameterdescription>
</parameteritem>
</parameterlist>
The primary part of the class name is a string without namespace and template delimiters.</para><para>On return, <computeroutput>pos</computeroutput> will be updated to point just past the last character consumed. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/ClassName.h" line="382" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/ClassName.cxx" bodystart="457" bodyend="475"/>
      </memberdef>
      <memberdef kind="function" id="d2/df5/classCxxUtils_1_1ClassName_1afea40aee0a0d7f4bf9e990d658cd5750" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void CxxUtils::ClassName::parseNamespace</definition>
        <argsstring>(const std::string &amp;name, std::string::size_type &amp;pos)</argsstring>
        <name>parseNamespace</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::string::size_type &amp;</type>
          <declname>pos</declname>
        </param>
        <briefdescription>
<para>Parse a namespace qualification. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>The string containing the name. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pos</parametername>
</parameternamelist>
<parameterdescription>
<para>Position in the string to start parsing.</para></parameterdescription>
</parameteritem>
</parameterlist>
When this is called, the namespace part has already been parsed, and the next two characters in <computeroutput>name</computeroutput> are `::`. This reads in the remainder of the string as a <computeroutput><ref refid="d2/df5/classCxxUtils_1_1ClassName" kindref="compound">ClassName</ref></computeroutput>, and then moves it inside the namespace given by the current object.</para><para>On return, <computeroutput>pos</computeroutput> will be updated to point just past the last character consumed. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/ClassName.h" line="398" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/ClassName.cxx" bodystart="491" bodyend="509"/>
      </memberdef>
      <memberdef kind="function" id="d2/df5/classCxxUtils_1_1ClassName_1a353e249188066fb9448d14c0eef7f7b5" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void CxxUtils::ClassName::parseTemplateArgs</definition>
        <argsstring>(const std::string &amp;name, std::string::size_type &amp;pos)</argsstring>
        <name>parseTemplateArgs</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::string::size_type &amp;</type>
          <declname>pos</declname>
        </param>
        <briefdescription>
<para>Parse the template part of a name. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>The string containing the name. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pos</parametername>
</parameternamelist>
<parameterdescription>
<para>Position in the string to start parsing.</para></parameterdescription>
</parameteritem>
</parameterlist>
When this is called, the qualified name part of the name has already been parsed, and the next character in <computeroutput>name</computeroutput> is `::`. This reads in template arguments from <computeroutput>name</computeroutput>.</para><para>On return, <computeroutput>pos</computeroutput> will be updated to point just past the last character consumed. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/ClassName.h" line="413" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/ClassName.cxx" bodystart="524" bodyend="547"/>
      </memberdef>
      <memberdef kind="function" id="d2/df5/classCxxUtils_1_1ClassName_1abd392d554b891e62bffe6e822915d71c" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void CxxUtils::ClassName::skipSpaces</definition>
        <argsstring>(const std::string &amp;name, std::string::size_type &amp;pos)</argsstring>
        <name>skipSpaces</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::string::size_type &amp;</type>
          <declname>pos</declname>
        </param>
        <briefdescription>
<para>Skip past spaces in a string. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>The string containing the name. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pos</parametername>
</parameternamelist>
<parameterdescription>
<para>Position in the string to start skipping.</para></parameterdescription>
</parameteritem>
</parameterlist>
On return, <computeroutput>pos</computeroutput> will be updated to point just past the last character consumed. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/ClassName.h" line="424" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/ClassName.cxx" bodystart="558" bodyend="563"/>
      </memberdef>
      <memberdef kind="function" id="d2/df5/classCxxUtils_1_1ClassName_1a11f5f4674bbb7ca6acc17bcf6c9d341c" prot="private" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool CxxUtils::ClassName::match1</definition>
        <argsstring>(const ClassName &amp;pattern, match_t &amp;matches) const </argsstring>
        <name>match1</name>
        <param>
          <type>const <ref refid="d2/df5/classCxxUtils_1_1ClassName" kindref="compound">ClassName</ref> &amp;</type>
          <declname>pattern</declname>
        </param>
        <param>
          <type><ref refid="d2/df5/classCxxUtils_1_1ClassName_1a8152d9ea3ca2a3217c43be8a4d645c14" kindref="member">match_t</ref> &amp;</type>
          <declname>matches</declname>
        </param>
        <briefdescription>
<para>Match this expression against a pattern. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pattern</parametername>
</parameternamelist>
<parameterdescription>
<para>The pattern to match. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">matches</parametername>
</parameternamelist>
<parameterdescription>
<para>Dictionary of pattern substitutions.</para></parameterdescription>
</parameteritem>
</parameterlist>
Return true if <computeroutput>pattern</computeroutput> matches the current expression. <computeroutput>pattern</computeroutput> may contain dummy variables of the form `$T`. On a successful return, the map <computeroutput>matches</computeroutput> contains the variable assignments needed for the match. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/ClassName.h" line="437" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/ClassName.cxx" bodystart="576" bodyend="623"/>
      </memberdef>
      <memberdef kind="function" id="d2/df5/classCxxUtils_1_1ClassName_1a5edb982781cba1a91eea069b0e104bff" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool CxxUtils::ClassName::applyRules1</definition>
        <argsstring>(const Rules &amp;rules)</argsstring>
        <name>applyRules1</name>
        <param>
          <type>const <ref refid="dd/d02/classCxxUtils_1_1ClassName_1_1Rules" kindref="compound">Rules</ref> &amp;</type>
          <declname>rules</declname>
        </param>
        <briefdescription>
<para>Apply a set of transformation rules to this object. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>rules</parametername>
</parameternamelist>
<parameterdescription>
<para>The set of rules to apply.</para></parameterdescription>
</parameteritem>
</parameterlist>
Recursively walk this expression, trying to apply the transformation rules in <computeroutput>rules</computeroutput>. If any matches are found, this expression is modified in-place.</para><para>Returns true if any matches were found. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/ClassName.h" line="450" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/ClassName.cxx" bodystart="636" bodyend="647"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Recursively separate out template arguments in a C++ class name. </para>    </briefdescription>
    <detaileddescription>
<para>This class allows making some simple transformations of C++ class names. For example, given these rules:</para><para><programlisting><codeline><highlight class="normal"><sp/>ClassName::Rules<sp/>rules;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>rules.add<sp/>(</highlight><highlight class="stringliteral">&quot;std::vector&lt;$T,<sp/>std::allocator&lt;$T&gt;<sp/>&gt;&quot;</highlight><highlight class="normal">,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;std::vector&lt;$T&gt;&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>rules.add<sp/>(</highlight><highlight class="stringliteral">&quot;std::map&lt;$K,$V,<sp/>std::less&lt;$K&gt;,<sp/>std::allocator&lt;std::pair&lt;const<sp/>$K,$V&gt;<sp/>&gt;<sp/>&gt;&quot;</highlight><highlight class="normal">,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;std::map&lt;$K,$V&gt;&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>rules.add<sp/>(</highlight><highlight class="stringliteral">&quot;DataVector&lt;$T,<sp/>$B&gt;&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;DataVector&lt;$T&gt;&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>rules.add<sp/>(</highlight><highlight class="stringliteral">&quot;std::__1&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;std&quot;</highlight><highlight class="normal">);</highlight></codeline>
</programlisting></para><para>then `rules.apply` can make transformations like this:</para><para><programlisting><codeline><highlight class="normal"><sp/>std::__1::vector&lt;std::__1::vector&lt;int,<sp/>std::__1::allocator&lt;int&gt;<sp/>&gt;,<sp/>std::__1::allocator&lt;std::__1::vector&lt;int,<sp/>std::__1::allocator&lt;int&gt;<sp/>&gt;<sp/>&gt;<sp/>&gt;<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>-&gt;<sp/>std::vector&lt;std::vector&lt;int&gt;<sp/>&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/>std::map&lt;int,<sp/>float,<sp/>std::less&lt;int&gt;,<sp/>std::allocator&lt;std::pair&lt;const<sp/>int,<sp/>float&gt;<sp/>&gt;<sp/>&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>-&gt;<sp/>std::map&lt;int,<sp/>float&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><ref refid="d0/d4d/classDataVector" kindref="compound" tooltip="Derived DataVector&amp;lt;T&amp;gt;.">DataVector&lt;Foo, DataModel_detail::NoBase&gt;</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>-&gt;<sp/><ref refid="d0/d4d/classDataVector" kindref="compound" tooltip="Derived DataVector&amp;lt;T&amp;gt;.">DataVector&lt;Foo&gt;</ref></highlight></codeline>
</programlisting></para><para>In slightly more <ref refid="dd/d39/namespacedetail" kindref="compound">detail</ref>: this class analyzes C++ class names. <ref refid="d4/dc4/structA" kindref="compound">A</ref> name like</para><para><programlisting><codeline><highlight class="normal"><sp/><sp/><sp/>A::B&lt;int,<sp/>double&gt;<sp/></highlight></codeline>
</programlisting></para><para>is broken down like this:</para><para><itemizedlist>
<listitem><para>Name: `B`.</para></listitem><listitem><para>Namespace: `A`.</para></listitem><listitem><para>Template arguments: `int` and `double`.</para></listitem></itemizedlist>
</para><para>This is done recursively; both the namespace and template argument pieces can be further broken down like this. <ref refid="d4/dc4/structA" kindref="compound">A</ref> name can also be marked as `const&apos;, but no other parsing of C-like declarators is done.</para><para>Parsed names can be matched against simple patterns like this:</para><para><programlisting><codeline><highlight class="normal"><sp/><sp/>A::B&lt;$T&gt;</highlight></codeline>
</programlisting></para><para>and the variable `T` gets set to the corresponding piece of the type being matched. For example, given the above pattern,</para><para><itemizedlist>
<listitem><para>`AC&lt;int&gt;` matches with `T` set to `int`.</para></listitem><listitem><para>`A<ref refid="db/db2/structC" kindref="compound">C</ref>&lt;const Foo&lt;Bar&gt; &gt;` matches with `T` set to `const Foo&lt;Bar&gt;`.</para></listitem></itemizedlist>
</para><para>If the pattern were `A<ref refid="d9/db3/structB" kindref="compound">B</ref>&lt;const $t&gt;=&quot;&quot;&gt;`, then `AB&lt;const int&gt;` would match with `T` set to `int`, but `AB&lt;int&gt;` would not match.</para><para>However, the root name of a pattern may not be a variable; for example, you can&apos;t use `A$T&lt;int&gt;` as a pattern.</para><para>You can also substitute variables back into a pattern; for example,</para><para><itemizedlist>
<listitem><para>`T=int` into `A<ref refid="d9/db3/structB" kindref="compound">B</ref>&lt; $t&gt;=&quot;&quot;&gt;` gives `AB&lt;int&gt;`.</para></listitem><listitem><para>`T=const int` into `A<ref refid="d9/db3/structB" kindref="compound">B</ref>&lt; $t&gt;=&quot;&quot;&gt;` gives `AB&lt;const int&gt;`.</para></listitem><listitem><para>`T=const int` into `AB&lt;const int&gt;` gives `AB&lt;const int&gt;`. </para></listitem></itemizedlist>
</para>    </detaileddescription>
    <collaborationgraph>
      <node id="3391">
        <label>string</label>
      </node>
      <node id="3390">
        <label>CxxUtils::ClassName</label>
        <link refid="d2/df5/classCxxUtils_1_1ClassName"/>
        <childnode refid="3391" relation="usage">
          <edgelabel>m_name</edgelabel>
        </childnode>
      </node>
    </collaborationgraph>
    <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/ClassName.h" line="98" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/ClassName.h" bodystart="97" bodyend="467"/>
    <listofallmembers>
      <member refid="d2/df5/classCxxUtils_1_1ClassName_1ad928b4f879a35defc22f2beca281e970" prot="public" virt="non-virtual"><scope>CxxUtils::ClassName</scope><name>applyRules</name></member>
      <member refid="d2/df5/classCxxUtils_1_1ClassName_1af5a4c19a613ef99e0b3f18a4fd44f9b8" prot="public" virt="non-virtual"><scope>CxxUtils::ClassName</scope><name>applyRules</name></member>
      <member refid="d2/df5/classCxxUtils_1_1ClassName_1a5edb982781cba1a91eea069b0e104bff" prot="private" virt="non-virtual"><scope>CxxUtils::ClassName</scope><name>applyRules1</name></member>
      <member refid="d2/df5/classCxxUtils_1_1ClassName_1a6705742f2fbe4b648be53846792b3483" prot="public" virt="non-virtual"><scope>CxxUtils::ClassName</scope><name>ClassName</name></member>
      <member refid="d2/df5/classCxxUtils_1_1ClassName_1aa7f558d1fc51bcd9c3268e968099d1b8" prot="public" virt="non-virtual"><scope>CxxUtils::ClassName</scope><name>ClassName</name></member>
      <member refid="d2/df5/classCxxUtils_1_1ClassName_1a8d8da4fd7f41e3d96b3368dd6065c935" prot="public" virt="non-virtual"><scope>CxxUtils::ClassName</scope><name>ClassName</name></member>
      <member refid="d2/df5/classCxxUtils_1_1ClassName_1a9287cfd35c7f801425fb895682ba62ad" prot="public" virt="non-virtual"><scope>CxxUtils::ClassName</scope><name>ClassName</name></member>
      <member refid="d2/df5/classCxxUtils_1_1ClassName_1abfa27284ab7fb9660ebffa0fe8159129" prot="public" virt="non-virtual"><scope>CxxUtils::ClassName</scope><name>fullName</name></member>
      <member refid="d2/df5/classCxxUtils_1_1ClassName_1a3bbd276f0778552f83817f8b206dd8f0" prot="private" virt="non-virtual"><scope>CxxUtils::ClassName</scope><name>m_const</name></member>
      <member refid="d2/df5/classCxxUtils_1_1ClassName_1a4bed176e39731ed94355bf3f0282f0df" prot="private" virt="non-virtual"><scope>CxxUtils::ClassName</scope><name>m_name</name></member>
      <member refid="d2/df5/classCxxUtils_1_1ClassName_1a1491da670a327df3058c30a7b133446e" prot="private" virt="non-virtual"><scope>CxxUtils::ClassName</scope><name>m_namespace</name></member>
      <member refid="d2/df5/classCxxUtils_1_1ClassName_1a60ba93a1e9de2c23b0aaebea8e04fd2a" prot="private" virt="non-virtual"><scope>CxxUtils::ClassName</scope><name>m_targs</name></member>
      <member refid="d2/df5/classCxxUtils_1_1ClassName_1a8c977888cec29d2538ee51fde6934414" prot="public" virt="non-virtual"><scope>CxxUtils::ClassName</scope><name>match</name></member>
      <member refid="d2/df5/classCxxUtils_1_1ClassName_1a11f5f4674bbb7ca6acc17bcf6c9d341c" prot="private" virt="non-virtual"><scope>CxxUtils::ClassName</scope><name>match1</name></member>
      <member refid="d2/df5/classCxxUtils_1_1ClassName_1a8152d9ea3ca2a3217c43be8a4d645c14" prot="public" virt="non-virtual"><scope>CxxUtils::ClassName</scope><name>match_t</name></member>
      <member refid="d2/df5/classCxxUtils_1_1ClassName_1a1f49f8ecf0f6cb155d25337c9a8040d2" prot="public" virt="non-virtual"><scope>CxxUtils::ClassName</scope><name>name</name></member>
      <member refid="d2/df5/classCxxUtils_1_1ClassName_1a830d0a5ab2061a7b93845e4b07f72365" prot="public" virt="non-virtual"><scope>CxxUtils::ClassName</scope><name>operator!=</name></member>
      <member refid="d2/df5/classCxxUtils_1_1ClassName_1ab72ab23cf89c5fa217366b4c0e55896c" prot="public" virt="non-virtual"><scope>CxxUtils::ClassName</scope><name>operator==</name></member>
      <member refid="d2/df5/classCxxUtils_1_1ClassName_1a21fbdef21009682ae3b9643f43f66fd0" prot="private" virt="non-virtual"><scope>CxxUtils::ClassName</scope><name>parse</name></member>
      <member refid="d2/df5/classCxxUtils_1_1ClassName_1afea40aee0a0d7f4bf9e990d658cd5750" prot="private" virt="non-virtual"><scope>CxxUtils::ClassName</scope><name>parseNamespace</name></member>
      <member refid="d2/df5/classCxxUtils_1_1ClassName_1af62e826b7c628e821c306097890d3ccb" prot="private" virt="non-virtual"><scope>CxxUtils::ClassName</scope><name>parsePrimary</name></member>
      <member refid="d2/df5/classCxxUtils_1_1ClassName_1a353e249188066fb9448d14c0eef7f7b5" prot="private" virt="non-virtual"><scope>CxxUtils::ClassName</scope><name>parseTemplateArgs</name></member>
      <member refid="d2/df5/classCxxUtils_1_1ClassName_1afac5cffe53dd2e346f2cf1148dac5713" prot="public" virt="non-virtual"><scope>CxxUtils::ClassName</scope><name>qualifiedName</name></member>
      <member refid="d2/df5/classCxxUtils_1_1ClassName_1afb46cf0dd4a6b1bda705391466713eef" prot="public" virt="non-virtual"><scope>CxxUtils::ClassName</scope><name>setConst</name></member>
      <member refid="d2/df5/classCxxUtils_1_1ClassName_1abd392d554b891e62bffe6e822915d71c" prot="private" virt="non-virtual"><scope>CxxUtils::ClassName</scope><name>skipSpaces</name></member>
      <member refid="d2/df5/classCxxUtils_1_1ClassName_1af128db26769f589d91221f3c6df44b4f" prot="public" virt="non-virtual"><scope>CxxUtils::ClassName</scope><name>subst</name></member>
      <member refid="d2/df5/classCxxUtils_1_1ClassName_1ade65e075ffad0e920593040136218b58" prot="public" virt="non-virtual"><scope>CxxUtils::ClassName</scope><name>substCopy</name></member>
      <member refid="d2/df5/classCxxUtils_1_1ClassName_1a8e16fe0dcb6be7a8746a47a7b38ca953" prot="public" virt="non-virtual"><scope>CxxUtils::ClassName</scope><name>swap</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
