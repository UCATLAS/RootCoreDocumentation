<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.6.1">
  <compounddef id="d9/d58/classAthena_1_1Signal" kind="class" prot="public">
    <compoundname>Athena::Signal</compoundname>
    <includes refid="d0/dc2/SealSignal_8h" local="no">SealSignal.h</includes>
      <sectiondef kind="public-type">
      <memberdef kind="typedef" id="d9/d58/classAthena_1_1Signal_1a580d4d8dab36af1b92760624a314fe10" prot="public" static="no">
        <type>bool(*</type>
        <definition>typedef bool(* Athena::Signal::QuitHook)(int sig, siginfo_t *info, void *x)</definition>
        <argsstring>)(int sig, siginfo_t *info, void *x)</argsstring>
        <name>QuitHook</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Application clean-up hook invoked before <ref refid="d9/d58/classAthena_1_1Signal_1a98067924cbcf318e105b92c019acf33e" kindref="member">quit()</ref> exits from program termination signals (SIGHUP, SIGTERM or SIGQUIT).</para><para>The handler should return <computeroutput>true</computeroutput> if the signal handler should proceed to exit the application. Note that certain options to handlFatal() cause this hook to be invoked for fatal signals. If such behaviour is enabled, be sure to check the <ref refid="d9/d58/classAthena_1_1Signal_1acb413f9b908ec38d19007f699679f8ab" kindref="member">crashed()</ref> status before deciding to let the application to continue.</para><para>The quit hook should take care of resetting terminal modes, killing child processes, removing lock files, and so forth. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="186" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" bodystart="186" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="d9/d58/classAthena_1_1Signal_1ad4933f5dea26508794985dc36879fd4f" prot="public" static="no">
        <type>bool(*</type>
        <definition>typedef bool(* Athena::Signal::FatalHook)(int sig, siginfo_t *info, void *x)</definition>
        <argsstring>)(int sig, siginfo_t *info, void *x)</argsstring>
        <name>FatalHook</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Application hook to run in <ref refid="d9/d58/classAthena_1_1Signal_1a29ed2239824de7084eec2096921df121" kindref="member">fatal()</ref>. The hook should return <computeroutput>true</computeroutput> if the signal handler should proceed to die. <emphasis>sig</emphasis> is the signal number, or its negative if core was dumped and, as far as can determined, successfully produced.</para><para>The fatal hooks should, if possible, perform clean-ups similar to <ref refid="d9/d58/classAthena_1_1Signal_1a580d4d8dab36af1b92760624a314fe10" kindref="member">QuitHook</ref>. The application may achieve this by actually using the quit by setting <ref refid="d9/d58/classAthena_1_1Signal_1a150e4c8e320da5b8a0690973b287890e" kindref="member">FATAL_AUTO_EXIT</ref> for <ref refid="d9/d58/classAthena_1_1Signal_1a91247206fb7476bfbc60ba82aed77309" kindref="member">handleFatal()</ref>, or it could reuse an internal function in both handlers. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="197" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" bodystart="197" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="d9/d58/classAthena_1_1Signal_1a0a1d20177cf76b6f120d8f70fd547414" prot="public" static="no">
        <type>void(*</type>
        <definition>typedef void(* Athena::Signal::FatalReturn)(int sig, siginfo_t *info, void *x)</definition>
        <argsstring>)(int sig, siginfo_t *info, void *x)</argsstring>
        <name>FatalReturn</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Application hook to jump back to the main program from a fatal signal, for example using siglongjmp. It must never return. <emphasis>sig</emphasis> is the signal number, or its negative if core was dumped and, as far as can determined, successfully produced. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="203" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" bodystart="203" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="d9/d58/classAthena_1_1Signal_1a165a8a731e1c838d8fcbdc8e8a90672f" prot="public" static="no">
        <type>void(*</type>
        <definition>typedef void(* Athena::Signal::HandlerType)(int sig, siginfo_t *info, void *extra)</definition>
        <argsstring>)(int sig, siginfo_t *info, void *extra)</argsstring>
        <name>HandlerType</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><ref refid="d9/d58/classAthena_1_1Signal" kindref="compound">Signal</ref> handler type. This is defined explicitly and does not necessarily match the system&apos;s concept of signal handler type. If necessary, suitable trampolines are used internally to make sure the arguments make sense.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sig</parametername>
</parameternamelist>
<parameterdescription>
<para>The signal number. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>info</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to signal info. This pointer will be null on platforms that do not support POSIX signals. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>extra</parametername>
</parameternamelist>
<parameterdescription>
<para>Extra argument, e.g. the fault address. This pointer will be null on platforms that do not support POSIX signals. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="217" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" bodystart="217" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-static-attrib">
      <memberdef kind="variable" id="d9/d58/classAthena_1_1Signal_1aadde66d635b299a4f8f88d222855ce3b" prot="public" static="yes" mutable="no">
        <type>const int</type>
        <definition>const int Athena::Signal::USR1_DUMP_CORE</definition>
        <argsstring></argsstring>
        <name>USR1_DUMP_CORE</name>
        <initializer> 1</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Option that instructs <ref refid="d9/d58/classAthena_1_1Signal_1a29ed2239824de7084eec2096921df121" kindref="member">fatal()</ref> to call coredump() on SIGUSR1. This is merely a request to drop a <computeroutput>core</computeroutput>; no attempt is made to guarantee success. Failure may result for example for lack of permissions, for lack of disk space, or due to low resource limits. Please note that <computeroutput>core</computeroutput> files can only be created on unixen. Note also that dropping a core is a security risk and should never be enabled in setuid or setgid programs or for production applications. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="132" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" bodystart="132" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="d9/d58/classAthena_1_1Signal_1a369e40f96220b4e610c171a03e09bde1" prot="public" static="yes" mutable="no">
        <type>const int</type>
        <definition>const int Athena::Signal::FATAL_ON_QUIT</definition>
        <argsstring></argsstring>
        <name>FATAL_ON_QUIT</name>
        <initializer> 2</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Option to make SIGHUP, SIGTERM and SIGQUIT fatal instead of just <ref refid="d9/d58/classAthena_1_1Signal_1a98067924cbcf318e105b92c019acf33e" kindref="member">quit()</ref> signals. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="136" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" bodystart="136" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="d9/d58/classAthena_1_1Signal_1afbce7583ec5181b33546721b78fe8f01" prot="public" static="yes" mutable="no">
        <type>const int</type>
        <definition>const int Athena::Signal::FATAL_ON_INT</definition>
        <argsstring></argsstring>
        <name>FATAL_ON_INT</name>
        <initializer> 4</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Option to make SIGINT fatal. It will still just quit, not crash. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="140" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" bodystart="140" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="d9/d58/classAthena_1_1Signal_1a6798ead5f4386eed186a5e8dd885e00f" prot="public" static="yes" mutable="no">
        <type>const int</type>
        <definition>const int Athena::Signal::FATAL_DUMP_CORE</definition>
        <argsstring></argsstring>
        <name>FATAL_DUMP_CORE</name>
        <initializer> 8</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Option to make <ref refid="d9/d58/classAthena_1_1Signal_1a29ed2239824de7084eec2096921df121" kindref="member">fatal()</ref> dump a core file before crashing. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="143" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" bodystart="143" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="d9/d58/classAthena_1_1Signal_1ac52e36621c04bb27790397c43dba6343" prot="public" static="yes" mutable="no">
        <type>const int</type>
        <definition>const int Athena::Signal::FATAL_DUMP_SIG</definition>
        <argsstring></argsstring>
        <name>FATAL_DUMP_SIG</name>
        <initializer> 16</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Option to make fataldump() (invoked by <ref refid="d9/d58/classAthena_1_1Signal_1a29ed2239824de7084eec2096921df121" kindref="member">fatal()</ref>) to dump the signal name (as reported by <ref refid="d9/d58/classAthena_1_1Signal_1a0adbe38fd6bad8af8f01df2ebadd226a" kindref="member">name()</ref>). </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="147" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" bodystart="147" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="d9/d58/classAthena_1_1Signal_1adf0c99c485898916f19e5f3b20a92855" prot="public" static="yes" mutable="no">
        <type>const int</type>
        <definition>const int Athena::Signal::FATAL_DUMP_STACK</definition>
        <argsstring></argsstring>
        <name>FATAL_DUMP_STACK</name>
        <initializer> 32</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Option to make fataldump() (invoked by <ref refid="d9/d58/classAthena_1_1Signal_1a29ed2239824de7084eec2096921df121" kindref="member">fatal()</ref>) to dump stack backtrace for the offending code location. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="151" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" bodystart="151" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="d9/d58/classAthena_1_1Signal_1aa774d944e7b551a7f9e2a4ad7d3558b6" prot="public" static="yes" mutable="no">
        <type>const int</type>
        <definition>const int Athena::Signal::FATAL_DUMP_LIBS</definition>
        <argsstring></argsstring>
        <name>FATAL_DUMP_LIBS</name>
        <initializer> 64</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Option to make fataldump() (invoked by <ref refid="d9/d58/classAthena_1_1Signal_1a29ed2239824de7084eec2096921df121" kindref="member">fatal()</ref>) to dump the list of currently loaded shared libraries. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="155" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" bodystart="155" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="d9/d58/classAthena_1_1Signal_1a09b1ac53de90bda7a0619f730531767b" prot="public" static="yes" mutable="no">
        <type>const int</type>
        <definition>const int Athena::Signal::FATAL_DUMP_CONTEXT</definition>
        <argsstring></argsstring>
        <name>FATAL_DUMP_CONTEXT</name>
        <initializer> 128</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Option to make fataldump() (invoked by <ref refid="d9/d58/classAthena_1_1Signal_1a29ed2239824de7084eec2096921df121" kindref="member">fatal()</ref>) to dump the machine context (registers etc.) from the fault position. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="159" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" bodystart="159" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="d9/d58/classAthena_1_1Signal_1a150e4c8e320da5b8a0690973b287890e" prot="public" static="yes" mutable="no">
        <type>const int</type>
        <definition>const int Athena::Signal::FATAL_AUTO_EXIT</definition>
        <argsstring></argsstring>
        <name>FATAL_AUTO_EXIT</name>
        <initializer> 256</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Option to make <ref refid="d9/d58/classAthena_1_1Signal_1a29ed2239824de7084eec2096921df121" kindref="member">fatal()</ref> exit via <ref refid="d9/d58/classAthena_1_1Signal_1a98067924cbcf318e105b92c019acf33e" kindref="member">quit()</ref>. This will cause all the application clean-up hook to run. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="163" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" bodystart="163" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="d9/d58/classAthena_1_1Signal_1a0c47f0fc8e3ccd9ef3de3c2bc7ea39a3" prot="public" static="yes" mutable="no">
        <type>const int</type>
        <definition>const int Athena::Signal::FATAL_DEFAULT</definition>
        <argsstring></argsstring>
        <name>FATAL_DEFAULT</name>
        <initializer> (<ref refid="d9/d58/classAthena_1_1Signal_1aadde66d635b299a4f8f88d222855ce3b" kindref="member">USR1_DUMP_CORE</ref>
				       | <ref refid="d9/d58/classAthena_1_1Signal_1afbce7583ec5181b33546721b78fe8f01" kindref="member">FATAL_ON_INT</ref>
				       | <ref refid="d9/d58/classAthena_1_1Signal_1a6798ead5f4386eed186a5e8dd885e00f" kindref="member">FATAL_DUMP_CORE</ref>
				       | <ref refid="d9/d58/classAthena_1_1Signal_1ac52e36621c04bb27790397c43dba6343" kindref="member">FATAL_DUMP_SIG</ref>
				       | <ref refid="d9/d58/classAthena_1_1Signal_1adf0c99c485898916f19e5f3b20a92855" kindref="member">FATAL_DUMP_STACK</ref>
				       | <ref refid="d9/d58/classAthena_1_1Signal_1aa774d944e7b551a7f9e2a4ad7d3558b6" kindref="member">FATAL_DUMP_LIBS</ref>
				       | <ref refid="d9/d58/classAthena_1_1Signal_1a09b1ac53de90bda7a0619f730531767b" kindref="member">FATAL_DUMP_CONTEXT</ref>
				       | <ref refid="d9/d58/classAthena_1_1Signal_1a150e4c8e320da5b8a0690973b287890e" kindref="member">FATAL_AUTO_EXIT</ref>)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Default options to <ref refid="d9/d58/classAthena_1_1Signal_1a91247206fb7476bfbc60ba82aed77309" kindref="member">handleFatal()</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="173" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" bodystart="166" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-static-attrib">
      <memberdef kind="variable" id="d9/d58/classAthena_1_1Signal_1a8e86a83a86de128d53e49d29dd003274" prot="private" static="yes" mutable="no">
        <type>bool</type>
        <definition>bool Athena::Signal::s_crashed</definition>
        <argsstring></argsstring>
        <name>s_crashed</name>
        <initializer> false</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Indicator that the application has been crashed: that a fatal signal has been delivered. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="287" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" bodystart="287" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="d9/d58/classAthena_1_1Signal_1a5f9b0cd1b5fa7df9205f1e75a7f48e60" prot="private" static="yes" mutable="no">
        <type>int</type>
        <definition>int Athena::Signal::s_inFatal</definition>
        <argsstring></argsstring>
        <name>s_inFatal</name>
        <initializer> 0</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Indicator that we are currently executing inside <ref refid="d9/d58/classAthena_1_1Signal_1a29ed2239824de7084eec2096921df121" kindref="member">fatal()</ref>. Used to protect against signals delivered during recovery attempts. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="288" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" bodystart="288" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="d9/d58/classAthena_1_1Signal_1a591f9662be6c703339cf6e19b7345462" prot="private" static="yes" mutable="no">
        <type>const char *</type>
        <definition>const char * Athena::Signal::s_applicationName</definition>
        <argsstring></argsstring>
        <name>s_applicationName</name>
        <initializer> 0</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The current application name. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="289" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" bodystart="289" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="d9/d58/classAthena_1_1Signal_1a22d89097603a16af74840b1d9d2c790c" prot="private" static="yes" mutable="no">
        <type><ref refid="d1/dc7/SealCommon_8h_1a98d936fe848403f33ff9cebfc9a38597" kindref="member">IOFD</ref></type>
        <definition>IOFD Athena::Signal::s_fatalFd</definition>
        <argsstring></argsstring>
        <name>s_fatalFd</name>
        <initializer> IOFD_INVALID</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The output file descriptor for fataldump(). </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="290" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" bodystart="290" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="d9/d58/classAthena_1_1Signal_1a642206afdbfedac1732915592d6f75b1" prot="private" static="yes" mutable="no">
        <type><ref refid="d9/d58/classAthena_1_1Signal_1ad4933f5dea26508794985dc36879fd4f" kindref="member">FatalHook</ref></type>
        <definition>Signal::FatalHook Athena::Signal::s_fatalHook</definition>
        <argsstring></argsstring>
        <name>s_fatalHook</name>
        <initializer> 0</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The application handler hook for fatal signals. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="291" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" bodystart="291" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="d9/d58/classAthena_1_1Signal_1a3e7adc14d0c26774965ee26d93dcf7c1" prot="private" static="yes" mutable="no">
        <type><ref refid="d9/d58/classAthena_1_1Signal_1a0a1d20177cf76b6f120d8f70fd547414" kindref="member">FatalReturn</ref></type>
        <definition>Signal::FatalReturn Athena::Signal::s_fatalReturn</definition>
        <argsstring></argsstring>
        <name>s_fatalReturn</name>
        <initializer> 0</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The application main return hook for fatal signals. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="292" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" bodystart="292" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="d9/d58/classAthena_1_1Signal_1a0524eaa9dc3d8949423b3c61ba55290e" prot="private" static="yes" mutable="no">
        <type>unsigned</type>
        <definition>unsigned Athena::Signal::s_fatalOptions</definition>
        <argsstring></argsstring>
        <name>s_fatalOptions</name>
        <initializer> 0</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The current fatal signal handling options. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="293" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" bodystart="293" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="d9/d58/classAthena_1_1Signal_1aac2e7aaa53d369755ea6fe1ca5590966" prot="private" static="yes" mutable="no">
        <type><ref refid="d9/d58/classAthena_1_1Signal_1a580d4d8dab36af1b92760624a314fe10" kindref="member">QuitHook</ref></type>
        <definition>Signal::QuitHook Athena::Signal::s_quitHook</definition>
        <argsstring></argsstring>
        <name>s_quitHook</name>
        <initializer> 0</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The application handler hook for quitting-related signals. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="294" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" bodystart="294" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="d9/d58/classAthena_1_1Signal_1ae402bac7a5e55ed23ea91a0d7586e6fd" prot="private" static="yes" mutable="no">
        <type><ref refid="d9/d58/classAthena_1_1Signal_1a165a8a731e1c838d8fcbdc8e8a90672f" kindref="member">HandlerType</ref></type>
        <definition>Signal::HandlerType Athena::Signal::s_trampolines</definition>
        <argsstring>[NSIG]</argsstring>
        <name>s_trampolines</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Actual signal handlers when POSIX signals are not available. These are required so that we can send pass correct (= null) arguments to the registered handler when the system is not passing anything, or garbage. If this happens, <ref refid="d9/d58/classAthena_1_1Signal_1acb0930a18360698b9c20245fa140eba2" kindref="member">handle()</ref> will register trampoline() as the signal handler and register the signal in this table, and trampoline just looks the actual handler here. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="296" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" bodystart="296" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-static-func">
      <memberdef kind="function" id="d9/d58/classAthena_1_1Signal_1a0adbe38fd6bad8af8f01df2ebadd226a" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>const char *</type>
        <definition>const char * Athena::Signal::name</definition>
        <argsstring>(int sig)</argsstring>
        <name>name</name>
        <param>
          <type>int</type>
          <declname>sig</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Return the name of the signal number <emphasis>sig</emphasis>. The returned memory is statically allocated and must not be freed. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="222" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/SealSignal.cxx" bodystart="201" bodyend="216"/>
      </memberdef>
      <memberdef kind="function" id="d9/d58/classAthena_1_1Signal_1a03b798ab9f156df7c4201b8ca965fc7c" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="d9/d58/classAthena_1_1Signal_1a165a8a731e1c838d8fcbdc8e8a90672f" kindref="member">HandlerType</ref></type>
        <definition>Signal::HandlerType Athena::Signal::handler</definition>
        <argsstring>(int sig, sigset_t *mask=0)</argsstring>
        <name>handler</name>
        <param>
          <type>int</type>
          <declname>sig</declname>
        </param>
        <param>
          <type>sigset_t *</type>
          <declname>mask</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Return the current handler for signal number <emphasis>sig</emphasis> and its blocked signals in <emphasis>mask</emphasis> (if non-null). </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="225" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/SealSignal.cxx" bodystart="221" bodyend="242"/>
      </memberdef>
      <memberdef kind="function" id="d9/d58/classAthena_1_1Signal_1acb0930a18360698b9c20245fa140eba2" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="d9/d58/classAthena_1_1Signal_1a165a8a731e1c838d8fcbdc8e8a90672f" kindref="member">HandlerType</ref></type>
        <definition>Signal::HandlerType Athena::Signal::handle</definition>
        <argsstring>(int sig, HandlerType handler, const sigset_t *blockMask=0)</argsstring>
        <name>handle</name>
        <param>
          <type>int</type>
          <declname>sig</declname>
        </param>
        <param>
          <type><ref refid="d9/d58/classAthena_1_1Signal_1a165a8a731e1c838d8fcbdc8e8a90672f" kindref="member">HandlerType</ref></type>
          <declname>handler</declname>
        </param>
        <param>
          <type>const sigset_t *</type>
          <declname>blockMask</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Install a new signal handler <emphasis>handler</emphasis> for signal number <emphasis>sig</emphasis> and returns the old handler.</para><para>This method uses the POSIX signal handling primitives if they are available, failing which falling back to the <ref refid="db/db2/structC" kindref="compound">C</ref> standard <computeroutput>signal()</computeroutput> function.</para><para>When POSIX signals are used, signals other than <emphasis>sig</emphasis> are blocked according to <emphasis>blockMask</emphasis> (if null, no change is made) during the execution of <emphasis>handler</emphasis>. Note that the signal itself is always blocked during the handler execution and need not be mentioned in the mask explicitly. System calls are made restartable although this has little impact as this library always restarts interrupted system calls automatically despite the signal handling settings.</para><para>(FIXME: Expose option SA_NOCLDSTOP, SA_ONSTACK?) (FIXME: Threads vs. signals) </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="227" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/SealSignal.cxx" bodystart="262" bodyend="307"/>
      </memberdef>
      <memberdef kind="function" id="d9/d58/classAthena_1_1Signal_1a76c5c303a2f6cbf9af04709666f0e47c" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void Athena::Signal::revert</definition>
        <argsstring>(int sig)</argsstring>
        <name>revert</name>
        <param>
          <type>int</type>
          <declname>sig</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Revert the signal number <emphasis>sig</emphasis> back to its default behaviour. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="228" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/SealSignal.cxx" bodystart="311" bodyend="312"/>
      </memberdef>
      <memberdef kind="function" id="d9/d58/classAthena_1_1Signal_1a7694b12f8ec856d8ece08fe5ffd46c3f" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void Athena::Signal::ignore</definition>
        <argsstring>(int sig)</argsstring>
        <name>ignore</name>
        <param>
          <type>int</type>
          <declname>sig</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Ignore the signal number <emphasis>sig</emphasis>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="229" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/SealSignal.cxx" bodystart="316" bodyend="317"/>
      </memberdef>
      <memberdef kind="function" id="d9/d58/classAthena_1_1Signal_1a641025898baba970dddb3806fe4d7024" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void Athena::Signal::block</definition>
        <argsstring>(int sig, bool sense)</argsstring>
        <name>block</name>
        <param>
          <type>int</type>
          <declname>sig</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>sense</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Block or unblock the signal number <emphasis>sig</emphasis>. The signal is blocked if <emphasis>sense</emphasis> is <computeroutput>true</computeroutput>, unblocked otherwise. This function is implemented only on systems with POSIX signals. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="231" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/SealSignal.cxx" bodystart="323" bodyend="332"/>
      </memberdef>
      <memberdef kind="function" id="d9/d58/classAthena_1_1Signal_1a50cde1da242d476e0fd35be113657121" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void Athena::Signal::block</definition>
        <argsstring>(const sigset_t *mask, bool sense)</argsstring>
        <name>block</name>
        <param>
          <type>const sigset_t *</type>
          <declname>mask</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>sense</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Block or unblock the signals specified by <emphasis>mask</emphasis>. The signals are blocked if <emphasis>sense</emphasis> is <computeroutput>true</computeroutput>, unblocked otherwise. This function is implemented only on systems with POSIX signals. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="232" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/SealSignal.cxx" bodystart="338" bodyend="344"/>
      </memberdef>
      <memberdef kind="function" id="d9/d58/classAthena_1_1Signal_1a4d98e5d67200d900fdc04abecb3d6911" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void Athena::Signal::mask</definition>
        <argsstring>(const sigset_t *mask, sigset_t *old=0)</argsstring>
        <name>mask</name>
        <param>
          <type>const sigset_t *</type>
          <declname>mask</declname>
        </param>
        <param>
          <type>sigset_t *</type>
          <declname>old</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Set the list of currently blocked signals to <emphasis>mask</emphasis> and return the old setting in <emphasis>old</emphasis> (if non-null). This function is implemented only on systems with POSIX signals. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="233" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/SealSignal.cxx" bodystart="350" bodyend="356"/>
      </memberdef>
      <memberdef kind="function" id="d9/d58/classAthena_1_1Signal_1a08098f4712adf303e1308740a647b6fb" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int Athena::Signal::raise</definition>
        <argsstring>(int sig)</argsstring>
        <name>raise</name>
        <param>
          <type>int</type>
          <declname>sig</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Raise the signal number <emphasis>sig</emphasis>. Returns the exit code from the <computeroutput><ref refid="d9/d58/classAthena_1_1Signal_1a08098f4712adf303e1308740a647b6fb" kindref="member">raise()</ref></computeroutput> system call (or <computeroutput><ref refid="d9/d58/classAthena_1_1Signal_1a15848d5bc08689bda47833527c74512d" kindref="member">kill()</ref></computeroutput> if <computeroutput><ref refid="d9/d58/classAthena_1_1Signal_1a08098f4712adf303e1308740a647b6fb" kindref="member">raise()</ref></computeroutput> does not exist). </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="236" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/SealSignal.cxx" bodystart="362" bodyend="369"/>
      </memberdef>
      <memberdef kind="function" id="d9/d58/classAthena_1_1Signal_1a15848d5bc08689bda47833527c74512d" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int Athena::Signal::kill</definition>
        <argsstring>(pid_t process, int sig)</argsstring>
        <name>kill</name>
        <param>
          <type>pid_t</type>
          <declname>process</declname>
        </param>
        <param>
          <type>int</type>
          <declname>sig</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Send the signal <emphasis>sig</emphasis> to process identified by <emphasis>process</emphasis>. Implemented only on unixen. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="237" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/SealSignal.cxx" bodystart="374" bodyend="382"/>
      </memberdef>
      <memberdef kind="function" id="d9/d58/classAthena_1_1Signal_1a2320430a74b58f6a2180a794f3e6aaab" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int Athena::Signal::queue</definition>
        <argsstring>(int sig, int value=0)</argsstring>
        <name>queue</name>
        <param>
          <type>int</type>
          <declname>sig</declname>
        </param>
        <param>
          <type>int</type>
          <declname>value</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Queue signal <emphasis>sig</emphasis> for this process with additional data <emphasis>value</emphasis>. Implemented only on systems with POSIX real-time signals. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="238" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/SealSignal.cxx" bodystart="431" bodyend="434"/>
      </memberdef>
      <memberdef kind="function" id="d9/d58/classAthena_1_1Signal_1ab440bbd5068c51676db72c90e2bd481f" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int Athena::Signal::queue</definition>
        <argsstring>(int sig, void *value)</argsstring>
        <name>queue</name>
        <param>
          <type>int</type>
          <declname>sig</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Queue signal <emphasis>sig</emphasis> for this process with additional data <emphasis>value</emphasis>. Implemented only on systems with POSIX real-time signals. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="239" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/SealSignal.cxx" bodystart="448" bodyend="451"/>
      </memberdef>
      <memberdef kind="function" id="d9/d58/classAthena_1_1Signal_1a3cb61f4a6cee9302b5726f12acba6100" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int Athena::Signal::queue</definition>
        <argsstring>(pid_t process, int sig, int value=0)</argsstring>
        <name>queue</name>
        <param>
          <type>pid_t</type>
          <declname>process</declname>
        </param>
        <param>
          <type>int</type>
          <declname>sig</declname>
        </param>
        <param>
          <type>int</type>
          <declname>value</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Queue signal <emphasis>sig</emphasis> with additional data <emphasis>value</emphasis> for <emphasis>process</emphasis>. Implemented only on systems with POSIX real-time signals. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="240" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/SealSignal.cxx" bodystart="396" bodyend="399"/>
      </memberdef>
      <memberdef kind="function" id="d9/d58/classAthena_1_1Signal_1a3736a405678e733d4ab65217a19d6a3e" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int Athena::Signal::queue</definition>
        <argsstring>(pid_t process, int sig, void *value)</argsstring>
        <name>queue</name>
        <param>
          <type>pid_t</type>
          <declname>process</declname>
        </param>
        <param>
          <type>int</type>
          <declname>sig</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Queue signal <emphasis>sig</emphasis> with additional data <emphasis>value</emphasis> for <emphasis>process</emphasis>. Implemented only on systems with POSIX real-time signals. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="241" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/SealSignal.cxx" bodystart="414" bodyend="417"/>
      </memberdef>
      <memberdef kind="function" id="d9/d58/classAthena_1_1Signal_1a9b3d452bd4db782ababb16856e502b4d" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool Athena::Signal::pending</definition>
        <argsstring>(int sig)</argsstring>
        <name>pending</name>
        <param>
          <type>int</type>
          <declname>sig</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Check if <emphasis>sig</emphasis> is pending for this process. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="243" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/SealSignal.cxx" bodystart="456" bodyend="457"/>
      </memberdef>
      <memberdef kind="function" id="d9/d58/classAthena_1_1Signal_1adc09b8c58ec8e5a11cec445fc8fc37bc" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void Athena::Signal::pending</definition>
        <argsstring>(sigset_t *mask)</argsstring>
        <name>pending</name>
        <param>
          <type>sigset_t *</type>
          <declname>mask</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Return in <emphasis>mask</emphasis> the list of signals pending for this process. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="244" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/SealSignal.cxx" bodystart="469" bodyend="471"/>
      </memberdef>
      <memberdef kind="function" id="d9/d58/classAthena_1_1Signal_1a12d5227fb0b4627b25f75c80bbc97232" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void Athena::Signal::suspend</definition>
        <argsstring>(const sigset_t *mask)</argsstring>
        <name>suspend</name>
        <param>
          <type>const sigset_t *</type>
          <declname>mask</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Temporarily replace the signal mask of the process with <emphasis>mask</emphasis> and then suspend until a signal is received. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="245" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/SealSignal.cxx" bodystart="485" bodyend="487"/>
      </memberdef>
      <memberdef kind="function" id="d9/d58/classAthena_1_1Signal_1a618af8c53f3f8942b558f712e12865ef" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool Athena::Signal::wait</definition>
        <argsstring>(int sig, siginfo_t *info=0, long msecs=-1)</argsstring>
        <name>wait</name>
        <param>
          <type>int</type>
          <declname>sig</declname>
        </param>
        <param>
          <type><ref refid="dc/dbc/structsiginfo__t" kindref="compound">siginfo_t</ref> *</type>
          <declname>info</declname>
          <defval>0</defval>
        </param>
        <param>
          <type>long</type>
          <declname>msecs</declname>
          <defval>-1</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Suspend the thread waiting for signal <emphasis>sig</emphasis> at most <emphasis>msecs</emphasis> milliseconds. If <emphasis>msecs</emphasis> is negative (the default), waits until a signal is delivered. Otherwise waits up to the specified time limit. Returns <computeroutput>true</computeroutput> if the signal was received. Note that the signal must be blocked (in a multi-threaded application in all the threads, not just the calling one) and not be ignored before calling this function; if a handler is registered, it won&apos;t be called. Implemented only on systems with POSIX real-time signals. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="248" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/SealSignal.cxx" bodystart="500" bodyend="506"/>
      </memberdef>
      <memberdef kind="function" id="d9/d58/classAthena_1_1Signal_1ad6d376707953d3536cbbbf7350d385e4" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int Athena::Signal::wait</definition>
        <argsstring>(const sigset_t *mask, siginfo_t *info=0, long msecs=-1)</argsstring>
        <name>wait</name>
        <param>
          <type>const sigset_t *</type>
          <declname>mask</declname>
        </param>
        <param>
          <type><ref refid="dc/dbc/structsiginfo__t" kindref="compound">siginfo_t</ref> *</type>
          <declname>info</declname>
          <defval>0</defval>
        </param>
        <param>
          <type>long</type>
          <declname>msecs</declname>
          <defval>-1</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Suspend the thread waiting for signals specified by <emphasis>mask</emphasis> for at most <emphasis>msecs</emphasis> milliseconds. If <emphasis>msecs</emphasis> is negative (the default), waits until a signal is delivered. Otherwise waits up to the specified time limit. Returns the number of the signal that was received, or -1 if the time limit expired. If <emphasis>info</emphasis> is given, fills it with the information that the handler would have otherwise been given. Note that the signals must be blocked (in a multi-threaded application in all the threads, not just the calling one) and not be ignored before calling this function; if a handler is registered, it won&apos;t be called. Implemented only on systems with POSIX real-time signals. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="251" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/SealSignal.cxx" bodystart="546" bodyend="551"/>
      </memberdef>
      <memberdef kind="function" id="d9/d58/classAthena_1_1Signal_1a937b6ad470e18df2e2509f150fb92fd9" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void Athena::Signal::handleQuit</definition>
        <argsstring>(QuitHook hook=0)</argsstring>
        <name>handleQuit</name>
        <param>
          <type><ref refid="d9/d58/classAthena_1_1Signal_1a580d4d8dab36af1b92760624a314fe10" kindref="member">QuitHook</ref></type>
          <declname>hook</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="254" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/SealSignal.cxx" bodystart="565" bodyend="589"/>
      </memberdef>
      <memberdef kind="function" id="d9/d58/classAthena_1_1Signal_1ae09161d0e01449d88a870c9ce33e48ab" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="d9/d58/classAthena_1_1Signal_1a580d4d8dab36af1b92760624a314fe10" kindref="member">QuitHook</ref></type>
        <definition>Signal::QuitHook Athena::Signal::handleQuitHook</definition>
        <argsstring>(void)</argsstring>
        <name>handleQuitHook</name>
        <param>
          <type>void</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Return the current application quit signal hook. Registered through handleQuit(). </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="255" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/SealSignal.cxx" bodystart="1481" bodyend="1482"/>
      </memberdef>
      <memberdef kind="function" id="d9/d58/classAthena_1_1Signal_1a98067924cbcf318e105b92c019acf33e" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void Athena::Signal::quit</definition>
        <argsstring>(int sig, siginfo_t *info, void *x)</argsstring>
        <name>quit</name>
        <param>
          <type>int</type>
          <declname>sig</declname>
        </param>
        <param>
          <type><ref refid="dc/dbc/structsiginfo__t" kindref="compound">siginfo_t</ref> *</type>
          <declname>info</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The quit signal handler.</para><para>This is the handler installed by handleQuit(). Please use handleQuit() and this method instead of installing your own handlers with <ref refid="d9/d58/classAthena_1_1Signal_1acb0930a18360698b9c20245fa140eba2" kindref="member">handle()</ref>.</para><para>This handler first invokes the application hook if one was given to handleQuit(). If the hook returns <computeroutput>true</computeroutput>, the signal handler for this signal (number <emphasis>sig</emphasis>) is reset to its default handler, and the signal is re-raised. This causes the program to exit via the signal and have a the correct exit status.</para><para>The application should do whatever is necessary for a graceful shutdown. Note however that this signal may arrive asynchronously at any time, hence it probably isn&apos;t safe to allocate memory, use the standard output streams, and so forth. What you can do is to set a flag, return <computeroutput>false</computeroutput> to return back to your application, detect the flag setting and drain your current event loop, and then quit. But do note that if <ref refid="d9/d58/classAthena_1_1Signal_1a150e4c8e320da5b8a0690973b287890e" kindref="member">FATAL_AUTO_EXIT</ref> was set in call to <ref refid="d9/d58/classAthena_1_1Signal_1a91247206fb7476bfbc60ba82aed77309" kindref="member">handleFatal()</ref>, <ref refid="d9/d58/classAthena_1_1Signal_1a29ed2239824de7084eec2096921df121" kindref="member">fatal()</ref> will call <ref refid="d9/d58/classAthena_1_1Signal_1a98067924cbcf318e105b92c019acf33e" kindref="member">quit()</ref> which in turn calls the application hook. Thus the hook should make sure it returns <computeroutput>true</computeroutput> if the application has crashed as noted in the documentation for &lt;&lt;QuitHook&gt;&gt;. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="257" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/SealSignal.cxx" bodystart="801" bodyend="815"/>
      </memberdef>
      <memberdef kind="function" id="d9/d58/classAthena_1_1Signal_1a91247206fb7476bfbc60ba82aed77309" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void Athena::Signal::handleFatal</definition>
        <argsstring>(const char *applicationName=0, IOFD fd=IOFD_INVALID, FatalHook hook=0, FatalReturn mainreturn=0, unsigned options=FATAL_DEFAULT)</argsstring>
        <name>handleFatal</name>
        <param>
          <type>const char *</type>
          <declname>applicationName</declname>
          <defval>0</defval>
        </param>
        <param>
          <type><ref refid="d1/dc7/SealCommon_8h_1a98d936fe848403f33ff9cebfc9a38597" kindref="member">IOFD</ref></type>
          <declname>fd</declname>
          <defval>IOFD_INVALID</defval>
        </param>
        <param>
          <type><ref refid="d9/d58/classAthena_1_1Signal_1ad4933f5dea26508794985dc36879fd4f" kindref="member">FatalHook</ref></type>
          <declname>hook</declname>
          <defval>0</defval>
        </param>
        <param>
          <type><ref refid="d9/d58/classAthena_1_1Signal_1a0a1d20177cf76b6f120d8f70fd547414" kindref="member">FatalReturn</ref></type>
          <declname>mainreturn</declname>
          <defval>0</defval>
        </param>
        <param>
          <type>unsigned</type>
          <declname>options</declname>
          <defval><ref refid="d9/d58/classAthena_1_1Signal_1a0c47f0fc8e3ccd9ef3de3c2bc7ea39a3" kindref="member">FATAL_DEFAULT</ref></defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Install default handler for fatal signals.</para><para>This method installs a handler for fatal signals such as floating point exceptions, illegal instructions, and memory violations. The behaviour is more precisely determined by <emphasis>options</emphasis>, a bitwise or of the option constants defined in the class declaration.</para><para><emphasis>applicationName</emphasis> sets the application name to be used to report the signal in <ref refid="d9/d58/classAthena_1_1Signal_1a5b6e599feec0e6ea2e5d204c7accf7ab" kindref="member">fatalDump()</ref>. <emphasis>fd</emphasis> sets the file descriptor to which the fatal signal message is written; by default this will be the standard error output. <emphasis>hook</emphasis> sets the pre-exit application hook to invoke, <emphasis>mainreturn</emphasis> sets the hook to return to back to the application &quot;main loop&quot; (i.e. ignore the signal by jumping out of the signal back to the somewhere higher up in the application).</para><para>Options left to default values will not change the current state. This allows one to re-install signal handlers without disturbing already registered information. Use this to restore handlers after some other library has meddled with the handlers.</para><para>This installs <ref refid="d9/d58/classAthena_1_1Signal_1a29ed2239824de7084eec2096921df121" kindref="member">fatal()</ref> as the handler for fatal signals and on Windows for otherwise unhandled fatal structured exceptions. If <ref refid="d9/d58/classAthena_1_1Signal_1a369e40f96220b4e610c171a03e09bde1" kindref="member">FATAL_ON_QUIT</ref> is included in <emphasis>options</emphasis>, quitting related signals (see <ref refid="d9/d58/classAthena_1_1Signal_1a98067924cbcf318e105b92c019acf33e" kindref="member">quit()</ref>) are also considered fatal. If <ref refid="d9/d58/classAthena_1_1Signal_1afbce7583ec5181b33546721b78fe8f01" kindref="member">FATAL_ON_INT</ref> is set, SIGINT is considered fatal---but see also <ref refid="d9/d58/classAthena_1_1Signal_1a29ed2239824de7084eec2096921df121" kindref="member">fatal()</ref> documentation. If <ref refid="d9/d58/classAthena_1_1Signal_1aadde66d635b299a4f8f88d222855ce3b" kindref="member">USR1_DUMP_CORE</ref> is set, DebugAids::coredump is registered as a handler for SIGUSR1 (please note the security risks of this option in its documentation).</para><para><ref refid="d4/dc4/structA" kindref="compound">A</ref> multi-threaded application should call this method in each thread. (FIXME: Calling this in one thread and blocking signals in others won&apos;t work on Linux, and in any case will probably produce non-sense stack traces (unless stacktrace can be fixed to dump the stacks of all the threads). Since the handler is always the same, I am not sure it will make the slightest difference which thread catches the signals, and on the other hand, it is best to dump the problems in the faulting thread if possible.) </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="264" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/SealSignal.cxx" bodystart="630" bodyend="775"/>
      </memberdef>
      <memberdef kind="function" id="d9/d58/classAthena_1_1Signal_1a531516a7bafb85ada87cc13df42be6c9" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="d1/dc7/SealCommon_8h_1a98d936fe848403f33ff9cebfc9a38597" kindref="member">IOFD</ref></type>
        <definition>IOFD Athena::Signal::handleFatalFd</definition>
        <argsstring>(void)</argsstring>
        <name>handleFatalFd</name>
        <param>
          <type>void</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Return the file descriptor fataldump() uses for output. Registered through <ref refid="d9/d58/classAthena_1_1Signal_1a91247206fb7476bfbc60ba82aed77309" kindref="member">handleFatal()</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="265" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/SealSignal.cxx" bodystart="1451" bodyend="1458"/>
      </memberdef>
      <memberdef kind="function" id="d9/d58/classAthena_1_1Signal_1acf9c12a42518c098bcdc03e2e1ec164a" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="d9/d58/classAthena_1_1Signal_1ad4933f5dea26508794985dc36879fd4f" kindref="member">FatalHook</ref></type>
        <definition>Signal::FatalHook Athena::Signal::handleFatalHook</definition>
        <argsstring>(void)</argsstring>
        <name>handleFatalHook</name>
        <param>
          <type>void</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Return the application fatal signal hook. Registered through <ref refid="d9/d58/classAthena_1_1Signal_1a91247206fb7476bfbc60ba82aed77309" kindref="member">handleFatal()</ref>. <simplesect kind="see"><para><ref refid="d9/d58/classAthena_1_1Signal_1a29ed2239824de7084eec2096921df121" kindref="member">fatal()</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="266" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/SealSignal.cxx" bodystart="1463" bodyend="1464"/>
      </memberdef>
      <memberdef kind="function" id="d9/d58/classAthena_1_1Signal_1a058d561130784cb3ff06f944dd2a642c" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="d9/d58/classAthena_1_1Signal_1a0a1d20177cf76b6f120d8f70fd547414" kindref="member">FatalReturn</ref></type>
        <definition>Signal::FatalReturn Athena::Signal::handleFatalReturn</definition>
        <argsstring>(void)</argsstring>
        <name>handleFatalReturn</name>
        <param>
          <type>void</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Return the application fatal signal return hook. Registered through <ref refid="d9/d58/classAthena_1_1Signal_1a91247206fb7476bfbc60ba82aed77309" kindref="member">handleFatal()</ref>. <simplesect kind="see"><para><ref refid="d9/d58/classAthena_1_1Signal_1a29ed2239824de7084eec2096921df121" kindref="member">fatal()</ref>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="267" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/SealSignal.cxx" bodystart="1469" bodyend="1470"/>
      </memberdef>
      <memberdef kind="function" id="d9/d58/classAthena_1_1Signal_1aab22be0d7aa1e7034b2de5f158c74533" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>unsigned</type>
        <definition>unsigned Athena::Signal::handleFatalOptions</definition>
        <argsstring>(void)</argsstring>
        <name>handleFatalOptions</name>
        <param>
          <type>void</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Return the current fatal signal handling options. Set on invocation to <ref refid="d9/d58/classAthena_1_1Signal_1a91247206fb7476bfbc60ba82aed77309" kindref="member">handleFatal()</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="268" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/SealSignal.cxx" bodystart="1475" bodyend="1476"/>
      </memberdef>
      <memberdef kind="function" id="d9/d58/classAthena_1_1Signal_1a29ed2239824de7084eec2096921df121" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void Athena::Signal::fatal</definition>
        <argsstring>(int sig, siginfo_t *info, void *x)</argsstring>
        <name>fatal</name>
        <param>
          <type>int</type>
          <declname>sig</declname>
        </param>
        <param>
          <type><ref refid="dc/dbc/structsiginfo__t" kindref="compound">siginfo_t</ref> *</type>
          <declname>info</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The fatal signal handler.</para><para>This is the handler installed by <ref refid="d9/d58/classAthena_1_1Signal_1a91247206fb7476bfbc60ba82aed77309" kindref="member">handleFatal()</ref>. Please use <ref refid="d9/d58/classAthena_1_1Signal_1a91247206fb7476bfbc60ba82aed77309" kindref="member">handleFatal()</ref> and this method instead of installing your handlers with <ref refid="d9/d58/classAthena_1_1Signal_1acb0930a18360698b9c20245fa140eba2" kindref="member">handle()</ref>. You should be able use the handler options to specify all the control you need.</para><para>The first thing this handler does is to reinstall itself for the benefit of platforms with single-delivery signals. Immediately after that it unblocks the delivery of that signal again, in case the signal handler itself gets in trouble. The next step is to check if the current crash level (the recursion of calls to <ref refid="d9/d58/classAthena_1_1Signal_1a29ed2239824de7084eec2096921df121" kindref="member">fatal()</ref>, see <ref refid="d9/d58/classAthena_1_1Signal_1ae19a24e2785bf4313373d693270a0318" kindref="member">fatalLevel()</ref>) exceeds the predefined limit of 4; if so, we give up and let the application die with this this signal. The handler then determines whether the signal is fatal: everything except SIGINT is, and SIGINT is fatal if <ref refid="d9/d58/classAthena_1_1Signal_1afbce7583ec5181b33546721b78fe8f01" kindref="member">FATAL_ON_INT</ref> was set. If the signal is fatal, crash indicator is set (see <ref refid="d9/d58/classAthena_1_1Signal_1acb413f9b908ec38d19007f699679f8ab" kindref="member">crashed()</ref>).</para><para>If this is not a nested fatal signal, the signal is fatal, and <ref refid="d9/d58/classAthena_1_1Signal_1a6798ead5f4386eed186a5e8dd885e00f" kindref="member">FATAL_DUMP_CORE</ref> is set, the handler tries dump a core file. Then the handler will either attempt to quit or to return to the main program depending on <ref refid="d9/d58/classAthena_1_1Signal_1a150e4c8e320da5b8a0690973b287890e" kindref="member">FATAL_AUTO_EXIT</ref> option setting. If it is set or this is a nested fatal signal, the handler will attempt to exit as follows: the application hook (or <ref refid="d9/d58/classAthena_1_1Signal_1a5b6e599feec0e6ea2e5d204c7accf7ab" kindref="member">fatalDump()</ref> in its absence) is invoked. If the hook returns <computeroutput>true</computeroutput>, <ref refid="d9/d58/classAthena_1_1Signal_1a98067924cbcf318e105b92c019acf33e" kindref="member">quit()</ref> is called; otherwise the signal handler will return (and crash or get an infinite sequence of fatal signals). Note that if an application hook is registered, fataldump() is not called by default; the application hook must invoke it itself to get the dump.</para><para>If <ref refid="d9/d58/classAthena_1_1Signal_1a150e4c8e320da5b8a0690973b287890e" kindref="member">FATAL_AUTO_EXIT</ref> is not set, the application must have registered a main return hook, which will be invoked. The hook must not return, but do a <computeroutput>siglongjmp</computeroutput> back to the main program (it should not throw unless all code is built with options that allow exceptions to be thrown from signal handlers). Note that the fatal signal may be asynchronous and may have arisen in code left in unsafe state, so returning back to the main program may not buy you much. It may make sense for a few things like rogue null pointer dereferences or floating point exceptions.</para><para>An interactive application using a main return hook should do something like this when the <computeroutput>sigsetjmp</computeroutput> in the main loop returns:<itemizedlist>
<listitem><para>disable &quot;main loop entered&quot; status</para></listitem><listitem><para>inform the user about the fatal error (e.g. with a popup); the popup window should be precreated for best stability</para></listitem><listitem><para>reset any locks the application holds, especially for user interface, including status bars, wait icons etc.</para></listitem><listitem><para>suggest to run a debugger against the program right there</para></listitem><listitem><para>in a windowing system ungrab pointer, keyboard and the server</para></listitem><listitem><para>unblock the signal via block(sig, false) as the operating system may think the signal is still being processed</para></listitem><listitem><para>add an idle processor to re-return the &quot;main loop entered&quot; once all pending event queue events have been drained</para></listitem><listitem><para>go onto processing gui events</para></listitem></itemizedlist>
</para><para>Using a main return will most likely leak memory like a sieve, but in balance, the application just got a fatal signal and the leak is unlikely to be the greatest concern. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="270" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/SealSignal.cxx" bodystart="879" bodyend="947"/>
      </memberdef>
      <memberdef kind="function" id="d9/d58/classAthena_1_1Signal_1a5b6e599feec0e6ea2e5d204c7accf7ab" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool Athena::Signal::fatalDump</definition>
        <argsstring>(int sig, siginfo_t *info, void *x)</argsstring>
        <name>fatalDump</name>
        <param>
          <type>int</type>
          <declname>sig</declname>
        </param>
        <param>
          <type><ref refid="dc/dbc/structsiginfo__t" kindref="compound">siginfo_t</ref> *</type>
          <declname>info</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>x</declname>
          <defname>extra</defname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Dump application state information on a fatal signal.</para><para>Use this method to dump program state on a delivery of a fatal signal. <ref refid="d9/d58/classAthena_1_1Signal_1a29ed2239824de7084eec2096921df121" kindref="member">fatal()</ref> uses this function automatically if no fatal handler hook has not been registered by the application.</para><para>This function attempts to be as maximally robust given that it runs in a signal handler in conditions where the program by definition is unstable. In other words, it allocates no memory and writes its output directly to a file descriptor with direct system calls. For this reason some initialisation is required; use <ref refid="d9/d58/classAthena_1_1Signal_1a91247206fb7476bfbc60ba82aed77309" kindref="member">handleFatal()</ref> to register the current application name and an output file descriptor, preferably as early in the program as possible.</para><para>The dump will consist of the following items:<itemizedlist>
<listitem><para>if <ref refid="d9/d58/classAthena_1_1Signal_1ac52e36621c04bb27790397c43dba6343" kindref="member">FATAL_DUMP_SIG</ref> option is set:<itemizedlist>
<listitem><para>the application name if registered with <ref refid="d9/d58/classAthena_1_1Signal_1a91247206fb7476bfbc60ba82aed77309" kindref="member">handleFatal()</ref></para></listitem><listitem><para>a title describing telling which fatal signal has been received (defined by <emphasis>sig</emphasis>, the signal number, or its negative if core has been dumped)</para></listitem><listitem><para>information available from the <emphasis>info</emphasis> argument</para></listitem></itemizedlist>
</para></listitem><listitem><para>if <ref refid="d9/d58/classAthena_1_1Signal_1a09b1ac53de90bda7a0619f730531767b" kindref="member">FATAL_DUMP_CONTEXT</ref> option is set, all the available CPU context information like registers</para></listitem><listitem><para>if <ref refid="d9/d58/classAthena_1_1Signal_1adf0c99c485898916f19e5f3b20a92855" kindref="member">FATAL_DUMP_STACK</ref> option is set, the stack trace</para></listitem><listitem><para>if <ref refid="d9/d58/classAthena_1_1Signal_1aa774d944e7b551a7f9e2a4ad7d3558b6" kindref="member">FATAL_DUMP_LIBS</ref> option is set, the list of currently loaded shared libraries</para></listitem></itemizedlist>
</para><para>This always returns <computeroutput>true</computeroutput> so it is convenient for the application fatal hook to return with a call to this function.</para><para>Note that this function will not flush <computeroutput>std::cerr</computeroutput> or <computeroutput>stderr</computeroutput> before producing output, for stability reasons. If the streams have unflushed output in their buffers, that output may get mixed with unbuffered direct output from this function. If you wish to avoid this mixup and are willing to take the risk that those calls might crash, install an application hook that flushes the streams and then calls this function. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="271" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/SealSignal.cxx" bodystart="1399" bodyend="1446"/>
      </memberdef>
      <memberdef kind="function" id="d9/d58/classAthena_1_1Signal_1ae19a24e2785bf4313373d693270a0318" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int Athena::Signal::fatalLevel</definition>
        <argsstring>(void)</argsstring>
        <name>fatalLevel</name>
        <param>
          <type>void</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Return the depth to which <ref refid="d9/d58/classAthena_1_1Signal_1a29ed2239824de7084eec2096921df121" kindref="member">fatal()</ref> is currently recursively entered, or zero if <ref refid="d9/d58/classAthena_1_1Signal_1a29ed2239824de7084eec2096921df121" kindref="member">fatal()</ref> is not currently active. Use this method in application fatal hook to decide which operations are safe to perform. For example, if the attempts to notify the user result in further signals, it is best to avoid such attempts at deeper recursion levels. Currently <ref refid="d9/d58/classAthena_1_1Signal_1a29ed2239824de7084eec2096921df121" kindref="member">fatal()</ref> ceases to call the application&apos;s hooks and forces termination if the nesting level reaches 4. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="272" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/SealSignal.cxx" bodystart="1493" bodyend="1494"/>
      </memberdef>
      <memberdef kind="function" id="d9/d58/classAthena_1_1Signal_1acb413f9b908ec38d19007f699679f8ab" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool Athena::Signal::crashed</definition>
        <argsstring>(void)</argsstring>
        <name>crashed</name>
        <param>
          <type>void</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Return the crash status indicator: <computeroutput>true</computeroutput> if a fatal signal has been received since the program started. Set if <ref refid="d9/d58/classAthena_1_1Signal_1a29ed2239824de7084eec2096921df121" kindref="member">fatal()</ref> is entered with a fatal signal. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="273" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/SealSignal.cxx" bodystart="1500" bodyend="1501"/>
      </memberdef>
      <memberdef kind="function" id="d9/d58/classAthena_1_1Signal_1aa686ec513eec1f5f9270a3093b536bcd" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void Athena::Signal::dumpInfo</definition>
        <argsstring>(IOFD fd, char *buf, int sig, const siginfo_t *info)</argsstring>
        <name>dumpInfo</name>
        <param>
          <type><ref refid="d1/dc7/SealCommon_8h_1a98d936fe848403f33ff9cebfc9a38597" kindref="member">IOFD</ref></type>
          <declname>fd</declname>
        </param>
        <param>
          <type>char *</type>
          <declname>buf</declname>
        </param>
        <param>
          <type>int</type>
          <declname>sig</declname>
        </param>
        <param>
          <type>const <ref refid="dc/dbc/structsiginfo__t" kindref="compound">siginfo_t</ref> *</type>
          <declname>info</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Utility function to dump the signal info descriptor for signal <emphasis>sig</emphasis>, as obtained for instance through signal handler parameters or <ref refid="d9/d58/classAthena_1_1Signal_1a618af8c53f3f8942b558f712e12865ef" kindref="member">wait()</ref>. The output is written directly to the file descriptor <emphasis>fd</emphasis>, using <emphasis>buf</emphasis> as the formatting buffer. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="276" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/SealSignal.cxx" bodystart="1068" bodyend="1162"/>
      </memberdef>
      <memberdef kind="function" id="d9/d58/classAthena_1_1Signal_1ab3650e5ddb5bdc899edac43d18446779" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void Athena::Signal::dumpMemory</definition>
        <argsstring>(IOFD fd, char *buf, const void *data, size_t n)</argsstring>
        <name>dumpMemory</name>
        <param>
          <type><ref refid="d1/dc7/SealCommon_8h_1a98d936fe848403f33ff9cebfc9a38597" kindref="member">IOFD</ref></type>
          <declname>fd</declname>
        </param>
        <param>
          <type>char *</type>
          <declname>buf</declname>
        </param>
        <param>
          <type>const void *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>n</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Utility function to dump memory section from <emphasis>data</emphasis> for <emphasis>n</emphasis> bytes. Used to dump machine context on platforms where we don&apos;t know any better. The output is written directly to the file descriptor <emphasis>fd</emphasis>, using <emphasis>buf</emphasis> as the formatting buffer. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="278" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/SealSignal.cxx" bodystart="1169" bodyend="1181"/>
      </memberdef>
      <memberdef kind="function" id="d9/d58/classAthena_1_1Signal_1acb9b9ecebefba6d45ac6ec5e019b133b" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void Athena::Signal::dumpContext</definition>
        <argsstring>(IOFD fd, char *buf, const void *context)</argsstring>
        <name>dumpContext</name>
        <param>
          <type><ref refid="d1/dc7/SealCommon_8h_1a98d936fe848403f33ff9cebfc9a38597" kindref="member">IOFD</ref></type>
          <declname>fd</declname>
        </param>
        <param>
          <type>char *</type>
          <declname>buf</declname>
        </param>
        <param>
          <type>const void *</type>
          <declname>context</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Utility function to dump the process context, as obtained for instance through signal handler parameters, unix <computeroutput>getcontext()</computeroutput> or Windows <computeroutput>GetThreadContext()</computeroutput>. The output is written directly to the file descriptor <emphasis>fd</emphasis>, using <emphasis>buf</emphasis> as the formatting buffer. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="280" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/SealSignal.cxx" bodystart="1188" bodyend="1358"/>
      </memberdef>
      <memberdef kind="function" id="d9/d58/classAthena_1_1Signal_1a35d052097f8387d33e7b74d63008a3a3" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>const char *</type>
        <definition>const char * Athena::Signal::describe</definition>
        <argsstring>(int sig, int code)</argsstring>
        <name>describe</name>
        <param>
          <type>int</type>
          <declname>sig</declname>
        </param>
        <param>
          <type>int</type>
          <declname>code</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Return the description for signal info code <emphasis>code</emphasis> for signal number <emphasis>sig</emphasis>. The code should come from <computeroutput>siginfo_t::si_code</computeroutput>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="282" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/SealSignal.cxx" bodystart="952" bodyend="1061"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-static-func">
      <memberdef kind="function" id="d9/d58/classAthena_1_1Signal_1abddb5b71da1f327a3dc0246afaae48d7" prot="private" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void Athena::Signal::trampoline</definition>
        <argsstring>(int sig)</argsstring>
        <name>trampoline</name>
        <param>
          <type>int</type>
          <declname>sig</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Internal signal handler trampoline to convert handler arguments to look more like POSIX signals. The actual handler must have been installed into s_trampolines by <ref refid="d9/d58/classAthena_1_1Signal_1acb0930a18360698b9c20245fa140eba2" kindref="member">handle()</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="285" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/SealSignal.cxx" bodystart="188" bodyend="195"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>Utilities for handling signals and fatal errors.</para><para>FIXME: POSIX single-threaded vs. multi-threaded signals?<itemizedlist>
<listitem><para>all threads should block all the signals</para></listitem><listitem><para>one thread should do sigwait.</para></listitem></itemizedlist>
</para><para>The fatal error handling is largely inspired by code in DDD, the Data Display Debugger, and by the examples in GNU libc manual. </para>    </detaileddescription>
    <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" line="122" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/SealSignal.h" bodystart="121" bodyend="298"/>
    <listofallmembers>
      <member refid="d9/d58/classAthena_1_1Signal_1a641025898baba970dddb3806fe4d7024" prot="public" virt="non-virtual"><scope>Athena::Signal</scope><name>block</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1a50cde1da242d476e0fd35be113657121" prot="public" virt="non-virtual"><scope>Athena::Signal</scope><name>block</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1acb413f9b908ec38d19007f699679f8ab" prot="public" virt="non-virtual"><scope>Athena::Signal</scope><name>crashed</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1a35d052097f8387d33e7b74d63008a3a3" prot="public" virt="non-virtual"><scope>Athena::Signal</scope><name>describe</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1acb9b9ecebefba6d45ac6ec5e019b133b" prot="public" virt="non-virtual"><scope>Athena::Signal</scope><name>dumpContext</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1aa686ec513eec1f5f9270a3093b536bcd" prot="public" virt="non-virtual"><scope>Athena::Signal</scope><name>dumpInfo</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1ab3650e5ddb5bdc899edac43d18446779" prot="public" virt="non-virtual"><scope>Athena::Signal</scope><name>dumpMemory</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1a29ed2239824de7084eec2096921df121" prot="public" virt="non-virtual"><scope>Athena::Signal</scope><name>fatal</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1a150e4c8e320da5b8a0690973b287890e" prot="public" virt="non-virtual"><scope>Athena::Signal</scope><name>FATAL_AUTO_EXIT</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1a0c47f0fc8e3ccd9ef3de3c2bc7ea39a3" prot="public" virt="non-virtual"><scope>Athena::Signal</scope><name>FATAL_DEFAULT</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1a09b1ac53de90bda7a0619f730531767b" prot="public" virt="non-virtual"><scope>Athena::Signal</scope><name>FATAL_DUMP_CONTEXT</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1a6798ead5f4386eed186a5e8dd885e00f" prot="public" virt="non-virtual"><scope>Athena::Signal</scope><name>FATAL_DUMP_CORE</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1aa774d944e7b551a7f9e2a4ad7d3558b6" prot="public" virt="non-virtual"><scope>Athena::Signal</scope><name>FATAL_DUMP_LIBS</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1ac52e36621c04bb27790397c43dba6343" prot="public" virt="non-virtual"><scope>Athena::Signal</scope><name>FATAL_DUMP_SIG</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1adf0c99c485898916f19e5f3b20a92855" prot="public" virt="non-virtual"><scope>Athena::Signal</scope><name>FATAL_DUMP_STACK</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1afbce7583ec5181b33546721b78fe8f01" prot="public" virt="non-virtual"><scope>Athena::Signal</scope><name>FATAL_ON_INT</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1a369e40f96220b4e610c171a03e09bde1" prot="public" virt="non-virtual"><scope>Athena::Signal</scope><name>FATAL_ON_QUIT</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1a5b6e599feec0e6ea2e5d204c7accf7ab" prot="public" virt="non-virtual"><scope>Athena::Signal</scope><name>fatalDump</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1ad4933f5dea26508794985dc36879fd4f" prot="public" virt="non-virtual"><scope>Athena::Signal</scope><name>FatalHook</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1ae19a24e2785bf4313373d693270a0318" prot="public" virt="non-virtual"><scope>Athena::Signal</scope><name>fatalLevel</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1a0a1d20177cf76b6f120d8f70fd547414" prot="public" virt="non-virtual"><scope>Athena::Signal</scope><name>FatalReturn</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1acb0930a18360698b9c20245fa140eba2" prot="public" virt="non-virtual"><scope>Athena::Signal</scope><name>handle</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1a91247206fb7476bfbc60ba82aed77309" prot="public" virt="non-virtual"><scope>Athena::Signal</scope><name>handleFatal</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1a531516a7bafb85ada87cc13df42be6c9" prot="public" virt="non-virtual"><scope>Athena::Signal</scope><name>handleFatalFd</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1acf9c12a42518c098bcdc03e2e1ec164a" prot="public" virt="non-virtual"><scope>Athena::Signal</scope><name>handleFatalHook</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1aab22be0d7aa1e7034b2de5f158c74533" prot="public" virt="non-virtual"><scope>Athena::Signal</scope><name>handleFatalOptions</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1a058d561130784cb3ff06f944dd2a642c" prot="public" virt="non-virtual"><scope>Athena::Signal</scope><name>handleFatalReturn</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1a937b6ad470e18df2e2509f150fb92fd9" prot="public" virt="non-virtual"><scope>Athena::Signal</scope><name>handleQuit</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1ae09161d0e01449d88a870c9ce33e48ab" prot="public" virt="non-virtual"><scope>Athena::Signal</scope><name>handleQuitHook</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1a03b798ab9f156df7c4201b8ca965fc7c" prot="public" virt="non-virtual"><scope>Athena::Signal</scope><name>handler</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1a165a8a731e1c838d8fcbdc8e8a90672f" prot="public" virt="non-virtual"><scope>Athena::Signal</scope><name>HandlerType</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1a7694b12f8ec856d8ece08fe5ffd46c3f" prot="public" virt="non-virtual"><scope>Athena::Signal</scope><name>ignore</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1a15848d5bc08689bda47833527c74512d" prot="public" virt="non-virtual"><scope>Athena::Signal</scope><name>kill</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1a4d98e5d67200d900fdc04abecb3d6911" prot="public" virt="non-virtual"><scope>Athena::Signal</scope><name>mask</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1a0adbe38fd6bad8af8f01df2ebadd226a" prot="public" virt="non-virtual"><scope>Athena::Signal</scope><name>name</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1a9b3d452bd4db782ababb16856e502b4d" prot="public" virt="non-virtual"><scope>Athena::Signal</scope><name>pending</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1adc09b8c58ec8e5a11cec445fc8fc37bc" prot="public" virt="non-virtual"><scope>Athena::Signal</scope><name>pending</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1a2320430a74b58f6a2180a794f3e6aaab" prot="public" virt="non-virtual"><scope>Athena::Signal</scope><name>queue</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1ab440bbd5068c51676db72c90e2bd481f" prot="public" virt="non-virtual"><scope>Athena::Signal</scope><name>queue</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1a3cb61f4a6cee9302b5726f12acba6100" prot="public" virt="non-virtual"><scope>Athena::Signal</scope><name>queue</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1a3736a405678e733d4ab65217a19d6a3e" prot="public" virt="non-virtual"><scope>Athena::Signal</scope><name>queue</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1a98067924cbcf318e105b92c019acf33e" prot="public" virt="non-virtual"><scope>Athena::Signal</scope><name>quit</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1a580d4d8dab36af1b92760624a314fe10" prot="public" virt="non-virtual"><scope>Athena::Signal</scope><name>QuitHook</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1a08098f4712adf303e1308740a647b6fb" prot="public" virt="non-virtual"><scope>Athena::Signal</scope><name>raise</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1a76c5c303a2f6cbf9af04709666f0e47c" prot="public" virt="non-virtual"><scope>Athena::Signal</scope><name>revert</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1a591f9662be6c703339cf6e19b7345462" prot="private" virt="non-virtual"><scope>Athena::Signal</scope><name>s_applicationName</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1a8e86a83a86de128d53e49d29dd003274" prot="private" virt="non-virtual"><scope>Athena::Signal</scope><name>s_crashed</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1a22d89097603a16af74840b1d9d2c790c" prot="private" virt="non-virtual"><scope>Athena::Signal</scope><name>s_fatalFd</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1a642206afdbfedac1732915592d6f75b1" prot="private" virt="non-virtual"><scope>Athena::Signal</scope><name>s_fatalHook</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1a0524eaa9dc3d8949423b3c61ba55290e" prot="private" virt="non-virtual"><scope>Athena::Signal</scope><name>s_fatalOptions</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1a3e7adc14d0c26774965ee26d93dcf7c1" prot="private" virt="non-virtual"><scope>Athena::Signal</scope><name>s_fatalReturn</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1a5f9b0cd1b5fa7df9205f1e75a7f48e60" prot="private" virt="non-virtual"><scope>Athena::Signal</scope><name>s_inFatal</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1aac2e7aaa53d369755ea6fe1ca5590966" prot="private" virt="non-virtual"><scope>Athena::Signal</scope><name>s_quitHook</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1ae402bac7a5e55ed23ea91a0d7586e6fd" prot="private" virt="non-virtual"><scope>Athena::Signal</scope><name>s_trampolines</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1a12d5227fb0b4627b25f75c80bbc97232" prot="public" virt="non-virtual"><scope>Athena::Signal</scope><name>suspend</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1abddb5b71da1f327a3dc0246afaae48d7" prot="private" virt="non-virtual"><scope>Athena::Signal</scope><name>trampoline</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1aadde66d635b299a4f8f88d222855ce3b" prot="public" virt="non-virtual"><scope>Athena::Signal</scope><name>USR1_DUMP_CORE</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1a618af8c53f3f8942b558f712e12865ef" prot="public" virt="non-virtual"><scope>Athena::Signal</scope><name>wait</name></member>
      <member refid="d9/d58/classAthena_1_1Signal_1ad6d376707953d3536cbbbf7350d385e4" prot="public" virt="non-virtual"><scope>Athena::Signal</scope><name>wait</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
