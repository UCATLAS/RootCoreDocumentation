<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.6.1">
  <compounddef id="de/d12/namespaceCxxUtils" kind="namespace">
    <compoundname>CxxUtils</compoundname>
    <innerclass refid="d5/d27/classCxxUtils_1_1ArrayIteratorChooser" prot="public">CxxUtils::ArrayIteratorChooser</innerclass>
    <innerclass refid="d4/d1b/classCxxUtils_1_1ArrayIteratorChooser_3_011_01_4" prot="public">CxxUtils::ArrayIteratorChooser&lt; 1 &gt;</innerclass>
    <innerclass refid="d5/dd9/classCxxUtils_1_1Array" prot="public">CxxUtils::Array</innerclass>
    <innerclass refid="df/d88/classCxxUtils_1_1Array_3_010_01_4" prot="public">CxxUtils::Array&lt; 0 &gt;</innerclass>
    <innerclass refid="d4/d75/classCxxUtils_1_1ArrayIterator" prot="public">CxxUtils::ArrayIterator</innerclass>
    <innerclass refid="dc/dcc/classCxxUtils_1_1WritableArray" prot="public">CxxUtils::WritableArray</innerclass>
    <innerclass refid="d0/da2/classCxxUtils_1_1WritableArray_3_010_01_4" prot="public">CxxUtils::WritableArray&lt; 0 &gt;</innerclass>
    <innerclass refid="d3/dd4/classCxxUtils_1_1WritableArrayData" prot="public">CxxUtils::WritableArrayData</innerclass>
    <innerclass refid="df/dac/classCxxUtils_1_1ArrayScanner" prot="public">CxxUtils::ArrayScanner</innerclass>
    <innerclass refid="d5/d3c/classCxxUtils_1_1BitPacker" prot="public">CxxUtils::BitPacker</innerclass>
    <innerclass refid="d8/dd9/classCxxUtils_1_1BitPacker8" prot="public">CxxUtils::BitPacker8</innerclass>
    <innerclass refid="d7/d5c/classCxxUtils_1_1BitPacker16" prot="public">CxxUtils::BitPacker16</innerclass>
    <innerclass refid="d4/d06/classCxxUtils_1_1BitUnpacker" prot="public">CxxUtils::BitUnpacker</innerclass>
    <innerclass refid="d8/dac/classCxxUtils_1_1BitUnpacker8" prot="public">CxxUtils::BitUnpacker8</innerclass>
    <innerclass refid="d3/dbe/classCxxUtils_1_1BitUnpacker16" prot="public">CxxUtils::BitUnpacker16</innerclass>
    <innerclass refid="d2/df5/classCxxUtils_1_1ClassName" prot="public">CxxUtils::ClassName</innerclass>
    <innerclass refid="d9/d8c/structCxxUtils_1_1enable__if" prot="public">CxxUtils::enable_if</innerclass>
    <innerclass refid="d8/d83/structCxxUtils_1_1enable__if_3_01true_00_01__Tp_01_4" prot="public">CxxUtils::enable_if&lt; true, _Tp &gt;</innerclass>
    <innerclass refid="da/df0/classCxxUtils_1_1FloatPacker" prot="public">CxxUtils::FloatPacker</innerclass>
    <innerclass refid="d2/dad/classCxxUtils_1_1PackedArray" prot="public">CxxUtils::PackedArray</innerclass>
    <innerclass refid="d1/d6f/classCxxUtils_1_1pointer__list__base" prot="public">CxxUtils::pointer_list_base</innerclass>
    <innerclass refid="d1/d88/classCxxUtils_1_1pointer__list" prot="public">CxxUtils::pointer_list</innerclass>
    <innerclass refid="d4/d12/structCxxUtils_1_1sincos" prot="public">CxxUtils::sincos</innerclass>
    <innerclass refid="dd/d5e/structCxxUtils_1_1extrace__init" prot="public">CxxUtils::extrace_init</innerclass>
    <innernamespace refid="d3/de9/namespaceCxxUtils_1_1fpcompare">CxxUtils::fpcompare</innernamespace>
    <innernamespace refid="d5/d12/namespaceCxxUtils_1_1fpcompare__fn">CxxUtils::fpcompare_fn</innernamespace>
    <innernamespace refid="d2/d1f/namespaceCxxUtils_1_1StringUtils">CxxUtils::StringUtils</innernamespace>
      <sectiondef kind="enum">
      <memberdef kind="enum" id="de/d12/namespaceCxxUtils_1a54810c47c6611708ade2af979df76b25" prot="public" static="no">
        <name>@8</name>
        <enumvalue id="de/d12/namespaceCxxUtils_1a54810c47c6611708ade2af979df76b25aef968cbfaa0ace367635f31504669a01" prot="public">
          <name>CacheLineSize</name>
          <initializer> 64</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>While it is possible to determine cache line size at run time (e.g. using sysconf(_SC_LEVEL1_DCACHE_LINESIZE) on Linux or sysctlbyname(&quot;hw.cachelinesize&quot;, ...) on Apple systems) that approach creates more problems: the location that stores cache line size will probably be out of cache when one needs to know it. This is why we use a compile time constant for cache line size. Cache line size is 64 for the current generation of Intel/AMD CPUs.</para><para>If an object spans multiple cache lines then prefetching whole object should be done by prefetching at least one address from each of the cache lines that object occupies. How many lines are needed depends on three things: object size, cache line size, and object starting address. If CacheLineSize is lower than the actual line size then more prefetches than necessary will be generated (2, 4, or more per cache line if cache line size is power of 2). This may be somewhat wasteful so this number may need to be adjusted in the far future when _all_ CPUs have wider cache lines. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/prefetch.h" line="54" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/prefetch.h" bodystart="54" bodyend="54"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="var">
      <memberdef kind="variable" id="de/d12/namespaceCxxUtils_1a5c9755e7f5798fdd6257521801e7b4b0" prot="public" static="yes" mutable="no">
        <type><ref refid="dd/d5e/structCxxUtils_1_1extrace__init" kindref="compound">extrace_init</ref></type>
        <definition>extrace_init CxxUtils::initer</definition>
        <argsstring></argsstring>
        <name>initer</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/src/exctrace/exctrace_collector.cxx" line="61" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/src/exctrace/exctrace_collector.cxx" bodystart="61" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="de/d12/namespaceCxxUtils_1a426624a3ea2d412c113ce5217166d38d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename InputIterator</type>
          </param>
          <param>
            <type>typename OutputIterator</type>
          </param>
          <param>
            <type>typename Predicate</type>
          </param>
        </templateparamlist>
        <type>OutputIterator</type>
        <definition>OutputIterator CxxUtils::copy_if</definition>
        <argsstring>(InputIterator first, InputIterator last, OutputIterator result, Predicate pred)</argsstring>
        <name>copy_if</name>
        <param>
          <type>InputIterator</type>
          <declname>first</declname>
        </param>
        <param>
          <type>InputIterator</type>
          <declname>last</declname>
        </param>
        <param>
          <type>OutputIterator</type>
          <declname>result</declname>
        </param>
        <param>
          <type>Predicate</type>
          <declname>pred</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/algorithms.h" line="39" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/algorithms.h" bodystart="37" bodyend="46"/>
      </memberdef>
      <memberdef kind="function" id="de/d12/namespaceCxxUtils_1af16c85f6fe3658154a9b225609574726" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class InputIterator</type>
          </param>
          <param>
            <type>class OutputIterator</type>
          </param>
          <param>
            <type>class InputTag</type>
          </param>
          <param>
            <type>class OutputTag</type>
          </param>
        </templateparamlist>
        <type>OutputIterator</type>
        <definition>OutputIterator CxxUtils::copy_bounded1</definition>
        <argsstring>(InputIterator begi, InputIterator endi, OutputIterator bego, OutputIterator endo, const InputTag &amp;, const OutputTag &amp;)</argsstring>
        <name>copy_bounded1</name>
        <param>
          <type>InputIterator</type>
          <declname>begi</declname>
        </param>
        <param>
          <type>InputIterator</type>
          <declname>endi</declname>
        </param>
        <param>
          <type>OutputIterator</type>
          <declname>bego</declname>
        </param>
        <param>
          <type>OutputIterator</type>
          <declname>endo</declname>
        </param>
        <param>
          <type>const InputTag &amp;</type>
        </param>
        <param>
          <type>const OutputTag &amp;</type>
        </param>
        <briefdescription>
<para>Copy a range with bounds restriction; generic version. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/copy_bounded.h" line="36" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/copy_bounded.h" bodystart="32" bodyend="43"/>
      </memberdef>
      <memberdef kind="function" id="de/d12/namespaceCxxUtils_1a5ede98c8f13a1c221e932fe588f5d996" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class InputIterator</type>
          </param>
          <param>
            <type>class OutputIterator</type>
          </param>
        </templateparamlist>
        <type>OutputIterator</type>
        <definition>OutputIterator CxxUtils::copy_bounded1</definition>
        <argsstring>(InputIterator begi, InputIterator endi, OutputIterator bego, OutputIterator endo, const std::random_access_iterator_tag &amp;, const std::random_access_iterator_tag &amp;)</argsstring>
        <name>copy_bounded1</name>
        <param>
          <type>InputIterator</type>
          <declname>begi</declname>
        </param>
        <param>
          <type>InputIterator</type>
          <declname>endi</declname>
        </param>
        <param>
          <type>OutputIterator</type>
          <declname>bego</declname>
        </param>
        <param>
          <type>OutputIterator</type>
          <declname>endo</declname>
        </param>
        <param>
          <type>const std::random_access_iterator_tag &amp;</type>
        </param>
        <param>
          <type>const std::random_access_iterator_tag &amp;</type>
        </param>
        <briefdescription>
<para>Copy a range with bounds restriction; random_access_iterator version. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/copy_bounded.h" line="56" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/copy_bounded.h" bodystart="52" bodyend="59"/>
      </memberdef>
      <memberdef kind="function" id="de/d12/namespaceCxxUtils_1a5049ecdf32f875ad81bca0377cd12bc3" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class InputIterator</type>
          </param>
          <param>
            <type>class OutputIterator</type>
          </param>
        </templateparamlist>
        <type>OutputIterator</type>
        <definition>OutputIterator CxxUtils::copy_bounded</definition>
        <argsstring>(InputIterator begi, InputIterator endi, OutputIterator bego, OutputIterator endo)</argsstring>
        <name>copy_bounded</name>
        <param>
          <type>InputIterator</type>
          <declname>begi</declname>
        </param>
        <param>
          <type>InputIterator</type>
          <declname>endi</declname>
        </param>
        <param>
          <type>OutputIterator</type>
          <declname>bego</declname>
        </param>
        <param>
          <type>OutputIterator</type>
          <declname>endo</declname>
        </param>
        <briefdescription>
<para>Copy a range with bounds restriction. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>begi</parametername>
</parameternamelist>
<parameterdescription>
<para>Start of input range. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>endi</parametername>
</parameternamelist>
<parameterdescription>
<para>End of input range. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bego</parametername>
</parameternamelist>
<parameterdescription>
<para>Start of output range. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>endo</parametername>
</parameternamelist>
<parameterdescription>
<para>End of output range.</para></parameterdescription>
</parameteritem>
</parameterlist>
Like std::copy(begi, endi, bego), except that it will not copy more than std::distance(bego, endo) elements.</para><para>Copies exactly n = std::min (std::distance(begi,endi), std::distance(bego,endo)) elements. Returns bego + n. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/copy_bounded.h" line="81" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/copy_bounded.h" bodystart="79" bodyend="86"/>
      </memberdef>
      <memberdef kind="function" id="de/d12/namespaceCxxUtils_1a13bedce0dab0a2e825383e8f21ea37b2" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class InputRange</type>
          </param>
          <param>
            <type>class OutputRange</type>
          </param>
        </templateparamlist>
        <type>boost::range_iterator&lt; OutputRange &gt;::type</type>
        <definition>boost::range_iterator&lt;OutputRange&gt;::type CxxUtils::copy_bounded</definition>
        <argsstring>(const InputRange &amp;input, OutputRange &amp;output)</argsstring>
        <name>copy_bounded</name>
        <param>
          <type>const InputRange &amp;</type>
          <declname>input</declname>
        </param>
        <param>
          <type>OutputRange &amp;</type>
          <declname>output</declname>
        </param>
        <briefdescription>
<para>Copy a range with bounds restriction. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>input</parametername>
</parameternamelist>
<parameterdescription>
<para>Input range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>output</parametername>
</parameternamelist>
<parameterdescription>
<para>Output range</para></parameterdescription>
</parameteritem>
</parameterlist>
copy_bounded written in terms of iterator ranges. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/copy_bounded.h" line="100" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/copy_bounded.h" bodystart="99" bodyend="104"/>
      </memberdef>
      <memberdef kind="function" id="de/d12/namespaceCxxUtils_1a1b199b3c90529fef9ea3d0b89d9eeca0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void CxxUtils::exctrace</definition>
        <argsstring>(const std::exception &amp;e, IOFD fd=IOFD_INVALID)</argsstring>
        <name>exctrace</name>
        <param>
          <type>const std::exception &amp;</type>
          <declname>e</declname>
        </param>
        <param>
          <type><ref refid="d1/dc7/SealCommon_8h_1a98d936fe848403f33ff9cebfc9a38597" kindref="member">IOFD</ref></type>
          <declname>fd</declname>
          <defval>IOFD_INVALID</defval>
        </param>
        <briefdescription>
<para>Print out information for the last exception. </para>        </briefdescription>
        <detaileddescription>
<para>Prints the supplied exception, plus the backtrace from the last exception, if available.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>e</parametername>
</parameternamelist>
<parameterdescription>
<para>The exception to print. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fd</parametername>
</parameternamelist>
<parameterdescription>
<para>The file descriptor to which to write. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/exctrace.h" line="41" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/exctrace.cxx" bodystart="45" bodyend="80"/>
      </memberdef>
      <memberdef kind="function" id="de/d12/namespaceCxxUtils_1a8d7b43f454542ab8071fe88444f3cb2b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class <ref refid="d1/def/classT" kindref="compound">T</ref></type>
          </param>
        </templateparamlist>
        <type><ref refid="d1/def/classT" kindref="compound">T</ref></type>
        <definition>T CxxUtils::ones</definition>
        <argsstring>(unsigned int n)</argsstring>
        <name>ones</name>
        <param>
          <type>unsigned int</type>
          <declname>n</declname>
        </param>
        <briefdescription>
<para>Return a bit mask with the lower <emphasis>n</emphasis> bits set. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/ones.h" line="24" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/ones.h" bodystart="23" bodyend="28"/>
      </memberdef>
      <memberdef kind="function" id="de/d12/namespaceCxxUtils_1abfc11f0c6320559e2a85f8dfabc4ab35" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void CxxUtils::prefetchOne</definition>
        <argsstring>(const void *address)</argsstring>
        <name>prefetchOne</name>
        <param>
          <type>const void *</type>
          <declname>address</declname>
        </param>
        <briefdescription>
<para>Generic prefetch method. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">address</parametername>
</parameternamelist>
<parameterdescription>
<para>memory location to prefetch</para></parameterdescription>
</parameteritem>
</parameterlist>
This is generic method that does not have any extra behavior. It only prefetches the whole cache line which contains the specified memory location. It does not incur any additional overhead and may be the most efficient method for small objects which have a high chance of being on just a single cache line. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/prefetch.h" line="69" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/prefetch.h" bodystart="68" bodyend="71"/>
      </memberdef>
      <memberdef kind="function" id="de/d12/namespaceCxxUtils_1a678516f176527cc599c4f2d6955b04cb" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>size_t</type>
            <declname>N</declname>
            <defname>N</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void CxxUtils::prefetchN</definition>
        <argsstring>(const void *ptr)</argsstring>
        <name>prefetchN</name>
        <param>
          <type>const void *</type>
          <declname>ptr</declname>
        </param>
        <briefdescription>
<para>Prefetch an N-byte block of memory. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">ptr</parametername>
</parameternamelist>
<parameterdescription>
<para>Starting address of the block. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/prefetch.h" line="81" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/prefetch.h" bodystart="80" bodyend="91"/>
      </memberdef>
      <memberdef kind="function" id="de/d12/namespaceCxxUtils_1a01ccd92e2dd3def19d3a69cec058555d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename <ref refid="d1/def/classT" kindref="compound">T</ref></type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void CxxUtils::prefetchObj</definition>
        <argsstring>(const T *ptr)</argsstring>
        <name>prefetchObj</name>
        <param>
          <type>const <ref refid="d1/def/classT" kindref="compound">T</ref> *</type>
          <declname>ptr</declname>
        </param>
        <briefdescription>
<para>Generic prefetch of the object of specific types (sizes). </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">address</parametername>
</parameternamelist>
<parameterdescription>
<para>memory location to prefetch</para></parameterdescription>
</parameteritem>
</parameterlist>
This method will prefetch as many cache lines as needed to store the object of the specified type in memory. Type is specified as a template argument. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/prefetch.h" line="104" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/prefetch.h" bodystart="103" bodyend="106"/>
      </memberdef>
      <memberdef kind="function" id="de/d12/namespaceCxxUtils_1a026e0a124e8bb253ee77fe73f952d7e1" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Iter</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void CxxUtils::prefetchNext</definition>
        <argsstring>(Iter iter, Iter endIter)</argsstring>
        <name>prefetchNext</name>
        <param>
          <type>Iter</type>
          <declname>iter</declname>
        </param>
        <param>
          <type>Iter</type>
          <declname>endIter</declname>
        </param>
        <briefdescription>
<para>Prefetch next object in sequence. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>iter</parametername>
</parameternamelist>
<parameterdescription>
<para>Current iteration position. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>endIter</parametername>
</parameternamelist>
<parameterdescription>
<para>End of the sequence.</para></parameterdescription>
</parameteritem>
</parameterlist>
<computeroutput>Iter</computeroutput> is a <computeroutput>ForwardIterator</computeroutput> over pointers.</para><para>Prefetches next object in a collection of pointers. Accepts two iterators: the first iterator is the current iteration position, and the second iterator is the end iterator for the whole sequence. The first iterator must not be equal to the end iterator (this is not checked). This increments the iterator and, if not equal to the end, prefetches the complete object referenced by the pointer. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/prefetch.h" line="126" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/prefetch.h" bodystart="125" bodyend="129"/>
      </memberdef>
      <memberdef kind="function" id="de/d12/namespaceCxxUtils_1ad61690c9769710cbcf846e498e0e762a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Iter</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void CxxUtils::prefetchTwo</definition>
        <argsstring>(Iter iter, Iter endIter)</argsstring>
        <name>prefetchTwo</name>
        <param>
          <type>Iter</type>
          <declname>iter</declname>
        </param>
        <param>
          <type>Iter</type>
          <declname>endIter</declname>
        </param>
        <briefdescription>
<para>Prefetch two objects. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>iter</parametername>
</parameternamelist>
<parameterdescription>
<para>Current iteration position. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>endIter</parametername>
</parameternamelist>
<parameterdescription>
<para>End of the sequence.</para></parameterdescription>
</parameteritem>
</parameterlist>
<computeroutput>Iter</computeroutput> is a <computeroutput>ForwardIterator</computeroutput> over pointers.</para><para>Prefetches the current and next objects in a collection of pointers. Accepts two iterators: the first iterator is the current iteration position, and the second is the end iterator for the whole sequence. If the first iterator is not equal to end the iterator, the object to which it points is prefetched. Then the iterator is incremented and, if not equal to the end iterator, the next objects is also prefetched. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/prefetch.h" line="150" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/prefetch.h" bodystart="149" bodyend="157"/>
      </memberdef>
      <memberdef kind="function" id="de/d12/namespaceCxxUtils_1a20e9ea3bf1e4593c7e9e4fe952edc452" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string CxxUtils::strformat</definition>
        <argsstring>(const char *fmt,...)</argsstring>
        <name>strformat</name>
        <param>
          <type>const char *</type>
          <declname>fmt</declname>
        </param>
        <param>
          <type>...</type>
        </param>
        <briefdescription>
<para>return a `stdstring` according to a format `fmt` and varargs </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/StrFormat.h" line="25" bodyfile="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/Root/StrFormat.cxx" bodystart="42" bodyend="65"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Copy the elements of a sequence for which a predicate is true. </para>    </briefdescription>
    <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>An input iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>An input iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>result</parametername>
</parameternamelist>
<parameterdescription>
<para>An output iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pred</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="d4/dc4/structA" kindref="compound">A</ref> predicate. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>An iterator designating the end of the resulting sequence.</para></simplesect>
Copies each element in the range <computeroutput></computeroutput>[first,last) for which <computeroutput>pred</computeroutput> returns true to the range beginning at <computeroutput>result</computeroutput>.</para><para>copy_if() is stable, so the relative order of elements that are copied is unchanged.</para><para><emphasis>Example</emphasis>: <programlisting><codeline><highlight class="normal"><sp/><sp/>CxxUtils::copy_if(<sp/>in.begin(),<sp/>in.end(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::back_inserter(out),<sp/>filter<sp/>);</highlight></codeline>
</programlisting> where in and out are STL-like containers and filter is a predicate </para>    </detaileddescription>
    <location file="/cvmfs/atlas.cern.ch/repo/sw/ASG/AnalysisBase/2.4.28/CxxUtils/CxxUtils/algorithms.h" line="32"/>
  </compounddef>
</doxygen>
